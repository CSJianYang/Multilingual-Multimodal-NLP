[
    {
        "title": "Plus One",
        "question_content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n&nbsp;\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n&nbsp;\nConstraints:\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "solutions": [
            {
                "id": 24082,
                "title": "my-simple-java-solution",
                "content": "    public int[] plusOne(int[] digits) {\\n            \\n        int n = digits.length;\\n        for(int i=n-1; i>=0; i--) {\\n            if(digits[i] < 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            \\n            digits[i] = 0;\\n        }\\n        \\n        int[] newNumber = new int [n+1];\\n        newNumber[0] = 1;\\n        \\n        return newNumber;\\n    }",
                "solutionTags": [],
                "code": "    public int[] plusOne(int[] digits) {\\n            \\n        int n = digits.length;\\n        for(int i=n-1; i>=0; i--) {\\n            if(digits[i] < 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            \\n            digits[i] = 0;\\n        }\\n        \\n        int[] newNumber = new int [n+1];\\n        newNumber[0] = 1;\\n        \\n        return newNumber;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2706861,
                "title": "java-fastest-0ms-runtime-easy-and-elegant-solution",
                "content": "```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\\n\\n\\nexplanation\\n\\n```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t\\t// starting from extreme right--> if array[i] is less than 9 means can be added with 1\\n\\t\\t// i.e. [ 5,8 ]-->[ 5,9 ] or\\n\\t\\t//      [ 9,4 ]-->[ 9,5 ] or\\n\\t\\t//      [ 6,0 ]-->[ 6,1 ]\\n\\t\\t// and will directly return array\\n\\t}\\n\\tdigits[i] = 0;\\n\\t// if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\\n\\t// and we again revolve around loop to check for number if less than 9 or not\\n\\t// i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\\n\\t//      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\\n\\t// and will directly return array\\n}\\n\\n// if all number inside array are 9\\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\\n\\n\\n// to make like above we need to make new array of length--> n+1\\n// by default new array values are set to -->0 only\\n// thus just changed first value of array to 1 and return the array\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\\n\\n**TC O(n)\\nSC O(n)**\\n\\n\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\n```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t\\t// starting from extreme right--> if array[i] is less than 9 means can be added with 1\\n\\t\\t// i.e. [ 5,8 ]-->[ 5,9 ] or\\n\\t\\t//      [ 9,4 ]-->[ 9,5 ] or\\n\\t\\t//      [ 6,0 ]-->[ 6,1 ]\\n\\t\\t// and will directly return array\\n\\t}\\n\\tdigits[i] = 0;\\n\\t// if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\\n\\t// and we again revolve around loop to check for number if less than 9 or not\\n\\t// i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\\n\\t//      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\\n\\t// and will directly return array\\n}\\n\\n// if all number inside array are 9\\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\\n\\n\\n// to make like above we need to make new array of length--> n+1\\n// by default new array values are set to -->0 only\\n// thus just changed first value of array to 1 and return the array\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054321,
                "title": "simple-c-solution-with-good-explanation",
                "content": "# Intuition\\nIf we thought that all elements of the vector is a number we need to increase it by 1. The input can be 100 digits so we must handle that through digits.\\n\\n# Approach\\nFirst we increment the first digit (last element) by 1, if it becomes 10 we make it 0 ans add 1 to the second digit.. until the last digit (first element), if it becoms 10 we make it 1 and push_back a leading zero.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i = n-1; i >= 0; i--){\\n            if(i == n-1)\\n                v[i]++;\\n            if(v[i] == 10){\\n                v[i] = 0;\\n                if(i != 0){\\n                    v[i-1]++;\\n                }\\n                else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nDon\\'t forget please :\\')\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/a6b046f8-0b13-4de1-95f9-78327b0dccba_1673782056.4431267.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i = n-1; i >= 0; i--){\\n            if(i == n-1)\\n                v[i]++;\\n            if(v[i] == 10){\\n                v[i] = 0;\\n                if(i != 0){\\n                    v[i-1]++;\\n                }\\n                else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723116,
                "title": "c-solution-with-intuitive-explanation",
                "content": "My solution is nothing special and isn\\'t clever at all.  I decided to post it since I thought the [\"official\" solution article from leetcode](https://leetcode.com/problems/plus-one/solution/) was very poorly written and confused me more, even after I solved it on my own.\\n\\nSo, I believe my comments below should explain the idea, but I want to add that it helps to test the more obscure test cases for this problem to understand the algorithm.  For example:\\n\\n- `[9]`\\n- `[9090]`\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```\\n\\nAs always, I look forward to comments and feedback. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24139,
                "title": "simple-java-solution",
                "content": "\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >=0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {\\n            int[] res = new int[digits.length+1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        return digits;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >=0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {\\n            int[] res = new int[digits.length+1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24085,
                "title": "simple-python-solution-with-explanation-plus-one",
                "content": "    def plusOne(digits):\\n        num = 0\\n        for i in range(len(digits)):\\n        \\tnum += digits[i] * pow(10, (len(digits)-1-i))\\n        return [int(i) for i in str(num+1)]\\n\\nWe're given a list of digits, and the idea here is to convert that list to an integer, *num*. So each digit is multiplied by the proper place value and added to *num*. For example, if *digits* = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to *num*. Then 8 is multiplied by 10^2 and added to *num*, and so on.\\n\\nThe last step is to add 1 to *num*, convert it to a list and return that list.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def plusOne(digits):\\n        num = 0\\n        for i in range(len(digits)):\\n        \\tnum += digits[i] * pow(10, (len(digits)-1-i))\\n        return [int(i) for i in str(num+1)]\\n\\nWe're given a list of digits, and the idea here is to convert that list to an integer, *num*. So each digit is multiplied by the proper place value and added to *num*. For example, if *digits* = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to *num*. Then 8 is multiplied by 10^2 and added to *num*, and so on.\\n\\nThe last step is to add 1 to *num*, convert it to a list and return that list.",
                "codeTag": "Python3"
            },
            {
                "id": 24289,
                "title": "java-concise-solution-with-early-return",
                "content": "    \\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        for (int i = digits.length-1; i>= 0; i--) {\\n            digits[i] += carry;\\n            if (digits[i] <= 9) // early return \\n                return digits;\\n            digits[i] = 0;\\n        }\\n        int[] ret = new int[digits.length+1];\\n        ret[0] = 1;\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        for (int i = digits.length-1; i>= 0; i--) {\\n            digits[i] += carry;\\n            if (digits[i] <= 9) // early return \\n                return digits;\\n            digits[i] = 0;\\n        }\\n        int[] ret = new int[digits.length+1];\\n        ret[0] = 1;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 438791,
                "title": "recursive-python-solution-98-87-speed-100-memory",
                "content": "While this can be solved with a one liner, I thought that it was also a good candidate for a simple little soliution that modfiies the values in the list without converting to different formats etc. Uses recursion to deal with adding 1 to 9.\\n```python\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if digits[-1] < 9:\\n            digits[-1] += 1\\n            return digits\\n        elif len(digits) == 1 and digits[0] == 9:\\n            return [1, 0]\\n        else:\\n            digits[-1] = 0\\n            digits[0:-1] = self.plusOne(digits[0:-1])\\n            return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if digits[-1] < 9:\\n            digits[-1] += 1\\n            return digits\\n        elif len(digits) == 1 and digits[0] == 9:\\n            return [1, 0]\\n        else:\\n            digits[-1] = 0\\n            digits[0:-1] = self.plusOne(digits[0:-1])\\n            return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24297,
                "title": "simple-direct-javascript-solution",
                "content": "    var plusOne = function(digits) {\\n    for(var i = digits.length - 1; i >= 0; i--){\\n         digits[i]++; \\n        if(digits[i] > 9){\\n            digits[i] = 0;\\n        }else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n    };\\n\\n\\nFirst, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array. \\n\\nLast, when running over for loop, I just put fill 1 in front of the array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var plusOne = function(digits) {\\n    for(var i = digits.length - 1; i >= 0; i--){\\n         digits[i]++; \\n        if(digits[i] > 9){\\n            digits[i] = 0;\\n        }else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n    };\\n\\n\\nFirst, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array. \\n\\nLast, when running over for loop, I just put fill 1 in front of the array.",
                "codeTag": "Unknown"
            },
            {
                "id": 3090372,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n       int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i)\\n      { \\n        if (digits[i] == 9)\\n            digits[i] = 0;\\n      else\\n      {  \\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    } \\n    \\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n       int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i)\\n      { \\n        if (digits[i] == 9)\\n            digits[i] = 0;\\n      else\\n      {  \\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    } \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24122,
                "title": "my-c-solution-with-few-lines",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            bool carry = true;\\n            \\n            for(int i=digits.size()-1; i >= 0 && carry; i--) {\\n                carry = (++digits[i]%=10) == 0;\\n            }\\n    \\n            if(carry) {\\n                digits.insert(digits.begin(), 1);\\n            }\\n        \\n            return digits;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            bool carry = true;\\n            \\n            for(int i=digits.size()-1; i >= 0 && carry; i--) {\\n                carry = (++digits[i]%=10) == 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24353,
                "title": "simple-javascript-solution",
                "content": "    var plusOne = function(digits) {\\n      for(var i = digits.length - 1; i >= 0; i--){\\n        if(++digits[i] > 9) digits[i] = 0;\\n        else return digits;\\n      }\\n      digits.unshift(1);\\n      return digits;\\n    };",
                "solutionTags": [],
                "code": "    var plusOne = function(digits) {\\n      for(var i = digits.length - 1; i >= 0; i--){\\n        if(++digits[i] > 9) digits[i] = 0;\\n        else return digits;\\n      }\\n      digits.unshift(1);\\n      return digits;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 24091,
                "title": "easy-python-solution-o-n",
                "content": "\\n    def plusOne(digits):\\n        digits[-1] += 1\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] != 10:\\n                break\\n            digits[i] = 0\\n            digits[i-1] += 1\\n        \\n        if digits[0] == 10:\\n            digits[0] = 0\\n            return [1] + digits\\n        return digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def plusOne(digits):\\n        digits[-1] += 1\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] != 10:\\n                break\\n            digits[i] = 0\\n            digits[i-1] += 1\\n        \\n        if digits[0] == 10:\\n            digits[0] = 0\\n            return [1] + digits\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 24090,
                "title": "python-simple-solution-using-recursion",
                "content": "    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(digits) == 0:\\n            digits = [1]\\n        elif digits[-1] == 9:\\n            digits = self.plusOne(digits[:-1])\\n            digits.extend([0])\\n        else:\\n            digits[-1] += 1\\n        return digits",
                "solutionTags": [],
                "code": "    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(digits) == 0:\\n            digits = [1]\\n        elif digits[-1] == 9:\\n            digits = self.plusOne(digits[:-1])\\n            digits.extend([0])\\n        else:\\n            digits[-1] += 1\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 485912,
                "title": "c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size() - 1;i >= 0;i--){\\n            if(digits[i] != 9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else\\n                digits[i] = 0;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size() - 1;i >= 0;i--){\\n            if(digits[i] != 9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else\\n                digits[i] = 0;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147127,
                "title": "javascript-simple-solution",
                "content": "```\\nvar plusOne = function(digits) {\\n  for(let i = digits.length - 1; i >= 0; i --){\\n    if(digits[i] === 9){\\n      digits[i] = 0;\\n    }\\n    else {\\n      digits[i] ++;\\n      return digits;\\n    }\\n  }\\n  return [1, ...digits];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar plusOne = function(digits) {\\n  for(let i = digits.length - 1; i >= 0; i --){\\n    if(digits[i] === 9){\\n      digits[i] = 0;\\n    }\\n    else {\\n      digits[i] ++;\\n      return digits;\\n    }\\n  }\\n  return [1, ...digits];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129110,
                "title": "simplest-python-approach-beats-99-5",
                "content": "# Intuition\\nOften the obvious approach is among the best. If you just convert to an integer and add one, it beats 98% of solutions.\\n\\n# Approach\\nInstead of looping across the list and accounting for random 9s, just convert to an integer and add one.  Then convert back to a list.\\n\\n# Complexity\\nThe time complexity is O(n) because we have to traverse the list exactly once then convert back to a list.\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)\\n\\n        temp = str(int(strings) +1)\\n\\n        return [int(temp[i]) for i in range(len(temp))]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)\\n\\n        temp = str(int(strings) +1)\\n\\n        return [int(temp[i]) for i in range(len(temp))]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383696,
                "title": "super-simple-java-solution-explained-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int len = digits.length; // length of array;\\n        \\n        // start the loop from last index;\\n        for (int i = len-1; i>=0; i--) {\\n            // if ith index is 9, that means there will be an overflow if we add 1\\n            // adding 1 will make it 10, so we set it to 0. and continue the loop; \\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }else {\\n                // if ith value is not 9 we just add 1 to it and return;\\n                digits[i] += 1;\\n                return digits;\\n            }     \\n        }\\n        \\n        // if we are here, that means all the value of the array were 9;\\n        // and they are 0 now;\\n        // example: [9,9,9,9], after loop becomes [0,0,0,0];\\n        // so we have to create a new array of +1 length of the previous.\\n        // and place 1 at 0th index;\\n        int[] arr = new int[len+1];\\n        arr[0] = 1;\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int len = digits.length; // length of array;\\n        \\n        // start the loop from last index;\\n        for (int i = len-1; i>=0; i--) {\\n            // if ith index is 9, that means there will be an overflow if we add 1\\n            // adding 1 will make it 10, so we set it to 0. and continue the loop; \\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3073756,
                "title": "one-line-js-solution-with-full-explanation-beginner-friendly",
                "content": "\\n# Approach\\nAs we are told we are given a large integer represented as an integer array. So we should use the BigInt type. Our first work is joining the numbers using join() method and of course we wrap it in BigInt and add BigInt(1). Because we can\\'t add regular number to bigInt, this is why we are using the bigInt type for 1 too. And we convert the BigInt to a string and split() it\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 65 ms\\nBeats 74.99%\\n\\n\\n- Space complexity:\\nMemor: 41.7 MB\\nBeats 81.73%\\n\\n# Code\\n```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    return (BigInt(digits.join(\"\")) + BigInt(1)).toString().split(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    return (BigInt(digits.join(\"\")) + BigInt(1)).toString().split(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674763,
                "title": "c-simple-solution",
                "content": "```\\n for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468139,
                "title": "python-3-one-line-solution-explained",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [x for x in str(int(\\'\\'.join(map(str, digits))) + 1)]\\n```\\n\\n1. `map(str, digits)` - applies funciton `str` to every element of the list, returning iterable object \\n2. `\\'\\'.join()` - joins all elements inside parentheses together, using empty separator, specified between `\\'\\'`\\n3. `int` converts joined string og digits to integer value\\n4. `+1` increases it\\n5. `str` converts new number into string\\n6. `[x for x in ...]` generates list of digits in string from step 5.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [x for x in str(int(\\'\\'.join(map(str, digits))) + 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758992,
                "title": "c-solution-that-passed-all-test-cases",
                "content": "C# Solution that passed all test cases\\n\\n```\\n        public int[] PlusOne(int[] digits)\\n        {\\n            int n = digits.Length;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                if (digits[i] < 9)\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n                digits[i] = 0;\\n            }\\n            int[] newNumber = new int[n + 1];\\n            newNumber[0] = 1;\\n\\n            return newNumber;\\n        }\\n\\t\\t\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public int[] PlusOne(int[] digits)\\n        {\\n            int n = digits.Length;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                if (digits[i] < 9)\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n                digits[i] = 0;\\n            }\\n            int[] newNumber = new int[n + 1];\\n            newNumber[0] = 1;\\n\\n            return newNumber;\\n        }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409531,
                "title": "javascript-easy-to-understand-solution",
                "content": "```/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    for(let i = digits.length - 1; i>= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    digits.unshift(1)\\n    return digits\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    for(let i = digits.length - 1; i>= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    digits.unshift(1)\\n    return digits\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 24294,
                "title": "golang-go-solution",
                "content": "    func plusOne(digits []int) []int {\\n        var n int = len(digits)\\n        for i:= n-1; i>=0; i--{\\n            if digits[i] < 9 {\\n                digits[i]+=1\\n                return digits\\n            } else {\\n                digits[i] = 0\\n            }\\n        }\\n        var a = make([]int,n+1)\\n        a[0] = 1\\n        return a\\n    \\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func plusOne(digits []int) []int {\\n        var n int = len(digits)\\n        for i:= n-1; i>=0; i--{\\n            if digits[i] < 9 {\\n                digits[i]+=1\\n                return digits\\n            } else {\\n                digits[i] = 0\\n            }\\n        }\\n        var a = make([]int,n+1)\\n        a[0] = 1\\n        return a\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915685,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the digits.\\n    //   - space: O(n), where n is the length of the digits.\\n\\n    func plusOne(_ digits: [Int]) -> [Int] {\\n        var digits = digits\\n\\n        for i in (0..<digits.count).reversed() {\\n            guard digits[i] == 9 else {\\n                digits[i] += 1\\n                return digits\\n            }\\n\\n            digits[i] = 0\\n        }\\n\\n        digits.insert(1, at: 0)\\n        return digits\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the digits.\\n    //   - space: O(n), where n is the length of the digits.\\n\\n    func plusOne(_ digits: [Int]) -> [Int] {\\n        var digits = digits\\n\\n        for i in (0..<digits.count).reversed() {\\n            guard digits[i] == 9 else {\\n                digits[i] += 1\\n                return digits\\n            }\\n\\n            digits[i] = 0\\n        }\\n\\n        digits.insert(1, at: 0)\\n        return digits\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24320,
                "title": "java-recursion-solution",
                "content": "    public class Solution {\\n        public int[] plusOne(int[] digits) {\\n            return helper(digits,digits.length-1);\\n        }\\n        \\n        private int[] helper(int[] digits, int index){\\n            if(digits[index] < 9){\\n                digits[index]++;\\n                return digits;\\n            }else{\\n                if(index != 0){\\n                    digits[index] = 0;\\n                    return helper(digits,index-1);\\n                }else{\\n                    int[] res = new int[digits.length+1];\\n                    res[0] = 1;\\n                    return res;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] plusOne(int[] digits) {\\n            return helper(digits,digits.length-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 587672,
                "title": "javascript-simple-solution",
                "content": "Runtime: 52 ms, faster than 81.75% of JavaScript online submissions for Plus One.\\nMemory Usage: 33.8 MB, less than 55.32% of JavaScript online submissions for Plus One.\\n```\\nfunction plusOne(digits) {\\n  let co = true;\\n  for (let i = digits.length - 1; i >= 0 && co; i--) {\\n    digits[i]++;\\n    co = digits[i] >= 10;\\n    co && (digits[i] = 0);\\n  }\\n  co && digits.unshift(1);\\n  return digits;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction plusOne(digits) {\\n  let co = true;\\n  for (let i = digits.length - 1; i >= 0 && co; i--) {\\n    digits[i]++;\\n    co = digits[i] >= 10;\\n    co && (digits[i] = 0);\\n  }\\n  co && digits.unshift(1);\\n  return digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745099,
                "title": "one-for-loop-beats-93",
                "content": "# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]==9:\\n                digits[i]=0\\n            else:\\n                digits[i]+=1\\n                return digits\\n        return [1]+digits\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]==9:\\n                digits[i]=0\\n            else:\\n                digits[i]+=1\\n                return digits\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727575,
                "title": "python-100-speed-one-liner-hardworking-way",
                "content": "**Python | 100% Speed | One Liner + Hardworking Way**\\n\\n**A) Python One-Liner**\\n\\nShameless Python One-Liner, O(n) solution.\\nDe-compressed Steps:\\n\\n1. The integer-array \"digits\" is first converted into a joined string: [1,2,3] -> \"123\".  ***Code:**   a = \\'\\'.join(map(str,digits))*\\n2. The joined string is then converted into an integer, and we add one.  ***Code:**   b = int(a)+1\\n3. Our new integer is re-converted into a string, and then into a list format. Finally, the INT operator is applied to each element of the list to obtain new integer digits ***Code:**   [ int(c) for c in str(b) ]  or  list(map(int,str(b)))\\n\\n```\\n# Version A: Outer Loop\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(x) for x in  str(int(\\'\\'.join(map(str,digits)))+1) ]\\n```\\n\\n```\\n# Version B: Pure Functions\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return list(map(int,str(int(\\'\\'.join(map(str,digits)))+1)))\\n```\\n\\n**B) Hardworking Digit Processing - O(1) space**\\n```\\n# Hard-Working Version: Manual Digit Check\\n# O(1) space, and O(1) time for most cases as well (with few chained 9\\'s in the lower digits)\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if not digits:\\n            return digits\\n        i = len(digits)-1\\n        digits[i] += 1\\n        while digits[i]==10:\\n            digits[i] = 0\\n            if i==0:\\n                digits.insert(0,1)\\n            else:\\n                digits[i-1] += 1\\n                i -= 1\\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Version A: Outer Loop\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(x) for x in  str(int(\\'\\'.join(map(str,digits)))+1) ]\\n```\n```\\n# Version B: Pure Functions\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return list(map(int,str(int(\\'\\'.join(map(str,digits)))+1)))\\n```\n```\\n# Hard-Working Version: Manual Digit Check\\n# O(1) space, and O(1) time for most cases as well (with few chained 9\\'s in the lower digits)\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if not digits:\\n            return digits\\n        i = len(digits)-1\\n        digits[i] += 1\\n        while digits[i]==10:\\n            digits[i] = 0\\n            if i==0:\\n                digits.insert(0,1)\\n            else:\\n                digits[i-1] += 1\\n                i -= 1\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422298,
                "title": "python-solution-faster-than-97-02",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits[idx] != 9:\\n                digits[idx] += 1\\n                break\\n            else:\\n                digits[idx] = 0\\n        if digits[0] == 0:\\n            digits.insert(0, 1)\\n        return digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits[idx] != 9:\\n                digits[idx] += 1\\n                break\\n            else:\\n                digits[idx] = 0\\n        if digits[0] == 0:\\n            digits.insert(0, 1)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322882,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\\n        for x in digits.iter_mut().rev() {\\n            match *x == 9 {\\n                true => *x = 0,\\n                false => {\\n                    *x += 1;\\n                    return digits;\\n                }\\n            }\\n        }\\n        digits.insert(0, 1);\\n        digits\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\\n        for x in digits.iter_mut().rev() {\\n            match *x == 9 {\\n                true => *x = 0,\\n                false => {\\n                    *x += 1;\\n                    return digits;\\n                }\\n            }\\n        }\\n        digits.insert(0, 1);\\n        digits\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708232,
                "title": "easy-and-simplest-c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n= digits.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i]<9){\\n                digits[i]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;        \\n    }\\n};\\n```\\n![4i5ri4f9.png](https://assets.leetcode.com/users/images/280cc0bf-e1b5-417b-a72d-4ba7e737f34f_1688448157.4485767.png)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n= digits.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i]<9){\\n                digits[i]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722211,
                "title": "python-find-maximum-number-of-9-in-the-end-explained",
                "content": "How we can add `1` to given number? We need to find the biggest number of `9` in the end of our number, for example for number `5123521999235123999`, there will be three `9` in the end. `512352199923512`**3999**` + 1 = 512352199923512`**4000**: so we need to increase previous symbol by one and change all `9` after to `0`. Now, the steps of algorithm are to following:\\n\\n1. Let us add one `0` before our data to handle cases like `9`, `99`, `999`, ... \\n2. Find maximum number of `9`, starting from the end and moving to the left.\\n3. Change all found `9` in the end to `0` and previous digit increasy by `1`.\\n4. Handle border cases: if we have leading zero, remove it.\\n\\n**Complexity** time complexity is `O(n)`, where `n` is length of list. Additional space complexity is `O(1)`, because we edit input data directly.\\n\\n```\\nclass Solution:\\n    def plusOne(self, digits):\\n        digits = [0] + digits\\n        \\n        end = len(digits) - 1\\n        while digits[end] == 9:\\n            end -= 1\\n    \\n        digits[end] += 1\\n        digits[end+1:] = [0] * (len(digits)-1-end)\\n                   \\n        return digits if digits[0] != 0 else digits[1:]      \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        digits = [0] + digits\\n        \\n        end = len(digits) - 1\\n        while digits[end] == 9:\\n            end -= 1\\n    \\n        digits[end] += 1\\n        digits[end+1:] = [0] * (len(digits)-1-end)\\n                   \\n        return digits if digits[0] != 0 else digits[1:]      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954062,
                "title": "java-runtime-0-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to solving this problem involves adding one to the given integer represented by an array of digits. I\\'ll iterate through the array of digits from right to left, simulating the process of adding one to the number.\\n\\n# Approach\\nI will iterate through the array of digits from right to left. For each digit, I\\'ll check if it\\'s 9. If it\\'s 9, I\\'ll set it to 0 and continue iterating. If it\\'s not 9, I\\'ll increment it by one and immediately return the modified array. This is because there\\'s no need to carry over to the next digit in this case.\\n\\nIf the loop completes without returning, it means all digits were 9, and we need to add a new leading digit. I\\'ll create a new array with a length one more than the original array, set the first element to 1, and return the new array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the array of digits once, where \\'n\\' is the length of the array.\\n\\n- Space complexity: O(n) or O(n+1)\\n  In the worst case, the algorithm creates a new array with a length one more than the original array. Thus, the space complexity can be considered O(n+1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            } else {\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        \\n        int[] newDigits = new int[digits.length + 1];\\n        newDigits[0] = 1;\\n        return newDigits;\\n    }\\n        \\n\\n    }\\n\\n\\n\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            } else {\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        \\n        int[] newDigits = new int[digits.length + 1];\\n        newDigits[0] = 1;\\n        return newDigits;\\n    }\\n        \\n\\n    }\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568113,
                "title": "easy-c-solution-o-n-time-complexity-just-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will see the last element as we have to add 1 to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start traversing through end.\\n2. If last element is not 9, just add 1 to it and return the vector.\\n3. If last element is 9, make it zero, move ahead (reverse order).\\n4. Now if this element is not 9, add 1 to it and return vector, otherwise if it is also 9, make it zero and repeat the 3rd and 4th steps.\\n5. Now, if the number is 999, then we have to make it 1000 (999 + 1 = 1000). So, push 0 to the last of our vector (0,0,0) so that it becomes (0,0,0,0) and make first element \\'1\\' => 1000.\\n6. This is how we add 1 to the number!\\n7. Thank You, Don\\'t forget to upvote :)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(v[i]<9){\\n                ++v[i];\\n                return v;\\n            }else{\\n                v[i] = 0;\\n            }\\n        }\\n\\n        v.push_back(0);      // to handle \\'999\\' => 999 + 1 = 1000\\n        v[0] = 1;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(v[i]<9){\\n                ++v[i];\\n                return v;\\n            }else{\\n                v[i] = 0;\\n            }\\n        }\\n\\n        v.push_back(0);      // to handle \\'999\\' => 999 + 1 = 1000\\n        v[0] = 1;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455692,
                "title": "java-100-faster-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/15360baf-39c0-45e7-b2e2-b8d6d07813d5_1682477226.014943.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        // Starting from the least significant digit (i.e., the last element of the array)\\n        for (int i = n - 1; i >= 0; i--) {\\n            // If the current digit is less than 9, we can add 1 to it and return the updated array\\n            if (digits[i] < 9) {\\n                digits[i]++; // Add 1 to the current digit\\n                return digits; // Return the updated array\\n            }\\n            // If the current digit is 9, we set it to 0 and continue with the next digit\\n            else {\\n                digits[i] = 0; // Set the current digit to 0\\n            }\\n        }\\n        // If we reach here, it means all digits were 9, so we need to create a new array with one more element\\n        int[] result = new int[n + 1]; // Create a new array with length n + 1\\n        result[0] = 1; // Set the first element to 1, since all other elements are 0 by default\\n        return result; // Return the new array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        // Starting from the least significant digit (i.e., the last element of the array)\\n        for (int i = n - 1; i >= 0; i--) {\\n            // If the current digit is less than 9, we can add 1 to it and return the updated array\\n            if (digits[i] < 9) {\\n                digits[i]++; // Add 1 to the current digit\\n                return digits; // Return the updated array\\n            }\\n            // If the current digit is 9, we set it to 0 and continue with the next digit\\n            else {\\n                digits[i] = 0; // Set the current digit to 0\\n            }\\n        }\\n        // If we reach here, it means all digits were 9, so we need to create a new array with one more element\\n        int[] result = new int[n + 1]; // Create a new array with length n + 1\\n        result[0] = 1; // Set the first element to 1, since all other elements are 0 by default\\n        return result; // Return the new array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614101,
                "title": "c-simple-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```\\n**Please upvote if you like the solution\\ncomment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529365,
                "title": "java-tc-o-n-sc-o-1-optimized-math-addition-simulation",
                "content": "```java\\n/**\\n * Simulate Math Addition\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1) --> Excluding the result space\\n *\\n * N = Length of input digits array.\\n */\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        if (digits == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = digits.length;\\n        if (len == 0) {\\n            return new int[] { 1 };\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n\\n        digits = new int[len + 1];\\n        digits[0] = 1;\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Simulate Math Addition\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1) --> Excluding the result space\\n *\\n * N = Length of input digits array.\\n */\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        if (digits == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = digits.length;\\n        if (len == 0) {\\n            return new int[] { 1 };\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n\\n        digits = new int[len + 1];\\n        digits[0] = 1;\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24310,
                "title": "python-solution-simple",
                "content": "\\n\\n    def plusOne(self, digits):\\n        for i in xrange(len(digits)-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n        return [1] + digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    def plusOne(self, digits):\\n        for i in xrange(len(digits)-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n        return [1] + digits",
                "codeTag": "Python3"
            },
            {
                "id": 1286610,
                "title": "javascript-simple-iterative-solution-faster-than-92-65-72ms",
                "content": "```\\nvar plusOne = function(digits) {    \\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] !== 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n        if (i === 0) {\\n            digits.unshift(1);\\n            return digits;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar plusOne = function(digits) {    \\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] !== 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n        if (i === 0) {\\n            digits.unshift(1);\\n            return digits;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283271,
                "title": "100-fast-solution-in-golang-detailed-video-explanation-o-n",
                "content": "I have created a detailed video to explain the logic and the code for this problem you can have a look at it incase you want better understanding on how I came up with the approch\\n[Plus One| O(n) Solution by The Exception Handler](https://www.youtube.com/watch?v=mrYywKoIq-E&list=PL8-bdB4cHmXzuGvBnFmByq-4yyAy-ceaK&index=3)\\n\\n```\\nfunc plusOne(digits []int) []int {\\n    \\n\\tn := len(digits)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif digits[i] < 9 {\\n\\t\\t\\tdigits[i]++\\n\\t\\t\\treturn digits\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\n\\t}\\n\\tdigits = append([]int{1}, digits...)\\n\\treturn digits\\n}\\n```\\n\\nPlease upvote this solution in case you like the explaniation",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    \\n\\tn := len(digits)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif digits[i] < 9 {\\n\\t\\t\\tdigits[i]++\\n\\t\\t\\treturn digits\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\n\\t}\\n\\tdigits = append([]int{1}, digits...)\\n\\treturn digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022733,
                "title": "kotlin",
                "content": "```\\nfun plusOne(digits: IntArray): IntArray {\\n        for (i in digits.size - 1 downTo 0) {\\n            digits[i] += 1\\n            if (digits[i] <= 9) return digits\\n            digits[i] = 0\\n        }\\n        val arr = IntArray(digits.size + 1)\\n        arr[0] = 1\\n\\n        return arr\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun plusOne(digits: IntArray): IntArray {\\n        for (i in digits.size - 1 downTo 0) {\\n            digits[i] += 1\\n            if (digits[i] <= 9) return digits\\n            digits[i] = 0\\n        }\\n        val arr = IntArray(digits.size + 1)\\n        arr[0] = 1\\n\\n        return arr\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832514,
                "title": "javascript-solution-66",
                "content": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nlet plusOne = function(digits) {\\n    for(let i=digits.length-1;i>=0;i--){\\n        digits[i]++;\\n        if(digits[i]>9){\\n            digits[i]=0;\\n        }\\n        else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```\\n**Runtime: 72 ms, faster than 83.48% of JavaScript online submissions for Plus One.**\\n\\n**Memory Usage: 37 MB, less than 9.82% of JavaScript online submissions for Plus One.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nlet plusOne = function(digits) {\\n    for(let i=digits.length-1;i>=0;i--){\\n        digits[i]++;\\n        if(digits[i]>9){\\n            digits[i]=0;\\n        }\\n        else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24086,
                "title": "recursive-c-solution-3ms",
                "content": "```\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        if (digits.back() == 9)\\n        {\\n            digits.pop_back();\\n            digits = plusOne(digits);\\n            digits.push_back(0);\\n        }\\n        \\n        else if (digits.empty())\\n            digits.push_back(1);\\n\\n        else\\n            digits.back()++;\\n        \\n        return digits;\\n    }\\n```\\nIf the last digit is ```9```, we remove that ```9``` from the vector and add ```1``` to the vector without ```9```; essentially carrying the ```1```. After adding the ```1``` we put``` 0``` at the end of the vector, which will take the place of the ```9 ```from this particular recursion. Since the input is described as non-empty, we can assume the vector will only be empty if it was composed solely of 9's. Thus, we simply push_back ```1``` and return the vector.\\nThis allows for ```plusOne([9,9,9])``` to return ```[1,0,0,0]```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        if (digits.back() == 9)\\n        {\\n            digits.pop_back();\\n            digits = plusOne(digits);\\n            digits.push_back(0);\\n        }\\n        \\n        else if (digits.empty())\\n            digits.push_back(1);\\n\\n        else\\n            digits.back()++;\\n        \\n        return digits;\\n    }\\n```\n```9```\n```9```\n```1```\n```9```\n```1```\n```1```\n``` 0```\n```9 ```\n```1```\n```plusOne([9,9,9])```\n```[1,0,0,0]```",
                "codeTag": "Unknown"
            },
            {
                "id": 24125,
                "title": "0ms-java-solution",
                "content": "    public int[] plusOne(int[] digits) {\\n        int i = digits.length - 1;\\n        while(i >= 0){\\n            if(digits[i] == 9)\\n                digits[i--] = 0;\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        int[] array = new int[digits.length+1];\\n        array[0] = 1;\\n        return array;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] plusOne(int[] digits) {\\n        int i = digits.length - 1;\\n        while(i >= 0){\\n            if(digits[i] == 9)\\n                digits[i--] = 0;\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        int[] array = new int[digits.length+1];\\n        array[0] = 1;\\n        return array;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24416,
                "title": "share-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {   //\\u672a\\u8003\\u8651\\u524d\\u7f000\\u7684\\u60c5\\u51b5\\n            for(int i = digits.size() - 1; i >= 0; i--)   \\n            {\\n                if(digits[i] != 9)\\n                {\\n                    digits[i] ++;\\n                    break;\\n                }\\n                digits[i] = 0;\\n            }\\n            if(digits[0] == 0)\\n                digits.insert(digits.begin(), 1);\\n            return digits;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {   //\\u672a\\u8003\\u8651\\u524d\\u7f000\\u7684\\u60c5\\u51b5\\n            for(int i = digits.size() - 1; i >= 0; i--)   \\n            {\\n                if(digits[i] != 9)\\n                {\\n                    digits[i] ++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3032275,
                "title": "beats-98-7-solutions-easy-to-understand-single-for-loop-o-n-tc-in-python-by-bolt-coding",
                "content": "# Explanation\\nWe are iterating from back to the list as we need to add at the end. We are checking if the current digit is 9. That means we have to replace 9 with 0 and have a carry of 1. If thats not the case then we don\\'t have to iterate through whole loop, we can simply return the list of digit from there.\\n\\nIn case its running until the loop ends, that means all the digits are 9. So inorder to insert a 1 at 0 position we appened with an additional 0 at the end and changed digit[0] to 1. Now there are various ways to do the same, we can use insert method as well.\\n# Complexity\\n- Time complexity: O(n) as we are using a single loop and worst case if all the digits are 9 we have to iterate through whole loop \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) as we haven\\'t used any additional variable to store the number.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digit: List[int]) -> List[int]:\\n        for i in range(len(digit)-1, -1, -1):\\n            if digit[i] == 9:\\n                digit[i] = 0\\n            else:\\n                digit[i]+=1\\n                return digit\\n    \\n        digit.append(0)            \\n        digit[0] = 1\\n        return digit\\n        \\n\\n        \\n```\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digit: List[int]) -> List[int]:\\n        for i in range(len(digit)-1, -1, -1):\\n            if digit[i] == 9:\\n                digit[i] = 0\\n            else:\\n                digit[i]+=1\\n                return digit\\n    \\n        digit.append(0)            \\n        digit[0] = 1\\n        return digit\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331911,
                "title": "javascript-easy-solution",
                "content": "Easy to understand solution I found, not the fastest around, but nice for beginners like me :) \\n\\n```\\nvar plusOne = function(digits) {\\n    const fromArray = digits.join(\\'\\'); // get Digits out of Array\\n    const toInt = BigInt(fromArray) ; //Dont use parseInt, use BigInt instead :) \\n    const addOne = toInt + 1n; // add one! \\n    const result =  Array.from(String(addOne), Number); // return digits to array\\n    return result\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    const fromArray = digits.join(\\'\\'); // get Digits out of Array\\n    const toInt = BigInt(fromArray) ; //Dont use parseInt, use BigInt instead :) \\n    const addOne = toInt + 1n; // add one! \\n    const result =  Array.from(String(addOne), Number); // return digits to array\\n    return result\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24461,
                "title": "fastest-and-simplest-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            int i,j,carry=1;\\n            // traditional long addition..\\n            for(i=digits.size()-1;i>=0&&carry;i--){\\n                int sum=carry+digits[i];\\n                carry=sum/10;\\n                digits[i]=sum%10;\\n            }\\n            if(carry){ // if carry is 1, then digits must be all 99..999\\n                digits[0]=1;\\n                digits.push_back(0);\\n            }\\n            return digits;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            int i,j,carry=1;\\n            // traditional long addition..\\n            for(i=digits.size()-1;i>=0&&carry;i--){\\n                int sum=carry+digits[i];\\n                carry=sum/10;\\n                digits[i]=sum%10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2314145,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n\\n```\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNumber = new int [n+1];\\n    newNumber[0] = 1;\\n    \\n    return newNumber;\\n}\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNumber = new int [n+1];\\n    newNumber[0] = 1;\\n    \\n    return newNumber;\\n}\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188812,
                "title": "java-0ms-easy-100",
                "content": "If it helps, do an Upvote \\u2B06\\uFE0F\\uD83C\\uDD99 So others can also find it helpful\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(++digits[i] != 10) return digits;\\n            digits[i] = 0;\\n        }\\n        int [] res = new int[digits.length + 1];\\n        \\n        res[0] = 1;\\n        return res;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(++digits[i] != 10) return digits;\\n            digits[i] = 0;\\n        }\\n        int [] res = new int[digits.length + 1];\\n        \\n        res[0] = 1;\\n        return res;\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24174,
                "title": "simple-swift-solution",
                "content": "```\\nfunc plusOne(_ digits: [Int]) -> [Int] {\\n        var result = digits\\n        for i in (0..<result.count).reversed() {\\n            if result[i] != 9 {\\n                result[i] = result[i]+1\\n                return result\\n            } else {\\n                result[i] = 0\\n            }\\n        }\\n        if result.first == 0 {\\n            result.insert(1, at: 0)\\n        }\\n        return result\\n    }\\n```\\nExplanation: Loop from the end of the array to start. Just add 1 if the digit is not a 9, and return. If digit is a 9, replace it with a 0 and go to the previous digit - rinse an repeat. In the end, check if the first digit of the resulting array is a 0. If it is, that means that the number was of the form 9999... In this case, insert a 1 in the start.",
                "solutionTags": [],
                "code": "```\\nfunc plusOne(_ digits: [Int]) -> [Int] {\\n        var result = digits\\n        for i in (0..<result.count).reversed() {\\n            if result[i] != 9 {\\n                result[i] = result[i]+1\\n                return result\\n            } else {\\n                result[i] = 0\\n            }\\n        }\\n        if result.first == 0 {\\n            result.insert(1, at: 0)\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24349,
                "title": "simple-python-o-n-solution-without-converting-to-a-number",
                "content": "The idea here is to start from the right side.  As soon as we find a number that isn't 9 we can add 1 to it and return.  If the number is 9, we change it to 0 and continue until we find a number that is not 9 to carry the 1 to.  If we reach the end of array with all 9's we then insert the 1 in front of array. \\n\\n\\n     def plusOne(self, digits):\\n        for i in range(len(digits)-1, -1, -1):\\n            digits[i] = digits[i] + 1 if digits[i] < 9 else 0\\n            if digits[i]: \\n                return digits\\n        digits.insert(0, 1)\\n        return digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea here is to start from the right side.  As soon as we find a number that isn't 9 we can add 1 to it and return.  If the number is 9, we change it to 0 and continue until we find a number that is not 9 to carry the 1 to.  If we reach the end of array with all 9's we then insert the 1 in front of array. \\n\\n\\n     def plusOne(self, digits):\\n        for i in range(len(digits)-1, -1, -1):\\n            digits[i] = digits[i] + 1 if digits[i] < 9 else 0\\n            if digits[i]: \\n                return digits\\n        digits.insert(0, 1)\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 3624231,
                "title": "easy-approach-0ms-cpp-0-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust iterate from back instead of from front. Then keep adding and handling carry variable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust add as if adding a normal numbers\\nLike if you want to add 239 + 1 then first you do 9+1 = 10, then we take 0 and carry 1.\\nThis 0 above is 10%10 and 1 is 10/10. Thus, I have taken, digits[i] = add%10 and carry is add/10.\\n\\n\\nAt the end if the carry is not 0 --> Add an element in the vector at the frontend.\\nEx - 9 + 1 = 0 and carry 1\\nSo insert it at the beginning as 10 to make 9+1=10\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry = 1;\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            int add = digits[i] + carry;\\n            digits[i] = add%10;\\n            carry = add/10;\\n        }\\n        if(carry > 0){\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry = 1;\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            int add = digits[i] + carry;\\n            digits[i] = add%10;\\n            carry = add/10;\\n        }\\n        if(carry > 0){\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159471,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        carry = 1\\n        for i in range(len(digits)-1, -1, -1):\\n            carry, digits[i] = divmod(digits[i]+carry, 10)\\n            if carry == 0:\\n                return digits\\n        return [1]+digits\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        carry = 1\\n        for i in range(len(digits)-1, -1, -1):\\n            carry, digits[i] = divmod(digits[i]+carry, 10)\\n            if carry == 0:\\n                return digits\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780735,
                "title": "java-solution-easy-to-undersatnd-explained-in-detail",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n * we started checking from back if last digit is less than 9 we simply add one one to the digit and return the digit.\\n *  otherwise the case will be last digit was 9 so we make the digit 0 as we know 9+1 = 10 so last digit in these cases need to be 0 so we do that.\\n *  here we create a new array of size input given to us +1 so that we can actually add 1 to beginning of our new array and we retuen the new array thats it.For ex:[9,9,9] = [1,0,0,0] in this case we need one more digit space as we need to carry 1 so in this way we do this.\\n\\n\\n**If it is helpful please do upvote,Happy coding!!\\n**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i=n-1;i>=0;i--){  \\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        int [] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i=n-1;i>=0;i--){  \\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        int [] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557528,
                "title": "c-easy-solution",
                "content": "/// C# Code\\npublic int[] PlusOne(int[] digits) {\\n        for(int i=digits.Length-1;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        int[] result=new int[digits.Length+1];\\n        result[0]=1;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "/// C# Code\\npublic int[] PlusOne(int[] digits) {\\n        for(int i=digits.Length-1;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        int[] result=new int[digits.Length+1];\\n        result[0]=1;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 500774,
                "title": "simple-solution-faster-than-98-82",
                "content": "```\\n    public class Solution\\n    {\\n        public int[] PlusOne(int[] digits)\\n        {\\n            for (int i = digits.Length - 1; i >= 0; i--)\\n            {\\n                if (digits[i] == 9)\\n                {\\n                    digits[i] = 0;\\n                }\\n                else\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            }\\n            int[] newBigOne = new int[digits.Length + 1];\\n            newBigOne[0] = 1;\\n            return newBigOne;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int[] PlusOne(int[] digits)\\n        {\\n            for (int i = digits.Length - 1; i >= 0; i--)\\n            {\\n                if (digits[i] == 9)\\n                {\\n                    digits[i] = 0;\\n                }\\n                else\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            }\\n            int[] newBigOne = new int[digits.Length + 1];\\n            newBigOne[0] = 1;\\n            return newBigOne;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24333,
                "title": "accepted-easy-java-solution",
                "content": "    public static int[] plusOne(int[] digits) {\\n\\t        if(0==digits.length) return digits;\\n\\t\\t    for(int i=digits.length-1;i>=0;i--)\\n\\t\\t    {\\n\\t\\t        \\n\\t\\t       if(digits[i]!=9) {digits[i]++;return digits;}\\n\\t\\t   \\t   else\\tdigits[i]=0;\\n\\t\\t    }\\n\\t\\t  int[] result=new int[digits.length+1];\\n\\t\\t  result[0]=1; \\n\\t\\t  return result;   \\n\\t    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int[] plusOne(int[] digits) {\\n\\t        if(0==digits.length) return digits;\\n\\t\\t    for(int i=digits.length-1;i>=0;i--)\\n\\t\\t    {\\n\\t\\t        \\n\\t\\t       if(digits[i]!=9) {digits[i]++;return digits;}\\n\\t\\t   \\t   else\\tdigits[i]=0;\\n\\t\\t    }\\n\\t\\t  int[] result=new int[digits.length+1];\\n\\t\\t  result[0]=1; \\n\\t\\t  return result;   \\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24346,
                "title": "c-solution-with-comments",
                "content": "    \\n    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    int carry = 1, i = digitsSize;\\n    int* ret = (int*)malloc(sizeof(int)*(digitsSize+1));\\n    while (i > 0) {\\n        ret[i] = (digits[i-1]+carry)%10;\\n        carry = (digits[i-1]+carry)/10;\\n        i--;\\n    }\\n    if (!ret[1]) { \\n        // size increased 1, set the first digit\\n        ret[0] = 1;\\n        *returnSize = digitsSize+1;\\n        return ret;\\n    } else {\\n        *returnSize = digitsSize;\\n        return ret+1;\\n    }",
                "solutionTags": [],
                "code": "    \\n    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    int carry = 1, i = digitsSize;\\n    int* ret = (int*)malloc(sizeof(int)*(digitsSize+1));\\n    while (i > 0) {\\n        ret[i] = (digits[i-1]+carry)%10;\\n        carry = (digits[i-1]+carry)/10;\\n        i--;\\n    }\\n    if (!ret[1]) { \\n        // size increased 1, set the first digit\\n        ret[0] = 1;\\n        *returnSize = digitsSize+1;\\n        return ret;\\n    } else {\\n        *returnSize = digitsSize;\\n        return ret+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3192789,
                "title": "easy-solution-javascript",
                "content": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--){\\n        if(arr[i]<9){\\n            arr[i]++;\\n            return arr;\\n        }\\n        arr[i] = 0;\\n    }\\n    arr.unshift(1);\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--){\\n        if(arr[i]<9){\\n            arr[i]++;\\n            return arr;\\n        }\\n        arr[i] = 0;\\n    }\\n    arr.unshift(1);\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069349,
                "title": "python3-29ms-beats-95",
                "content": "![image.png](https://assets.leetcode.com/users/images/85217fc8-e205-4817-89aa-1d0fb37eae44_1675841089.4490588.png)\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        digits=digits[::-1]\\n        x=1\\n        ans=[]\\n        for i in range(len(digits)):\\n            ans+=[(digits[i]+x)%10]\\n            x=(digits[i]+x)//10\\n        if x:\\n            ans+=[x]\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        digits=digits[::-1]\\n        x=1\\n        ans=[]\\n        for i in range(len(digits)):\\n            ans+=[(digits[i]+x)%10]\\n            x=(digits[i]+x)//10\\n        if x:\\n            ans+=[x]\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520098,
                "title": "easy-javascript-solution",
                "content": "```\\n    // first join the digits with no space and add 1  \\n    let str = digits.join(\"\");\\n    let num = BigInt(str)+ BigInt(1);\\n    // convert the num into array\\n    num = num.toString().split(\\'\\').map((num) => parseInt(num));\\n    return num;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    // first join the digits with no space and add 1  \\n    let str = digits.join(\"\");\\n    let num = BigInt(str)+ BigInt(1);\\n    // convert the num into array\\n    num = num.toString().split(\\'\\').map((num) => parseInt(num));\\n    return num;",
                "codeTag": "Unknown"
            },
            {
                "id": 1794804,
                "title": "python3-one-line-simple-and-fastest-using-str-int-and-line-comprehension",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a=[str(i) for i in digits]\\n        a=\\'\\'.join(a)\\n        a=str(int(a)+1)\\n        return [int(i) for i in a]\\n\\n```\\n\\n**compressed into one line**\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(i) for i in str(int(\\'\\'.join([str(i) for i in digits]))+1)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a=[str(i) for i in digits]\\n        a=\\'\\'.join(a)\\n        a=str(int(a)+1)\\n        return [int(i) for i in a]\\n\\n```\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(i) for i in str(int(\\'\\'.join([str(i) for i in digits]))+1)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232867,
                "title": "js-faster-than-93-o-n",
                "content": "First we add 1 to the last element. \\nThen, we iteratively check starting from least significant to most significant if the digit is a 10. \\nIf it is, we set it to 0 and to the digit before it we add 1.\\nOnce we are done with this, we update the first digit if it\\'s a 10, adding a digit of 1 in front of it.\\n```\\nconst plusOne = (digits) => {\\n  const last = digits.length - 1;\\n  digits[last]++;\\n  for (let i = last; i > 0 && digits[i] === 10; i--) {\\n    digits[i] = 0;\\n    digits[i - 1]++;\\n  }\\n  if (digits[0] === 10) {\\n    digits[0] = 0;\\n    digits.unshift(1);\\n  }\\n  return digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst plusOne = (digits) => {\\n  const last = digits.length - 1;\\n  digits[last]++;\\n  for (let i = last; i > 0 && digits[i] === 10; i--) {\\n    digits[i] = 0;\\n    digits[i - 1]++;\\n  }\\n  if (digits[0] === 10) {\\n    digits[0] = 0;\\n    digits.unshift(1);\\n  }\\n  return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167759,
                "title": "go-solution",
                "content": "```\\nfunc plusOne(digits []int) []int {\\n    for i := len(digits)-1; i >= 0; i-- {\\n        if digits[i] < 9 {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    \\n    digits = append([]int{1}, digits...)\\n    \\n    return digits\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    for i := len(digits)-1; i >= 0; i-- {\\n        if digits[i] < 9 {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    \\n    digits = append([]int{1}, digits...)\\n    \\n    return digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24372,
                "title": "accepted-4ms-c-solution-easy-and-short",
                "content": "    class Solution {\\n    public:\\n        std::vector<int> plusOne(std::vector<int>& digits) {\\n            int pos = digits.size() - 1;\\n            while (pos >= 0 && digits[pos] == 9) {\\n                digits[pos] = 0;\\n                --pos;\\n            }\\n            if (pos == -1) {\\n                digits[0] = 1;\\n                digits.push_back(0);\\n            } else {\\n                ++digits[pos];\\n            }\\n            return digits;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::vector<int> plusOne(std::vector<int>& digits) {\\n            int pos = digits.size() - 1;\\n            while (pos >= 0 && digits[pos] == 9) {\\n                digits[pos] = 0;\\n                --pos;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3942526,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n         \\n        int i = 0;\\n        while (i <= digits.length - 1 && digits[digits.length - 1 - i] == 9) {\\n            i++;\\n        }\\n\\n        int[] output = (digits.length == i) ? new int[digits.length + 1] : new int[digits.length];\\n\\n        if (digits.length == i) {\\n            output[0] = 1;\\n        } else {\\n\\n            for (int j = 0; j <= digits.length - i - 1; j++) \\n            {\\n                output[j] = digits[j];\\n            }\\n\\n            output[digits.length - 1 - i] = digits[digits.length - i - 1] + 1;\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/f7abc399-3a52-4e17-850a-9fc8984ee6c9_1692645882.9655104.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n         \\n        int i = 0;\\n        while (i <= digits.length - 1 && digits[digits.length - 1 - i] == 9) {\\n            i++;\\n        }\\n\\n        int[] output = (digits.length == i) ? new int[digits.length + 1] : new int[digits.length];\\n\\n        if (digits.length == i) {\\n            output[0] = 1;\\n        } else {\\n\\n            for (int j = 0; j <= digits.length - i - 1; j++) \\n            {\\n                output[j] = digits[j];\\n            }\\n\\n            output[digits.length - 1 - i] = digits[digits.length - i - 1] + 1;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056619,
                "title": "c-properly-explained-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835091,
                "title": "c-most-optimal-solution-0ms-and-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s=digits.size()-1;    //Length of the vector \\n        while(s>=0){\\n            if(digits[s]<9){\\n                digits[s]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[s]=0;\\n                s--;\\n            }\\n        }\\n        vector<int> :: iterator iter=digits.begin();   //Inserting 1 if incase the number is [9],[9,9,9,9] etc\\n        digits.insert(iter,1);\\n        return digits;\\n    }\\n};\\n```\\n\\nPlease upvote if found useful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s=digits.size()-1;    //Length of the vector \\n        while(s>=0){\\n            if(digits[s]<9){\\n                digits[s]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[s]=0;\\n                s--;\\n            }\\n        }\\n        vector<int> :: iterator iter=digits.begin();   //Inserting 1 if incase the number is [9],[9,9,9,9] etc\\n        digits.insert(iter,1);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800794,
                "title": "fast-as-fuck-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n    }\\n};\\n```\\nupvote if useful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257638,
                "title": "very-easy-java-solution-100-fully-explained-and-understandable",
                "content": "```\\nclass Solution {\\n\\n    public int[] plusOne(int[] digits) {\\n        \\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            int[] res = new int[digits.length + 1];    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] plusOne(int[] digits) {\\n        \\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            int[] res = new int[digits.length + 1];    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117634,
                "title": "python-99-75-list-str-int-1-str-list",
                "content": "*Runtime: 20 ms, faster than 99.74% of Python3 online submissions for Plus One.\\nMemory Usage: 14 MB, less than 99.00% of Python3 online submissions for Plus One.*\\n\\nVariables named as writes are much faster than reads:\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a = \\'\\'.join(map(str, digits))\\n        b = int(a) + 1\\n        c = str(b)\\n        return list(map(int, c))\\n```\\nhttps://leetcode.com/submissions/detail/469908019/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a = \\'\\'.join(map(str, digits))\\n        b = int(a) + 1\\n        c = str(b)\\n        return list(map(int, c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627432,
                "title": "simple-java-code-easy-approach-0ms-runtime",
                "content": "# Intuition\\nAs per the question given we need to increment the array value by one and return the resultant array with ith digit at ith position of that array For example: digits=[1,2,3] after adding one to this array i.e, 123+1=124 ...gives digits=[1,2,4] \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we need to notice that the input maybe given any large integer value so we cannot convert our array into number and increemnt and convert it back as an array instead i followed this follwing logic by taking one place and comparing whether its less than 9 or equal to 9.\\nif its equal to 9 go and check for next ith digit else increment this digit by one and return the array\\nFor better undertanding please see these below steps:\\n1. As its already an int[] array given the last element of the array will be considered as the units place of the number we need to add 1 for last digit if its less than 9\\n2. if the last element is greater than 9 we need to check for before element and increment if its less than 9..\\n3. if all the elements are 9 we need add another element to the array\\nfor example: [9,9] --> [1,0,0]\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    StringBuilder s=new StringBuilder();\\n    public int[] plusOne(int[] digits) {\\n        for(int i=(digits.length)-1;i >= 0;i--){\\n            if(digits[i]<9){\\n                digits[i]=digits[i]+1;\\n                return digits;\\n            }else if(digits[i]==9){\\n                digits[i]=0;\\n            }   \\n        }\\n        int[] newarr=new int[digits.length+1];\\n        newarr[0]=1;\\n        return newarr;\\n    }\\n}\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/239c196e-5f36-48cc-b148-20966d5a3f9f_1687449464.7053354.png)\\n\\n\\n\\n**Guys please upvote if you find my solution worthy!! Thanks!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder s=new StringBuilder();\\n    public int[] plusOne(int[] digits) {\\n        for(int i=(digits.length)-1;i >= 0;i--){\\n            if(digits[i]<9){\\n                digits[i]=digits[i]+1;\\n                return digits;\\n            }else if(digits[i]==9){\\n                digits[i]=0;\\n            }   \\n        }\\n        int[] newarr=new int[digits.length+1];\\n        newarr[0]=1;\\n        return newarr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946815,
                "title": "simple-backward-looping-with-c",
                "content": "# Intuition\\nThought about how we can minimize the amount of computation.\\n\\n# Approach\\nLoop backward. \\n\\n1. In case of 9, assign 0. That means we need to increment next digit.\\n2. The others increment and return the digits. \\n3. If the loop has been finished, that means, it requres additional digit. add it and return it.\\n\\nOnly the 3 cases requires additional Memory space and breaks before reach N.\\n\\n# Complexity\\n- Time complexity:\\nO(2N) = O(N).\\nNOTE: I don\\'t know the internal of Concat method. So that my guess.\\n\\n- Space complexity:\\nO(N): Probably, Linq might create a new List or equivalent.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n       for(int i = digits.Length - 1; i >= 0; i--) {\\n           if (digits[i] == 9) {\\n               digits[i] = 0;\\n           } else {\\n               digits[i]++;\\n               return digits;\\n           }\\n       } \\n       int[] firstOne = new int[] { 1 };\\n       return firstOne.Concat(digits).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n       for(int i = digits.Length - 1; i >= 0; i--) {\\n           if (digits[i] == 9) {\\n               digits[i] = 0;\\n           } else {\\n               digits[i]++;\\n               return digits;\\n           }\\n       } \\n       int[] firstOne = new int[] { 1 };\\n       return firstOne.Concat(digits).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711629,
                "title": "fastest-and-easiest-one-liner-faster-than-92-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/5c6d1d55-0730-49d9-a4d8-2d838174d939_1666035771.7792413.png)\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        d=int(\"\".join(map(str, digits)))\\n        d+=1\\n        return list(str(d))\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        d=int(\"\".join(map(str, digits)))\\n        d+=1\\n        return list(str(d))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543183,
                "title": "easy-java-solution-faster-than-100-users",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i =n-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n            \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i =n-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n            \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754490,
                "title": "c-solution-fastest-with-least-time-complexity-and-constant-space",
                "content": "```\\n        //storing given array\\'s size in n\\n        int n = digits.size();\\n        \\n        //taking flag for putting a condition further in code\\n        bool flag = 0;\\n        \\n        //traversing from the last for incrementing with a condition i.e. digit should be < 9.\\n        for(int i = n-1; i>=0; i--){\\n            //checking condition whether digit < 9\\n            if(digits[i]<9){\\n                digits[i] = digits[i] + 1;\\n                flag = 1;\\n                break;\\n            }else{\\n                //if digit is not < 9, then we have to make it 0(coz 9 + 1 = 10(0 in this case, as we are taking ones place))\\n                digits[i] = 0;\\n            }\\n        }\\n        //checking if flag is still 0, if it is 0 then we have to insert 1 at the beginning\\n        if(flag==0){\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n        //storing given array\\'s size in n\\n        int n = digits.size();\\n        \\n        //taking flag for putting a condition further in code\\n        bool flag = 0;\\n        \\n        //traversing from the last for incrementing with a condition i.e. digit should be < 9.\\n        for(int i = n-1; i>=0; i--){\\n            //checking condition whether digit < 9\\n            if(digits[i]<9){\\n                digits[i] = digits[i] + 1;\\n                flag = 1;\\n                break;\\n            }else{\\n                //if digit is not < 9, then we have to make it 0(coz 9 + 1 = 10(0 in this case, as we are taking ones place))\\n                digits[i] = 0;\\n            }\\n        }\\n        //checking if flag is still 0, if it is 0 then we have to insert 1 at the beginning\\n        if(flag==0){\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721895,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n        int carrier = 1;\\n        \\n        for (int i = digits.Length - 1; i >= 0; i--)\\n        {\\n            int temp = digits[i] + carrier;\\n            \\n            digits[i] = temp % 10;\\n            carrier = temp / 10;\\n        }\\n        \\n        if (carrier == 1)\\n        {\\n            List<int> temp = new List<int>();\\n            \\n            temp.Add(carrier);\\n            \\n            foreach (var n in digits)\\n                temp.Add(n);\\n            \\n            return temp.ToArray();\\n        }\\n        \\n        return digits;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] PlusOne(int[] digits) {\\n        int carrier = 1;\\n        \\n        for (int i = digits.Length - 1; i >= 0; i--)\\n        {\\n            int temp = digits[i] + carrier;\\n            \\n            digits[i] = temp % 10;\\n            carrier = temp / 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 24150,
                "title": "a-few-lines-of-javascript",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        digits[i] = (digits[i] + 1) % 10;\\n        if (digits[i]) return digits;\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        digits[i] = (digits[i] + 1) % 10;\\n        if (digits[i]) return digits;\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24338,
                "title": "simple-java-solution-no-copying-arrays",
                "content": "Start from the end. If the current number is less than 9, we won't have a carry: increment the digit and return the array. If we have a 9, then set the current to 0 and simply repeat with the next digit.\\n\\nHere's the kicker: if we complete the loop and don't return, this means that the whole array was set to 0! The answer must therefore be an array that's one bigger with the first number being 1. There's no need to copy to the new array since all numbers are by default initialized to 0.\\n\\n    public int[] plusOne(int[] digits) {\\n        if(digits == null || digits.length == 0){\\n            return new int[0];\\n        }\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{\\n                digits[i] = 0;\\n            }\\n        }\\n        \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Start from the end. If the current number is less than 9, we won't have a carry: increment the digit and return the array. If we have a 9, then set the current to 0 and simply repeat with the next digit.\\n\\nHere's the kicker: if we complete the loop and don't return, this means that the whole array was set to 0! The answer must therefore be an array that's one bigger with the first number being 1. There's no need to copy to the new array since all numbers are by default initialized to 0.\\n\\n    public int[] plusOne(int[] digits) {\\n        if(digits == null || digits.length == 0){\\n            return new int[0];\\n        }\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{\\n                digits[i] = 0;\\n            }\\n        }\\n        \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24386,
                "title": "short-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int>& digits) {\\n            for (int k = digits.size() - 1; k >= 0; --k) {\\n                if (digits[k] < 9) { \\n                    digits[k]++; \\n                    return digits; \\n                } else {\\n                    digits[k] = 0;\\n                }\\n            }\\n            digits[0] = 1, digits.push_back(0);\\n            return digits;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int>& digits) {\\n            for (int k = digits.size() - 1; k >= 0; --k) {\\n                if (digits[k] < 9) { \\n                    digits[k]++; \\n                    return digits; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3138391,
                "title": "straightforward-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe initialize an empty string and fill it with the digits. Then we cast it to an integer and add one. we will then createa a new empty list and go through the characters of the typecasted number (so that its iterable) and append to the empty answer list. Finally, we return the list\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        string = \"\"\\n        for digit in digits:\\n            string += str(digit)\\n        number = int(string) + 1\\n        ans = []\\n        for digit in str(number):\\n            ans.append(int(digit))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        string = \"\"\\n        for digit in digits:\\n            string += str(digit)\\n        number = int(string) + 1\\n        ans = []\\n        for digit in str(number):\\n            ans.append(int(digit))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120632,
                "title": "python-simple-code-beat-100-explained",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        # Adjusting an array of digits into an integer\\n        digits_integer = int(\\'\\'.join(map(str,digits)))\\n        digits_integer +=1\\n        # Adjusting back an integer into an array of digits after plus 1\\n        return [int(x) for x in str(digits_integer)]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        # Adjusting an array of digits into an integer\\n        digits_integer = int(\\'\\'.join(map(str,digits)))\\n        digits_integer +=1\\n        # Adjusting back an integer into an array of digits after plus 1\\n        return [int(x) for x in str(digits_integer)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065579,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Intuition\\nI mean intially I just thought of it being like any other number, just increasing the right will increase the left if it carries over.\\nThat\\'s about it.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i {(int)digits.size()-1}; i >= 0; i--){\\n            if(digits.at(i)!=9){\\n                digits.at(i)++;\\n                break;\\n            }else{digits.at(i)=0;}\\n        }\\n        if(digits.at(0)==0){digits.insert(digits.begin(),1);}\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i {(int)digits.size()-1}; i >= 0; i--){\\n            if(digits.at(i)!=9){\\n                digits.at(i)++;\\n                break;\\n            }else{digits.at(i)=0;}\\n        }\\n        if(digits.at(0)==0){digits.insert(digits.begin(),1);}\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683252,
                "title": "1-line-python",
                "content": "```\\nreturn [int(x) for x in str(int(\"\".join([str(x) for x in digits]))+1)]",
                "solutionTags": [],
                "code": "```\\nreturn [int(x) for x in str(int(\"\".join([str(x) for x in digits]))+1)]",
                "codeTag": "Unknown"
            },
            {
                "id": 2490947,
                "title": "python-easy-solution",
                "content": "```\\ndef plusOne(self, digits: List[int]) -> List[int]: # digits = [4,3,2,1]\\n        st_digits_list = [str(dig) for dig in digits] # [\\'4\\', \\'3\\', \\'2\\', \\'1\\']\\n        st_digits = \"\".join(st_digits_list) # \"4321\"\\n        num = int(st_digits) + 1 # 4322\\n        output= [int(n) for n in str(num)] # [4, 3, 2, 2]\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]: # digits = [4,3,2,1]\\n        st_digits_list = [str(dig) for dig in digits] # [\\'4\\', \\'3\\', \\'2\\', \\'1\\']\\n        st_digits = \"\".join(st_digits_list) # \"4321\"\\n        num = int(st_digits) + 1 # 4322\\n        output= [int(n) for n in str(num)] # [4, 3, 2, 2]\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2432426,
                "title": "java-script-using-only-for-loop-and-if-else-65-ms",
                "content": "//unshit is used to push 1 at front  of array//\\n//if you like it pls upvote//\\nvar plusOne = function(digits) {\\n   for(i=digits.length-1;i>=0;i--){\\n    if(digits[i]!==9){\\n        digits[i]=digits[i]+1;\\n      break;\\n  }\\n   else{\\ndigits[i]=0;\\nif(digits[0]==0){\\n    digits.unshift(1);\\n}\\n   }\\n}return digits;\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "//unshit is used to push 1 at front  of array//\\n//if you like it pls upvote//\\nvar plusOne = function(digits) {\\n   for(i=digits.length-1;i>=0;i--){\\n    if(digits[i]!==9){\\n        digits[i]=digits[i]+1;\\n      break;\\n  }\\n   else{\\ndigits[i]=0;\\nif(digits[0]==0){\\n    digits.unshift(1);\\n}\\n   }\\n}return digits;\\n};\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2370411,
                "title": "0-ms-java-solution",
                "content": "```\\nclass Solution {\\n   public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNo = new int [n+1];\\n    newNo[0] = 1;\\n    \\n    return newNo;\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNo = new int [n+1];\\n    newNo[0] = 1;\\n    \\n    return newNo;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121244,
                "title": "python-concise-solution-with-divmod",
                "content": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        \\n        carry = 1\\n        \\n        for i in range(len(digits) - 1,-1,-1):\\n            carry, digits[i] = divmod(digits[i] + carry, 10)\\n        \\n        return [carry] + digits if carry else digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        \\n        carry = 1\\n        \\n        for i in range(len(digits) - 1,-1,-1):\\n            carry, digits[i] = divmod(digits[i] + carry, 10)\\n        \\n        return [carry] + digits if carry else digits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1463033,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        pointer = len(digits) - 1\\n        \\n        while digits[pointer] == 9:\\n            digits[pointer] = 0\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            digits.insert(0, 1)\\n        \\n        else:\\n            digits[pointer] += 1\\n        \\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        pointer = len(digits) - 1\\n        \\n        while digits[pointer] == 9:\\n            digits[pointer] = 0\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            digits.insert(0, 1)\\n        \\n        else:\\n            digits[pointer] += 1\\n        \\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808473,
                "title": "javascript",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i != -1; i--) {\\n        if (digits[i] != 9) {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    digits.unshift(1) //Getting here means everything was a 9, so it\\'s now all 0\\'s, meaning we should add a 1 in front.\\n    return digits\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i != -1; i--) {\\n        if (digits[i] != 9) {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    digits.unshift(1) //Getting here means everything was a 9, so it\\'s now all 0\\'s, meaning we should add a 1 in front.\\n    return digits\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24207,
                "title": "c-look-for-first-non-9-from-the-tail-backwards",
                "content": "    public int[] PlusOne(int[] digits) \\n    {\\n        int index = digits.Length - 1;\\n        while (index >= 0 && digits[index] == 9)\\n        {\\n            index--;\\n        }\\n        \\n        if (index < 0)\\n        {\\n            int[] res = new int[digits.Length + 1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        else\\n        {\\n            digits[index++]++;\\n            while (index < digits.Length)\\n            {\\n                digits[index++] = 0;\\n            }\\n            return digits;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public int[] PlusOne(int[] digits) \\n    {\\n        int index = digits.Length - 1;\\n        while (index >= 0 && digits[index] == 9)\\n        {\\n            index--;\\n        }\\n        \\n        if (index < 0)\\n        {\\n            int[] res = new int[digits.Length + 1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        else\\n        {\\n            digits[index++]++;\\n            while (index < digits.Length)\\n            {\\n                digits[index++] = 0;\\n            }\\n            return digits;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24109,
                "title": "my-c-code-accepted-with-2-ms",
                "content": "    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n        if (digits == NULL)\\n        {\\n            return NULL;\\n        }\\n        int n = digitsSize-1;\\n        while(n >= 0)\\n        {\\n            if(digits[n] < 9)\\n            {\\n                digits[n]++;\\n                *returnSize = digitsSize;\\n                return digits;\\n            }else\\n            {\\n                digits[n] = 0;\\n                n--;\\n            }\\n        }\\n        \\n        int* newdigit = (int*)malloc((digitsSize+1) * sizeof(int));\\n        newdigit[0] = 1;\\n        for(int i = 1; i < (digitsSize+1); i++)\\n        {\\n            newdigit[i] = digits[i-1];\\n        }\\n        *returnSize = digitsSize+1;\\n        return newdigit;\\n    }",
                "solutionTags": [],
                "code": "    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n        if (digits == NULL)\\n        {\\n            return NULL;\\n        }\\n        int n = digitsSize-1;\\n        while(n >= 0)\\n        {\\n            if(digits[n] < 9)\\n            {\\n                digits[n]++;\\n                *returnSize = digitsSize;\\n                return digits;\\n            }else\\n            {\\n                digits[n] = 0;\\n                n--;\\n            }\\n        }\\n        \\n        int* newdigit = (int*)malloc((digitsSize+1) * sizeof(int));\\n        newdigit[0] = 1;\\n        for(int i = 1; i < (digitsSize+1); i++)\\n        {\\n            newdigit[i] = digits[i-1];\\n        }\\n        *returnSize = digitsSize+1;\\n        return newdigit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24458,
                "title": "my-accepted-java-solution",
                "content": "Hi everyone, this is my accepted Java solution. I used a while loop here so that I don't need to go through the entire array if it's not necessary. Basically, the code will start from the last index of the array and go backwards. if there is a carry-over value, then it will keep going, otherwise it will stop. After the traversing is done, it will check if the first digit is zero (9999 + 1 = 0000) and handle that case. Hope this helps :)\\n\\n    public int[] plusOne(int[] digits) {\\n        boolean carry = true;\\n        int index = digits.length - 1;\\n        while (carry && index > -1) {\\n            if (digits[index] == 9) {\\n                digits[index] = 0; // carry remains true\\n            } else {\\n                digits[index] += 1;\\n                carry = false;\\n            }\\n            index--;\\n        }\\n        if (digits[0] == 0) {\\n            int[] result = new int[digits.length + 1];\\n            result[0] = 1;\\n            for (int i = 1; i < digits.length; i++) {\\n                result[i] = digits[i - 1];\\n            }\\n            return result;\\n        }\\n        return digits;\\n    }",
                "solutionTags": [],
                "code": "Hi everyone, this is my accepted Java solution. I used a while loop here so that I don't need to go through the entire array if it's not necessary. Basically, the code will start from the last index of the array and go backwards. if there is a carry-over value, then it will keep going, otherwise it will stop. After the traversing is done, it will check if the first digit is zero (9999 + 1 = 0000) and handle that case. Hope this helps :)\\n\\n    public int[] plusOne(int[] digits) {\\n        boolean carry = true;\\n        int index = digits.length - 1;\\n        while (carry && index > -1) {\\n            if (digits[index] == 9) {\\n                digits[index] = 0; // carry remains true\\n            } else {\\n                digits[index] += 1;\\n                carry = false;\\n            }\\n            index--;\\n        }\\n        if (digits[0] == 0) {\\n            int[] result = new int[digits.length + 1];\\n            result[0] = 1;\\n            for (int i = 1; i < digits.length; i++) {\\n                result[i] = digits[i - 1];\\n            }\\n            return result;\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795230,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially wanted to make a function variable to keep track of wether we needed to carry and was attempting to handle the edge case for if we needed to increase the size of the array in an over complicated way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooping through the array starting at the last element, if a digit is a 9 we make it a zero and repeat. When we\\'re able to add 1 without going over 9 we should break there, because there is no more work left to do. If we dont\\'t find a number that isn\\'t 9 (meaning we never reach the else condition in the loop), we should then create a new array with 1 as the first element followed by the array digits that got turned to all 0\\'s.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n\\n    for(let i = digits.length - 1; i >= 0; i--) {\\n        if(digits[i] === 9) {\\n            digits[i] = 0\\n        }\\n        else {\\n            digits[i] += 1\\n            return digits\\n        }\\n    }\\n\\n    return [1, ...digits]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n\\n    for(let i = digits.length - 1; i >= 0; i--) {\\n        if(digits[i] === 9) {\\n            digits[i] = 0\\n        }\\n        else {\\n            digits[i] += 1\\n            return digits\\n        }\\n    }\\n\\n    return [1, ...digits]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3394130,
                "title": "clear-c-solution-let-s-find-best-solution-together",
                "content": "**`If you have any thought feel free leave a comment below`**\\n\\n# Code\\n```\\n/** Note: The returned array must be malloced, assume     */\\n/** caller calls free().                                  */\\nint *plusOne(int *digits, int digitsSize, int *returnSize) {\\n    *returnSize = digitsSize;\\n    int *plusOne = malloc(digitsSize * sizeof(int));\\n    if (plusOne == NULL)\\n        return (NULL);\\n    for (int i = 0; i < digitsSize; i++)\\n        plusOne[i] = digits[i];\\n    \\n    plusOne[digitsSize - 1]++;\\n    for (int i = digitsSize - 1; i - 1 >= 0; i--)\\n        if (plusOne[i] == 10) {\\n            plusOne[i] = 0;\\n            plusOne[i - 1]++;\\n        }\\n\\n    if (plusOne[0] == 10) {\\n        (*returnSize)++;\\n        plusOne = realloc(plusOne, *returnSize * sizeof(int));\\n        if (plusOne == NULL)\\n            return (NULL);\\n        memmove(plusOne + 1, plusOne, digitsSize * sizeof(int));\\n        plusOne[0] = 1;\\n        plusOne[1] = 0;\\n    }\\n    return (plusOne);\\n}\\n\\n```\\n1) In the first part we just take memory for return array, and copy source array there\\n2) In the second part we add one to the last element. Go through elements of array from the end and on 10, we split it\\n3) In the last part we work with first element equal to 10. If it is so, we need to realloc memory and move an array by one element\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/** Note: The returned array must be malloced, assume     */\\n/** caller calls free().                                  */\\nint *plusOne(int *digits, int digitsSize, int *returnSize) {\\n    *returnSize = digitsSize;\\n    int *plusOne = malloc(digitsSize * sizeof(int));\\n    if (plusOne == NULL)\\n        return (NULL);\\n    for (int i = 0; i < digitsSize; i++)\\n        plusOne[i] = digits[i];\\n    \\n    plusOne[digitsSize - 1]++;\\n    for (int i = digitsSize - 1; i - 1 >= 0; i--)\\n        if (plusOne[i] == 10) {\\n            plusOne[i] = 0;\\n            plusOne[i - 1]++;\\n        }\\n\\n    if (plusOne[0] == 10) {\\n        (*returnSize)++;\\n        plusOne = realloc(plusOne, *returnSize * sizeof(int));\\n        if (plusOne == NULL)\\n            return (NULL);\\n        memmove(plusOne + 1, plusOne, digitsSize * sizeof(int));\\n        plusOne[0] = 1;\\n        plusOne[1] = 0;\\n    }\\n    return (plusOne);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715491,
                "title": "javascript-solution",
                "content": "var plusOne = function (digits) {\\n    let arrToNumber =BigInt(digits.join(\\'\\'))\\n    let res = BigInt(arrToNumber + BigInt(1))\\n    let myFunc = res => Number(res);\\n\\n    var intArr = Array.from(String(res), myFunc);\\n    return intArr\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var plusOne = function (digits) {\\n    let arrToNumber =BigInt(digits.join(\\'\\'))\\n    let res = BigInt(arrToNumber + BigInt(1))\\n    let myFunc = res => Number(res);\\n\\n    var intArr = Array.from(String(res), myFunc);\\n    return intArr\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2526659,
                "title": "0-ms-java-solution-faster-than-100-simple-solution-within-20-lines",
                "content": "vote up if you like my solution or if it helps you !\\n\\n\\n```\\n    public static int[] plusOne (int[] digits) {\\n        int l = digits.length;\\n        if ( digits[l - 1] != 9 ) {\\n            digits[l - 1]++;\\n            return digits;\\n        } else {\\n            int[] temp = new int[l + 1];\\n            for ( int i = l - 1; i >= 0; i-- )\\n                if ( digits[i] == 9 ) {\\n                    digits[i] = i == 0 ? 1 : 0;\\n                    temp[i] = digits[i];\\n                } else {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            return temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int[] plusOne (int[] digits) {\\n        int l = digits.length;\\n        if ( digits[l - 1] != 9 ) {\\n            digits[l - 1]++;\\n            return digits;\\n        } else {\\n            int[] temp = new int[l + 1];\\n            for ( int i = l - 1; i >= 0; i-- )\\n                if ( digits[i] == 9 ) {\\n                    digits[i] = i == 0 ? 1 : 0;\\n                    temp[i] = digits[i];\\n                } else {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            return temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474823,
                "title": "0ms-hacky-c-solution-tc-o-n-sc-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/a35c611d-a1fa-4ec5-b0ce-135364134343_1661608674.9935284.png)\\n\\nDon\\'t feel confused by looking at the solution complexity. Take a book and go through it once. Then you will get to know how **easy** it really is.\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        if(digits[n]!=9){                                  //If last element is not 9, simply add 1 to it and return\\n            digits[n]++;\\n        }\\n        else{\\n            digits[n]=0;                                   //If you reach here, it means the element is 9. Then make it 0 and follow ahead.\\n            for(int i=n-1; i>=0; i--){                     //Now check the previous element (if exists)\\n                if(digits[i]==9 && i-1>=0){                //If (previous) element is 9 and there is still an element previous to it, then make it 0 and follow ahead.\\n                    digits[i]=0;\\n                }\\n                else if(digits[i]!=9){                     //If (previous) element is not 9, add 1 to it and return the vector.\\n                    digits[i]+=1;\\n                    return digits;\\n                }\\n            }\\n            digits[0]=0;                                   //If you reach here, that means all elements in the vector are 9. (Think about it a little bit!). We made the rest of the elements 0. Now make the first element 0 and insert 1 at the beginning.\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;                                     //Return the final vector!!\\n    }\\n};\\n```\\nPS: If you made it through the process, congrats, you just added a drop to your ocean of knowledge :)\\n**Plz Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        if(digits[n]!=9){                                  //If last element is not 9, simply add 1 to it and return\\n            digits[n]++;\\n        }\\n        else{\\n            digits[n]=0;                                   //If you reach here, it means the element is 9. Then make it 0 and follow ahead.\\n            for(int i=n-1; i>=0; i--){                     //Now check the previous element (if exists)\\n                if(digits[i]==9 && i-1>=0){                //If (previous) element is 9 and there is still an element previous to it, then make it 0 and follow ahead.\\n                    digits[i]=0;\\n                }\\n                else if(digits[i]!=9){                     //If (previous) element is not 9, add 1 to it and return the vector.\\n                    digits[i]+=1;\\n                    return digits;\\n                }\\n            }\\n            digits[0]=0;                                   //If you reach here, that means all elements in the vector are 9. (Think about it a little bit!). We made the rest of the elements 0. Now make the first element 0 and insert 1 at the beginning.\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;                                     //Return the final vector!!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257688,
                "title": "very-easy-c-solution-100-fully-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.size() - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            vector<int>res(digits.size()+1,0);    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.size() - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            vector<int>res(digits.size()+1,0);    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044309,
                "title": "java-simplest-soln-shortest-soln-with-explanation",
                "content": "***If you like the code, Kindly Upvote***\\n\\n```\\nclass Solution {\\npublic int[] plusOne(int[] digits) {\\n    \\n    int carry = 1;\\n    \\n    for (int i = digits.length-1; i>= 0; i--) {\\n        digits[i] += carry;\\n        if (digits[i] != 10) // early return \\n            return digits;\\n        digits[i] = 0;\\n    }\\n    \\n\\t//if upper return statement didn\\'t run, it means [9],[9,9] type of test case is present.\\n\\t\\n    int[] ans = new int[digits.length+1]; \\n    ans[0] = 1; //As other elements will be 0, therefore only updating the 0th element\\n    return ans;\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int[] plusOne(int[] digits) {\\n    \\n    int carry = 1;\\n    \\n    for (int i = digits.length-1; i>= 0; i--) {\\n        digits[i] += carry;\\n        if (digits[i] != 10) // early return \\n            return digits;\\n        digits[i] = 0;\\n    }\\n    \\n\\t//if upper return statement didn\\'t run, it means [9],[9,9] type of test case is present.\\n\\t\\n    int[] ans = new int[digits.length+1]; \\n    ans[0] = 1; //As other elements will be 0, therefore only updating the 0th element\\n    return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839674,
                "title": "very-easy-python-solution-faster-than-97-48",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i, num in [*enumerate(digits)][::-1]:\\n            if num != 9:\\n                digits[i] += 1\\n                break\\n            digits[i] = 0\\n\\n        return [1] + digits if not digits[0] else digits\\n```\\n\\n\"Exploiting\" enumarte to iterate from end to start, and making one less check before returning a value.\\nIf the first number is ```0``` -> concatenate ```[1]``` to start of the list.\\nIf not -> just return digits.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i, num in [*enumerate(digits)][::-1]:\\n            if num != 9:\\n                digits[i] += 1\\n                break\\n            digits[i] = 0\\n\\n        return [1] + digits if not digits[0] else digits\\n```\n```0```\n```[1]```",
                "codeTag": "Java"
            },
            {
                "id": 1726820,
                "title": "simple-java-solution-with-explanation",
                "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        int n = digits.length; \\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;    // if a digit is less than 9, just add 1 and return the new digit array\\n                return digits;\\n            }else{\\n                digits[i] = 0; // if digit is 9, make it zero and in the next iteration the next value will get increment\\n            }           \\n        }\\n        \\n        // if we are here means, every digit in array was 9. So create a new array with +1 size and make first digit Zero.\\n        // exp:  99 => create new array of size 3 => make its first digit 1 => return new array => 100;\\n        \\n        int[] newDigit = new int[n+1];\\n        newDigit[0] = 1;\\n        \\n        return newDigit;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        int n = digits.length; \\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;    // if a digit is less than 9, just add 1 and return the new digit array\\n                return digits;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667209,
                "title": "js",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length -1; i >= 0; i--) {\\n        const curDigit = digits[i];\\n        if (curDigit < 9) {\\n            digits[i] = digits[i] + 1;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    return [1, ...digits];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length -1; i >= 0; i--) {\\n        const curDigit = digits[i];\\n        if (curDigit < 9) {\\n            digits[i] = digits[i] + 1;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    return [1, ...digits];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428535,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size(),carry=1;\\n        for(int i=n-1;i>=0;--i){\\n            int x = digits[i]+carry;\\n            digits[i]=x%10;\\n            carry = x/10;\\n            if(carry==0) break;\\n        }\\n        if(carry>0) digits.insert(digits.begin()+0,carry);\\n        return digits;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size(),carry=1;\\n        for(int i=n-1;i>=0;--i){\\n            int x = digits[i]+carry;\\n            digits[i]=x%10;\\n            carry = x/10;\\n            if(carry==0) break;\\n        }\\n        if(carry>0) digits.insert(digits.begin()+0,carry);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379354,
                "title": "c-0ms-100-faster-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        \\n        //\\n        int n  = digits.size() ;\\n\\n        while(1)\\n        {  // if the digit is not nine then simply add it\\n            if(digits[n-1]!= 9)\\n            {\\n                digits[n-1]++;\\n                return digits;\\n            }\\n\\t\\t\\t// if 9 then 9+1 is 10 we need the 0 only \\n            else \\n            {\\n                digits[n-1] = 0 ;\\n                --n;\\n            }\\n           // if all nine then first digit will be zero add one in the begining\\n            if(digits[0] == 0)\\n            {\\n                digits.insert(digits.begin(),1);\\n                return digits;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        \\n        //\\n        int n  = digits.size() ;\\n\\n        while(1)\\n        {  // if the digit is not nine then simply add it\\n            if(digits[n-1]!= 9)\\n            {\\n                digits[n-1]++;\\n                return digits;\\n            }\\n\\t\\t\\t// if 9 then 9+1 is 10 we need the 0 only \\n            else \\n            {\\n                digits[n-1] = 0 ;\\n                --n;\\n            }\\n           // if all nine then first digit will be zero add one in the begining\\n            if(digits[0] == 0)\\n            {\\n                digits.insert(digits.begin(),1);\\n                return digits;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123616,
                "title": "rust-iterator-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Plus One.\\nMemory Usage: 1.9 MB, less than 95.31% of Rust online submissions for Plus One.\\n```\\nimpl Solution {\\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\\n        let mut digits = digits;\\n        for v in digits.iter_mut().rev() {\\n            let sum = *v + 1;\\n            *v = sum % 10;\\n            if sum < 10 {\\n                return digits;\\n            }\\n        }\\n        [&vec![1], &digits[..]].concat()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\\n        let mut digits = digits;\\n        for v in digits.iter_mut().rev() {\\n            let sum = *v + 1;\\n            *v = sum % 10;\\n            if sum < 10 {\\n                return digits;\\n            }\\n        }\\n        [&vec![1], &digits[..]].concat()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 722172,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i in reversed(range(len(digits))):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            else:\\n                digits[i] = 0\\n        return [1]+digits\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i in reversed(range(len(digits))):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            else:\\n                digits[i] = 0\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142730,
                "title": "simple-javascript-solution-es6",
                "content": "```\\nconst plusOne = digits => {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] < 9) {\\n            digits[i]++\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    return [1, ...digits]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst plusOne = digits => {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] < 9) {\\n            digits[i]++\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    return [1, ...digits]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24296,
                "title": "python-one-line-answer",
                "content": "    return list(map(int, str(int(''.join(map(str, digits)))+1)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return list(map(int, str(int(''.join(map(str, digits)))+1)))",
                "codeTag": "Unknown"
            },
            {
                "id": 24363,
                "title": "javascript-solution-sharing",
                "content": "    /**\\n     * note: [9] plus one [1, 0] // digits[0]=10\\n     */\\n    var plusOne = function(digits) {\\n        var carry = 1;\\n        for(var i=digits.length-1; i>=0; i--){\\n            digits[i] = digits[i] + carry;\\n            digits[i] = (digits[i]>=10)?(carry=1, digits[i]-10):(carry=0, digits[i]);\\n        }\\n        if(carry){ digits.unshift(1); } // note\\n        return digits;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * note: [9] plus one [1, 0] // digits[0]=10\\n     */\\n    var plusOne = function(digits) {\\n        var carry = 1;\\n        for(var i=digits.length-1; i>=0; i--){\\n            digits[i] = digits[i] + carry;\\n            digits[i] = (digits[i]>=10)?(carry=1, digits[i]-10):(carry=0, digits[i]);\\n        }\\n        if(carry){ digits.unshift(1); } // note\\n        return digits;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 24432,
                "title": "my-accepted-java-solution",
                "content": "Just plus one to the last element in the digits , and judge every element then return \\n\\n\\n    public class Solution {\\n        public int[] plusOne(int[] digits) {\\n            digits[digits.length-1]+=1;\\n            for(int i=digits.length-1;i>0;i--)\\n            {\\n                if(digits[i]==10)\\n                {\\n                    digits[i]=0;\\n                    digits[i-1]+=1;\\n                }\\n            }\\n            if(digits[0]==10)\\n            {\\n                int[] res=new int[digits.length+1];\\n                digits[0]=0;\\n                res[0]=1;\\n                for(int i=1;i<res.length;i++)\\n                {\\n                    res[i]=digits[i-1];\\n                }\\n                return res;\\n            }\\n            return digits;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] plusOne(int[] digits) {\\n            digits[digits.length-1]+=1;\\n            for(int i=digits.length-1;i>0;i--)\\n            {\\n                if(digits[i]==10)\\n                {\\n                    digits[i]=0;\\n                    digits[i-1]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3792748,
                "title": "beats-100-explanation-optimized-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This concept is great, and we can imagine it well enough.\\n- We always add the number to another at the end, Ex: 1002 + 2 = 100***4*** \\n- If we get any carry we pass it to the next number from right to left.\\n- Similarly it\\'s an easy version of that.\\n##### Let\\'s dive deep into it:\\n- We have to just add 1 to the number whose digit are represented in array format.\\n###### - There can be only two cases:\\n1. The number = 9 (need to pass one as carry, and number will be equals to zero)\\n2. If number !=9 , number++;\\n\\n###### - The Special Case:\\n1. Let\\'s say the number is in form of 999, after adding 1, number= 1000 (**Need to increase the size of vector**: (v.push_back(0))\\n2. If not then come out of loop.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate over the vector: \\n 1. if i==n-1, v[i]++\\n 2. then check if v[i]==10\\n  - v[i]=0\\n  - if(i!=0) v[i-1]++\\n  - else push_back 0, and v[i]=1; \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n##### We can more optimize it but it would have no effect on time complexity \\n# More optimized:\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510251,
                "title": "c-quick-addition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your timecomplexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short int i = digits.size() - 1;\\n        if (i >= 0) {\\n            while (i != -1) {\\n                digits[i] += 1;\\n                if (i == 0 && digits[i] == 10) {\\n                    digits[i] = 0;\\n                    digits.insert(digits.begin(), 1);\\n                }\\n                else if (digits[i] == 10) digits[i] = 0;\\n                else break;\\n                i--;\\n            }\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short int i = digits.size() - 1;\\n        if (i >= 0) {\\n            while (i != -1) {\\n                digits[i] += 1;\\n                if (i == 0 && digits[i] == 10) {\\n                    digits[i] = 0;\\n                    digits.insert(digits.begin(), 1);\\n                }\\n                else if (digits[i] == 10) digits[i] = 0;\\n                else break;\\n                i--;\\n            }\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473937,
                "title": "easy-to-understand-explained-part-by-part-without-reverse",
                "content": "\\n# Approach\\nwe have to add 1 at the last element ;\\nso we took a for loop which starts from the end;\\n\\nif the last digit is not 9 then we can easily add 1 with it .But for 9 we will get extra 1 carry. 9+0=10;\\nwe will handle that letter.\\n\\nfirst off all if our element is lesser then 9 .we will simply add 1 and break the loop and return .\\n \\n      if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\nif the digit is 9 then the sum will 10 .we have to put 0 and 1 carry will be added with prvious number .\\nexample : [1,2,9] -> [1,3,0]\\n \\n    else { digits[i]=0;}\\nif all the array becomes 0 .for example [9,9,9]+1 the result should be [1,0,0,0]\\nso we inserted \\'1\\' at the begining of the array\\n    \\n    if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\n            else { digits[i]=0;}\\n        }\\n        if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n        return digits;\\n    }\\n};\\n```\\n# please Upvote :(",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\n            else { digits[i]=0;}\\n        }\\n        if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176624,
                "title": "java-best-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int p=digits.length;\\n        for(int i=p-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n\\n        int arr[]=new int[p+1];\\n        arr[0]=1;\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int p=digits.length;\\n        for(int i=p-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n\\n        int arr[]=new int[p+1];\\n        arr[0]=1;\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994509,
                "title": "recursive-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSaw a lot of iterative solutions, so I tried to think of a recursive one. As can be quickly deduce, the difficulty of this problem is dealing with the \"9\" digits, not just the ones in the last digit but all of them. In order to simplify the work, we recursively solve for this specific case, so that it does not matter how many \"9\"s we have.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur two base cases are when the **only** digit is \"9\" and when it is not \"9\". Otherwise, we recursively call this function for the rest of the digits, while accounting for our last digit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        last = digits[-1]\\n        if last == 9:\\n            if len(digits) == 1:\\n                return [1,0]\\n            return self.plusOne(digits[:-1]) + [0]\\n        digits[-1] += 1\\n        return digits\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        last = digits[-1]\\n        if last == 9:\\n            if len(digits) == 1:\\n                return [1,0]\\n            return self.plusOne(digits[:-1]) + [0]\\n        digits[-1] += 1\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765133,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { \\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { \\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760321,
                "title": "golang-0ms-portugues-br-video",
                "content": "https://www.youtube.com/watch?v=Wx_dAxDFEZ4&ab_channel=Codando\\n\\n```\\nfunc plusOne(digits []int) []int {\\n    \\n    for i := len(digits) - 1; i >= 0; i--{\\n        \\n        if digits[i] < 9{\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    \\n    if digits[0] == 0{\\n        digits = append([]int{1}, digits...)\\n    }\\n    \\n    return digits\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    \\n    for i := len(digits) - 1; i >= 0; i--{\\n        \\n        if digits[i] < 9{\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    \\n    if digits[0] == 0{\\n        digits = append([]int{1}, digits...)\\n    }\\n    \\n    return digits\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710251,
                "title": "typescript-oneliner-solution",
                "content": "`return Array.from((BigInt(digits.join(\\'\\')) + BigInt(\\'1\\')).toString(), Number)`",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "`return Array.from((BigInt(digits.join(\\'\\')) + BigInt(\\'1\\')).toString(), Number)`",
                "codeTag": "Unknown"
            },
            {
                "id": 2687851,
                "title": "plus-one-java-100-fast-solution",
                "content": "Hi Everyone\\nHere is the easy solution for the Plus One Question with explanation as in commented code.\\n\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        int n = digits.length;\\n\\t\\t// loop to add the digits\\n        for(int i=n-1; i>=0; i--) {\\n            digits[i] += carry;   // add carry in every digit\\n            carry = digits[i] / 10;   // update carry for next digit\\n            digits[i] = digits[i] % 10;   //  put remainder in the digit\\n        }\\n        if(carry == 1) {   // in case of carry, we need to return n+1 length array\\n            int[] res = new int[n+1];\\n            res[0] = 1;\\n\\t\\t\\t// assinging values of digit in new array\\n            for(int i=1; i<=n;i++) {\\n                res[i] = digits[i-1];\\n            }\\n            return res;\\n        }\\n        return digits;   // not a carry, we can send updated digit array\\n    }\\n}\\n```\\n\\nThanks & Happy Coding!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        int n = digits.length;\\n\\t\\t// loop to add the digits\\n        for(int i=n-1; i>=0; i--) {\\n            digits[i] += carry;   // add carry in every digit\\n            carry = digits[i] / 10;   // update carry for next digit\\n            digits[i] = digits[i] % 10;   //  put remainder in the digit\\n        }\\n        if(carry == 1) {   // in case of carry, we need to return n+1 length array\\n            int[] res = new int[n+1];\\n            res[0] = 1;\\n\\t\\t\\t// assinging values of digit in new array\\n            for(int i=1; i<=n;i++) {\\n                res[i] = digits[i-1];\\n            }\\n            return res;\\n        }\\n        return digits;   // not a carry, we can send updated digit array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680601,
                "title": "java-100-runtime-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n       int len=digits.length;\\n       for(int i=len-1;i>=0;i--){\\n           if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n           }\\n           digits[i]=0;\\n       }\\n        int[] newArr=new int[len+1];\\n        newArr[0]=1;\\n        return newArr;\\n    }\\n}\\n```\\n**please upvote if u like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n       int len=digits.length;\\n       for(int i=len-1;i>=0;i--){\\n           if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n           }\\n           digits[i]=0;\\n       }\\n        int[] newArr=new int[len+1];\\n        newArr[0]=1;\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666984,
                "title": "c-clean-o-1-space-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        //same as add 1\\n        int carry = 1;\\n        \\n        // propagate carry\\n        for (int i = digits.size() - 1; i >= 0; --i) {\\n            digits[i] += carry;\\n            carry = digits[i] / 10;\\n            digits[i] = digits[i] % 10;\\n        }\\n        \\n        // handle the last carry if any\\n        if (carry) {\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        //same as add 1\\n        int carry = 1;\\n        \\n        // propagate carry\\n        for (int i = digits.size() - 1; i >= 0; --i) {\\n            digits[i] += carry;\\n            carry = digits[i] / 10;\\n            digits[i] = digits[i] % 10;\\n        }\\n        \\n        // handle the last carry if any\\n        if (carry) {\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574962,
                "title": "javascript-two-line-solution",
                "content": "```\\nvar plusOne = function (digits) {\\n  const arr = [...(BigInt(digits.join(\"\")) + BigInt(1)).toString()];\\n  return arr.map(Number);\\n};\\n```\\nWe have to use the **bigInt()**. <br>\\nBecause JS have a limited precision (2^53=9,007,199,254,740,992 for the biggest integer). And Test case `[6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3]` has passed that limit. As we cross the limit, we have to call the `bigInt()` function to to do precise calculation. And we can not add 1 directly to a `big-integer`. The number has to be the same type. Therefore, we have to add 1 like -  `bigInt(1)`. <br>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function (digits) {\\n  const arr = [...(BigInt(digits.join(\"\")) + BigInt(1)).toString()];\\n  return arr.map(Number);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377251,
                "title": "c-solution-easy-fast-than-96",
                "content": "```\\nvector<int> plusOne(vector<int>& digits) {\\n\\tint n = digits.size(), i; \\n\\tfor (i = n-1; i>=0; i--) {\\n\\t\\tif(digits[i]!=9) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(i==-1) {\\n\\t\\tvector<int> v(n+1, 0);\\n\\t\\tv[0]=1;\\n\\t\\treturn v;\\n\\t}\\n\\tdigits[i]++;\\n\\tfor(int j = i+1; j<n; j++) \\n\\t\\tdigits[j] = 0;\\n\\treturn digits;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> plusOne(vector<int>& digits) {\\n\\tint n = digits.size(), i; \\n\\tfor (i = n-1; i>=0; i--) {\\n\\t\\tif(digits[i]!=9) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(i==-1) {\\n\\t\\tvector<int> v(n+1, 0);\\n\\t\\tv[0]=1;\\n\\t\\treturn v;\\n\\t}\\n\\tdigits[i]++;\\n\\tfor(int j = i+1; j<n; j++) \\n\\t\\tdigits[j] = 0;\\n\\treturn digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267126,
                "title": "go-easy-and-fast",
                "content": "```\\nfunc PlusOne(digits []int) []int {\\n\\tvar res int = 1\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\ts := digits[i]\\n\\t\\tif s+res <= 9 {\\n\\t\\t\\tdigits[i] += res\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\t\\tif i == 0 {\\n\\t\\t\\tdigits = append([]int{1}, digits...)\\n\\t\\t}\\n\\t}\\n\\treturn digits\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc PlusOne(digits []int) []int {\\n\\tvar res int = 1\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\ts := digits[i]\\n\\t\\tif s+res <= 9 {\\n\\t\\t\\tdigits[i] += res\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\t\\tif i == 0 {\\n\\t\\t\\tdigits = append([]int{1}, digits...)\\n\\t\\t}\\n\\t}\\n\\treturn digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090046,
                "title": "ruby-solutions-elegant-ruby-pointer-using-modulus-and-recursion",
                "content": "## Elegant Ruby solution\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n```\\n\\n## Pointer with modulus solution\\n\\nThis is what a technical interview is looking for....\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    carryover, pointer = 1, -1\\n    \\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n        \\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n        \\n    digits\\nend\\n```\\n\\n## Recursiion of pointer with modulus solution\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n    \\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n    \\n    plus_one(digits, pointer - 1, sum / 10)\\nend\\n```\\n\\n## Benchmark\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_ruby_like(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_pointer(digits)\\n    carryover, pointer = 1, -1\\n\\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n\\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n\\n    digits\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_recursive(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n\\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n\\n    plus_one_recursive(digits, pointer - 1, sum / 10)\\nend\\n\\nrequire \\'benchmark\\'\\n\\nn = 1_000_000\\ntest_cases =\\n    [\\n        [1,2,3],\\n        [4,3,2,1],\\n        [9]\\n    ]\\n\\nBenchmark.bmbm do |x|\\n    x.report(\\'plus_one_ruby_like()\\') { n.times { |nth| plus_one_ruby_like(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_pointer()\\')  { n.times { |nth| plus_one_pointer(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_recursive()\\')  { n.times { |nth| plus_one_recursive(test_cases[nth % test_cases.length]) } }\\nend\\n```\\n\\nResult:\\n\\nRuby-like solution is slower due to the new object creations and transformation.\\n\\nThe pointer is faster since its updating the existing object, `digits`, in place.\\n\\nThis can be verified by calling `object_id` on the resulting object. The Ruby-like solution creates new objects, while the pointer solution result has the same `object_id` as the input.\\n\\n```\\nRehearsal --------------------------------------------------------\\nplus_one_ruby_like()   0.872726   0.003306   0.876032 (  0.876655)\\nplus_one_pointer()     0.176923   0.000899   0.177822 (  0.178070)\\nplus_one_recursive()   0.185491   0.000453   0.185944 (  0.185986)\\n----------------------------------------------- total: 1.239798sec\\n\\n                           user     system      total        real\\nplus_one_ruby_like()   1.449080   0.008460   1.457540 (  1.458386)\\nplus_one_pointer()     0.176361   0.001490   0.177851 (  0.178214)\\nplus_one_recursive()   0.188032   0.001648   0.189680 (  0.190059)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    carryover, pointer = 1, -1\\n    \\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n        \\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n        \\n    digits\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n    \\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n    \\n    plus_one(digits, pointer - 1, sum / 10)\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_ruby_like(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_pointer(digits)\\n    carryover, pointer = 1, -1\\n\\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n\\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n\\n    digits\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_recursive(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n\\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n\\n    plus_one_recursive(digits, pointer - 1, sum / 10)\\nend\\n\\nrequire \\'benchmark\\'\\n\\nn = 1_000_000\\ntest_cases =\\n    [\\n        [1,2,3],\\n        [4,3,2,1],\\n        [9]\\n    ]\\n\\nBenchmark.bmbm do |x|\\n    x.report(\\'plus_one_ruby_like()\\') { n.times { |nth| plus_one_ruby_like(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_pointer()\\')  { n.times { |nth| plus_one_pointer(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_recursive()\\')  { n.times { |nth| plus_one_recursive(test_cases[nth % test_cases.length]) } }\\nend\\n```\n```\\nRehearsal --------------------------------------------------------\\nplus_one_ruby_like()   0.872726   0.003306   0.876032 (  0.876655)\\nplus_one_pointer()     0.176923   0.000899   0.177822 (  0.178070)\\nplus_one_recursive()   0.185491   0.000453   0.185944 (  0.185986)\\n----------------------------------------------- total: 1.239798sec\\n\\n                           user     system      total        real\\nplus_one_ruby_like()   1.449080   0.008460   1.457540 (  1.458386)\\nplus_one_pointer()     0.176361   0.001490   0.177851 (  0.178214)\\nplus_one_recursive()   0.188032   0.001648   0.189680 (  0.190059)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2057867,
                "title": "php-solutions-in-one-line",
                "content": "```\\nfunction plusOne($digits) {\\n        return str_split(bcadd(1,implode($digits)));\\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction plusOne($digits) {\\n        return str_split(bcadd(1,implode($digits)));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031771,
                "title": "c-solution-two-approaches-easy-to-understand",
                "content": "**Approach 1 :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry=1,size=digits.size();\\n        for(int i=size-1;i>=0;i--) {\\n            int sum=digits[i]+carry;\\n            digits[i]=sum%10;\\n            carry=sum/10;\\n        }\\n        if(carry>0) digits.insert(digits.begin(),carry);\\n        return digits;\\n    }\\n};\\n```\\n\\n\\n**Approach 2 :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```\\n\\nIf you liked the solution then, please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry=1,size=digits.size();\\n        for(int i=size-1;i>=0;i--) {\\n            int sum=digits[i]+carry;\\n            digits[i]=sum%10;\\n            carry=sum/10;\\n        }\\n        if(carry>0) digits.insert(digits.begin(),carry);\\n        return digits;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478974,
                "title": "c-the-best-teacher-is-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368813,
                "title": "plus-one-easy-python-solution",
                "content": "If the last digit is any number from **0-8**, incrementing that by 1 will not cause any issue, making the case simple. In case the last digit is **9**, adding 1 will make it 10, so 9 will be replaced by 0 and addition of 1 to the previous number is to be done.\\n\\nConsider the example of 99 = [9,9] - adding 1 to last digit makes it 0 and 1 is added to previous digit and that again will become 0. Now since this is the first digit of the number (here in list format), 1 needs to be appended before it to finish the addition. This is done in the code blow. \\n\\n```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        n = len(digits)\\n        \\n        while n>0:\\n            if digits[n-1]==9:\\n                if (n-1) == 0:\\n                    digits[n-1] = 0\\n                    temp = [1] + digits\\n                    return temp\\n                else:\\n                    digits[n-1] = 0\\n                    n = n-1\\n            else:\\n                digits[n-1] += 1\\n                return digits\\n        \\n        return digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        n = len(digits)\\n        \\n        while n>0:\\n            if digits[n-1]==9:\\n                if (n-1) == 0:\\n                    digits[n-1] = 0\\n                    temp = [1] + digits\\n                    return temp\\n                else:\\n                    digits[n-1] = 0\\n                    n = n-1\\n            else:\\n                digits[n-1] += 1\\n                return digits\\n        \\n        return digits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1290715,
                "title": "java-simple-0ms-faster-than-100-pure-logic-clean-efficient-explained",
                "content": "# **Please Upvote if you got any help from the provided solution!!!**\\n\\nBasic Idea behind this implementation is:\\n* Increment the element by 1 if it is not equal to 9 and return it. \\neg: 35 + 1 = 16, so we will increment the element 5 by 1 to make it 6 and return it as no further manipulation is required on element 3(from 38).\\n\\n* But if element is 9, then make that element as 0(zero).\\neg: 59 + 1 = 60, here we will make the element 9 as 0(zero) and in the next iteration increment the element 5(from 59) by 1 to make it 6 and return it.\\n\\n* But for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array so as to fit an extra element into it and return the newly created array.\\neg: If we have an array of length 4 and all elements consists of 9, then we need an array of length 5, so as to make the first element as 1(one) and remaining ones as 0\\'s(zeros).<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9999  <-- here the number of digits are 4\\n<u>&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</u> \\n&nbsp;&nbsp;&nbsp;10000  <-- but after adding 1 to it the number of digits becomes 5 and for storing an extra element we need to create a new array of 1 length larger than the original one.\\n<hr><br>\\n\\n\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        final int len = digits.length;\\n        \\n        for(int index = len - 1; index >= 0; --index){\\n            if(digits[index] != 9){\\n                digits[index] += 1;  // if element is not equal to 9, then increment it by 1 and return it\\n                return digits; \\n            }\\n            digits[index] = 0; // else if element is 9, then make that element as 0(zero)\\n        }\\n        \\n        final int[] result = new int[len + 1]; //  for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array\\n        result[0] = 1; // making the 1st element as 1 and rest will be 0 as the default value of int is 0, so all elements will be 0 except for 1st element which will be 1\\n        return result;\\n    }\\n}\\n```\\n\\n# **Please Upvote if you got any help from the provided solution!!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        final int len = digits.length;\\n        \\n        for(int index = len - 1; index >= 0; --index){\\n            if(digits[index] != 9){\\n                digits[index] += 1;  // if element is not equal to 9, then increment it by 1 and return it\\n                return digits; \\n            }\\n            digits[index] = 0; // else if element is 9, then make that element as 0(zero)\\n        }\\n        \\n        final int[] result = new int[len + 1]; //  for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array\\n        result[0] = 1; // making the 1st element as 1 and rest will be 0 as the default value of int is 0, so all elements will be 0 except for 1st element which will be 1\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207212,
                "title": "java-faster-than-100-easy-way",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\t\\t\\n\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (digits[i] < 9) { \\n\\t\\t\\t\\tdigits[i]++;\\n\\t\\t\\t\\treturn digits;\\n\\t\\t\\t} else { digits[i] = 0; }\\n\\t\\t}\\n        \\n        int[] temp = new int[digits.length + 1];\\n\\t\\ttemp[0] = 1;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\t\\t\\n\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (digits[i] < 9) { \\n\\t\\t\\t\\tdigits[i]++;\\n\\t\\t\\t\\treturn digits;\\n\\t\\t\\t} else { digits[i] = 0; }\\n\\t\\t}\\n        \\n        int[] temp = new int[digits.length + 1];\\n\\t\\ttemp[0] = 1;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694574,
                "title": "java-with-comments-easy-to-understand-100-time",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for(int i=digits.length-1; i>=0; i--){\\n            if(digits[i]<9){\\n                //first non-9 will be incremented by 1 and then the result is returned\\n                digits[i] = digits[i] + 1;\\n                return digits;\\n            }\\n            //if it is 9, make it zero. we\\'re incrementing first non-9 above.\\n            digits[i] = 0;\\n        }\\n            \\n        //if we reached here that means we have a case where array consists of all nines.  \\n        //In that case, the array is all zeroes. we just need to make 0th position 1. \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for(int i=digits.length-1; i>=0; i--){\\n            if(digits[i]<9){\\n                //first non-9 will be incremented by 1 and then the result is returned\\n                digits[i] = digits[i] + 1;\\n                return digits;\\n            }\\n            //if it is 9, make it zero. we\\'re incrementing first non-9 above.\\n            digits[i] = 0;\\n        }\\n            \\n        //if we reached here that means we have a case where array consists of all nines.  \\n        //In that case, the array is all zeroes. we just need to make 0th position 1. \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24438,
                "title": "my-c-code-check-9",
                "content": "    vector<int> plusOne(vector<int> &digits) {\\n        int i;\\n        for(i=digits.size()-1;i>=0;i--)\\n        {\\n            if(digits[i]!=9)\\n            {\\n                digits[i]++;\\n                break;\\n            }\\n            else\\n            {\\n                digits[i] = 0;\\n            }\\n        }\\n        if(!digits[0])\\n        {\\n            digits[0] = 1;\\n            digits.push_back(0);\\n        }\\n        return digits;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> plusOne(vector<int> &digits) {\\n        int i;\\n        for(i=digits.size()-1;i>=0;i--)\\n        {\\n            if(digits[i]!=9)\\n            {\\n                digits[i]++;\\n                break;\\n            }\\n            else\\n            {\\n                digits[i] = 0;\\n            }\\n        }\\n        if(!digits[0])\\n        {\\n            digits[0] = 1;\\n            digits.push_back(0);\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4087841,
                "title": "python-98-30-beats-2-approachs-simple-code",
                "content": "**If you got help from this,... Plz Upvote .. it encourage me**\\n\\n# Code\\n# Approach 1 (Array) -> 98.30 % beats\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1, -1, -1):\\n            if digits[i] == 9:\\n                digits[i] = 0\\n            else:\\n                digits[i] = digits[i] + 1\\n                return digits\\n        return [1] + digits \\n\\n        \\n```\\n\\n# Approach 2 (Convert list -> Number :: -> Addition +1 :: -> Number  -> List\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        # List -> Number\\n        n = 0\\n        for ele in digits:\\n            n = (n*10) + ele\\n        \\n        n = n+1\\n        \\n        # Number -> List\\n        digits = []\\n        while n > 0:\\n            digits.insert(0, n % 10)  \\n            n //= 10 \\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1, -1, -1):\\n            if digits[i] == 9:\\n                digits[i] = 0\\n            else:\\n                digits[i] = digits[i] + 1\\n                return digits\\n        return [1] + digits \\n\\n        \\n```\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        # List -> Number\\n        n = 0\\n        for ele in digits:\\n            n = (n*10) + ele\\n        \\n        n = n+1\\n        \\n        # Number -> List\\n        digits = []\\n        while n > 0:\\n            digits.insert(0, n % 10)  \\n            n //= 10 \\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075521,
                "title": "simple-and-easy-approach-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n //you have to traverse array until the element is not equal to 9\\n//from last index and add one if element is not equal to 9\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n//if whole array is nine the push_back one element and index[0]==1\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n //you have to traverse array until the element is not equal to 9\\n//from last index and add one if element is not equal to 9\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n//if whole array is nine the push_back one element and index[0]==1\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959120,
                "title": "java-code-easy-to-under-stand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            digits[i]++;\\n            if (digits[i] < 10) {\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n       \\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            digits[i]++;\\n            if (digits[i] < 10) {\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n       \\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934362,
                "title": "simple-easy-solution-in-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668116,
                "title": "intuitive-recursive-solution-run-time-o-n-space-o-1",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the last element is smaller than 9. -> ** add 1 to the last element**\\n\\nIf the last element is equal to 9. --> **change the value of the element to 0 (as we can\\'t store the value 10 in one digit, we have to carry 1 to the next digit)\\n\\nDecrease i by 1 (to iterate backward as we are using i as index) and decrease length by 1 (we need length as a reference to stop the recursion)\\n$$note:$$ we don\\'t need a \"carry\" variable as in every scenario it is going to be 1\\nCall the function again.\\n\\nWhen we call the function again, if the next digit is smaller than 9 we can just +1 the value of the element we are on.\\n\\nIf the element is 9 we can call our function again.\\nIf there is no element left (but we still have to add the $$carry$$, we add 1 as a new element to the list)\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        i = -1 #index to start from the end\\n        length = len(digits) \\n\\n        def Calculate(arr, i, length):\\n            if length != 0 and arr[i] != 9:\\n                arr[i] += 1 \\n            elif length > 0:\\n                arr[i] = 0\\n                length -= 1\\n                i -= 1\\n                Calculate(arr, i, length)\\n            else:\\n                arr.insert(0, 1) \\n        \\n        Calculate(digits, i, length)\\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        i = -1 #index to start from the end\\n        length = len(digits) \\n\\n        def Calculate(arr, i, length):\\n            if length != 0 and arr[i] != 9:\\n                arr[i] += 1 \\n            elif length > 0:\\n                arr[i] = 0\\n                length -= 1\\n                i -= 1\\n                Calculate(arr, i, length)\\n            else:\\n                arr.insert(0, 1) \\n        \\n        Calculate(digits, i, length)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606996,
                "title": "optimized-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size(); // Get the size of the digits array\\n        for (int i = n - 1; i >= 0; i--) { // Iterate over the digits array from right to left\\n            if (digits[i] < 9) { // Check if the current digit is less than 9\\n                digits[i]++; // If it is, increment the digit by 1\\n                return digits; // Return the modified array\\n            }\\n            digits[i] = 0; // Set the current digit to 0 since it was 9\\n        }\\n        digits.insert(digits.begin(), 1); // If all digits were 9, insert 1 at the beginning\\n        return digits; // Return the modified array\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size(); // Get the size of the digits array\\n        for (int i = n - 1; i >= 0; i--) { // Iterate over the digits array from right to left\\n            if (digits[i] < 9) { // Check if the current digit is less than 9\\n                digits[i]++; // If it is, increment the digit by 1\\n                return digits; // Return the modified array\\n            }\\n            digits[i] = 0; // Set the current digit to 0 since it was 9\\n        }\\n        digits.insert(digits.begin(), 1); // If all digits were 9, insert 1 at the beginning\\n        return digits; // Return the modified array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462162,
                "title": "add-one-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        int c=1;\\n        for(int i=d.size()-1;i>=0;i--)\\n        {\\n            int f=d[i]+c;\\n            d[i]=f%10;\\n            c=f/10;\\n        }\\n        if(c!=0)\\n        {\\n            reverse(d.begin(),d.end());\\n            d.push_back(c);\\n            reverse(d.begin(),d.end());\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        int c=1;\\n        for(int i=d.size()-1;i>=0;i--)\\n        {\\n            int f=d[i]+c;\\n            d[i]=f%10;\\n            c=f/10;\\n        }\\n        if(c!=0)\\n        {\\n            reverse(d.begin(),d.end());\\n            d.push_back(c);\\n            reverse(d.begin(),d.end());\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393850,
                "title": "increment-a-large-integer-represented-as-an-array-c-solution-easy-to-understand",
                "content": "# Intuition\\n![iages.jpeg](https://assets.leetcode.com/users/images/886eabe7-02a5-4004-a712-457c4c886152_1680957173.8068066.jpeg)\\n\\n\\n***We need to increment a large integer represented as an integer array by 1. One way to approach this problem is to iterate through the array from right to left and add 1 to each digit until we find a digit that is less than 10. If we reach the leftmost digit and it needs to be set to 0, we need to create a new array with one extra element and set the first element to 1.***\\n\\n# Approach\\n\\n***We will implement the approach mentioned in the intuition. We will start iterating through the array from right to left and increment each digit by 1. If the resulting digit is less than 10, we can return the modified array. Otherwise, we will set the current digit to 0 and continue with the next digit.If we reach the leftmost digit and it needs to be set to 0, we will create a new array with one extra element and set the first element to 1. We will return this new array as the result.***\\n\\n# Complexity\\n- Time complexity:\\n- \\n       O(N)\\n\\n- Space complexity:\\n- \\n       O(1)\\n       \\n\\n# Code\\n```\\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    for (int i = digitsSize - 1; i >= 0; i--) {\\n        digits[i]++;\\n        if (digits[i] < 10) {\\n            *returnSize = digitsSize;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\\n    result[0] = 1;\\n    for (int i = 1; i <= digitsSize; i++) {\\n        result[i] = 0;\\n    }\\n    *returnSize = digitsSize + 1;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    for (int i = digitsSize - 1; i >= 0; i--) {\\n        digits[i]++;\\n        if (digits[i] < 10) {\\n            *returnSize = digitsSize;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\\n    result[0] = 1;\\n    for (int i = 1; i <= digitsSize; i++) {\\n        result[i] = 0;\\n    }\\n    *returnSize = digitsSize + 1;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298844,
                "title": "python-easiest-approach-beating-90-25",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/cfd19bd3-25de-4601-b4c4-24885a9e2151_1678857572.4187334.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        digits=[str(i) for i in digits]\\n        s=\\'\\'.join(digits)\\n        a=int(s)+1\\n        l=list(str(a))\\n        l=[int(i) for i in l]\\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        digits=[str(i) for i in digits]\\n        s=\\'\\'.join(digits)\\n        a=int(s)+1\\n        l=list(str(a))\\n        l=[int(i) for i in l]\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260726,
                "title": "python3-95-fast",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- MSB to LSB is gives so increment in reverse manner.\\n- maintan carry variable to map if we have any previous overflow.\\n- at last if we have any carry left insert it to front of list.\\n- return digits.\\n\\n\\n![Screenshot 2023-03-05 204834.png](https://assets.leetcode.com/users/images/c7e27b34-d600-40e9-b750-d26fb8a3e99c_1678029545.3783138.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 0\\n        n = len(digits)\\n        for i in reversed(range(n)):\\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\\n            if val <= 9:\\n                digits[i] = val\\n                carry = 0\\n            else:\\n                carry = val // 10\\n                val -= 10\\n                digits[i] = val\\n        if carry:\\n            digits.insert(0, carry)\\n        return digits\\n```\\n# Please like and Comment below \\uD83D\\uDC4B\\u2267\\u25C9\\u1D25\\u25C9\\u2266",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 0\\n        n = len(digits)\\n        for i in reversed(range(n)):\\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\\n            if val <= 9:\\n                digits[i] = val\\n                carry = 0\\n            else:\\n                carry = val // 10\\n                val -= 10\\n                digits[i] = val\\n        if carry:\\n            digits.insert(0, carry)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137627,
                "title": "plus-one-o-n-time-complexity",
                "content": "# Intuition\\nTo not use Brute Force Approach and optimize the solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* for numbers less than or equal to 8 - can directly be incremented by 1.\\n* eg: 786 + 1= 787\\n* for number which is equal to 9 - will be replaced with 0 and generate a carry\\n* That carry will be further added to the beginning. \\n* eg: 9 + 1 = 0 carry generated  \\n* Now 1 will be placed in the beginning. \\n* Final array will be 10 \\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short i =0; // for smaller integers\\n        bool carry =0; // carry can be zero or one so used bool\\n        for(i=digits.size()-1;i>=0;--i){\\n            if(digits[i]<=8){ // for digits less than 8\\n                digits[i]++; // incremented by 1 directly\\n                carry =0; // no need of carry\\n                break; // increased the number by 1 and break\\n            }\\n            else{\\n                digits[i]=0; // else if the number is 9 , so replace the number by 0\\n                carry=1; // generate a carry 1\\n            }\\n        }\\n        if (carry) digits.insert(digits.begin(),1); // as number was increased by 1 there was 1 carry , carry will be placed in beginning \\n        return digits; // return the incremented digits as final output \\n    }\\nint main(){\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short i =0; // for smaller integers\\n        bool carry =0; // carry can be zero or one so used bool\\n        for(i=digits.size()-1;i>=0;--i){\\n            if(digits[i]<=8){ // for digits less than 8\\n                digits[i]++; // incremented by 1 directly\\n                carry =0; // no need of carry\\n                break; // increased the number by 1 and break\\n            }\\n            else{\\n                digits[i]=0; // else if the number is 9 , so replace the number by 0\\n                carry=1; // generate a carry 1\\n            }\\n        }\\n        if (carry) digits.insert(digits.begin(),1); // as number was increased by 1 there was 1 carry , carry will be placed in beginning \\n        return digits; // return the incremented digits as final output \\n    }\\nint main(){\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122017,
                "title": "simple-way-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int idx=digits.size()-1;\\n        while(idx>=0)\\n        {\\n            if(digits[idx]==9)\\n            {\\n                digits[idx]=0;\\n            }\\n            else\\n            {\\n                digits[idx]+=1;\\n                return digits;\\n            }\\n            idx--;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n        \\n        \\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int idx=digits.size()-1;\\n        while(idx>=0)\\n        {\\n            if(digits[idx]==9)\\n            {\\n                digits[idx]=0;\\n            }\\n            else\\n            {\\n                digits[idx]+=1;\\n                return digits;\\n            }\\n            idx--;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n        \\n        \\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086740,
                "title": "beats-100-easy-beginner-friendly-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nHere,First we have to take two cases\\n1) if digit < 9\\n    casually increment digit[i];\\n2) if digit == 9\\n    here we find no of last occuring 9\\'s so,we increment just      before index of first 9 in given array order.\\n->apply for loop to get incrementing position\\ntwo cases\\n 1.if only one 9 i.e., {9} then we have update 9 to 1 and pushback 0;\\n 2. if no of 9\\'s > 1 (ex:499,87999)then we update the just before index of first consecutive 9 and update the remaining values 0f 9with for loop by 0\\n \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        #for storing last consecutive 9\\'s location appearing from reverse\\n        int a = 0;\\n\\n        if(digits[n-1] < 9){\\n            digits[n-1]++;\\n            return digits;\\n        }\\n\\n        if(digits[n-1]==9){\\n            #for finding last consective 9 from reverse\\n            for(int i = n-1; i>=0;i--){\\n               \\n                if(digits[i] == 9){\\n                    a  =  i;                 \\n                }\\n                else if(digits[i]<9){\\n                    break;\\n\\n                }\\n              \\n            }\\n            #updating 9\\'s with 1\\n            if(a == 0){\\n                digits[0] = 1;\\n                for(int i = 1;i<n;i++){\\n                    digits[i] = 0;\\n                }\\n                digits.push_back(0);\\n            }\\n            #updating 9\\'s with 0\\n            if(a>0){\\n                 digits[a-1]++;\\n                for(int i = a; i<n; i++){\\n                    digits[i] = 0;\\n                }\\n            }   \\n        }\\n        \\n      return digits;\\n    }\\n    \\n};\\n\\n```\\n\\n\\n![{C6536750-B4F1-492E-9ED4-046628FB312E}.png](https://assets.leetcode.com/users/images/6ae85fce-a91d-408f-bb91-87d599ad888f_1674403258.8890588.png)\\n\\n\\nIf u find it useful please upvote this solution.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        #for storing last consecutive 9\\'s location appearing from reverse\\n        int a = 0;\\n\\n        if(digits[n-1] < 9){\\n            digits[n-1]++;\\n            return digits;\\n        }\\n\\n        if(digits[n-1]==9){\\n            #for finding last consective 9 from reverse\\n            for(int i = n-1; i>=0;i--){\\n               \\n                if(digits[i] == 9){\\n                    a  =  i;                 \\n                }\\n                else if(digits[i]<9){\\n                    break;\\n\\n                }\\n              \\n            }\\n            #updating 9\\'s with 1\\n            if(a == 0){\\n                digits[0] = 1;\\n                for(int i = 1;i<n;i++){\\n                    digits[i] = 0;\\n                }\\n                digits.push_back(0);\\n            }\\n            #updating 9\\'s with 0\\n            if(a>0){\\n                 digits[a-1]++;\\n                for(int i = a; i<n; i++){\\n                    digits[i] = 0;\\n                }\\n            }   \\n        }\\n        \\n      return digits;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961997,
                "title": "100-beats-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        for(int i=d.size()-1;i>=0;i--)  {\\n          if(d[i]<9){\\n              d[i]++;\\n              return d;\\n          }\\n          else{\\n              d[i]=0;\\n          }\\n      }\\n        d.push_back(0);\\n        d[0]=1;\\n          \\n      \\n\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        for(int i=d.size()-1;i>=0;i--)  {\\n          if(d[i]<9){\\n              d[i]++;\\n              return d;\\n          }\\n          else{\\n              d[i]=0;\\n          }\\n      }\\n        d.push_back(0);\\n        d[0]=1;\\n          \\n      \\n\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572510,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568525,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1663040,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1571826,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1779772,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1569392,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568886,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1659327,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568480,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1574979,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1572510,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568525,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1663040,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1571826,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1779772,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1569392,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568886,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1659327,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568480,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1574979,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1945414,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1570218,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1953534,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1570820,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 2028655,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1729564,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1718343,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1625339,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1573484,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1568626,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1998273,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1996383,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1948881,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1772771,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572288,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572251,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572202,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575637,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575354,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575298,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1571908,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2075848,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2071032,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2069813,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2069121,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2067406,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2055166,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2054500,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2050421,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2047933,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2045323,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2044544,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2040611,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2036252,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2035844,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2022155,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2009432,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2005275,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2003887,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 1998898,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 1994941,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1986849,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1978507,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1972982,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1971507,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1966992,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1959180,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1956445,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1942942,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1941708,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1941687,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1934735,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1922431,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1918670,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1908466,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1907090,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1891365,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1884705,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1883693,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1858251,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1846145,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1841757,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1840067,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1839821,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1838736,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1835121,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1830114,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1827168,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1813842,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1808828,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1805046,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1800492,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1798573,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1796819,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1794579,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1789588,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1789139,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1785143,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1779515,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1774899,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1772541,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1772367,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1767978,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1767655,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1762112,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1760265,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1759374,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1758655,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1754118,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1751716,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1750926,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1750884,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1749795,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1749204,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1741891,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1738350,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1733046,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1729248,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1724878,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1723443,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1722518,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1721161,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1720584,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1718041,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1716171,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1715296,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1707595,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1706793,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1704307,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1701915,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1701808,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1699010,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1697006,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1690646,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1685423,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1685414,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1684055,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1682619,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1681229,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1676120,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Fraction to Recurring Decimal",
        "question_content": "<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 51106,
                "title": "my-clean-java-solution",
                "content": "The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\\n\\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part.\\n\\nPlease comment if you see something wrong or can be improved. Cheers!\\n\\n    public class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }\\n            StringBuilder res = new StringBuilder();\\n            // \"+\" or \"-\"\\n            res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\\n            long num = Math.abs((long)numerator);\\n            long den = Math.abs((long)denominator);\\n            \\n            // integral part\\n            res.append(num / den);\\n            num %= den;\\n            if (num == 0) {\\n                return res.toString();\\n            }\\n            \\n            // fractional part\\n            res.append(\".\");\\n            HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n            map.put(num, res.length());\\n            while (num != 0) {\\n                num *= 10;\\n                res.append(num / den);\\n                num %= den;\\n                if (map.containsKey(num)) {\\n                    int index = map.get(num);\\n                    res.insert(index, \"(\");\\n                    res.append(\")\");\\n                    break;\\n                }\\n                else {\\n                    map.put(num, res.length());\\n                }\\n            }\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51109,
                "title": "accepted-cpp-solution-with-explainations",
                "content": "    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51160,
                "title": "c-unordered-map",
                "content": "For the decimal part to recur, **the remainder should recur**. So we maintain the remainders we have seen. Once we see an existing remainder, we have reached the end of the recurring part (enclose it with a `)`). Moreover, insert the `(` to the starting index of the recurring part by maintaining a mapping from each remainder to the index of the corresponding digit and using it to retrieve the starting index.\\n\\nFor those without fractional parts or with non-recursive fractional points, we may find them out by `%` or zero remainder. Some other problems that need to be considered include the sign and overflow (`-2147483648 / -1`).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) {\\n            return \"0\";\\n        }\\n        string ans;\\n        if (numerator > 0 ^ denominator > 0) {\\n            ans += \\'-\\';\\n        }\\n        long n = labs(numerator), d = labs(denominator), r = n % d;\\n        ans += to_string(n / d);\\n        if (!r) {\\n            return ans;\\n        }\\n        ans += \\'.\\';\\n        unordered_map<long, int> rs;\\n        while (r) {\\n            if (rs.find(r) != rs.end()) {\\n                ans.insert(rs[r], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            rs[r] = ans.size();\\n            r *= 10;\\n            ans += to_string(r / d);\\n            r %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) {\\n            return \"0\";\\n        }\\n        string ans;\\n        if (numerator > 0 ^ denominator > 0) {\\n            ans += \\'-\\';\\n        }\\n        long n = labs(numerator), d = labs(denominator), r = n % d;\\n        ans += to_string(n / d);\\n        if (!r) {\\n            return ans;\\n        }\\n        ans += \\'.\\';\\n        unordered_map<long, int> rs;\\n        while (r) {\\n            if (rs.find(r) != rs.end()) {\\n                ans.insert(rs[r], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            rs[r] = ans.size();\\n            r *= 10;\\n            ans += to_string(r / d);\\n            r %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51110,
                "title": "do-not-use-python-as-cpp-here-s-a-short-version-python-code",
                "content": "Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow",
                "solutionTags": [
                    "Python"
                ],
                "code": "Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow",
                "codeTag": "Java"
            },
            {
                "id": 51187,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51140,
                "title": "short-java-solution",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }",
                "solutionTags": [],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1669777,
                "title": "accepted-simple-solution-with-step-by-step-detailed-explaination",
                "content": "So we can divide this question in three parts :\\n1.\\tDivision with its own multiple for eg. 8 / 4 = 2\\n2.\\tDivision without repeating numbers after decimal for eg. 41 / 2 = 20.5\\n3.\\tDivision with repeating numbers after decimal for eg. 14 / 3 = 4.(6) or 47 / 18 = 2.6(1)\\nNote : Here the repeating part is in bracket.\\n\\nFor **1st Part** we can normally divide the numbers and add it to the ans string and return if the remainder is 0.\\n\\n```\\n//Code: \\nint q = num / den;\\nint r = num % den;\\nans += q;\\nif(r == 0) return ans;\\n```\\n\\nFor **2nd part** we need to add a \\u201C.\\u201D if remainder is not zero and then make the remainder 10 times everytime and append the quotient to the ans string.\\n```\\n//Code:\\nwhile(r != 0)\\n\\tr *= 10;\\n\\tq = r / den;\\n\\tr = r % den;\\n\\tans += q;\\n```\\n\\nFor the **3rd part** we need to use and unordered_map so that we can store the the position from where the repeating of number starts in front of the remainder. If the remainder is already in the map then we insert the \\u201C(\\u201D opening bracket at the position of that rem and lastly append a \\u201C)\\u201D closing bracket and break out of the loop and return the ans.\\n```\\n//Code :\\nunordered_map<int, int> mp;\\nwhile(r != 0)\\n\\tif(mp(r) is in map)\\n\\t\\tint pos = mp[r];\\n\\t\\tans.insert(pos, \"(\");\\n\\t\\tans += \\')\\';\\n\\t\\tbreak;\\n\\telse\\n\\t\\tmp[r] = ans.length();\\n\\t\\tr *= 10;\\n\\t\\tq = r / den;\\n\\t\\tr = r % den;\\n\\t\\tans += q;\\n```\\n\\nNow it will give runtime error for cases like -1 / -2147483648 so we need to change the int to long\\n```\\nlong num = labs(numerator), den = labs(denominator);\\nlong q = num / den;\\nlong r = num % den;\\n```\\nand \\n```\\nunordered_map<long, int> mp;\\n```\\nWe need to handle the case where there are negative numbers. So if numerator is negative and denominator is positive or numerator is positive and denominator is negative we need to add a \\u201C-\\u201C negative symbol in the ans.\\n```\\nif (numerator > 0 ^ denominator > 0) \\n\\tans += \\'-\\';\\n```\\n\\n**Final Code :**\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(!numerator) return \"0\";\\n        string ans = \"\";\\n        if (numerator > 0 ^ denominator > 0) ans += \\'-\\';\\n        long num = labs(numerator), den = labs(denominator);\\n        long q = num / den;\\n        long r = num % den;\\n        ans += to_string(q);\\n        \\n        if(r == 0) return ans;\\n        \\n        ans += \\'.\\';\\n        unordered_map<long, int> mp;\\n        while(r != 0){\\n            if(mp.find(r) != mp.end()){\\n                int pos = mp[r];\\n                ans.insert(pos, \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                mp[r] = ans.length();\\n                r *= 10;\\n                q = r / den;\\n                r = r % den;\\n                ans += to_string(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n//Code: \\nint q = num / den;\\nint r = num % den;\\nans += q;\\nif(r == 0) return ans;\\n```\n```\\n//Code:\\nwhile(r != 0)\\n\\tr *= 10;\\n\\tq = r / den;\\n\\tr = r % den;\\n\\tans += q;\\n```\n```\\n//Code :\\nunordered_map<int, int> mp;\\nwhile(r != 0)\\n\\tif(mp(r) is in map)\\n\\t\\tint pos = mp[r];\\n\\t\\tans.insert(pos, \"(\");\\n\\t\\tans += \\')\\';\\n\\t\\tbreak;\\n\\telse\\n\\t\\tmp[r] = ans.length();\\n\\t\\tr *= 10;\\n\\t\\tq = r / den;\\n\\t\\tr = r % den;\\n\\t\\tans += q;\\n```\n```\\nlong num = labs(numerator), den = labs(denominator);\\nlong q = num / den;\\nlong r = num % den;\\n```\n```\\nunordered_map<long, int> mp;\\n```\n```\\nif (numerator > 0 ^ denominator > 0) \\n\\tans += \\'-\\';\\n```\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(!numerator) return \"0\";\\n        string ans = \"\";\\n        if (numerator > 0 ^ denominator > 0) ans += \\'-\\';\\n        long num = labs(numerator), den = labs(denominator);\\n        long q = num / den;\\n        long r = num % den;\\n        ans += to_string(q);\\n        \\n        if(r == 0) return ans;\\n        \\n        ans += \\'.\\';\\n        unordered_map<long, int> mp;\\n        while(r != 0){\\n            if(mp.find(r) != mp.end()){\\n                int pos = mp[r];\\n                ans.insert(pos, \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                mp[r] = ans.length();\\n                r *= 10;\\n                q = r / den;\\n                r = r % den;\\n                ans += to_string(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51107,
                "title": "accepted-clean-java-solution",
                "content": "I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 51114,
                "title": "python-solution",
                "content": "    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}\\n        while numerator!=0:\\n            if numerator not in table.keys():\\n                table[numerator]=i\\n            else:\\n                i=table[numerator]\\n                res=res[:i]+\"(\"+res[i:]+\")\"\\n                return res\\n            numerator=numerator*10\\n            res+=str(numerator/denominator)\\n            numerator%=denominator\\n            i+=1\\n        return res\\n\\nIdea is to put every remainder into the hash table as a key, and the current length of the result string as the value. When the same remainder shows again, it's circulating from the index of the value in the table.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}",
                "codeTag": "Java"
            },
            {
                "id": 180004,
                "title": "python-4-lines-32ms-beats-100-with-explanation",
                "content": "LOLOLOL:\\n```python\\ndef fractionToDecimal(self, n, d): # 32ms, beats 100%\\n    if n % d == 0: return str(n // d)\\n    p, q, r, s, m = abs(n), abs(d), abs(n) % abs(d), \\'\\', {}\\n    while r and r not in m: m[r], r, s = len(s), r * 10 % q, s + str(r * 10 // q)\\n    return (\\'\\' if (n > 0) == (d > 0) else \\'-\\') + str(p // q) + \\'.\\' + (s[:m[r]] + \\'(\\' + s[m[r]:] + \\')\\' if r else s)\\n```\\n---\\n\\n### Explanation\\nMy original solution:\\n```python\\ndef fractionToDecimal(self, numerator, denominator):\\n    if numerator % denominator == 0: return str(numerator // denominator)\\n    p, q = map(abs, (numerator, denominator))\\n    prefix = (\\'\\' if (numerator > 0) == (denominator > 0) else \\'-\\') + str(p // q) + \\'.\\' # everything before the decimal point\\n    suffix = \\'\\' # everything after the decimal point\\n    remainder = p % q\\n    index = {}\\n    while remainder not in index: # search for recurrence\\n        index[remainder] = len(suffix)\\n        suffix += str(remainder * 10 // q)\\n        remainder = remainder * 10 % q\\n        if remainder == 0: return prefix + suffix # no recurring decimal\\n    return prefix + suffix[:index[remainder]] + \\'(\\' + suffix[index[remainder]:] + \\')\\'\\n```\\nThis is easy to understand by following an example. Consider the fraction `611/4950 == 0.12(34)`. If you work out the division, you\\'ll see that the remainders are `611`, `1160`, `1700`, `2150`, `1700`, `2150`, etc.\\n```\\n      0.123434...\\n    +---------\\n4950|611\\n       0\\n     ---------\\n     6110      <- remainder is 611\\n     4950\\n     ---------\\n     11600     <- remainder is 1160\\n      9900\\n     ---------\\n      17000    <- remainder is 1700\\n      14850\\n     ---------\\n       21500   <- remainder is 2150\\n       19800\\n     ---------\\n        17000  <- remainder is 1700\\n        14850\\n     ---------\\n         21500 <- remainder is 2150\\n         19800\\n     ---------\\n          1700 <- remainder is 1700\\n           ...\\n```\\nSo we just have to keep track of the remainders. The moment we see a repeated one (`1700` in this example), we stop and ask \"when was the first time I saw this remainder?\" For this particular example, the answer is \"when I was trying to find the `3rd` decimal place\". Therefore, the recurrence starts from the `3rd` decimal place. That\\'s it.",
                "solutionTags": [],
                "code": "```python\\ndef fractionToDecimal(self, n, d): # 32ms, beats 100%\\n    if n % d == 0: return str(n // d)\\n    p, q, r, s, m = abs(n), abs(d), abs(n) % abs(d), \\'\\', {}\\n    while r and r not in m: m[r], r, s = len(s), r * 10 % q, s + str(r * 10 // q)\\n    return (\\'\\' if (n > 0) == (d > 0) else \\'-\\') + str(p // q) + \\'.\\' + (s[:m[r]] + \\'(\\' + s[m[r]:] + \\')\\' if r else s)\\n```\n```python\\ndef fractionToDecimal(self, numerator, denominator):\\n    if numerator % denominator == 0: return str(numerator // denominator)\\n    p, q = map(abs, (numerator, denominator))\\n    prefix = (\\'\\' if (numerator > 0) == (denominator > 0) else \\'-\\') + str(p // q) + \\'.\\' # everything before the decimal point\\n    suffix = \\'\\' # everything after the decimal point\\n    remainder = p % q\\n    index = {}\\n    while remainder not in index: # search for recurrence\\n        index[remainder] = len(suffix)\\n        suffix += str(remainder * 10 // q)\\n        remainder = remainder * 10 % q\\n        if remainder == 0: return prefix + suffix # no recurring decimal\\n    return prefix + suffix[:index[remainder]] + \\'(\\' + suffix[index[remainder]:] + \\')\\'\\n```\n```\\n      0.123434...\\n    +---------\\n4950|611\\n       0\\n     ---------\\n     6110      <- remainder is 611\\n     4950\\n     ---------\\n     11600     <- remainder is 1160\\n      9900\\n     ---------\\n      17000    <- remainder is 1700\\n      14850\\n     ---------\\n       21500   <- remainder is 2150\\n       19800\\n     ---------\\n        17000  <- remainder is 1700\\n        14850\\n     ---------\\n         21500 <- remainder is 2150\\n         19800\\n     ---------\\n          1700 <- remainder is 1700\\n           ...\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 51128,
                "title": "simple-and-short-solution-in-java",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 457990,
                "title": "java-a-simple-solution-with-explanation",
                "content": "```\\npublic String fractionToDecimal(int num, int den) {\\n        \\n\\tif(num==0) return \"0\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// Negative sign is appended if either of num or den is negative\\n\\tres.append((num > 0) ^ (den > 0) ? \"-\" : \"\");\\n\\n\\t// Get rid of signs and convert to long to prevent overflow\\n\\tlong n = Math.abs((long) num);\\n\\tlong d = Math.abs((long) den);\\n\\n\\t// Append the integral part\\n\\tres.append(n/d);\\n\\n\\tn %= d;\\n\\tif(n==0) return res.toString();             // Cause there is no fraction\\n\\n\\t// Append the fraction\\n\\tres.append(\".\");\\n\\tHashMap<Long, Integer> hm = new HashMap();  // Map will store remainders and their positions\\n\\thm.put(n, res.length());\\n\\twhile(n!=0) {                               // We will break in case of recurring fraction\\n\\t\\tn *= 10;\\n\\t\\tres.append(n/d);\\n\\t\\tn %= d;\\n\\n\\t\\tInteger remainderIndex = hm.get(n);\\n\\t\\tif(remainderIndex!=null) {              // We have a recurrence\\n\\t\\t\\tres.insert(remainderIndex, \"(\");\\n\\t\\t\\tres.append(\")\");\\n\\t\\t\\treturn res.toString();\\n\\t\\t} else {\\n\\t\\t\\thm.put(n, res.length());            // Add for future checks\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String fractionToDecimal(int num, int den) {\\n        \\n\\tif(num==0) return \"0\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// Negative sign is appended if either of num or den is negative\\n\\tres.append((num > 0) ^ (den > 0) ? \"-\" : \"\");\\n\\n\\t// Get rid of signs and convert to long to prevent overflow\\n\\tlong n = Math.abs((long) num);\\n\\tlong d = Math.abs((long) den);\\n\\n\\t// Append the integral part\\n\\tres.append(n/d);\\n\\n\\tn %= d;\\n\\tif(n==0) return res.toString();             // Cause there is no fraction\\n\\n\\t// Append the fraction\\n\\tres.append(\".\");\\n\\tHashMap<Long, Integer> hm = new HashMap();  // Map will store remainders and their positions\\n\\thm.put(n, res.length());\\n\\twhile(n!=0) {                               // We will break in case of recurring fraction\\n\\t\\tn *= 10;\\n\\t\\tres.append(n/d);\\n\\t\\tn %= d;\\n\\n\\t\\tInteger remainderIndex = hm.get(n);\\n\\t\\tif(remainderIndex!=null) {              // We have a recurrence\\n\\t\\t\\tres.insert(remainderIndex, \"(\");\\n\\t\\t\\tres.append(\")\");\\n\\t\\t\\treturn res.toString();\\n\\t\\t} else {\\n\\t\\t\\thm.put(n, res.length());            // Add for future checks\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51186,
                "title": "fast-and-concise-python-solution-using-dictionary",
                "content": "    def fractionToDecimal(self, numerator, denominator):\\n        sign = '-' if numerator * denominator < 0 else ''\\n        head, remainder = divmod(abs(numerator), abs(denominator))\\n        tail, seen = '', {}\\n        while remainder != 0:\\n            if remainder in seen:\\n                tail = tail[: seen[remainder]] + '(' + tail[seen[remainder]:] + ')'\\n                break\\n            seen[remainder] = len(tail)\\n            digit, remainder = divmod( remainder*10, abs(denominator) )\\n            tail+=str(digit)\\n        return sign + str(head) + (tail and '.' + tail)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def fractionToDecimal(self, numerator, denominator):\\n        sign = '-' if numerator * denominator < 0 else ''\\n        head, remainder = divmod(abs(numerator), abs(denominator))\\n        tail, seen = '', {}\\n        while remainder != 0:\\n            if remainder in seen:\\n                tail = tail[: seen[remainder]] + '(' + tail[seen[remainder]:] + ')'\\n                break\\n            seen[remainder] = len(tail)\\n            digit, remainder = divmod( remainder*10, abs(denominator) )\\n            tail+=str(digit)\\n        return sign + str(head) + (tail and '.' + tail)",
                "codeTag": "Python3"
            },
            {
                "id": 157398,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0: \\n            return \\'0\\'\\n        neg = (numerator < 0) ^ (denominator < 0)\\n        w,r = divmod(abs(numerator),abs(denominator))\\n        s = str(w)\\n        if neg:\\n            s = \"-\" + s \\n        if r:\\n            s += \\'.\\'\\n        i = len(s)\\n        nums = { r: i }\\n        while r:\\n            q,r = divmod(r * 10, abs(denominator))\\n            s += str(q)\\n            if r in nums:\\n                s = s[:nums[r]] + \\'(\\' + s[nums[r]:] + \\')\\' \\n                return s\\n            i += 1\\n            nums[r] = i\\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0: \\n            return \\'0\\'\\n        neg = (numerator < 0) ^ (denominator < 0)\\n        w,r = divmod(abs(numerator),abs(denominator))\\n        s = str(w)\\n        if neg:\\n            s = \"-\" + s \\n        if r:\\n            s += \\'.\\'\\n        i = len(s)\\n        nums = { r: i }",
                "codeTag": "Java"
            },
            {
                "id": 2549071,
                "title": "c-handling-edge-cases-easily-with-full-explanation-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n     \\n        string ans = \"\";\\n       \\n        \\n        // Handling Negative Case\\n        if((n<0 && d>0) || (n>0 && d<0 ))\\n            ans+= \\'-\\';\\n        \\n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\\n        // in Long long datatype ans remainder as well\\n        \\n        long long a = abs(n);\\n        long long b = abs(d);\\n        \\n        // Calculation Integral Part Of Answer\\n        long long num = abs(a/b);\\n        \\n        // Storing that to our ans string\\n        ans += to_string(num);\\n        \\n        // Calculate Remainder\\n        long long rem = abs(a%b);\\n        \\n        \\n        // IF remainder is zero , there wont be decimal part so return ans\\n        if(rem == 0)\\n            return ans;\\n        \\n        ans.push_back(\\'.\\');\\n        \\n        // Now We will calculate decimal part\\n        // we will store mapping of remainder with its appearing index \\n        // ex : 1/10 => rem = 1 its index will be 0\\n        \\n        string dec = \"\";\\n        unordered_map<int, int> mp;\\n       \\n        \\n        while(rem)\\n        {\\n            // iF We come across any remainder which is present in mapping \\n            // it means the recurring part start from that remainder and we will get its index \\n            // and process the result\\n            if(mp.find(rem) != mp.end())\\n            {\\n                int index  = mp[rem];\\n                string recurring = dec.substr(index);\\n                dec.erase(index);\\n                dec += \\'(\\' + recurring + \\')\\';\\n                break;\\n            }\\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\\n            else\\n            {\\n                mp[rem] = dec.size();\\n                dec += to_string(rem*10/b);\\n                rem = (rem*10)%b;\\n            }\\n        }\\n        \\n        ans += dec;\\n        return ans;\\n        \\n        \\n        // Pls Upvote If You Like It\\n    }\\n};\\n\\n// Some Good Test Cases\\n// 4\\n// 333\\n\\n// -1\\n// -2147483648\\n\\n// 1\\n// 17\\n\\n// 45\\n// 499\\n\\n// -2147483648\\n// -1\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n     \\n        string ans = \"\";\\n       \\n        \\n        // Handling Negative Case\\n        if((n<0 && d>0) || (n>0 && d<0 ))\\n            ans+= \\'-\\';\\n        \\n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\\n        // in Long long datatype ans remainder as well\\n        \\n        long long a = abs(n);\\n        long long b = abs(d);\\n        \\n        // Calculation Integral Part Of Answer\\n        long long num = abs(a/b);\\n        \\n        // Storing that to our ans string\\n        ans += to_string(num);\\n        \\n        // Calculate Remainder\\n        long long rem = abs(a%b);\\n        \\n        \\n        // IF remainder is zero , there wont be decimal part so return ans\\n        if(rem == 0)\\n            return ans;\\n        \\n        ans.push_back(\\'.\\');\\n        \\n        // Now We will calculate decimal part\\n        // we will store mapping of remainder with its appearing index \\n        // ex : 1/10 => rem = 1 its index will be 0\\n        \\n        string dec = \"\";\\n        unordered_map<int, int> mp;\\n       \\n        \\n        while(rem)\\n        {\\n            // iF We come across any remainder which is present in mapping \\n            // it means the recurring part start from that remainder and we will get its index \\n            // and process the result\\n            if(mp.find(rem) != mp.end())\\n            {\\n                int index  = mp[rem];\\n                string recurring = dec.substr(index);\\n                dec.erase(index);\\n                dec += \\'(\\' + recurring + \\')\\';\\n                break;\\n            }\\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\\n            else\\n            {\\n                mp[rem] = dec.size();\\n                dec += to_string(rem*10/b);\\n                rem = (rem*10)%b;\\n            }\\n        }\\n        \\n        ans += dec;\\n        return ans;\\n        \\n        \\n        // Pls Upvote If You Like It\\n    }\\n};\\n\\n// Some Good Test Cases\\n// 4\\n// 333\\n\\n// -1\\n// -2147483648\\n\\n// 1\\n// 17\\n\\n// 45\\n// 499\\n\\n// -2147483648\\n// -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208837,
                "title": "166-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also handles the edge cases of a zero numerator and a zero denominator, and also checks for the negative sign at the beginning. It then calculates the integer part of the result by doing an integer division of the numerator by the denominator, and checks if there is a fractional part by checking if the remainder of this division is zero. If there is a fractional part, it adds a decimal point to the result.\\n\\nThe main optimization in this solution is the use of a dictionary to store the position of each remainder in the result. This way, we can easily check if a remainder has already appeared in the result, and if it has, we know that we have found a repeating part. We can then insert the opening and closing parentheses at the appropriate positions in the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Handle edge cases\\n        if numerator == 0:\\n            return \"0\"\\n        if denominator == 0:\\n            return \"\"\\n\\n        # Initialize result and check for negative sign\\n        result = \"\"\\n        if (numerator < 0) ^ (denominator < 0):\\n            result += \"-\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n\\n        # Integer part of the result\\n        result += str(numerator // denominator)\\n\\n        # Check if there is a fractional part\\n        if numerator % denominator == 0:\\n            return result\\n\\n        result += \".\"\\n\\n        # Use a dictionary to store the position of each remainder\\n        remainder_dict = {}\\n        remainder = numerator % denominator\\n\\n        # Keep adding the remainder to the result until it repeats or the remainder becomes 0\\n        while remainder != 0 and remainder not in remainder_dict:\\n            remainder_dict[remainder] = len(result)\\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder %= denominator\\n\\n        # Check if there is a repeating part\\n        if remainder in remainder_dict:\\n            result = result[:remainder_dict[remainder]] + \"(\" + result[remainder_dict[remainder]:] + \")\"\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Handle edge cases\\n        if numerator == 0:\\n            return \"0\"\\n        if denominator == 0:\\n            return \"\"\\n\\n        # Initialize result and check for negative sign\\n        result = \"\"\\n        if (numerator < 0) ^ (denominator < 0):\\n            result += \"-\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n\\n        # Integer part of the result\\n        result += str(numerator // denominator)\\n\\n        # Check if there is a fractional part\\n        if numerator % denominator == 0:\\n            return result\\n\\n        result += \".\"\\n\\n        # Use a dictionary to store the position of each remainder\\n        remainder_dict = {}\\n        remainder = numerator % denominator\\n\\n        # Keep adding the remainder to the result until it repeats or the remainder becomes 0\\n        while remainder != 0 and remainder not in remainder_dict:\\n            remainder_dict[remainder] = len(result)\\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder %= denominator\\n\\n        # Check if there is a repeating part\\n        if remainder in remainder_dict:\\n            result = result[:remainder_dict[remainder]] + \"(\" + result[remainder_dict[remainder]:] + \")\"\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163728,
                "title": "swift-fraction-to-recurring-decimal",
                "content": "```swift\\nclass Solution {\\n    func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String {\\n        var num = numerator, den = denominator\\n        var result = [String]()\\n        \\n        guard num != 0 else { return \"0\" }\\n        \\n        if (num > 0 && den < 0) || (num < 0 && den > 0) {\\n            result.append(\"-\")\\n        }\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        result.append(String(num/den))\\n        num %= den\\n        \\n        guard num != 0 else { return result.joined() }\\n        \\n        result.append(\".\")\\n        var map = [Int:Int]()\\n        map[num] = result.count\\n        \\n        while num != 0 {\\n            num *= 10\\n            result.append(String(num / den))\\n            num %= den\\n            if let value = map[num] {\\n                let index = value\\n                result.insert(\"(\", at: index)\\n                result.append(\")\")\\n                break\\n            } else {\\n                map[num] = result.count\\n            }\\n        }\\n        return result.joined()\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.081 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssert(s.fractionToDecimal(1, 2) == \"0.5\") // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.fractionToDecimal(2, 1) == \"2\") // success\\n    }\\n    func testExample3() {\\n        XCTAssert(s.fractionToDecimal(2, 3) == \"0.(6)\") // success\\n    }\\n    func testExample4() {\\n        XCTAssert(s.fractionToDecimal(4, 333) == \"0.(012)\") // success\\n    }\\n    func testExample5() {\\n        XCTAssert(s.fractionToDecimal(1, 5) == \"0.2\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String {\\n        var num = numerator, den = denominator\\n        var result = [String]()\\n        \\n        guard num != 0 else { return \"0\" }\\n        \\n        if (num > 0 && den < 0) || (num < 0 && den > 0) {\\n            result.append(\"-\")\\n        }\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        result.append(String(num/den))\\n        num %= den\\n        \\n        guard num != 0 else { return result.joined() }\\n        \\n        result.append(\".\")\\n        var map = [Int:Int]()\\n        map[num] = result.count\\n        \\n        while num != 0 {\\n            num *= 10\\n            result.append(String(num / den))\\n            num %= den\\n            if let value = map[num] {\\n                let index = value\\n                result.insert(\"(\", at: index)\\n                result.append(\")\")\\n                break\\n            } else {\\n                map[num] = result.count\\n            }\\n        }\\n        return result.joined()\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.081 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssert(s.fractionToDecimal(1, 2) == \"0.5\") // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.fractionToDecimal(2, 1) == \"2\") // success\\n    }\\n    func testExample3() {\\n        XCTAssert(s.fractionToDecimal(2, 3) == \"0.(6)\") // success\\n    }\\n    func testExample4() {\\n        XCTAssert(s.fractionToDecimal(4, 333) == \"0.(012)\") // success\\n    }\\n    func testExample5() {\\n        XCTAssert(s.fractionToDecimal(1, 5) == \"0.2\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262401,
                "title": "c-very-easy-to-understand-100-beat",
                "content": "The problem is quiet straight forward except few cases.\\n*Steps:*\\n1. First decide the **sign** of output as (num/den) can be positive or negative as well.\\n2. Divide is **numerator** by **denominator**, check whether **remainder** exist or not\\n3. If *remainder* does exists and equal to ``0``, then simply return, as we have divided num by den.\\n4. Else divide till *remainder* is ``0`` and **repeat** exists.\\n\\t a. Check whether *remainder* will repeat after some time of division.\\n\\t b. If *remainder* repeats, then it\\'s guaranteed that next number will again repeat, then simply put braces at the end ``)`` and since we need to see previous tracked *remainders*, we have to use **hash-table** for *constant time operation*, then we also the **first** occurance of *remainder*, then simply get the position and insert the ``(`` bracket.\\n\\t c. Else if **remainder** do not repeat, then it has to converge to ``0``. Once it\\'s ``0`` we are out of loop and simply return the output.\\n\\t \\n\\t *Below is implementation of above algorithm*\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int num, int den) {\\n        bool neg = (num<0)^(den<0) ? true: false;\\n        long long int n = num;\\n        long long int d = den;\\n        n = abs(n);\\n        d = abs(d);\\n        long long int tmp = n/d;\\n        string res = \"\";\\n        if(neg && n!=0)\\n         res += \"-\";\\n\\n        res += to_string(tmp);\\n        n %= d;\\n        if(n==0){\\n            return res;\\n        }\\n        res += \".\";\\n        // now before decimal, work is over now after decimal\\n        bool repeat = false;\\n        unordered_map<long long int, int> mp; // mapping from remainder to size of string\\n        while(n!=0 && !repeat){\\n            if(mp.find(n)==mp.end())\\n                mp[n] = res.size();\\n            else if(mp.find(n)!=mp.end()){\\n                // repeat found\\n                repeat = true; // no need of repeat variable as we are breaking explicitly\\n                res.push_back(\\')\\');\\n                res.insert(mp[n],\"(\");\\n                break;\\n            }\\n            n = n*10;\\n            res += to_string(n/d);\\n            n %= d;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote: pardon my English\\nHappy Coding.",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int num, int den) {\\n        bool neg = (num<0)^(den<0) ? true: false;\\n        long long int n = num;\\n        long long int d = den;\\n        n = abs(n);\\n        d = abs(d);\\n        long long int tmp = n/d;\\n        string res = \"\";\\n        if(neg && n!=0)\\n         res += \"-\";\\n\\n        res += to_string(tmp);\\n        n %= d;\\n        if(n==0){\\n            return res;\\n        }\\n        res += \".\";\\n        // now before decimal, work is over now after decimal\\n        bool repeat = false;\\n        unordered_map<long long int, int> mp; // mapping from remainder to size of string\\n        while(n!=0 && !repeat){\\n            if(mp.find(n)==mp.end())\\n                mp[n] = res.size();\\n            else if(mp.find(n)!=mp.end()){\\n                // repeat found\\n                repeat = true; // no need of repeat variable as we are breaking explicitly\\n                res.push_back(\\')\\');\\n                res.insert(mp[n],\"(\");\\n                break;\\n            }\\n            n = n*10;\\n            res += to_string(n/d);\\n            n %= d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411727,
                "title": "c-solution-0ms-beats-100-concise-code",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Fraction to Recurring Decimal.\\nMemory Usage: 9 MB, less than 73.33% of C++ online submissions for Fraction to Recurring Decimal.\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int nu, int de) {\\n        \\n        if (nu == 0)  return \"0\";\\n        string res;\\n        unordered_map<long long int, int> mp;\\n        bool flag = ((nu < 0 && de >= 0) || (nu >= 0 && de < 0));\\n        long long numerator = nu;\\n        long long denominator = de;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        long long dividend = numerator/denominator;\\n        long long rem = numerator%denominator;\\n        res = std::to_string(dividend);\\n        \\n        if(rem == 0)\\n            return (flag ? \\'-\\' + res : res);\\n        \\n        res.push_back(\\'.\\');\\n        while(rem != 0)\\n        {\\n            numerator = rem*10;\\n            if(mp.find(numerator) != mp.end())\\n            {\\n                int p = mp[numerator];\\n                res = res.substr(0,p) + \\'(\\' + res.substr(p) + \\')\\';\\n                break;\\n            }\\n            \\n            mp[numerator] = res.size();\\n            dividend = numerator/denominator;\\n            res.push_back(dividend+\\'0\\');\\n            rem = numerator%denominator;\\n        }\\n        \\n        if(flag)\\n            res.insert(res.begin(), \\'-\\');\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string fractionToDecimal(int nu, int de) {\\n        \\n        if (nu == 0)  return \"0\";\\n        string res;\\n        unordered_map<long long int, int> mp;\\n        bool flag = ((nu < 0 && de >= 0) || (nu >= 0 && de < 0));\\n        long long numerator = nu;\\n        long long denominator = de;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        long long dividend = numerator/denominator;\\n        long long rem = numerator%denominator;\\n        res = std::to_string(dividend);\\n        \\n        if(rem == 0)\\n            return (flag ? \\'-\\' + res : res);\\n        \\n        res.push_back(\\'.\\');\\n        while(rem != 0)\\n        {\\n            numerator = rem*10;\\n            if(mp.find(numerator) != mp.end())\\n            {\\n                int p = mp[numerator];\\n                res = res.substr(0,p) + \\'(\\' + res.substr(p) + \\')\\';\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51165,
                "title": "easy-to-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if(denominator == 0) return \"\";\\n            if(numerator == 0) return \"0\"; \\n            unordered_map<long, int> appeared;\\n            string ans;\\n            \\n            long p_int = abs((long)numerator / (long)denominator);\\n            ans += string((numerator < 0) ^ (denominator < 0), '-'); \\n            ans += to_string(p_int);\\n            long rem = abs((long)numerator % (long)denominator);\\n            if(rem == 0) return ans;\\n            ans += \".\";\\n            \\n            while(rem){\\n                appeared[rem] = ans.size();\\n                rem *= 10;\\n                ans += to_string(rem / abs((long)denominator));\\n                rem %= abs((long)denominator);\\n                if(appeared.find(rem) != appeared.end()){\\n                    ans.insert(appeared[rem], \"(\");\\n                    ans += \")\";\\n                    break;\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if(denominator == 0) return \"\";\\n            if(numerator == 0) return \"0\"; \\n            unordered_map<long, int> appeared;\\n            string ans;\\n            \\n            long p_int = abs((long)numerator / (long)denominator);\\n            ans += string((numerator < 0) ^ (denominator < 0), '-'); \\n            ans += to_string(p_int);\\n            long rem = abs((long)numerator % (long)denominator);\\n            if(rem == 0) return ans;\\n            ans += \".\";\\n            \\n            while(rem){\\n                appeared[rem] = ans.size();\\n                rem *= 10;\\n                ans += to_string(rem / abs((long)denominator));\\n                rem %= abs((long)denominator);\\n                if(appeared.find(rem) != appeared.end()){\\n                    ans.insert(appeared[rem], \"(\");\\n                    ans += \")\";\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 495542,
                "title": "python-long-divsion-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \\'0\\'\\n        \\n        result = []\\n        if numerator < 0 and denominator > 0 or numerator >= 0 and denominator < 0:\\n            result.append(\\'-\\')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        result.append(str(numerator // denominator))\\n        \\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(result)\\n        result.append(\\'.\\')\\n        \\n        d = {}\\n        while remainder != 0:\\n            if remainder in d:\\n                result.insert(d[remainder], \\'(\\')\\n                result.append(\\')\\')\\n                return \\'\\'.join(result)\\n            \\n            d[remainder] = len(result)\\n            \\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder = remainder % denominator\\n        \\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \\'0\\'\\n        \\n        result = []\\n        if numerator < 0 and denominator > 0 or numerator >= 0 and denominator < 0:\\n            result.append(\\'-\\')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        result.append(str(numerator // denominator))\\n        \\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(result)\\n        result.append(\\'.\\')\\n        \\n        d = {}\\n        while remainder != 0:\\n            if remainder in d:\\n                result.insert(d[remainder], \\'(\\')\\n                result.append(\\')\\')\\n                return \\'\\'.join(result)\\n            \\n            d[remainder] = len(result)\\n            \\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder = remainder % denominator\\n        \\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51131,
                "title": "an-intuitive-solution-in-c-beating-100-submissions-well-explained",
                "content": "Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1029272,
                "title": "javascript-solution",
                "content": "```javascript\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988279,
                "title": "python-optimal-and-easy-solution-faster-than-95",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```\\n\\n**Guys give it an upvote if you liked it, so it can help others :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51205,
                "title": "a-clean-c-solution-with-3ms",
                "content": "    class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\tres += \"0\";\\n    \\t\\t}\\n    \\n    \\t\\tif(0 == rem) return res; // That the remainder is 0 means there isn't a fractional part of the result, \\n    \\t\\t//so we return the integral part.\\n    \\n    \\t\\t/*\\n    \\t\\tIn the following, we record the numerator to be divided by the denominator and the length of the temporary result.\\n    \\t\\tIf a numerator has been met before, circulation happens, so we stop the computation and insert a parathesis, and return \\n    \\t\\tthe result.\\n    \\t\\t*/\\n    \\t\\tnum = rem;\\n    \\n    \\t\\tunordered_map<long long, int> m;\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\tnum *= 10;\\n    \\t\\tres.append(\".\");\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\twhile(num > 0)\\n    \\t\\t{\\n    \\t\\t\\tif(num < den)\\n    \\t\\t\\t{// If the numerator is less than the denominator, we multiply the numerator with 10, and append a 'o'\\n    \\t\\t\\t\\t// to the result. And we record the numerator and the temporary size of the result.\\n    \\t\\t\\t\\tnum *= 10;\\n    \\t\\t\\t\\tres.append(\"0\");\\n    \\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tif(num > den)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tchar ch = '0' + num/den; // Compute the quotient and push the quotient to the result.\\n    \\t\\t\\t\\tres.push_back(ch);\\n    \\t\\t\\t\\tnum %= den; // Compute the remainder; \\n    \\t\\t\\t\\tnum *= 10; // multiply the remainder with 10, and it will be the new numerator.\\n    \\t\\t\\t\\tif(m.end() == m.find(num)) // This numerator occurs for the first time, so we record it.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse // Circulation happens, so we return the result.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tstring temp = res.substr(0, m[num]) + \"(\" + res.substr(m[num], string::npos) + \")\";\\n    \\t\\t\\t\\t\\tres = temp;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51235,
                "title": "online-judge-pass-java-version",
                "content": "     public class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n                if (denominator == 0) {\\n                    throw new IllegalArgumentException(\" denominator can not be zero\");\\n                }\\n                \\n                // avoid overflow for minimum vlaue of interger\\n                long newNum = (long) numerator;\\n                long newDeNom = (long) denominator;\\n        \\t\\t\\n        \\t\\tStringBuilder sb = new StringBuilder();\\n                \\n                // detect sign\\n                if ((newNum > 0 && newDeNom < 0) || (newNum <0 && newDeNom > 0)) {\\n        \\t\\t    sb.append(\"-\");\\n        \\t\\t}\\n        \\t\\t// make sure it is postive value\\n        \\t\\tnewNum = Math.abs(newNum);\\n        \\t\\tnewDeNom = Math.abs(newDeNom);      \\n                       \\n                sb.append(newNum / newDeNom);\\n                \\n                long reminder = newNum % newDeNom;\\n                Map<Long, Integer> reminderMap = new HashMap<>();\\n                \\n                if (reminder != 0) {\\n                    sb.append(\".\");\\n                }\\n                \\n                while (reminder != 0 && !reminderMap.containsKey(reminder)) {\\n                    reminderMap.put(reminder, sb.length());\\n                    reminder *= 10;\\n                    sb.append(reminder / newDeNom);\\n                    reminder = reminder % newDeNom; \\n                }\\n                \\n                if (reminderMap.containsKey(reminder)) {\\n                    sb.insert(reminderMap.get(reminder), \"(\");\\n                    sb.append(\")\");\\n                }\\n                return sb.toString();\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n                if (denominator == 0) {\\n                    throw new IllegalArgumentException(\" denominator can not be zero\");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3041777,
                "title": "100-fast-simple-c-implementation",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    string tostring(long long n){\\n        if (n==0)return \"0\";\\n        string ans;\\n        while (n>0){\\n            string dem;\\n            dem+= ((n%10)+\\'0\\');\\n            ans= dem+ans;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    string fractionToDecimal(int num, int denom) {\\n        if (num==0)return \"0\";\\n        string ans;\\n        if ((num<0 && denom>0) || (num>0 && denom<0))ans.push_back(\\'-\\');\\n        num= abs(num); denom= abs(denom);\\n        long long quotient= num/denom;\\n        long long remainder= num%denom;\\n        ans= ans+tostring(quotient);\\n        if (remainder==0)return ans;\\n        ans+=\\'.\\';\\n        map<long long, int> mp;\\n        while (remainder != 0){\\n            if (mp.find(remainder)!= mp.end()){\\n                int pos= mp[remainder];\\n                ans.insert(pos,\"(\");\\n                ans+=\\')\\';\\n                break;\\n            }\\n            else {\\n                mp[remainder]= ans.length();\\n                remainder*= 10;\\n                quotient= remainder/denom;\\n                remainder= remainder%denom;\\n                ans+= tostring(quotient);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string tostring(long long n){\\n        if (n==0)return \"0\";\\n        string ans;\\n        while (n>0){\\n            string dem;\\n            dem+= ((n%10)+\\'0\\');\\n            ans= dem+ans;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    string fractionToDecimal(int num, int denom) {\\n        if (num==0)return \"0\";\\n        string ans;\\n        if ((num<0 && denom>0) || (num>0 && denom<0))ans.push_back(\\'-\\');\\n        num= abs(num); denom= abs(denom);\\n        long long quotient= num/denom;\\n        long long remainder= num%denom;\\n        ans= ans+tostring(quotient);\\n        if (remainder==0)return ans;\\n        ans+=\\'.\\';\\n        map<long long, int> mp;\\n        while (remainder != 0){\\n            if (mp.find(remainder)!= mp.end()){\\n                int pos= mp[remainder];\\n                ans.insert(pos,\"(\");\\n                ans+=\\')\\';\\n                break;\\n            }\\n            else {\\n                mp[remainder]= ans.length();\\n                remainder*= 10;\\n                quotient= remainder/denom;\\n                remainder= remainder%denom;\\n                ans+= tostring(quotient);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545296,
                "title": "c-faster-than-100-easy",
                "content": "![image](https://assets.leetcode.com/users/images/c81f470d-88e4-4e34-bea5-ff6256a539ee_1635417844.7527034.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n1, int d1) {\\n        string ans = \"\", temp = \"\";\\n        unordered_map<int, int> mp;\\n        \\n        if(!n1){\\n            return \"0\";\\n        }\\n        if(n1 > 0 and d1 < 0 or n1 < 0 and d1 > 0){\\n            temp += \\'-\\';\\n        }\\n        long n = abs(n1);\\n        long d = abs(d1);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        if(n){\\n            ans += \\'.\\';\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n *= 10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0, mp[n]) + \\'(\\' + ans.substr(mp[n]) + \\')\\';\\n            }\\n        }\\n        return temp + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n1, int d1) {\\n        string ans = \"\", temp = \"\";\\n        unordered_map<int, int> mp;\\n        \\n        if(!n1){\\n            return \"0\";\\n        }\\n        if(n1 > 0 and d1 < 0 or n1 < 0 and d1 > 0){\\n            temp += \\'-\\';\\n        }\\n        long n = abs(n1);\\n        long d = abs(d1);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        if(n){\\n            ans += \\'.\\';\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n *= 10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0, mp[n]) + \\'(\\' + ans.substr(mp[n]) + \\')\\';\\n            }\\n        }\\n        return temp + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496638,
                "title": "java-with-explanation-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public String fractionToDecimal(int num, int den) {\\n        //base case\\n        if(num==0)\\n            return \"0\";\\n        \\n        //converting all integers to num becuase we may multiply them with 10 also multiple time.\\n        long numerator=num;\\n        long denominator=den;\\n        \\n        //chekcing what sign our result should have \\n        boolean flag=false;\\n        \\n        if((numerator<0 && denominator>=0) || (numerator>=0 && denominator<0))\\n            flag=true;\\n        \\n        //and removing sign from den and num\\n        numerator=Math.abs(numerator);\\n        denominator=Math.abs(denominator);\\n        \\n        \\n        long divider=numerator/denominator;\\n        long rem=numerator%denominator;\\n        \\n        StringBuilder op;\\n        if(rem==0){//no need to move further ,just return the results..\\n            op=(new StringBuilder()).append(divider);\\n        }else{//we have to find fractional points\\n            //we always multiply rem by 10 once then move forwad in case of remainder\\n            op= (new StringBuilder()).append(divider).append(\".\").append(fraction(rem*10,denominator,new StringBuilder(),new HashMap<Long,Integer>()));\\n        }\\n        //System.out.println(op.toString());\\n        if(flag)\\n            op.insert(0,\\'-\\');\\n        return op.toString();\\n    }\\n                           \\n    //while finding fractionals numbers we keep track of waht we have found till now \\n    //so we can just stop if we have already found solution for current situation and append parenthises as asked in question.\\n    public StringBuilder fraction(long num,long den,StringBuilder sb,HashMap<Long,Integer> hm){\\n        \\n        //if we solved it before just append () at appropriate indices\\n        if(hm.containsKey(num)){\\n            int index=hm.get(num);\\n            sb.insert(index,\\'(\\');\\n            sb.append(\\')\\');\\n            return sb;\\n        }\\n        \\n        if(num<den){//we have to multiply num with 10.\\n            sb.append(0);//to do so we first have to append 0 in divider\\n            return fraction(num*10,den,sb,hm);\\n        }\\n        \\n        long divider=num/den;\\n        long rem=num%den;\\n        \\n        if(rem==0){\\n            return sb.append(divider);\\n        }else{\\n            hm.put(num,sb.length());\\n            sb.append(divider);\\n            return fraction(rem*10,den,sb,hm);\\n        }\\n    }\\n\\t//if you find this helpful then please up vote.\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String fractionToDecimal(int num, int den) {\\n        //base case\\n        if(num==0)\\n            return \"0\";\\n        \\n        //converting all integers to num becuase we may multiply them with 10 also multiple time.\\n        long numerator=num;\\n        long denominator=den;\\n        \\n        //chekcing what sign our result should have \\n        boolean flag=false;\\n        \\n        if((numerator<0 && denominator>=0) || (numerator>=0 && denominator<0))\\n            flag=true;\\n        \\n        //and removing sign from den and num\\n        numerator=Math.abs(numerator);\\n        denominator=Math.abs(denominator);\\n        \\n        \\n        long divider=numerator/denominator;\\n        long rem=numerator%denominator;\\n        \\n        StringBuilder op;\\n        if(rem==0){//no need to move further ,just return the results..\\n            op=(new StringBuilder()).append(divider);\\n        }else{//we have to find fractional points\\n            //we always multiply rem by 10 once then move forwad in case of remainder\\n            op= (new StringBuilder()).append(divider).append(\".\").append(fraction(rem*10,denominator,new StringBuilder(),new HashMap<Long,Integer>()));\\n        }\\n        //System.out.println(op.toString());\\n        if(flag)\\n            op.insert(0,\\'-\\');\\n        return op.toString();\\n    }\\n                           \\n    //while finding fractionals numbers we keep track of waht we have found till now \\n    //so we can just stop if we have already found solution for current situation and append parenthises as asked in question.\\n    public StringBuilder fraction(long num,long den,StringBuilder sb,HashMap<Long,Integer> hm){\\n        \\n        //if we solved it before just append () at appropriate indices\\n        if(hm.containsKey(num)){\\n            int index=hm.get(num);\\n            sb.insert(index,\\'(\\');\\n            sb.append(\\')\\');\\n            return sb;\\n        }\\n        \\n        if(num<den){//we have to multiply num with 10.\\n            sb.append(0);//to do so we first have to append 0 in divider\\n            return fraction(num*10,den,sb,hm);\\n        }\\n        \\n        long divider=num/den;\\n        long rem=num%den;\\n        \\n        if(rem==0){\\n            return sb.append(divider);\\n        }else{\\n            hm.put(num,sb.length());\\n            sb.append(divider);\\n            return fraction(rem*10,den,sb,hm);\\n        }\\n    }\\n\\t//if you find this helpful then please up vote.\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200334,
                "title": "c-100-faster-76-less-space-easy-to-understand",
                "content": "// Use a map to track repeating fraction.\\n// Need to handling int overflow, which caused me 90% of the time, and end up having to use\\n// long long, which I should have thought of much earlier.\\n\\n\\tstring fractionToDecimal(int numerator, int denominator)\\n\\t{\\n\\t\\tif (!numerator)\\n\\t\\t{\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\n\\t\\tstring result;\\n\\t\\tlong long remainder = numerator;\\n\\t\\tunordered_map<long long, int> pattern;\\n\\n\\t\\t// Determine sign so that we don\\'t have to care about it later.\\n\\t\\tif ((remainder < 0 && denominator > 0) ||\\n\\t\\t\\t(remainder > 0 && denominator < 0))\\n\\t\\t{\\n\\t\\t\\tresult += \"-\";\\n\\t\\t}\\n\\n\\t\\twhile (remainder)\\n\\t\\t{\\n\\t\\t\\tresult += to_string(llabs(remainder / denominator));\\n\\t\\t\\tremainder = remainder % denominator;\\n\\n\\t\\t\\t// Each time we got a new remainder, check if it matches a repeat pattern. \\n\\t\\t\\tif (pattern.find(remainder) != pattern.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.insert(pattern[remainder], \"(\");\\n\\t\\t\\t\\tresult.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we are not done by dividing once, we need a \".\".\\n\\t\\t\\tif (remainder && result.find(\\'.\\') == result.npos)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += \".\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save the remainder and its correspounding position in the result.\\n\\t\\t\\tpattern[remainder] = result.length();\\n\\n\\t\\t\\tremainder *= 10;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "// Use a map to track repeating fraction.\\n// Need to handling int overflow, which caused me 90% of the time, and end up having to use\\n// long long, which I should have thought of much earlier.\\n\\n\\tstring fractionToDecimal(int numerator, int denominator)\\n\\t{\\n\\t\\tif (!numerator)\\n\\t\\t{\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\n\\t\\tstring result;\\n\\t\\tlong long remainder = numerator;\\n\\t\\tunordered_map<long long, int> pattern;\\n\\n\\t\\t// Determine sign so that we don\\'t have to care about it later.\\n\\t\\tif ((remainder < 0 && denominator > 0) ||\\n\\t\\t\\t(remainder > 0 && denominator < 0))\\n\\t\\t{\\n\\t\\t\\tresult += \"-\";\\n\\t\\t}\\n\\n\\t\\twhile (remainder)\\n\\t\\t{\\n\\t\\t\\tresult += to_string(llabs(remainder / denominator));\\n\\t\\t\\tremainder = remainder % denominator;\\n\\n\\t\\t\\t// Each time we got a new remainder, check if it matches a repeat pattern. \\n\\t\\t\\tif (pattern.find(remainder) != pattern.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.insert(pattern[remainder], \"(\");\\n\\t\\t\\t\\tresult.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we are not done by dividing once, we need a \".\".\\n\\t\\t\\tif (remainder && result.find(\\'.\\') == result.npos)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += \".\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save the remainder and its correspounding position in the result.\\n\\t\\t\\tpattern[remainder] = result.length();\\n\\n\\t\\t\\tremainder *= 10;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 673275,
                "title": "java-clean-code-easy-to-understand-1-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n\\t\\n\\t\\tif(numerator == 0) return \"0\";\\n\\t\\tif(denominator == 0) return \"\";\\n\\t\\n\\t\\tboolean sign = (numerator < 0) ^ (denominator < 0);\\n \\n\\t\\tStringBuilder ans = new StringBuilder();\\n \\n\\t\\tlong num = Math.abs(new Long(numerator));\\n\\t\\tlong den = Math.abs(new Long(denominator));\\n\\t\\t\\n\\t\\tif(sign) ans.append(\"-\");\\n \\n\\t\\tans.append(num / den);\\n\\t\\tlong remainder = (num % den) * 10;\\n\\t\\t\\n\\t\\tif(remainder != 0) ans.append(\".\");\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n        \\n\\t\\twhile(remainder != 0) {\\n\\t\\t\\tif(map.containsKey(remainder)) {\\n\\t\\t\\t\\tans.insert(map.get(remainder), \"(\");\\n\\t\\t\\t\\tans.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmap.put(remainder, ans.length());\\n\\t\\t\\tans.append(remainder / den);\\n\\t\\t\\tremainder = (remainder % den) * 10;\\n\\t\\t}\\n \\n\\t\\treturn ans.toString();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n\\t\\n\\t\\tif(numerator == 0) return \"0\";\\n\\t\\tif(denominator == 0) return \"\";\\n\\t\\n\\t\\tboolean sign = (numerator < 0) ^ (denominator < 0);\\n \\n\\t\\tStringBuilder ans = new StringBuilder();\\n \\n\\t\\tlong num = Math.abs(new Long(numerator));\\n\\t\\tlong den = Math.abs(new Long(denominator));\\n\\t\\t\\n\\t\\tif(sign) ans.append(\"-\");\\n \\n\\t\\tans.append(num / den);\\n\\t\\tlong remainder = (num % den) * 10;\\n\\t\\t\\n\\t\\tif(remainder != 0) ans.append(\".\");\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n        \\n\\t\\twhile(remainder != 0) {\\n\\t\\t\\tif(map.containsKey(remainder)) {\\n\\t\\t\\t\\tans.insert(map.get(remainder), \"(\");\\n\\t\\t\\t\\tans.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmap.put(remainder, ans.length());\\n\\t\\t\\tans.append(remainder / den);\\n\\t\\t\\tremainder = (remainder % den) * 10;\\n\\t\\t}\\n \\n\\t\\treturn ans.toString();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413293,
                "title": "clean-java-solution-1ms",
                "content": "This uses a map to detect a cycle.\\n\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder builder = new StringBuilder();\\n        if ((numerator < 0) ^ (denominator < 0)) builder.append(\"-\");\\n\\t\\t\\n\\t\\t//converts to long to get rid of the pesky int overflow\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\n        builder.append((n/d));\\n        if ((n %= d) == 0) return builder.toString();\\n        builder.append(\".\");\\n        \\n\\t\\t//map stores the index in our  builder where we first encounter this numerator\\n        Map<Long, Integer> numerators = new HashMap<>();\\n        while(!numerators.containsKey(n)) {\\n            numerators.put(n, builder.length());\\n            n *= 10;\\n            builder.append(n/d);\\n            if ((n %= d) == 0) return builder.toString();\\n        }\\n\\t\\t//we use the index to insert our bracket\\n        return builder.insert(numerators.get(n),\"(\").append(\")\").toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder builder = new StringBuilder();\\n        if ((numerator < 0) ^ (denominator < 0)) builder.append(\"-\");\\n\\t\\t\\n\\t\\t//converts to long to get rid of the pesky int overflow\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\n        builder.append((n/d));\\n        if ((n %= d) == 0) return builder.toString();\\n        builder.append(\".\");\\n        \\n\\t\\t//map stores the index in our  builder where we first encounter this numerator\\n        Map<Long, Integer> numerators = new HashMap<>();\\n        while(!numerators.containsKey(n)) {\\n            numerators.put(n, builder.length());\\n            n *= 10;\\n            builder.append(n/d);\\n            if ((n %= d) == 0) return builder.toString();\\n        }\\n\\t\\t//we use the index to insert our bracket\\n        return builder.insert(numerators.get(n),\"(\").append(\")\").toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228992,
                "title": "easy-to-read-javascript-solution-w-explanation-beats-100-68-ms",
                "content": "Idea: the core of this problem is identifying and handling repeating decimals correctly. Besides that, you just need to make sure that you\\'re handling edge cases appropriately. One way to think about identifying repeating decimals is to track the \"carry\" as if you\\'re doing long division by hand. If you\\'ve seen the \"carry\" before, then you\\'re in a loop that started at the index of the first time you saw that carry.\\n\\nFor example, with 2 / 3:\\n \\n![image](https://assets.leetcode.com/users/tadasant/image_1548851304.png)\\n\\n\\nEdge cases:\\n* Left side of decimal is >0, or >9 (i.e. multiple digits might throw off your idx counting)\\n* Numerator is zero\\n* Negative numbers (one or both numerator/denominator)\\n* Whole numbers (i.e. no need for decimal point)\\n* Non-repeating decimals\\n\\n```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    // Handle zero edge case\\n    if (numerator === 0) {\\n        return \"0\";\\n    }\\n    \\n    // Handle negatives edge cases, work with positive numbers moving forward\\n    const isNegative = numerator < 0 ? denominator > 0 : denominator < 0;\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    \\n    // Handle whole number edge case\\n    const leftSide = Math.floor(numerator / denominator);\\n    const hasDecimal = (numerator / denominator) % 1 !== 0;\\n    if (!hasDecimal) {\\n        return isNegative ? `-${leftSide.toString()}` : leftSide.toString();\\n    }\\n    \\n    // Invoke core algorithm\\n    const result = [leftSide.toString(), \\'.\\'];\\n    addDecimal(numerator, denominator, leftSide, result);\\n    \\n    // Finish handling negatives edge case\\n    if (isNegative) {\\n        result.unshift(\"-\");\\n    }\\n\\t\\n    return result.join(\\'\\');\\n};\\n\\nfunction addDecimal(numerator, denominator, leftSide, result) {\\n    // Account for whole number edge case; make numerator less than denominator\\n    numerator -= (leftSide * denominator);\\n    \\n    let idx = 0; // idx of the current digit\\n    const carries = {}; // carry values to index (within decimal digit chars) mapping\\n    \\n    // Loop dividing numerator by denominator and tracking carry at each step\\n    while (numerator !== 0 && !(numerator in carries)) {\\n        carries[numerator] = idx++;\\n        numerator *= 10;\\n        const nextDigit = Math.floor(numerator / denominator);\\n        result.push(nextDigit.toString());\\n        numerator %= denominator;\\n    }\\n    \\n    // If we detected a loop, add the repeating parentheses\\n    if (numerator in carries) {\\n        addParens(carries[numerator], result);\\n    }\\n}\\n\\nfunction addParens(decimalIdx, result) {\\n    result.splice(2 + decimalIdx, 0, \\'(\\'); // +2 because decimal point is at idx 1\\n    result.push(\\')\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    // Handle zero edge case\\n    if (numerator === 0) {\\n        return \"0\";\\n    }\\n    \\n    // Handle negatives edge cases, work with positive numbers moving forward\\n    const isNegative = numerator < 0 ? denominator > 0 : denominator < 0;\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    \\n    // Handle whole number edge case\\n    const leftSide = Math.floor(numerator / denominator);\\n    const hasDecimal = (numerator / denominator) % 1 !== 0;\\n    if (!hasDecimal) {\\n        return isNegative ? `-${leftSide.toString()}` : leftSide.toString();\\n    }\\n    \\n    // Invoke core algorithm\\n    const result = [leftSide.toString(), \\'.\\'];\\n    addDecimal(numerator, denominator, leftSide, result);\\n    \\n    // Finish handling negatives edge case\\n    if (isNegative) {\\n        result.unshift(\"-\");\\n    }\\n\\t\\n    return result.join(\\'\\');\\n};\\n\\nfunction addDecimal(numerator, denominator, leftSide, result) {\\n    // Account for whole number edge case; make numerator less than denominator\\n    numerator -= (leftSide * denominator);\\n    \\n    let idx = 0; // idx of the current digit\\n    const carries = {}; // carry values to index (within decimal digit chars) mapping\\n    \\n    // Loop dividing numerator by denominator and tracking carry at each step\\n    while (numerator !== 0 && !(numerator in carries)) {\\n        carries[numerator] = idx++;\\n        numerator *= 10;\\n        const nextDigit = Math.floor(numerator / denominator);\\n        result.push(nextDigit.toString());\\n        numerator %= denominator;\\n    }\\n    \\n    // If we detected a loop, add the repeating parentheses\\n    if (numerator in carries) {\\n        addParens(carries[numerator], result);\\n    }\\n}\\n\\nfunction addParens(decimalIdx, result) {\\n    result.splice(2 + decimalIdx, 0, \\'(\\'); // +2 because decimal point is at idx 1\\n    result.push(\\')\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 137886,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\'-\\' if numerator*denominator < 0 else \\'\\'\\n        fraction = [sign+str(n)]\\n        if remainder == 0:\\n            return \\'\\'.join(fraction)\\n\\n        fraction.append(\\'.\\')\\n        dic = {}\\n        while remainder != 0:\\n            if remainder in dic:\\n                fraction.insert(dic[remainder], \\'(\\')\\n                fraction.append(\\')\\')\\n                break\\n            dic[remainder] = len(fraction)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            fraction.append(str(n))\\n        return \\'\\'.join(fraction)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\'-\\' if numerator*denominator < 0 else \\'\\'\\n        fraction = [sign+str(n)]\\n        if remainder == 0:\\n            return \\'\\'.join(fraction)\\n\\n        fraction.append(\\'.\\')\\n        dic = {}\\n        while remainder != 0:\\n            if remainder in dic:\\n                fraction.insert(dic[remainder], \\'(\\')\\n                fraction.append(\\')\\')\\n                break\\n            dic[remainder] = len(fraction)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            fraction.append(str(n))\\n        return \\'\\'.join(fraction)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51113,
                "title": "fastest-java-solution-1-ms-and-o-1-space",
                "content": "My algorithm base on the Floyd's cycle-finding algorithm. Instead of using hashMap to store the result of each step, It uses two pointer, fast (iterate twice each time) and slow (iterate once each time) to detect cycle. Then It finds out the non-cycle part and cycle part. Therefore, it's O(1) space and is faster than those of using hash.\\n```\\npublic class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        // negative sign\\n        boolean negative = (numerator < 0) ^ (denominator < 0);\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n        long intPart = n / d;\\n        long rest = n - intPart * d;\\n        if (rest == 0) return negative ? String.valueOf(intPart * (-1)) : String.valueOf(intPart); // Integer result\\n        StringBuilder res = new StringBuilder();\\n        if (negative) res.append(\"-\");\\n        res.append(intPart);\\n        res.append(\".\");\\n        long slow;\\n        long fast;\\n        long[] temp = new long[2];\\n        slow = Decimal(rest*10, d)[1];\\n        fast = Decimal(Decimal(rest*10, d)[1], d)[1];\\n        while (slow != fast) {\\n            slow = Decimal(slow, d)[1];\\n            fast = Decimal(Decimal(fast, d)[1], d)[1];\\n        }\\n        slow = rest * 10;\\n        while (slow != fast && slow != 0) {\\n            temp = Decimal(slow, d);\\n            slow = temp[1];\\n            res.append(temp[0]);       // non-cycle part\\n            fast = Decimal(fast, d)[1];\\n        }\\n        if (slow == 0) return res.toString();  // return when result is finite decimal\\n        temp = Decimal(slow, d);\\n        fast = temp[1];\\n        res.append(\"(\");\\n        res.append(temp[0]);\\n        while (slow != fast) {\\n            temp = Decimal(fast, d);\\n            fast = temp[1];\\n            res.append(temp[0]);  // cycle part\\n        }\\n        res.append(\")\");\\n        return res.toString();\\n    }\\n    public long[] Decimal(long rest, long denominator) {\\n        // return the quotient and remainder (multiplied by 10)\\n        long r1;\\n        long r2;\\n        if (rest < denominator) {\\n            r1 = 0;\\n            r2 = rest * 10;\\n        }\\n        else {\\n            r1 = rest / denominator;\\n            r2 = (rest - denominator * r1) * 10;\\n        }\\n        return new long[]{r1, r2};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        // negative sign\\n        boolean negative = (numerator < 0) ^ (denominator < 0);\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n        long intPart = n / d;\\n        long rest = n - intPart * d;\\n        if (rest == 0) return negative ? String.valueOf(intPart * (-1)) : String.valueOf(intPart); // Integer result\\n        StringBuilder res = new StringBuilder();\\n        if (negative) res.append(\"-\");\\n        res.append(intPart);\\n        res.append(\".\");\\n        long slow;\\n        long fast;\\n        long[] temp = new long[2];\\n        slow = Decimal(rest*10, d)[1];\\n        fast = Decimal(Decimal(rest*10, d)[1], d)[1];\\n        while (slow != fast) {\\n            slow = Decimal(slow, d)[1];\\n            fast = Decimal(Decimal(fast, d)[1], d)[1];\\n        }\\n        slow = rest * 10;\\n        while (slow != fast && slow != 0) {\\n            temp = Decimal(slow, d);\\n            slow = temp[1];\\n            res.append(temp[0]);       // non-cycle part\\n            fast = Decimal(fast, d)[1];\\n        }\\n        if (slow == 0) return res.toString();  // return when result is finite decimal\\n        temp = Decimal(slow, d);\\n        fast = temp[1];\\n        res.append(\"(\");\\n        res.append(temp[0]);\\n        while (slow != fast) {\\n            temp = Decimal(fast, d);\\n            fast = temp[1];\\n            res.append(temp[0]);  // cycle part\\n        }\\n        res.append(\")\");\\n        return res.toString();\\n    }\\n    public long[] Decimal(long rest, long denominator) {\\n        // return the quotient and remainder (multiplied by 10)\\n        long r1;\\n        long r2;\\n        if (rest < denominator) {\\n            r1 = 0;\\n            r2 = rest * 10;\\n        }\\n        else {\\n            r1 = rest / denominator;\\n            r2 = (rest - denominator * r1) * 10;\\n        }\\n        return new long[]{r1, r2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881820,
                "title": "c-hashmap-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string ans;\\n        ans = (numerator > 0)^(denominator > 0) ? \"-\":\"\";       //adding sign if either num or deno is -ve\\n        \\n        long n = abs(numerator);        //making both num and deno +ve\\n        long d = abs(denominator);\\n        ans += to_string(n/d);          \\n        \\n        n = n%d;\\n        if(!n) return ans;              //if we got remainder n = 0 then return ans else add \".\" to the ans\\n        \\n        ans += \".\";\\n        \\n        //If you find remainder again means ans from that point will start repeating from there so we map\\n        //remainder with the length pf answer at that point so that if it occur again then we can insert bracket there\\n        unordered_map<long, int> mp;\\n        \\n        while(n)        //repeat untill remainder != 0\\n        {   \\n            if(mp[n])   //if you find that this remainder has occurred before then  \\n            {\\n                ans.insert(mp[n], \"(\");    //Inserting ( at position when we first found that remainder\\n                ans += \")\";                //Inserting closing bracket at the last\\n                break;          \\n            }\\n            else{\\n                mp[n] = ans.size();     //storing when remainder n come then what is the size of ans\\n                n *= 10;\\n                ans += to_string(n/d);  \\n                n = n%d;                //calculating remainder\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string ans;\\n        ans = (numerator > 0)^(denominator > 0) ? \"-\":\"\";       //adding sign if either num or deno is -ve\\n        \\n        long n = abs(numerator);        //making both num and deno +ve\\n        long d = abs(denominator);\\n        ans += to_string(n/d);          \\n        \\n        n = n%d;\\n        if(!n) return ans;              //if we got remainder n = 0 then return ans else add \".\" to the ans\\n        \\n        ans += \".\";\\n        \\n        //If you find remainder again means ans from that point will start repeating from there so we map\\n        //remainder with the length pf answer at that point so that if it occur again then we can insert bracket there\\n        unordered_map<long, int> mp;\\n        \\n        while(n)        //repeat untill remainder != 0\\n        {   \\n            if(mp[n])   //if you find that this remainder has occurred before then  \\n            {\\n                ans.insert(mp[n], \"(\");    //Inserting ( at position when we first found that remainder\\n                ans += \")\";                //Inserting closing bracket at the last\\n                break;          \\n            }\\n            else{\\n                mp[n] = ans.size();     //storing when remainder n come then what is the size of ans\\n                n *= 10;\\n                ans += to_string(n/d);  \\n                n = n%d;                //calculating remainder\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296174,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0){\\n            return  \"0\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0){\\n            sb.append(\"-\");\\n        }\\n        \\n        long divisor = Math.abs((long)numerator);\\n        long dividend = Math.abs((long)denominator);\\n        long remainder = divisor % dividend;\\n        sb.append(divisor / dividend);\\n        \\n        if(remainder == 0){\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        while(remainder!=0){\\n            if(map.containsKey(remainder)){\\n                sb.insert(map.get(remainder), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(remainder, sb.length());\\n            remainder*= 10;\\n            sb.append(remainder/dividend);\\n            remainder%= dividend;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0){\\n            return  \"0\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1017288,
                "title": "explained-python-3-time-complexity-o-len-frac-28-ms",
                "content": "The general idea is to keep a list of the decimal and all the remainders. If the remainder is 0, return the decimal, and if the remainder started repeating, add parenthesis to the part repeating and return it.\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        times = \\'\\'\\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\\n            times = \\'-\\'\\n            numerator = abs(numerator)\\n            denominator = abs(denominator)\\n        if numerator < 0 and denominator < 0:\\n            numerator = -numerator\\n            denominator = -denominator\\n        decimal = []\\n        remainders = []\\n        while True:\\n            decimal.append(str(numerator // denominator))\\n            numerator %= denominator\\n            remainders.append(numerator)\\n            numerator *= 10\\n            \\n            if numerator == 0:\\n                if len(decimal) == 1:\\n                    return times + \\'\\'.join(decimal)\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n            \\n            if remainders.count(remainders[-1]) > 1:\\n                decimal.insert(remainders.index(remainders[-1]) + 1, \\'(\\')\\n                decimal.append(\\')\\')\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n```\\n\\t\\nthe first part is to deal with negatives (If one is negative, make a times variable to add to the start and make all the variables positive. If both are negative, just make all positive)\\nThe start of the while loop is just doing long division and adding the remainders to the remainder list.\\nThe middle of the while loop is dealing with if the denominator (numerator in this case) is 0, which I will then return the decimal because the fraction isn\\'t repeating.\\n\\nThe end part of the while part is the tricky part, and I admit it took me 15 minutes of constant submitting and bug-fixing. the if statement is checking is the remainder had the same value twice, which means the decimal is repeating. So, the demical.insert() is inserting a parenthesis at the start of when the repeating part started. For example, if decimal is \\'0.6\\' (\\'06\\' in the actual code but that doesn\\'t matter) and remainders is [2, 2] I know that the six is repeating, and insert a parenthesis right before \\'6\\'. Then i append a parenthesis at the end of the decimal to get \\'0.(6)\\', and then return it.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        times = \\'\\'\\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\\n            times = \\'-\\'\\n            numerator = abs(numerator)\\n            denominator = abs(denominator)\\n        if numerator < 0 and denominator < 0:\\n            numerator = -numerator\\n            denominator = -denominator\\n        decimal = []\\n        remainders = []\\n        while True:\\n            decimal.append(str(numerator // denominator))\\n            numerator %= denominator\\n            remainders.append(numerator)\\n            numerator *= 10\\n            \\n            if numerator == 0:\\n                if len(decimal) == 1:\\n                    return times + \\'\\'.join(decimal)\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n            \\n            if remainders.count(remainders[-1]) > 1:\\n                decimal.insert(remainders.index(remainders[-1]) + 1, \\'(\\')\\n                decimal.append(\\')\\')\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922829,
                "title": "easyway-explanation-every-step",
                "content": "# ![image](https://assets.leetcode.com/users/images/3990a5fc-e26c-4b29-8268-5dce917a531d_1604464154.2853613.png)\\n\\n\\n# Quotient=numerator / denominator\\n# remainder=numerator % denominator\\n```\\nans=\"\"\\n         x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n\\n```\\n\\n# at first make  negative number to positive for make to easy .at last when original result send than handle it.\\n\\n```\\nreturn ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n\\n\\n```\\n# there is two condition if remainder is zero then skip middle of the code and return this way\\n# here numerator(x) and denominator(y)\\n\\n# Main part of the code when not zero means fractional part is present\\n\\n```\\nif r!=0:\\n          ans+=\".\"\\n```\\n# so at first put into  \".\"  reason is  this is fractional part\\n```\\n          h={}\\n```\\n# we put remainder and what is the length of the output in hasmap . it helps what is the  position  when this remainder come\\n```\\n          while r!=0:\\n                if r in h:\\n              \\n                      l=h[r]\\n                      ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n                      break\\n  ```\\n  # if your remainder present in hasmsp then modify your answer according to leetcode wanted and break .if not put break then loop goes infinity\\n  \\n  \\n```\\n            h[r]=len(ans)\\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n\\n\\n```\\n# if not present then put remainder as a key and length of output as data \\n# this is fractional part so multiple with 10 with remainder\\n# continue same process utill remaind is not zero\\n```\\n\\n\\nYour input\\n4\\n333\\n\\n\\noriginal output = 0.012012012012012012.......\\n\\n store new remainder(key) in hasmap= 4 when length of output (data)= 2 ( 0. ) hasmap= {4: 2}\\n\\n store new remainder(key) in hasmap= 40 when length of output (data)= 3 ( 0.0 ) hasmap= {4: 2, 40: 3}\\n\\n store new remainder(key) in hasmap= 67 when length of output (data)= 4 ( 0.01 ) hasmap= {4: 2, 40: 3, 67: 4}\\n\\n repeated remainder= 4 repeated position= 2\\n{4: 2, 40: 3, 67: 4}\\n\\nOutput\\n\"0.(012)\"\\nExpected\\n\\n```\\n```\\n\\nYour input\\n622\\n495\\noriginal output = 1.256565656565656......\\n\\n store new remainder(key) in hasmap= 127 when length of output (data)= 2 ( 1. ) hasmap= {127: 2}\\n\\n store new remainder(key) in hasmap= 280 when length of output (data)= 3 ( 1.2 ) hasmap= {127: 2, 280: 3}\\n\\n store new remainder(key) in hasmap= 325 when length of output (data)= 4 ( 1.25 ) hasmap= {127: 2, 280: 3, 325: 4}\\n\\n repeated remainder= 280 repeated position= 3\\n{127: 2, 280: 3, 325: 4}\\n\\nOutput\\n\"1.2(56)\"\\nExpected\\n\"1.2(56)\"\\n\\nRun Code\\n\\n\\n\\n\\n```\\n\\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, n, d):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        \\n        x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n        \\n        if r!=0:\\n          ans+=\".\"\\n          h={}\\n          while r!=0:\\n            \\n            if r in h:\\n              \\n              l=h[r]\\n              ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n              break\\n              \\n            h[r]=len(ans)\\n            \\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n        \\n        return ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n            \\n          \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nans=\"\"\\n         x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n\\n```\n```\\nreturn ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n\\n\\n```\n```\\nif r!=0:\\n          ans+=\".\"\\n```\n```\\n          h={}\\n```\n```\\n          while r!=0:\\n                if r in h:\\n              \\n                      l=h[r]\\n                      ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n                      break\\n  ```\n```\\n            h[r]=len(ans)\\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n\\n\\n```\n```\\n\\n\\nYour input\\n4\\n333\\n\\n\\noriginal output = 0.012012012012012012.......\\n\\n store new remainder(key) in hasmap= 4 when length of output (data)= 2 ( 0. ) hasmap= {4: 2}\\n\\n store new remainder(key) in hasmap= 40 when length of output (data)= 3 ( 0.0 ) hasmap= {4: 2, 40: 3}\\n\\n store new remainder(key) in hasmap= 67 when length of output (data)= 4 ( 0.01 ) hasmap= {4: 2, 40: 3, 67: 4}\\n\\n repeated remainder= 4 repeated position= 2\\n{4: 2, 40: 3, 67: 4}\\n\\nOutput\\n\"0.(012)\"\\nExpected\\n\\n```\n```\\n\\nYour input\\n622\\n495\\noriginal output = 1.256565656565656......\\n\\n store new remainder(key) in hasmap= 127 when length of output (data)= 2 ( 1. ) hasmap= {127: 2}\\n\\n store new remainder(key) in hasmap= 280 when length of output (data)= 3 ( 1.2 ) hasmap= {127: 2, 280: 3}\\n\\n store new remainder(key) in hasmap= 325 when length of output (data)= 4 ( 1.25 ) hasmap= {127: 2, 280: 3, 325: 4}\\n\\n repeated remainder= 280 repeated position= 3\\n{127: 2, 280: 3, 325: 4}\\n\\nOutput\\n\"1.2(56)\"\\nExpected\\n\"1.2(56)\"\\n\\nRun Code\\n\\n\\n\\n\\n```\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, n, d):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        \\n        x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n        \\n        if r!=0:\\n          ans+=\".\"\\n          h={}\\n          while r!=0:\\n            \\n            if r in h:\\n              \\n              l=h[r]\\n              ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n              break\\n              \\n            h[r]=len(ans)\\n            \\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n        \\n        return ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n            \\n          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 292716,
                "title": "c-dictionary-and-while",
                "content": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator) {\\n        return FractionToDecimalLong((long)numerator, (long)denominator);\\n    }\\n\\n    private string FractionToDecimalLong(long numerator, long denominator) {\\n        var isNegative = false;\\n        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {\\n            isNegative = true;\\n        }\\n\\n        numerator = Math.Abs(numerator);\\n        denominator = Math.Abs(denominator);\\n\\n        var integerPart = numerator / denominator;\\n\\n        var floatPart = \"\";\\n\\n        var remainderAndIndex = new Dictionary<long, int>();\\n        var remainder = numerator % denominator;\\n\\n        if (remainder == 0) return isNegative ? $\"-{integerPart}\" : $\"{integerPart}\";\\n\\n        var i = 0;\\n\\n        while (remainder != 0) {\\n            remainderAndIndex[remainder] = i;\\n            i++;\\n            remainder *= 10;\\n            floatPart = $\"{floatPart}{remainder / denominator}\";\\n            remainder = remainder % denominator;\\n            if (remainderAndIndex.ContainsKey(remainder)) {\\n                floatPart = floatPart.Insert(remainderAndIndex[remainder], \"(\");\\n                floatPart += \")\";\\n                break;\\n            }\\n        }\\n\\n        if (isNegative) {\\n            return $\"-{integerPart}.{floatPart}\";\\n        }\\n\\n        return $\"{integerPart}.{floatPart}\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator) {\\n        return FractionToDecimalLong((long)numerator, (long)denominator);\\n    }\\n\\n    private string FractionToDecimalLong(long numerator, long denominator) {\\n        var isNegative = false;\\n        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {\\n            isNegative = true;\\n        }\\n\\n        numerator = Math.Abs(numerator);\\n        denominator = Math.Abs(denominator);\\n\\n        var integerPart = numerator / denominator;\\n\\n        var floatPart = \"\";\\n\\n        var remainderAndIndex = new Dictionary<long, int>();\\n        var remainder = numerator % denominator;\\n\\n        if (remainder == 0) return isNegative ? $\"-{integerPart}\" : $\"{integerPart}\";\\n\\n        var i = 0;\\n\\n        while (remainder != 0) {\\n            remainderAndIndex[remainder] = i;\\n            i++;\\n            remainder *= 10;\\n            floatPart = $\"{floatPart}{remainder / denominator}\";\\n            remainder = remainder % denominator;\\n            if (remainderAndIndex.ContainsKey(remainder)) {\\n                floatPart = floatPart.Insert(remainderAndIndex[remainder], \"(\");\\n                floatPart += \")\";\\n                break;\\n            }\\n        }\\n\\n        if (isNegative) {\\n            return $\"-{integerPart}.{floatPart}\";\\n        }\\n\\n        return $\"{integerPart}.{floatPart}\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51122,
                "title": "java-1ms-without-using-hash-table",
                "content": "  Actually there is no need to use a hash table.\\n\\n  I get this inspiration from the problem NO.142, Linked list Cycle II, imagine every remainder you take as a node when you perform the division. When you get the recurring decimals, the pattern will be the same as the pattern mentioned in Linked list Cydle II(Find the node which the cycle starts).\\n \\n  How to find that node we want? Suppose we have n nodes who are not in the cycle and m nodes who are in the cycle. We create two pointers. The first one moves one nodes per step, the second one moves two nodes per step. When the first one reaches the node that we want, the second one is n nodes ahead. For the second node, if it want to catch up the first node, it will have to move m-n steps ahead. So far the first node have moved for (m-n+n) = m steps and there are (m+n-m) = n steps left to reach the node which starts the cycle. The same thing is, it will take exactly n steps for the first node to reach that node. So we could use a pointer start from the beginning of the list and move all of them one nodes per step. When they reach the same node. That node is the node we want.\\n\\n  The actual code is as follows.\\n\\npublic class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator==Integer.MIN_VALUE&&denominator==-1)\\n            return \"2147483648\";\\n        int dummy = numerator/denominator, lef = numerator%denominator;\\n        String str = dummy+\"\";\\n        if(dummy==0){\\n            if((numerator>0&&denominator<0)||(numerator<0&&denominator>0))\\n            str = \"-\" + str; // 0 does not have a negative mark in front of it, so we have to add that.\\n        }\\n        if(lef==0) return str; // this indicates the result is an integer.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(str);\\n        sb.append(\".\");\\n        long left = lef<0? -lef : lef;\\n        long denomin = denominator<0? -denominator : denominator;\\n        if(denominator==Integer.MIN_VALUE){\\n            denomin = Integer.MAX_VALUE;\\n            denomin++; // without this, when the denominator is -214748648, it will cause a overflow.\\n        }\\n        long slow = mod(left,denomin), fast = mod(mod(left,denomin),denomin);\\n        if(slow==0){ // no need to start the loop.\\n            left = extend(left,denomin,sb);\\n            return sb.toString();\\n        }\\n        \\n        while(slow!=fast){\\n            if(fast==0){  // this indicates there are no cycles.\\n                while(left!=0)\\n                    left = extend(left,denomin,sb);\\n                return sb.toString();\\n            }\\n            slow = mod(slow,denomin);\\n            fast = mod(mod(fast,denomin),denomin);\\n        }\\n        \\n        slow = left;\\n        while(slow!=fast){\\n            slow = mod(slow,denomin);\\n            fast = mod(fast,denomin);\\n        }\\n        while(left!=slow)\\n            left = extend(left,denomin,sb);\\n        sb.append(\"(\"); // the start of the cycle.\\n        left = extend(left,denomin,sb);\\n        while(left!=slow)\\n            left = extend(left,denomin,sb);\\n        sb.append(\")\");\\n        return sb.toString();\\n    }\\n    \\n    private long mod(long left, long denominator){\\n        left = left * 10;      \\n        return left%denominator;    \\n    }\\n    \\n    private long extend(long left, long denominator, StringBuilder sb){\\n        left = left * 10;      \\n        sb.append(left/denominator);\\n        return left%denominator;\\n    }\\n\\n }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator==Integer.MIN_VALUE&&denominator==-1)\\n            return \"2147483648\";\\n        int dummy = numerator/denominator, lef = numerator%denominator;\\n        String str = dummy+\"\";\\n        if(dummy==0){\\n            if((numerator>0&&denominator<0)||(numerator<0&&denominator>0))\\n            str = \"-\" + str; // 0 does not have a negative mark in front of it, so we have to add that.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2405774,
                "title": "c-unordered-map-0ms-time",
                "content": "**C++ Implementation**\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        int cnt = 0;\\n        if(n == 0) return \"0\";\\n        if(n < 0) cnt++;\\n        if(d < 0) cnt++;\\n        n = abs(n);\\n        d = abs(d);        \\n        long long rem = n%d;\\n        long long q = n/d;\\n        string ans = \"\";\\n        ans += to_string(q);\\n        if(rem == 0) {\\n            if(cnt == 1) return \"-\"+ans;\\n            else return ans;\\n        }\\n        unordered_map<int,int>mp;\\n        ans += \".\";\\n        while(rem != 0){\\n            if(mp.find(rem) != mp.end()){\\n                int len = mp[rem];\\n                string s1 = ans.substr(0,len);\\n                string s2 = ans.substr(len);\\n                ans = s1+\"(\"+s2+\")\";\\n                break;\\n            }\\n            else{\\n                mp[rem] = ans.size();\\n                rem *= 10;\\n                q = rem/d;\\n                rem = rem%d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(cnt == 1) return \"-\"+ans;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please like my solution**\\n**HAPPY CODING**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        int cnt = 0;\\n        if(n == 0) return \"0\";\\n        if(n < 0) cnt++;\\n        if(d < 0) cnt++;\\n        n = abs(n);\\n        d = abs(d);        \\n        long long rem = n%d;\\n        long long q = n/d;\\n        string ans = \"\";\\n        ans += to_string(q);\\n        if(rem == 0) {\\n            if(cnt == 1) return \"-\"+ans;\\n            else return ans;\\n        }\\n        unordered_map<int,int>mp;\\n        ans += \".\";\\n        while(rem != 0){\\n            if(mp.find(rem) != mp.end()){\\n                int len = mp[rem];\\n                string s1 = ans.substr(0,len);\\n                string s2 = ans.substr(len);\\n                ans = s1+\"(\"+s2+\")\";\\n                break;\\n            }\\n            else{\\n                mp[rem] = ans.size();\\n                rem *= 10;\\n                q = rem/d;\\n                rem = rem%d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(cnt == 1) return \"-\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209251,
                "title": "cpp-string-map",
                "content": "```\\nstring fractionToDecimal(int num, int den) {\\n\\t//WV recommended\\n\\tbool isNegative = false;\\n\\tint newNum = num;\\n\\tint newDen = den;\\n\\tif (num < 0 or den < 0) {\\n\\t\\tisNegative = true;\\n\\t\\tnewNum = abs(num);\\n\\t\\tnewDen = abs(den);\\n\\t}\\n\\tif (num < 0 and den < 0) {\\n\\t\\t//coz, dono - hai to ek doosre ko cancel kr dege\\n\\t\\tisNegative = false;\\n\\t}\\n\\n\\tstring ans = \"\";\\n\\tlong long quotent = newNum / newDen;\\n\\tlong long rem = newNum % newDen;\\n\\tans += to_string(abs(quotent));\\n\\n\\tif (rem == 0) {\\n\\t\\tif (isNegative and ans != \"0\") {\\n\\t\\t\\tans.insert(0, \"-\");\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\telse { //rem != 0\\n\\t\\tans += \".\"; // decimal lga dia\\n\\t\\tmap<long long, long long> mp; //rem,position(index)\\n\\t\\t// cout << \"test \" << ans << endl;\\n\\t\\twhile (rem != 0) {\\n\\t\\t\\tif (mp.find(rem) != mp.end()) { //found\\n\\t\\t\\t\\t//means remainder repeat hua h, recurring decimal exist(WV). so add \"(\" at position(from map) and \")\" at the end\\n\\t\\t\\t\\tlong long len = mp[rem];\\n\\t\\t\\t\\tans.insert(len, \"(\");\\n\\t\\t\\t\\tans += \")\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse { //not found\\n\\t\\t\\t\\tmp[rem] = ans.size();\\n\\t\\t\\t\\trem *= 10; //decimal lga hai toh zero add krte h, jaese actual divide krte time krte h(WV)\\n\\t\\t\\t\\tquotent = rem / newDen;\\n\\t\\t\\t\\trem = rem % newDen;\\n\\t\\t\\t\\tans += to_string(abs(quotent));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (isNegative) {\\n\\t\\tcout << \"test \" << ans << endl;\\n\\t\\tans.insert(0, \"-\");\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nstring fractionToDecimal(int num, int den) {\\n\\t//WV recommended\\n\\tbool isNegative = false;\\n\\tint newNum = num;\\n\\tint newDen = den;\\n\\tif (num < 0 or den < 0) {\\n\\t\\tisNegative = true;\\n\\t\\tnewNum = abs(num);\\n\\t\\tnewDen = abs(den);\\n\\t}\\n\\tif (num < 0 and den < 0) {\\n\\t\\t//coz, dono - hai to ek doosre ko cancel kr dege\\n\\t\\tisNegative = false;\\n\\t}\\n\\n\\tstring ans = \"\";\\n\\tlong long quotent = newNum / newDen;\\n\\tlong long rem = newNum % newDen;\\n\\tans += to_string(abs(quotent));\\n\\n\\tif (rem == 0) {\\n\\t\\tif (isNegative and ans != \"0\") {\\n\\t\\t\\tans.insert(0, \"-\");\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\telse { //rem != 0\\n\\t\\tans += \".\"; // decimal lga dia\\n\\t\\tmap<long long, long long> mp; //rem,position(index)\\n\\t\\t// cout << \"test \" << ans << endl;\\n\\t\\twhile (rem != 0) {\\n\\t\\t\\tif (mp.find(rem) != mp.end()) { //found\\n\\t\\t\\t\\t//means remainder repeat hua h, recurring decimal exist(WV). so add \"(\" at position(from map) and \")\" at the end\\n\\t\\t\\t\\tlong long len = mp[rem];\\n\\t\\t\\t\\tans.insert(len, \"(\");\\n\\t\\t\\t\\tans += \")\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse { //not found\\n\\t\\t\\t\\tmp[rem] = ans.size();\\n\\t\\t\\t\\trem *= 10; //decimal lga hai toh zero add krte h, jaese actual divide krte time krte h(WV)\\n\\t\\t\\t\\tquotent = rem / newDen;\\n\\t\\t\\t\\trem = rem % newDen;\\n\\t\\t\\t\\tans += to_string(abs(quotent));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (isNegative) {\\n\\t\\tcout << \"test \" << ans << endl;\\n\\t\\tans.insert(0, \"-\");\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "C++"
            },
            {
                "id": 1387484,
                "title": "java-using-hashmap-faster-than-100",
                "content": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator==0) return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //negative case\\n        if (numerator>0 && denominator<0 || numerator<0 && denominator>0) {\\n            sb.append(\"-\");\\n        }\\n        \\n        long x = Math.abs(Long.valueOf(numerator));\\n        long y = Math.abs(Long.valueOf(denominator));\\n        \\n        sb.append(String.valueOf(x/y));\\n        \\n        long remainder = x%y;\\n        if (remainder==0) {\\n            return sb.toString();\\n        }\\n        \\n        //decimal case\\n        sb.append(\".\");\\n\\t\\t\\n\\t\\t//store the remainder in a Hashmap because in the case of recurring decimal, the remainder repeats as dividend.\\n        Map<Long,Integer> map = new HashMap<>();\\n        while (remainder != 0) {\\n            if (map.containsKey(remainder)){\\n                sb.insert(map.get(remainder), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n\\t\\t\\t//store the remainder and the index of it\\'s occurence in the String\\n            map.put(remainder, sb.length());\\n            remainder *= 10;\\n            sb.append(String.valueOf(remainder/y));\\n            remainder %= y;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator==0) return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //negative case\\n        if (numerator>0 && denominator<0 || numerator<0 && denominator>0) {\\n            sb.append(\"-\");\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1261844,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(long numerator, long denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        bool negative = numerator<0 ^ denominator<0;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        string integer = (negative?\"-\":\"\") + to_string(numerator/denominator);\\n        numerator %= denominator;\\n        \\n        unordered_map<int, int> seen;\\n        string decimal = \".\";\\n        while (numerator != 0) {\\n            numerator *= 10;\\n            decimal += to_string(numerator/denominator);\\n            numerator %= denominator;\\n            if (seen[numerator]) {\\n                decimal.insert(seen[numerator], \"(\");\\n                decimal += \")\";\\n                break;\\n            }\\n            seen[numerator] = decimal.size();\\n        }\\n        \\n        if (decimal.size() == 1) return integer;\\n        else return integer + decimal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(long numerator, long denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        bool negative = numerator<0 ^ denominator<0;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        string integer = (negative?\"-\":\"\") + to_string(numerator/denominator);\\n        numerator %= denominator;\\n        \\n        unordered_map<int, int> seen;\\n        string decimal = \".\";\\n        while (numerator != 0) {\\n            numerator *= 10;\\n            decimal += to_string(numerator/denominator);\\n            numerator %= denominator;\\n            if (seen[numerator]) {\\n                decimal.insert(seen[numerator], \"(\");\\n                decimal += \")\";\\n                break;\\n            }\\n            seen[numerator] = decimal.size();\\n        }\\n        \\n        if (decimal.size() == 1) return integer;\\n        else return integer + decimal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833246,
                "title": "simple-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long num = numerator;\\n        long deno = denominator;\\n        boolean negtive = (double)num/deno < 0 ? true:false;\\n        num = Math.abs(num);\\n        deno = Math.abs(deno);\\n        String res = negtive? \"-\"+num/deno : num/deno+\"\";\\n        if(num % deno == 0) \\n            return res;\\n        String decimal = \"\";\\n        num = (num % deno) * 10;\\n        HashMap<Long, Integer> mods = new HashMap();\\n        int index = 0;\\n        while(!mods.containsKey(num) && num != 0){\\n            mods.put(num, index++);\\n            decimal += num/deno;\\n            num = (num % deno) * 10;\\n        }\\n        if(num == 0) return res+\".\"+decimal;\\n        int i = mods.get(num);\\n        res += \".\" + decimal.substring(0, i) + \"(\" + decimal.substring(i) + \")\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long num = numerator;\\n        long deno = denominator;\\n        boolean negtive = (double)num/deno < 0 ? true:false;\\n        num = Math.abs(num);\\n        deno = Math.abs(deno);\\n        String res = negtive? \"-\"+num/deno : num/deno+\"\";\\n        if(num % deno == 0) \\n            return res;\\n        String decimal = \"\";\\n        num = (num % deno) * 10;\\n        HashMap<Long, Integer> mods = new HashMap();\\n        int index = 0;\\n        while(!mods.containsKey(num) && num != 0){\\n            mods.put(num, index++);\\n            decimal += num/deno;\\n            num = (num % deno) * 10;\\n        }\\n        if(num == 0) return res+\".\"+decimal;\\n        int i = mods.get(num);\\n        res += \".\" + decimal.substring(0, i) + \"(\" + decimal.substring(i) + \")\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793983,
                "title": "c-beats-100-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0 || denominator == 0) {\\n            return \"0\";\\n        }\\n        \\n        long num = labs(numerator);\\n        long den = labs(denominator);\\n        \\n        string cur = \"\";\\n        \\n        if(numerator < 0 ^ denominator < 0) {\\n            cur += \"-\";\\n        }\\n        \\n        cur += to_string(num / den);\\n        \\n        if(num % den == 0) {\\n            return cur;\\n        }\\n        num %= den;\\n        \\n        cur += \".\";\\n        \\n        \\n        unordered_map<long, int> seen;\\n        \\n        while(num > 0) {\\n            if(seen.find(num) != seen.end()) {\\n                cur.insert(seen[num], 1, \\'(\\');\\n                cur += \")\";\\n                return cur;\\n            }\\n            \\n            seen[num] = cur.size();\\n            num *= 10;\\n            cur += to_string(num / den);\\n            num %= den;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0 || denominator == 0) {\\n            return \"0\";\\n        }\\n        \\n        long num = labs(numerator);\\n        long den = labs(denominator);\\n        \\n        string cur = \"\";\\n        \\n        if(numerator < 0 ^ denominator < 0) {\\n            cur += \"-\";\\n        }\\n        \\n        cur += to_string(num / den);\\n        \\n        if(num % den == 0) {\\n            return cur;\\n        }\\n        num %= den;\\n        \\n        cur += \".\";\\n        \\n        \\n        unordered_map<long, int> seen;\\n        \\n        while(num > 0) {\\n            if(seen.find(num) != seen.end()) {\\n                cur.insert(seen[num], 1, \\'(\\');\\n                cur += \")\";\\n                return cur;\\n            }\\n            \\n            seen[num] = cur.size();\\n            num *= 10;\\n            cur += to_string(num / den);\\n            num %= den;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51200,
                "title": "my-python-code-without-using-extra-space",
                "content": "The idea is pretty simple, the question is essentially the same with \"Find the start point of a linked list cycle\". I used the fast pointer and slow pointer trick.\\nBelow is my code with some explanation:\\n\\n    def fractionToDecimal(self, numerator, denominator):\\n        n = numerator\\n        d = denominator\\n        if n % d == 0:\\n            return str(n//d)\\n        # Deal with negatives\\n        if (abs(n)/n) * (abs(d)/d) < 0:\\n            res = '-'\\n            n = abs(n)\\n            d = abs(d)\\n        else:\\n            res = ''\\n        # Integer part\\n        res = res + str(n//d) + '.'\\n        n = n % d\\n        # Start point of the \"list\"\\n        frem = n\\n        srem = n\\n        firstTime = True\\n        while frem != 0 and not (firstTime == False and frem == srem):\\n            firstTime = False\\n            srem = (srem * 10) % d\\n            frem = (frem * 10) % d\\n            if frem:\\n                frem = (frem * 10) % d\\n        # The fast pointer encounters a remainder of 0, so no cycle in the \"list\"\\n        if frem == 0:\\n            res += str((n * 10) // d)\\n            rem = (n * 10) % d\\n            while rem:\\n                res += str((rem * 10) // d)\\n                rem = (rem * 10) % d\\n            return res\\n        else:\\n            # Find the start point of the cycle, meanwhile, generate the non recurring part\\n            srem = n\\n            while frem != srem:\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n                frem = (frem * 10) % d\\n            res += '('\\n            # Generate the recurring part\\n            firstTime = True\\n            while not (firstTime == False and srem == frem):\\n                firstTime = False\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n            res += ')'\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is pretty simple, the question is essentially the same with \"Find the start point of a linked list cycle\". I used the fast pointer and slow pointer trick.\\nBelow is my code with some explanation:\\n\\n    def fractionToDecimal(self, numerator, denominator):\\n        n = numerator\\n        d = denominator\\n        if n % d == 0:\\n            return str(n//d)\\n        # Deal with negatives\\n        if (abs(n)/n) * (abs(d)/d) < 0:\\n            res = '-'\\n            n = abs(n)\\n            d = abs(d)\\n        else:\\n            res = ''\\n        # Integer part\\n        res = res + str(n//d) + '.'\\n        n = n % d\\n        # Start point of the \"list\"\\n        frem = n\\n        srem = n\\n        firstTime = True\\n        while frem != 0 and not (firstTime == False and frem == srem):\\n            firstTime = False\\n            srem = (srem * 10) % d\\n            frem = (frem * 10) % d\\n            if frem:\\n                frem = (frem * 10) % d\\n        # The fast pointer encounters a remainder of 0, so no cycle in the \"list\"\\n        if frem == 0:\\n            res += str((n * 10) // d)\\n            rem = (n * 10) % d\\n            while rem:\\n                res += str((rem * 10) // d)\\n                rem = (rem * 10) % d\\n            return res\\n        else:\\n            # Find the start point of the cycle, meanwhile, generate the non recurring part\\n            srem = n\\n            while frem != srem:\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n                frem = (frem * 10) % d\\n            res += '('\\n            # Generate the recurring part\\n            firstTime = True\\n            while not (firstTime == False and srem == frem):\\n                firstTime = False\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n            res += ')'\\n            return res",
                "codeTag": "Python3"
            },
            {
                "id": 51228,
                "title": "my-java-solution",
                "content": "basic idea:\\n\\n1. for the input integer: positive and negative number matters? => yes, so check the sign first\\n\\n2. can get integer part directly by a/b, then deal with decimal part\\n\\n3. get remainder by a%b. the problem is: how to check the decimal part is repeated (or not)?\\n\\n4. for each loop, we can get the digit by remainder*10/b and update new remainder=remainder*10%b, if we get the same remainder again, previous result is repeated\\n\\n5. so, use a set to store the remainder(s) that already appeared and use queue to store int sequence that need to append to res\\n\\n6. check remainder for each loop, if 0, poll all elem in queue, if set contains the remainder (q...)\\n\\n7. but... the question comes again: example, if result is 0.123454545 or 1/7 = 0.123454545, need a parameter to store which digit the res starts to repeat.. extra info is needed when we store the remainder to \"locate\" its position\\n\\n8. back to step 5, define the map instead of set to store <remainder, position> position=i (each loop i++)\\n\\t\\n9. at last, check the remainder to know whether it's belong to \"recurring\" result or not\\n\\n\\n        public static String fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tString res = \"\";\\n    \\t\\tlong a = Math.abs((long) numerator);\\n    \\t\\tlong b = Math.abs((long) denominator);\\n    \\t\\tif ((denominator < 0 && numerator > 0) || (denominator > 0 && numerator < 0)) {\\n    \\t\\t\\tres += \"-\";\\n    \\t\\t}\\n    \\t\\tlong intPart= a / b;\\n    \\t\\tres += intPart;\\n    \\t\\tif (a % b == 0) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tres += \".\";\\n    \\t\\tlong remainder = a % b;\\n    \\t\\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n    \\t\\tint i = 1;\\n    \\t\\tmap.put(remainder, 1);\\n    \\t\\tQueue<Long> queue = new LinkedList<Long>();\\n    \\t\\tint begin = -1;\\n    \\t\\twhile (remainder != 0) {\\n    \\t\\t\\ti++;\\n    \\t\\t\\tlong tmp = remainder * 10 / b;\\n    \\t\\t\\tremainder = remainder * 10 % b;\\n    \\t\\t\\tif (map.containsKey(remainder)) {\\n    \\t\\t\\t\\tbegin = map.get(remainder);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tmap.put(remainder, i);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (remainder == 0) {\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tres += queue.poll();\\n    \\t\\t\\t}\\n    \\t\\t} else {\\n    \\t\\t\\tint j = 1;\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tlong cur = queue.poll();\\n    \\t\\t\\t\\tif (j != begin) {\\n    \\t\\t\\t\\t\\tres += cur;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tres = res + \"(\" + cur;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t\\tres += \")\";\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n\\na little optimization can be done: define stringbuilder as the result",
                "solutionTags": [
                    "Java"
                ],
                "code": "basic idea:\\n\\n1. for the input integer: positive and negative number matters? => yes, so check the sign first\\n\\n2. can get integer part directly by a/b, then deal with decimal part\\n\\n3. get remainder by a%b. the problem is: how to check the decimal part is repeated (or not)?\\n\\n4. for each loop, we can get the digit by remainder*10/b and update new remainder=remainder*10%b, if we get the same remainder again, previous result is repeated\\n\\n5. so, use a set to store the remainder(s) that already appeared and use queue to store int sequence that need to append to res\\n\\n6. check remainder for each loop, if 0, poll all elem in queue, if set contains the remainder (q...)\\n\\n7. but... the question comes again: example, if result is 0.123454545 or 1/7 = 0.123454545, need a parameter to store which digit the res starts to repeat.. extra info is needed when we store the remainder to \"locate\" its position\\n\\n8. back to step 5, define the map instead of set to store <remainder, position> position=i (each loop i++)\\n\\t\\n9. at last, check the remainder to know whether it's belong to \"recurring\" result or not\\n\\n\\n        public static String fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tString res = \"\";\\n    \\t\\tlong a = Math.abs((long) numerator);\\n    \\t\\tlong b = Math.abs((long) denominator);\\n    \\t\\tif ((denominator < 0 && numerator > 0) || (denominator > 0 && numerator < 0)) {\\n    \\t\\t\\tres += \"-\";\\n    \\t\\t}\\n    \\t\\tlong intPart= a / b;\\n    \\t\\tres += intPart;\\n    \\t\\tif (a % b == 0) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tres += \".\";\\n    \\t\\tlong remainder = a % b;\\n    \\t\\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n    \\t\\tint i = 1;\\n    \\t\\tmap.put(remainder, 1);\\n    \\t\\tQueue<Long> queue = new LinkedList<Long>();\\n    \\t\\tint begin = -1;\\n    \\t\\twhile (remainder != 0) {\\n    \\t\\t\\ti++;\\n    \\t\\t\\tlong tmp = remainder * 10 / b;\\n    \\t\\t\\tremainder = remainder * 10 % b;\\n    \\t\\t\\tif (map.containsKey(remainder)) {\\n    \\t\\t\\t\\tbegin = map.get(remainder);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tmap.put(remainder, i);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (remainder == 0) {\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tres += queue.poll();\\n    \\t\\t\\t}\\n    \\t\\t} else {\\n    \\t\\t\\tint j = 1;\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tlong cur = queue.poll();\\n    \\t\\t\\t\\tif (j != begin) {\\n    \\t\\t\\t\\t\\tres += cur;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tres = res + \"(\" + cur;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t\\tres += \")\";\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n\\na little optimization can be done: define stringbuilder as the result",
                "codeTag": "Unknown"
            },
            {
                "id": 3472668,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires converting a fraction to a decimal representation. If the decimal representation is finite, then the output is simply the quotient of the numerator and denominator. Otherwise, we need to represent the repeating decimal with a set of parentheses. We can detect the repeating part by using a hash table to keep track of the remainders and the corresponding position of the quotient where the remainder appears.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by checking if the numerator or denominator is negative. If both are negative, then we convert them to positive. We then calculate the quotient of the numerator and denominator using the integer division. If the remainder is 0, then the output is simply the quotient.\\n\\nIf the remainder is non-zero, we append a decimal point to the quotient and calculate the fractional part. We keep track of the remainders and corresponding positions of the quotient where the remainders appear. If we encounter a remainder that we have seen before, we know that the decimal expansion repeats. We can then insert the opening and closing parentheses around the repeating part of the quotient.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the algorithm is $$O(d)$$, where d is the number of digits in the repeating part of the decimal expansion. This is because we need to perform integer division and multiplication for each digit in the decimal expansion.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is $$O(d)$$, where d is the number of digits in the repeating part of the decimal expansion. This is because we need to store the remainders and corresponding positions of the quotient where the remainders appear in a hash table.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111158,
                "title": "o-n-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFractions are repeated due to recurring numerator and denominator\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave the numerator encounterd along with its posistion in the remainder string when it was encountered. When the remainder is found in hash map. Just break and add brances to the string in beetween\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    10^4  (O(n))      *             O(1)             +     O(N)\\n    MAX_STR_LENGTH    *   HASH SEARCH FOR REMAINDER  +  STRING COPY\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(N)          +    2 * O(N)       + c\\n    (HASH MAP)    +     STRINGS\\n\\nOne can optimize by using single string and soing string manipulations at the end\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        std::string ans;\\n        std::string final_ans; \\n        if((numerator<0&&denominator>0) ||(numerator>0&&denominator<0))\\n        {\\n        ans.append(\"-\");\\n        }\\n        long int d= abs(denominator);\\n        long int n=abs(numerator);\\n        \\n        ans = ans+std::to_string((long int)(n/d));\\n        std::unordered_map<long,int> m;\\n        long int remainder = n%d;\\n        if(remainder!=0)\\n        {\\n            ans.append(\".\");\\n            while(ans.size()<10001)\\n            {\\n                if(remainder ==0 ||m.find(remainder)!=m.end())\\n                {\\n                    break;\\n                }\\n                m[remainder] = ans.size();\\n                long int t= (remainder*10)/d;\\n                ans.append(std::to_string(t));\\n                remainder = (remainder*10)%d;\\n            }\\n            if(m.find(remainder)!=m.end())\\n            {\\n                final_ans = ans.substr(0,m[remainder]) \\n                + \"(\"+\\n                ans.substr(m[remainder])\\n                +\")\";\\n            }\\n            else{\\n                final_ans = ans;\\n            }\\n        }\\n        else\\n        final_ans = ans;\\n        return final_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        std::string ans;\\n        std::string final_ans; \\n        if((numerator<0&&denominator>0) ||(numerator>0&&denominator<0))\\n        {\\n        ans.append(\"-\");\\n        }\\n        long int d= abs(denominator);\\n        long int n=abs(numerator);\\n        \\n        ans = ans+std::to_string((long int)(n/d));\\n        std::unordered_map<long,int> m;\\n        long int remainder = n%d;\\n        if(remainder!=0)\\n        {\\n            ans.append(\".\");\\n            while(ans.size()<10001)\\n            {\\n                if(remainder ==0 ||m.find(remainder)!=m.end())\\n                {\\n                    break;\\n                }\\n                m[remainder] = ans.size();\\n                long int t= (remainder*10)/d;\\n                ans.append(std::to_string(t));\\n                remainder = (remainder*10)%d;\\n            }\\n            if(m.find(remainder)!=m.end())\\n            {\\n                final_ans = ans.substr(0,m[remainder]) \\n                + \"(\"+\\n                ans.substr(m[remainder])\\n                +\")\";\\n            }\\n            else{\\n                final_ans = ans;\\n            }\\n        }\\n        else\\n        final_ans = ans;\\n        return final_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746780,
                "title": "like-pen-paper-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, nu: int, de: int) -> str:\\n        cf=\"\"\\n        if(nu*de<0):\\n            cf=\"-\"\\n        nu=abs(nu)\\n        de=abs(de)\\n        st1=nu//de\\n        re=abs(nu%de)\\n        st1=str(st1)\\n        st2=\"\"\\n        i=0\\n        dc={}\\n        while(re>0):\\n            if(re<de):\\n                re*=10\\n            if((re,de) in dc):\\n                st2=st2[:dc[(re,de)]]+\"(\"+st2[dc[(re,de)]:]+\")\"\\n                break\\n            dc[(re,de)]=i\\n            i+=1\\n            st2+=str(re//de)\\n            re=re%de\\n        if(st2==\"\"):\\n            return cf+st1\\n        return(cf+st1+\".\"+st2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, nu: int, de: int) -> str:\\n        cf=\"\"\\n        if(nu*de<0):\\n            cf=\"-\"\\n        nu=abs(nu)\\n        de=abs(de)\\n        st1=nu//de\\n        re=abs(nu%de)\\n        st1=str(st1)\\n        st2=\"\"\\n        i=0\\n        dc={}\\n        while(re>0):\\n            if(re<de):\\n                re*=10\\n            if((re,de) in dc):\\n                st2=st2[:dc[(re,de)]]+\"(\"+st2[dc[(re,de)]:]+\")\"\\n                break\\n            dc[(re,de)]=i\\n            i+=1\\n            st2+=str(re//de)\\n            re=re%de\\n        if(st2==\"\"):\\n            return cf+st1\\n        return(cf+st1+\".\"+st2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419439,
                "title": "c-taking-care-of-minor-edge-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        if(n==0)    return \"0\";\\n        if(d==1)    return to_string(n);\\n        if(d==-1)    return to_string((long)fabs(n));\\n        string ans=\"\";\\n        if((n<0 && d>0) || (n>0 && d<0))    ans += \"-\";\\n        n = abs(n);\\n        d = abs(d);\\n        ans += to_string(n/d);\\n        long long rem = n%d;\\n        if(!rem)    return ans;\\n        else    ans += \".\";\\n        unordered_map<int,int>num;\\n        while(rem!=0)\\n        {\\n            if(num.find(rem)!=num.end())    \\n            {\\n                ans.insert(num[rem],\"(\");\\n                ans += \")\";\\n                return ans;\\n            }\\n            num[rem] = ans.length();\\n            rem *= 10;\\n            ans += to_string(rem/d);\\n            rem %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        if(n==0)    return \"0\";\\n        if(d==1)    return to_string(n);\\n        if(d==-1)    return to_string((long)fabs(n));\\n        string ans=\"\";\\n        if((n<0 && d>0) || (n>0 && d<0))    ans += \"-\";\\n        n = abs(n);\\n        d = abs(d);\\n        ans += to_string(n/d);\\n        long long rem = n%d;\\n        if(!rem)    return ans;\\n        else    ans += \".\";\\n        unordered_map<int,int>num;\\n        while(rem!=0)\\n        {\\n            if(num.find(rem)!=num.end())    \\n            {\\n                ans.insert(num[rem],\"(\");\\n                ans += \")\";\\n                return ans;\\n            }\\n            num[rem] = ans.length();\\n            rem *= 10;\\n            ans += to_string(rem/d);\\n            rem %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894376,
                "title": "26ms-python-efficient-easy-to-understand-solution",
                "content": "Please Upvote if you like it....\\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ansmaker = \"\"\\n        if numerator == 0:\\n            return \"0\"\\n        if numerator<0 and denominator<0:\\n            numerator = -1*numerator\\n            denominator = -1*denominator\\n        elif numerator<0 and denominator>=0:\\n            numerator = -1*numerator\\n            ansmaker= \"-\"\\n        elif numerator>=0 and denominator<0:\\n            denominator = -1* denominator\\n            ansmaker = \"-\"\\n        dict1 = {}\\n        q = numerator//denominator\\n        r = numerator%denominator\\n        # print(q,r)\\n        if r == 0:\\n            return(ansmaker + str(q))\\n        else:\\n            ans = ansmaker+ str(q) + \".\"\\n        while True:\\n            if r == 0:\\n                return ans\\n            if r in dict1:\\n                sl = dict1[r]\\n                ans = ans[:sl] + \"(\" + ans[sl:] + \")\"\\n                return ans\\n            dict1[r] = len(ans)\\n            r = r*10\\n            q = r//denominator\\n            r = r%denominator\\n            ans = ans+str(q)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ansmaker = \"\"\\n        if numerator == 0:\\n            return \"0\"\\n        if numerator<0 and denominator<0:\\n            numerator = -1*numerator\\n            denominator = -1*denominator\\n        elif numerator<0 and denominator>=0:\\n            numerator = -1*numerator\\n            ansmaker= \"-\"\\n        elif numerator>=0 and denominator<0:\\n            denominator = -1* denominator\\n            ansmaker = \"-\"\\n        dict1 = {}\\n        q = numerator//denominator\\n        r = numerator%denominator\\n        # print(q,r)\\n        if r == 0:\\n            return(ansmaker + str(q))\\n        else:\\n            ans = ansmaker+ str(q) + \".\"\\n        while True:\\n            if r == 0:\\n                return ans\\n            if r in dict1:\\n                sl = dict1[r]\\n                ans = ans[:sl] + \"(\" + ans[sl:] + \")\"\\n                return ans\\n            dict1[r] = len(ans)\\n            r = r*10\\n            q = r//denominator\\n            r = r%denominator\\n            ans = ans+str(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856027,
                "title": "java-convert-to-long",
                "content": "Double is not precise enough to be used for this question, so we will have to resort to elementary school math division. \\n\\nTo handle annoying edge cases, just convert it to long before we do anything.\\n\\n```Java\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) {\\n        long x = Math.abs(n*1L), y = Math.abs(d*1L);\\n        StringBuilder sb = new StringBuilder();\\n        if (n < 0 && d > 0 || n > 0 && d < 0){\\n            sb.append(\\'-\\'); // append \\'-\\' if one of n or d is negative.\\n        }\\n\\n        Map<Long, Integer> map = new HashMap<>();\\n        sb.append(x / y);\\n        x %= y;\\n        if (x > 0){ // only append \\'.\\' when we have reminder.\\n            sb.append(\\'.\\');\\n        }\\n        while(!map.containsKey(x)){ // keep doing division until we find a cycle\\n            map.put(x, map.size());\\n            x *= 10;\\n            if (x > 0){\\n                sb.append(x / y);\\n            }\\n            x %= y;\\n        }\\n\\n        if (x > 0){ // only append \\'()\\' when there is a cycle.\\n            sb.insert(sb.length() - (map.size() - map.get(x)), \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) {\\n        long x = Math.abs(n*1L), y = Math.abs(d*1L);\\n        StringBuilder sb = new StringBuilder();\\n        if (n < 0 && d > 0 || n > 0 && d < 0){\\n            sb.append(\\'-\\'); // append \\'-\\' if one of n or d is negative.\\n        }\\n\\n        Map<Long, Integer> map = new HashMap<>();\\n        sb.append(x / y);\\n        x %= y;\\n        if (x > 0){ // only append \\'.\\' when we have reminder.\\n            sb.append(\\'.\\');\\n        }\\n        while(!map.containsKey(x)){ // keep doing division until we find a cycle\\n            map.put(x, map.size());\\n            x *= 10;\\n            if (x > 0){\\n                sb.append(x / y);\\n            }\\n            x %= y;\\n        }\\n\\n        if (x > 0){ // only append \\'()\\' when there is a cycle.\\n            sb.insert(sb.length() - (map.size() - map.get(x)), \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774976,
                "title": "fraction-to-recurring-decimal-solution-java",
                "content": "class Solution {\\n  public String fractionToDecimal(int numerator, int denominator) {\\n    if (numerator == 0)\\n      return \"0\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    if (numerator < 0 ^ denominator < 0)\\n      sb.append(\"-\");\\n\\n    long n = Math.abs((long) numerator);\\n    long d = Math.abs((long) denominator);\\n    sb.append(n / d);\\n\\n    if (n % d == 0)\\n      return sb.toString();\\n\\n    sb.append(\".\");\\n    Map<Long, Integer> seen = new HashMap<>();\\n\\n    for (long r = n % d; r > 0; r %= d) {\\n      if (seen.containsKey(r)) {\\n        sb.insert(seen.get(r), \"(\");\\n        sb.append(\")\");\\n        break;\\n      }\\n      seen.put(r, sb.length());\\n      r *= 10;\\n      sb.append(r / d);\\n    }\\n\\n    return sb.toString();\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public String fractionToDecimal(int numerator, int denominator) {\\n    if (numerator == 0)\\n      return \"0\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    if (numerator < 0 ^ denominator < 0)\\n      sb.append(\"-\");\\n\\n    long n = Math.abs((long) numerator);\\n    long d = Math.abs((long) denominator);\\n    sb.append(n / d);\\n\\n    if (n % d == 0)\\n      return sb.toString();\\n\\n    sb.append(\".\");\\n    Map<Long, Integer> seen = new HashMap<>();\\n\\n    for (long r = n % d; r > 0; r %= d) {\\n      if (seen.containsKey(r)) {\\n        sb.insert(seen.get(r), \"(\");\\n        sb.append(\")\");\\n        break;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1744021,
                "title": "python-beginner-with-explanation",
                "content": "1. We get if the sign of answer we will return. if sign is true final answer will be positive else negative\\n2. then we do integer division of the given numerator with the given denominator \\n3. if the remainder is zero we return the answer using the sign we calculated\\n4. if remainder is not zero we append \".\" to the ans array and then keep trach of the remainder we will get each time we divide the coming remainder in a hashmap with the value of the place where we will need to insert the \"(\". \\n5. if we find such remainder value repeat we insert \"(\" at the required index and append \")\" at the last of the array and then return thr answer according to the sign we calculated\\nUPVOTE IF HELPFUL\\n```\\ndef fractionToDecimal(self, num: int, den: int) -> str:\\n        ans = []\\n        \\n        if (num >= 0 and den >= 0) or (num <= 0 and den <= 0):\\n            sign = True\\n        else:\\n            sign = False\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        q = num // den\\n        r = num % den\\n        \\n        ans.append(q)\\n\\n        if r == 0:\\n            return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n        else:\\n            ans.append(\".\")\\n            map1 = {}\\n            while r != 0:\\n                if r in map1:\\n                    ans.insert(map1[r], \"(\")\\n                    ans.append(\")\")\\n                    break\\n                else:\\n                    map1[r] = len(ans)\\n                    r *= 10\\n                    q = r // den\\n                    r %= den\\n                    ans.append(q)\\n        \\n        \\n        return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef fractionToDecimal(self, num: int, den: int) -> str:\\n        ans = []\\n        \\n        if (num >= 0 and den >= 0) or (num <= 0 and den <= 0):\\n            sign = True\\n        else:\\n            sign = False\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        q = num // den\\n        r = num % den\\n        \\n        ans.append(q)\\n\\n        if r == 0:\\n            return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n        else:\\n            ans.append(\".\")\\n            map1 = {}\\n            while r != 0:\\n                if r in map1:\\n                    ans.insert(map1[r], \"(\")\\n                    ans.append(\")\")\\n                    break\\n                else:\\n                    map1[r] = len(ans)\\n                    r *= 10\\n                    q = r // den\\n                    r %= den\\n                    ans.append(q)\\n        \\n        \\n        return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1535423,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        sign = bool(numerator > 0) ^ bool(denominator > 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = (\"-\" if sign else \"\") + str(numerator//denominator)\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return res\\n\\n        res += \".\"\\n        pos = {}\\n        while remainder != 0:\\n            if remainder not in pos:\\n                pos[remainder] = len(res)\\n            else:\\n                res = res[:pos[remainder]] + \"(\" + res[pos[remainder]:] + \")\"\\n                return res\\n                \\n            res += str(remainder * 10 // denominator)\\n            remainder = (remainder * 10) % denominator\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        sign = bool(numerator > 0) ^ bool(denominator > 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = (\"-\" if sign else \"\") + str(numerator//denominator)\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return res\\n\\n        res += \".\"\\n        pos = {}\\n        while remainder != 0:\\n            if remainder not in pos:\\n                pos[remainder] = len(res)\\n            else:\\n                res = res[:pos[remainder]] + \"(\" + res[pos[remainder]:] + \")\"\\n                return res\\n                \\n            res += str(remainder * 10 // denominator)\\n            remainder = (remainder * 10) % denominator\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401382,
                "title": "js-using-hashmap-with-explanation-in-the-comments",
                "content": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(numerator === 0) {\\n        return \\'0\\';\\n    }\\n\\t// check if the result should be negative or not\\n    const isNeg = (numerator < 0 && denominator > 0) || (denominator < 0 && numerator > 0);\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n\\n\\t// this map will keep note of all the remainders occurences,\\n\\t// if a remainder appears again, that will repeat the same pattern\\n    const remaindersMap = new Map();\\n\\n\\t// add the negative sign to result if applicable\\n    let result = isNeg ? \\'-\\' : \\'\\';\\n    let quotient = numerator / denominator,\\n        remainder = numerator % denominator;\\n\\n\\t// add the quotient to the result -\\n\\t// if num > deno the it will be a positive integer, else it will be 0\\n    result += Math.floor(quotient);\\n\\t\\n\\t// if remainder is 0, that means the num is entirely divisible by deno, so we can return the result\\n    if(remainder === 0) {\\n        return result;\\n    } else {\\n\\t\\t// else there will be a floating value, so we add decimal to the resultant string\\n\\t\\t// set num to remainder\\n\\t\\t// add the remainder to map to check if it reappears\\n        result += \\'.\\';\\n        numerator = remainder;\\n        remaindersMap.set(remainder, 0);\\n    }\\n\\t// handling the floating point separately, `decimalStr` will store that string\\n\\t// `patternStartIdx` - to keep note of the index from where pattern will start\\n    let decimalStr = \\'\\',\\n        patternStartIdx = -1;\\n\\t\\t\\n\\t// 2 conditions for getting out of the loop\\n\\t// num > 0 - when num === 0 that means num is divisible by deno\\n\\t// patternStartIdx === -1 - it will change when a pattern  is found\\n    while(numerator > 0 && patternStartIdx === -1) {\\n        numerator *= 10;    // numerator < denominator\\n        \\n        quotient = numerator / denominator;\\n        remainder = numerator % denominator;\\n        \\n\\t\\t// add the quotient to the decimalStr\\n        decimalStr += Math.floor(quotient);\\n\\t\\t\\n\\t\\t// if remainder is reoccuring => pattern found\\n        if(remaindersMap.has(remainder)) {\\n\\t\\t\\t// get the start index from where the pattern begin - it will be the index the remainder had previous occured\\n\\t\\t\\t// we get the value and break from the loop\\n            patternStartIdx = remaindersMap.get(remainder);\\n            break;\\n        }\\n\\t\\t// else add the remainder to the map with index as `decimalStr.length`\\n\\t\\t// and set num as the remainder for next iteration\\n        remaindersMap.set(remainder, decimalStr.length);\\n        numerator = remainder;\\n    }\\n\\t// if pattern is found, add the decimal string along with brackets around the repeating pattern\\n\\t// else simply add the decimalStr\\n    if(patternStartIdx !== -1) {\\n        result += decimalStr.substring(0, patternStartIdx);\\n        result += \\'(\\' + decimalStr.substring(patternStartIdx) + \\')\\';    \\n    } else {\\n        result += decimalStr;\\n    }\\n    return result;\\n}\\n```\\nTime Complexity = O(denominator)\\nSpace Complexity = O(denominator)\\n\\nThe range of remainder can be from [0, denominator - 1]\\nWe loop till remainder reoccurs, max it can check for each remainder and we are storing remainder values in a map.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(numerator === 0) {\\n        return \\'0\\';\\n    }\\n\\t// check if the result should be negative or not\\n    const isNeg = (numerator < 0 && denominator > 0) || (denominator < 0 && numerator > 0);\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n\\n\\t// this map will keep note of all the remainders occurences,\\n\\t// if a remainder appears again, that will repeat the same pattern\\n    const remaindersMap = new Map();\\n\\n\\t// add the negative sign to result if applicable\\n    let result = isNeg ? \\'-\\' : \\'\\';\\n    let quotient = numerator / denominator,\\n        remainder = numerator % denominator;\\n\\n\\t// add the quotient to the result -\\n\\t// if num > deno the it will be a positive integer, else it will be 0\\n    result += Math.floor(quotient);\\n\\t\\n\\t// if remainder is 0, that means the num is entirely divisible by deno, so we can return the result\\n    if(remainder === 0) {\\n        return result;\\n    } else {\\n\\t\\t// else there will be a floating value, so we add decimal to the resultant string\\n\\t\\t// set num to remainder\\n\\t\\t// add the remainder to map to check if it reappears\\n        result += \\'.\\';\\n        numerator = remainder;\\n        remaindersMap.set(remainder, 0);\\n    }\\n\\t// handling the floating point separately, `decimalStr` will store that string\\n\\t// `patternStartIdx` - to keep note of the index from where pattern will start\\n    let decimalStr = \\'\\',\\n        patternStartIdx = -1;\\n\\t\\t\\n\\t// 2 conditions for getting out of the loop\\n\\t// num > 0 - when num === 0 that means num is divisible by deno\\n\\t// patternStartIdx === -1 - it will change when a pattern  is found\\n    while(numerator > 0 && patternStartIdx === -1) {\\n        numerator *= 10;    // numerator < denominator\\n        \\n        quotient = numerator / denominator;\\n        remainder = numerator % denominator;\\n        \\n\\t\\t// add the quotient to the decimalStr\\n        decimalStr += Math.floor(quotient);\\n\\t\\t\\n\\t\\t// if remainder is reoccuring => pattern found\\n        if(remaindersMap.has(remainder)) {\\n\\t\\t\\t// get the start index from where the pattern begin - it will be the index the remainder had previous occured\\n\\t\\t\\t// we get the value and break from the loop\\n            patternStartIdx = remaindersMap.get(remainder);\\n            break;\\n        }\\n\\t\\t// else add the remainder to the map with index as `decimalStr.length`\\n\\t\\t// and set num as the remainder for next iteration\\n        remaindersMap.set(remainder, decimalStr.length);\\n        numerator = remainder;\\n    }\\n\\t// if pattern is found, add the decimal string along with brackets around the repeating pattern\\n\\t// else simply add the decimalStr\\n    if(patternStartIdx !== -1) {\\n        result += decimalStr.substring(0, patternStartIdx);\\n        result += \\'(\\' + decimalStr.substring(patternStartIdx) + \\')\\';    \\n    } else {\\n        result += decimalStr;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998707,
                "title": "python-solution-with-detail-explanation",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        if numerator % denominator == 0: \\n\\t\\t\\treturn str(numerator // denominator)\\n        \\n        prefix = \\'\\'\\n        if (numerator > 0) != (denominator > 0):\\n            prefix = \\'-\\'\\n        \\n        # Operation must be on positive values\\n        if numerator < 0:\\n            numerator = - numerator\\n        if denominator < 0:\\n            denominator = - denominator\\n\\n        digit, remainder = divmod(numerator, denominator)\\n            \\n        res = prefix + str(digit) + \\'.\\' # EVERYTHING BEFORE DECIMAL\\n        \\n        table = {}\\n        suffix = \\'\\'\\n        \\n        while remainder not in table.keys():\\n            \\n            # Store index of the reminder in the table\\n            table[remainder] = len(suffix)\\n            \\n            val, remainder = divmod(remainder*10, denominator)\\n            \\n            suffix += str(val)\\n            \\n            # No repeating\\n            if remainder == 0:\\n                return res + suffix\\n        \\n        indexOfRepeatingPart = table[remainder]\\n        \\n        decimalTillRepeatingPart = suffix[:indexOfRepeatingPart]\\n        \\n        repeatingPart = suffix[indexOfRepeatingPart:]\\n\\n        return res + decimalTillRepeatingPart + \\'(\\' + repeatingPart + \\')\\'\\n\\ns = Solution()\\n\\nprint(s.fractionToDecimal(2, 3))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        if numerator % denominator == 0: \\n\\t\\t\\treturn str(numerator // denominator)\\n        \\n        prefix = \\'\\'\\n        if (numerator > 0) != (denominator > 0):\\n            prefix = \\'-\\'\\n        \\n        # Operation must be on positive values\\n        if numerator < 0:\\n            numerator = - numerator\\n        if denominator < 0:\\n            denominator = - denominator\\n\\n        digit, remainder = divmod(numerator, denominator)\\n            \\n        res = prefix + str(digit) + \\'.\\' # EVERYTHING BEFORE DECIMAL\\n        \\n        table = {}",
                "codeTag": "Java"
            },
            {
                "id": 806380,
                "title": "scala",
                "content": "```\\nimport scala.math.Integral.Implicits._\\nimport scala.math._\\n\\nobject Solution {\\n  def fractionToDecimal(numerator: Int, denominator: Int): String = {\\n    val sign = if (signum(numerator) * signum(denominator) == -1) \"-\" else \"\"\\n    s\"${sign}${fractionToDecimal(abs(numerator.toLong), abs(denominator.toLong))}\"\\n  }\\n\\n  private def fractionToDecimal(numerator: Long, denominator: Long): String = {\\n    numerator /% denominator match {\\n      case (quot, 0)   => quot.toString\\n      case (quot, rem) => s\"${quot}.${generateFractional(rem, denominator)}\"\\n    }\\n  }\\n\\n  @scala.annotation.tailrec\\n  private def generateFractional(numerator: Long,\\n                                 denominator: Long,\\n                                 numeratorToIndex: Map[Long, Int] = Map(),\\n                                 fractional: String = \"\"): String = {\\n    numeratorToIndex.get(numerator) match {\\n      case Some(index) => s\"${fractional.substring(0, index)}(${fractional.substring(index)})\"\\n      case _           => 10 * numerator /% denominator match {\\n        case (quot, 0)   => fractional + quot\\n        case (quot, rem) => generateFractional(rem, denominator, numeratorToIndex + (numerator -> fractional.length),\\n                                               fractional + quot)\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\nimport scala.math.Integral.Implicits._\\nimport scala.math._\\n\\nobject Solution {\\n  def fractionToDecimal(numerator: Int, denominator: Int): String = {\\n    val sign = if (signum(numerator) * signum(denominator) == -1) \"-\" else \"\"\\n    s\"${sign}${fractionToDecimal(abs(numerator.toLong), abs(denominator.toLong))}\"\\n  }\\n\\n  private def fractionToDecimal(numerator: Long, denominator: Long): String = {\\n    numerator /% denominator match {\\n      case (quot, 0)   => quot.toString\\n      case (quot, rem) => s\"${quot}.${generateFractional(rem, denominator)}\"\\n    }\\n  }\\n\\n  @scala.annotation.tailrec\\n  private def generateFractional(numerator: Long,\\n                                 denominator: Long,\\n                                 numeratorToIndex: Map[Long, Int] = Map(),\\n                                 fractional: String = \"\"): String = {\\n    numeratorToIndex.get(numerator) match {\\n      case Some(index) => s\"${fractional.substring(0, index)}(${fractional.substring(index)})\"\\n      case _           => 10 * numerator /% denominator match {\\n        case (quot, 0)   => fractional + quot\\n        case (quot, rem) => generateFractional(rem, denominator, numeratorToIndex + (numerator -> fractional.length),\\n                                               fractional + quot)\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 696535,
                "title": "c-hashmaps-100-runtime",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        long long num = numerator;\\n        long long deno = denominator;\\n        if(num==0) return \"0\";\\n        bool isNeg = false;\\n        if(num<0 && deno<0){\\n            num=abs(num);\\n            deno=abs(deno);\\n        }\\n        else if(num<0) {\\n            isNeg = true;\\n            num = abs(num);\\n        }\\n        else if(deno<0) {\\n            isNeg = true;\\n            deno = abs(deno);\\n        }\\n        long long q = num/deno;\\n        string ans = to_string(q);\\n        long long rem = num%deno;\\n        if(rem==0) {\\n            if(isNeg) return \"-\"+ans;\\n            return ans;\\n        }\\n        unordered_map<int,int> m;\\n        m[rem]=0;\\n        int count = 1;\\n        string str = \"\";\\n        while(rem!=0) {\\n            rem = rem* 10;\\n            q = rem/deno;\\n            str+=to_string(q);\\n            rem=rem%deno;\\n            if(m.find(rem)!=m.end()){\\n                str = str.substr(0,m[rem]) + \"(\" + str.substr(m[rem]) + \")\";\\n                break;\\n            }\\n            m[rem]=count;\\n            count++;\\n        }\\n        if(isNeg) return \"-\"+ans+\".\"+str;\\n        return ans+\".\"+str;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        long long num = numerator;\\n        long long deno = denominator;\\n        if(num==0) return \"0\";\\n        bool isNeg = false;\\n        if(num<0 && deno<0){\\n            num=abs(num);\\n            deno=abs(deno);\\n        }\\n        else if(num<0) {\\n            isNeg = true;\\n            num = abs(num);\\n        }\\n        else if(deno<0) {\\n            isNeg = true;\\n            deno = abs(deno);\\n        }\\n        long long q = num/deno;\\n        string ans = to_string(q);\\n        long long rem = num%deno;\\n        if(rem==0) {\\n            if(isNeg) return \"-\"+ans;\\n            return ans;\\n        }\\n        unordered_map<int,int> m;\\n        m[rem]=0;\\n        int count = 1;\\n        string str = \"\";\\n        while(rem!=0) {\\n            rem = rem* 10;\\n            q = rem/deno;\\n            str+=to_string(q);\\n            rem=rem%deno;\\n            if(m.find(rem)!=m.end()){\\n                str = str.substr(0,m[rem]) + \"(\" + str.substr(m[rem]) + \")\";\\n                break;\\n            }\\n            m[rem]=count;\\n            count++;\\n        }\\n        if(isNeg) return \"-\"+ans+\".\"+str;\\n        return ans+\".\"+str;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 489423,
                "title": "python3-very-clean-recursive-explained-solution",
                "content": "Let\\'s talk about how long division with decimals works. There\\'s no secret for this problem, it really is just the standard long division you learn when you\\'re 6 years old or whatever, unless you\\'re like me and day dreamed in your early days and learned it in college ;)\\n\\nBy the way, the `quotient` is the answer you get after completing division.\\n\\nIn general, the algorithm goes like this:\\n\\n```\\n\\t1. Perform a standard integer division with the numerator and denominator. \\n\\t2. If there is a remainder, we are now entering the realm of decimal division. Else, we are done and you can return your quotient.\\n\\t3. Assuming a remainder, while there exists a remainder, multiply it by 10 and perform long division, then set the remainder to the new remainder after the division.\\n\\t   Keep appending your quotients to your final answer\\n```\\n\\nOk, simple right! Knowing how to do this by hand is just these steps. It gets more complicated when dealing with a computer, though. Sometimes with the decimal division algorithm, you get caught in a cycle. This is where the problem really gets interesting. Consider the following division, `4/300`.\\n\\n```\\nnumerator = 4, denominator = 333\\n\\n4/333 = 0, r 4, final answer = 0\\n\\nlet numerator = 4*10 = 40\\n\\nnumerator = 40, denominator = 333\\n\\n40/333 = 0, r 40, final answer = 0.0\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012\\n\\nlet numerator = 4*10 = 40 (*PAY ATTENTION NOW!!)\\n\\n40/333 = 0 r 40, final answer = 0.0120\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01201\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012012\\n\\nlet numerator = 4*10 = 40 \\n\\n40/300 = 0 r 40, final answer = 0.0120120\\n\\nlet numerator = 40*10 .........\\n\\nyou get the point\\n........\\n```\\n\\nBasically, we\\'re caught in a cycle. Decimal division is crude, and if you happen to get an irrational number from your division, you have a cycle in your division. So, the question wants you to observe this, and it wants you to wrap your cycle around with (`CYCLE HERE`). This is where the problem earns it\\'s worth. How do we, *find* and ***identify*** the cycle? Generally speaking, just knowing there\\'s a cycle is easy to detect, but being able to do something like pinpoint what/ where the cycle is, with these problems, is the difficult part (e.g., the critical connections problem).\\n\\nThe answer is what it always is, ***memoization***. Each time in your long division part, you see a new numerator, record it and where you first saw it. As demonstrated in the example above, if you run into the same numerator twice, you will start repeating the exact same sequence of numbers each time. If you happen to remember where that numerator took place in your current sequence, you could intervene and just wrap the start point and end point with a pair of parenthesis, and get your answer. In our example above, we would stop right where we saw the 40, and wrap the first occurance of it all the way to the end of our recorded sequence, and terminate the algorithm. So, we would\\'ve had the [\\'0\\',\\'1\\',\\'2\\'] sequence, then we see the 40 again, and intervene our sequence to be [\\'(0\\', \\'1\\', \\'2)\\'], and break out.\\n\\nThe reason I adore recursion for this problem, even though it\\'s not necesarry is because for one, it\\'s short, clear, and simple. Two, we are essentially treating this as a graph problem searching for a cycle. What do we do with most graph problems? DFS :D\\n\\n***NOTICE***:\\nBy the way, most examples you\\'ll see will have something like 5.13434134 == 5.(134), but it\\'s possible to have something like 4.232112316767676767 == 4.23211231(67). The cycle might not just happen when the decimal part starts. Also, negative numbers are a thing. The simple way to handle them like always is to just convert them into positives, and make the final answer negative if we have one of them is positive and the other negative.\\n\\nSo, here is our final algorithm:\\n\\n```\\n1. Convert the numbers to be positive, if they\\'re negative. Record if the division would\\'ve resulted in negative numbers or not.\\n2. Record the integer part of the division. If there is no remainder, jump to step 4, otherwise, begin the recording of a new sequence. Set the numerator equal to remainder * 10.\\n3. While the numerator is not zero and not seen before, perform long division. Mark this numerator as a numerator we\\'ve seen before in a hash table; memorizing the index we found it first. After each division, add the result to our new sequence, and perform long division again (i.e, repeat this step recursively) setting our new numerator to be the remainder of the division we just did multiplied by 10.\\nIf we end up seeing the same numerator, in our sequence, add a \\'(\\' on the index which corresponds to the numerator we\\'ve seen before, and the end of our sequence, also add a \\')\\' to that element\\n4. Join the integer part with the decimal part, if any.\\n5. Convert the result of 4. to a negative number by prepending a - in the front if we discovered at step 0 the result is supposed to be negative\\n```\\n\\n\\nAnd here\\'s my code. \\n\\n***Disclaimer***: I know recursion is not optimal for this problem. If the test cases were extreme, and made it so a lot of steps were needed to complete the algorithm, it wouldn\\'t be able to finish because Python would suffer stack overflow. But, this is an interview question and the important part is to get a nice working clean solution. If you were in an interview and decided to roll with a recursive solution, let the interviewer know you\\'re aware with the price you pay for using recursion. This isn\\'t just exclusive to this problem, it\\'s actually a general reason why general recursion should be avoided whenever possible. This is a problem where it\\'s easily avoidable, but just very clean to use it. As far as time complexity goes, I\\'m not sure. It\\'s not something I\\'d really expect the interviewers to ask you about unless you\\'re a math person. It\\'s not just a log number or something, there are some very complicated theorems that probably go into finding that out. This is something that is studied in a number theory course, so the scope is pretty high. Just make sure you do your job as a programmer to keep the complexity to the number of steps the long divison with decimals would take, i.e, not recreating lists or reconverting your sequences at each step.\\n\\nIf you have any questions or I said something wrong in here, please feel free to ask/ discuss in comments :D\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        def longDivision(numerator, denominator, seen, quotient):\\n            if numerator == 0:\\n                return\\n            elif numerator in seen:\\n                quotient[seen[numerator]] = \\'(\\' + quotient[seen[numerator]]\\n                quotient[-1] = quotient[-1] + \\')\\'\\n                return\\n            \\n            seen[numerator] = len(quotient)\\n            quotient.append(str(numerator//denominator))\\n            longDivision(numerator%denominator * 10, denominator, seen, quotient)\\n        \\n        #preprocess. Make negative positive.\\n        isNegative = (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        #extract the integer portion of the quotient\\n        integerPart = str(numerator//denominator)\\n        \\n        #prepare, and perform longdevision on remiander*10, if any\\n        seen = {}\\n        decimalPart = []\\n        longDivision(numerator%denominator * 10, denominator, seen, decimalPart)\\n        \\n        #merge the integer part with the decimal part, if decimal exists\\n        decimalPart = \\'.\\' + \\'\\'.join(decimalPart) if decimalPart else \\'\\'\\n        quotient = integerPart + decimalPart\\n        \\n        return quotient if not isNegative else \\'-\\' + quotient\\n```",
                "solutionTags": [],
                "code": "```\\n\\t1. Perform a standard integer division with the numerator and denominator. \\n\\t2. If there is a remainder, we are now entering the realm of decimal division. Else, we are done and you can return your quotient.\\n\\t3. Assuming a remainder, while there exists a remainder, multiply it by 10 and perform long division, then set the remainder to the new remainder after the division.\\n\\t   Keep appending your quotients to your final answer\\n```\n```\\nnumerator = 4, denominator = 333\\n\\n4/333 = 0, r 4, final answer = 0\\n\\nlet numerator = 4*10 = 40\\n\\nnumerator = 40, denominator = 333\\n\\n40/333 = 0, r 40, final answer = 0.0\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012\\n\\nlet numerator = 4*10 = 40 (*PAY ATTENTION NOW!!)\\n\\n40/333 = 0 r 40, final answer = 0.0120\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01201\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012012\\n\\nlet numerator = 4*10 = 40 \\n\\n40/300 = 0 r 40, final answer = 0.0120120\\n\\nlet numerator = 40*10 .........\\n\\nyou get the point\\n........\\n```\n```\\n1. Convert the numbers to be positive, if they\\'re negative. Record if the division would\\'ve resulted in negative numbers or not.\\n2. Record the integer part of the division. If there is no remainder, jump to step 4, otherwise, begin the recording of a new sequence. Set the numerator equal to remainder * 10.\\n3. While the numerator is not zero and not seen before, perform long division. Mark this numerator as a numerator we\\'ve seen before in a hash table; memorizing the index we found it first. After each division, add the result to our new sequence, and perform long division again (i.e, repeat this step recursively) setting our new numerator to be the remainder of the division we just did multiplied by 10.\\nIf we end up seeing the same numerator, in our sequence, add a \\'(\\' on the index which corresponds to the numerator we\\'ve seen before, and the end of our sequence, also add a \\')\\' to that element\\n4. Join the integer part with the decimal part, if any.\\n5. Convert the result of 4. to a negative number by prepending a - in the front if we discovered at step 0 the result is supposed to be negative\\n```\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        def longDivision(numerator, denominator, seen, quotient):\\n            if numerator == 0:\\n                return\\n            elif numerator in seen:\\n                quotient[seen[numerator]] = \\'(\\' + quotient[seen[numerator]]\\n                quotient[-1] = quotient[-1] + \\')\\'\\n                return\\n            \\n            seen[numerator] = len(quotient)\\n            quotient.append(str(numerator//denominator))\\n            longDivision(numerator%denominator * 10, denominator, seen, quotient)\\n        \\n        #preprocess. Make negative positive.\\n        isNegative = (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        #extract the integer portion of the quotient\\n        integerPart = str(numerator//denominator)\\n        \\n        #prepare, and perform longdevision on remiander*10, if any\\n        seen = {}\\n        decimalPart = []\\n        longDivision(numerator%denominator * 10, denominator, seen, decimalPart)\\n        \\n        #merge the integer part with the decimal part, if decimal exists\\n        decimalPart = \\'.\\' + \\'\\'.join(decimalPart) if decimalPart else \\'\\'\\n        quotient = integerPart + decimalPart\\n        \\n        return quotient if not isNegative else \\'-\\' + quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382877,
                "title": "straightforward-python-long-division-solution",
                "content": "```\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if denominator < 0:\\n            denominator *= -1\\n            numerator *= -1\\n        sign = 1\\n        if numerator < 0:\\n            sign = -1\\n            numerator *= -1\\n        inte = (\\'-\\' if sign == -1 else \\'\\') + str(numerator // denominator)\\n        rem = numerator % denominator\\n        frac, mp, i = [], dict(), 0\\n        while rem != 0 and rem not in mp:\\n            mp[rem] = i\\n            i += 1\\n            rem *= 10\\n            frac.append(str(rem // denominator))\\n            rem %= denominator\\n        if rem == 0:\\n            if frac == []:\\n                return inte\\n            else:\\n                return inte + \\'.\\' + \\'\\'.join(frac)\\n        else:\\n            j = mp[rem]\\n            return inte + \\'.\\' + \\'\\'.join(frac[:j]) + \\'(\\' + \\'\\'.join(frac[j:]) + \\')\\'\\n```",
                "solutionTags": [],
                "code": "```\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if denominator < 0:\\n            denominator *= -1\\n            numerator *= -1\\n        sign = 1\\n        if numerator < 0:\\n            sign = -1\\n            numerator *= -1\\n        inte = (\\'-\\' if sign == -1 else \\'\\') + str(numerator // denominator)\\n        rem = numerator % denominator\\n        frac, mp, i = [], dict(), 0\\n        while rem != 0 and rem not in mp:\\n            mp[rem] = i\\n            i += 1\\n            rem *= 10\\n            frac.append(str(rem // denominator))\\n            rem %= denominator\\n        if rem == 0:\\n            if frac == []:\\n                return inte\\n            else:\\n                return inte + \\'.\\' + \\'\\'.join(frac)\\n        else:\\n            j = mp[rem]\\n            return inte + \\'.\\' + \\'\\'.join(frac[:j]) + \\'(\\' + \\'\\'.join(frac[j:]) + \\')\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359183,
                "title": "javascript-solution-best-time-here-best-solution",
                "content": "**If you don\\'t have a rought idea or understand the code below, please check out tadasant\\'s post for explanation by searching tadasant in discuss section.**\\n\\nThis post is for people who love to use {} instead of new Map() when needing a map like me.\\n\\nRecently after reading this article: https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373 , I decided to do a performance test myself on this problem.\\n \\nSince leetcode has smaller amount of test cases, the run time beat % does not always mean the solution is optimal, you still have to think about run time complexity of your solution + any builtin function you used and data structure optimization.\\n\\n**NOTE:**\\nI\\'m new to performance testing and only did it on http://jsben.ch/ on chrome, please comment if you got something to offer or correct about my post.\\n\\n## Tests\\n**On LeetCode:** my solution with map was slower than obj with 37 test cases.\\n**On JSBEN: *code block 1* being obj {}, *code block 2* being new Map(), tests are [[nominator,denominator]......]**\\n\\n**1 test case [2,1] run 2000 times:** obj is only faster sometimes than map and not by much\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565868374.png)\\n\\nWith more tests cases it becomes apparent.\\n\\n\\n**[[1,2],[2,1],[1,998001],[-2147483648,1]] run 2000 times**\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565868996.png)\\n\\nLastly, to add more random test cases and at the same time not make the tab stop responding. I used the snippet here to generate 1 random test case and push it in.\\n```\\n//This block gets run 2000 times, to not explode I add onl 1 random element at the end.\\nconst tests = [[1,2],[2,1],[1,998001],[-2147483648,1]];\\n\\n\\nconst INT_MAX = Math.pow(2,32) - 1;\\nconst INT_MIN = -Math.pow(2,32);\\nconst range = INT_MAX-INT_MIN;\\ntests.push(Math.floor(Math.random()*(range)+INT_MIN),\\n           Math.floor(Math.random()*(range)+INT_MIN));\\n```\\n**[[1,2],[2,1],[1,998001],[-2147483648,1],[?,?]] run 2000 times**\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565869329.png)\\nWe can see map just beats object always. **Therefore use new Map() when you are using maps!** \\n\\nFor details of my code on JSBEN: http://jsben.ch/YeH2E , there are also plenty of map vs object tests on JSBEN you can search up and see for yourself of the getters and setters. Map is an object, but object is not a map.\\n\\n## Solution\\n```\\nconst fractionToDecimal = (numerator, denominator) => {\\n    if(numerator === 0) return \"0\";\\n    if(denominator === 0) return numerator < 0 ? Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;\\n    \\n    let res = \"\";\\n    \\n    //Check result sign\\n    if(Math.sign(numerator) !== Math.sign(denominator)) res += \"-\";\\n    \\n    let n = Math.abs(numerator);\\n    const d = Math.abs(denominator);\\n    \\n    //don\\'t use n/d | 0 to floor since js bitwise operation is based on 32 bits\\n    //and large positive num could cause sign bit to flip into a neg num or overflow\\n    res += Math.floor(n/d); \\n    n = n%d;\\n    \\n    if(n === 0) return res;\\n    \\n    res += \".\";\\n    \\n    //key for remainder, value for pattern start index\\n    let map = new Map();   // USE MAP\\n    \\n    //we can use res.length as index since it keeps track of the growth\\n    //alwasy being the next index to insert so we don\\'t need another variable!\\n    while(n !== 0){\\n        //keep track of remainders\\n        map.set(n,res.length);\\n        \\n        n *= 10;\\n        res += Math.floor(n/d); //add quotient digit to the res.length index\\n        n %= d;\\n    \\n        if(map.has(n))\\n            return `${res.substring(0,map.get(n))}(${res.substr(map.get(n))})`;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//This block gets run 2000 times, to not explode I add onl 1 random element at the end.\\nconst tests = [[1,2],[2,1],[1,998001],[-2147483648,1]];\\n\\n\\nconst INT_MAX = Math.pow(2,32) - 1;\\nconst INT_MIN = -Math.pow(2,32);\\nconst range = INT_MAX-INT_MIN;\\ntests.push(Math.floor(Math.random()*(range)+INT_MIN),\\n           Math.floor(Math.random()*(range)+INT_MIN));\\n```\n```\\nconst fractionToDecimal = (numerator, denominator) => {\\n    if(numerator === 0) return \"0\";\\n    if(denominator === 0) return numerator < 0 ? Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;\\n    \\n    let res = \"\";\\n    \\n    //Check result sign\\n    if(Math.sign(numerator) !== Math.sign(denominator)) res += \"-\";\\n    \\n    let n = Math.abs(numerator);\\n    const d = Math.abs(denominator);\\n    \\n    //don\\'t use n/d | 0 to floor since js bitwise operation is based on 32 bits\\n    //and large positive num could cause sign bit to flip into a neg num or overflow\\n    res += Math.floor(n/d); \\n    n = n%d;\\n    \\n    if(n === 0) return res;\\n    \\n    res += \".\";\\n    \\n    //key for remainder, value for pattern start index\\n    let map = new Map();   // USE MAP\\n    \\n    //we can use res.length as index since it keeps track of the growth\\n    //alwasy being the next index to insert so we don\\'t need another variable!\\n    while(n !== 0){\\n        //keep track of remainders\\n        map.set(n,res.length);\\n        \\n        n *= 10;\\n        res += Math.floor(n/d); //add quotient digit to the res.length index\\n        n %= d;\\n    \\n        if(map.has(n))\\n            return `${res.substring(0,map.get(n))}(${res.substr(map.get(n))})`;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208050,
                "title": "java-solution-20-lines",
                "content": "```\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n        long a = numerator, b = denominator, m = a % b;  //a\\u5206\\u5B50,b\\u5206\\u6BCD,m\\u4F59\\u6570\\n        Map<Long, Integer> map = new HashMap<>();\\n        if (m == 0)\\n            return a / b + \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if (a * b < 0)\\n            sb.append(\\'-\\');\\n        a = Math.abs(a);\\n        b = Math.abs(b);\\n        sb.append(a / b).append(\\'.\\');\\n        m = a % b;\\n        map.put(m, sb.length());\\n        while (m != 0) {\\n            a = m * 10;\\n            sb.append(a / b);\\n            m = a % b;\\n            if (map.containsKey(m))\\n                return sb.insert((int) map.get(m), \\'(\\').append(\\')\\').toString();\\n            map.put(m, sb.length());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n        long a = numerator, b = denominator, m = a % b;  //a\\u5206\\u5B50,b\\u5206\\u6BCD,m\\u4F59\\u6570\\n        Map<Long, Integer> map = new HashMap<>();\\n        if (m == 0)\\n            return a / b + \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if (a * b < 0)\\n            sb.append(\\'-\\');\\n        a = Math.abs(a);\\n        b = Math.abs(b);\\n        sb.append(a / b).append(\\'.\\');\\n        m = a % b;\\n        map.put(m, sb.length());\\n        while (m != 0) {\\n            a = m * 10;\\n            sb.append(a / b);\\n            m = a % b;\\n            if (map.containsKey(m))\\n                return sb.insert((int) map.get(m), \\'(\\').append(\\')\\').toString();\\n            map.put(m, sb.length());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205217,
                "title": "c-0-ms-with-example-explanation-complexity-discussion",
                "content": "Let\\'s divide the problem to two sections.\\n1. Calculating the decimal value \\n2. Calculating the fractional value.\\n \\n* Calculating the decimal value:\\nThis one is straight forward; we can get the decimal value by a single division operation and store it to a string variable.\\nIf the numerator is divisible to denumerator, then we are done and need to return the string value of the division result \\nFor example if we have   numerator =84 and denumerator =7 then we should return \"12\"\\n\\n* Calculating the fractional value:\\n This step could be tricky.\\n Here is an example to refresh your mind for division algorithm.\\n \\n 1 / 7 : 1/7 = 0 , 1%7 =1  => 1/7 = 0. **X**  \\n to find the value of **X** we need to multiply the remainder by 10 and then repeat the division like\\n 1\\\\*10 =10 then 10/ 7 : 10/7 =1 , 10%7 =3  => 1/7 = 0.1**X**\\n 3\\\\*10 =30 then 30/ 7 : 30/7 =4 , 30%7 =2  => 1/7 = 0.14**X**\\n 2\\\\*10 =20 then 20/ 7 : 20/7 =2 , 20%7 =6  => 1/7 = 0.142**X**\\n 6\\\\*10 =60 then 60/ 7 : 60/7 =8 , 60%7 =4  => 1/7 = 0.1428**X**\\n 4\\\\*10 =40 then 40/ 7 : 40/7 =5 , 40%7 =5  => 1/7 = 0.14285**X**\\n \\n 5*10 =50 then 50/ 7 ~ 50/7 =7 , 50%7 =1  => 1/7 = 0.142857   , at this stage you can see that we are reaching a same number we have already calculated. So we need to report like 1/ 7  ~ 0.(142857)\\n \\nThe idea to implement the elaborated example is here:\\nwe can keep track of each generated remainder in a hash as a key of hash. The value of the hash can be the location of them in generated string. For example in the given example we have the following values for the hash:\\n\\nkey   val\\n1        0\\n3        1\\n2        2\\n6        3\\n4        4\\n5        6\\n\\nSo, to finalize it we can insert the \"(\" at the position of previously visited h[val] and add the \")\" to the end of string\\n \\nOne more important point needs to be noticed is about the sign. To handle it we can decide about the sign at very beginning and add the \"-\" to the result if needed (when only one of the operators is negative) , then do the rest of algorithm by updating the input parameters with their absolutes values.\\n\\n \\n#  Complexity\\n*  The interesting or follow up question could be about the time complexity of this algorithm.\\n\\t*  Memory complexity:  for this approach is O(denominator), the reason is that we are hashing the remainder values, so the maximum required hash location is denominator-1.\\n\\t\\n\\t*  Time complexity:  Similarly the maximum division operation we need to do is equal to denominator, the readson is that the remainder can be any number from [0,denominator-1]. So we can say the time complexity of the algoritm is also O(denominator)\\n  \\n\\n```\\nstring fractionToDecimal(int num1, int num2) {\\n  string res =\"\";    \\n  if (num1==0) return \"0\";\\n  if (num2==0) return \"NaN\";  \\n  long int n1 = num1;\\n  long int n2 = num2;\\n  if (n1>0 ^ n2>0) res+=\\'-\\';\\n  n1 = abs(n1);\\n  n2 = abs (n2);\\n  res += to_string(n1/n2);  \\n  if (n1%n2==0)\\n      return res;\\n  res+=\\'.\\';   \\n  map <int, int> h;\\n  n1 = n1 %n2;\\n  n1*=10;\\n  int idx=0;\\n  string frac = \"\"; \\n  while (n1!= 0 )  {\\n      if (h.find(n1)!=h.end()) {\\n          frac.insert(h[n1], \"(\");\\n          frac.append(\")\");\\n          break;\\n      }\\n      frac+= to_string(n1/n2);     \\n      h[n1] = idx;  \\n      n1 = n1 %n2;\\n      n1*=10;\\n      idx++;\\n  }\\n  res+=frac;\\n  return res;    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstring fractionToDecimal(int num1, int num2) {\\n  string res =\"\";    \\n  if (num1==0) return \"0\";\\n  if (num2==0) return \"NaN\";  \\n  long int n1 = num1;\\n  long int n2 = num2;\\n  if (n1>0 ^ n2>0) res+=\\'-\\';\\n  n1 = abs(n1);\\n  n2 = abs (n2);\\n  res += to_string(n1/n2);  \\n  if (n1%n2==0)\\n      return res;\\n  res+=\\'.\\';   \\n  map <int, int> h;\\n  n1 = n1 %n2;\\n  n1*=10;\\n  int idx=0;\\n  string frac = \"\"; \\n  while (n1!= 0 )  {\\n      if (h.find(n1)!=h.end()) {\\n          frac.insert(h[n1], \"(\");\\n          frac.append(\")\");\\n          break;\\n      }\\n      frac+= to_string(n1/n2);     \\n      h[n1] = idx;  \\n      n1 = n1 %n2;\\n      n1*=10;\\n      idx++;\\n  }\\n  res+=frac;\\n  return res;    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51134,
                "title": "simple-java-solution-with-explanation-for-all-key-points",
                "content": "```\\npublic String fractionToDecimal(int numerator, int denominator) {\\n        //1. Handle 3 special cases and return directly.\\n        //1) Zero divisor\\n        if (denominator == 0) return \"Error: 0 cannot be a denominator!\";\\n        //2) Zero dividend\\n        if (numerator == 0) return \"0\";\\n        //3) Exact division\\n        if (numerator % denominator == 0) return String.valueOf((long)numerator / (long)denominator);\\n        //NOTE: Convert to long before dividing to avoid overflow.\\n\\n        //2. Handle indivisible case\\n        StringBuilder sb = new StringBuilder();\\n\\n        //1) Add \"-\" sign for negative numbers\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        //NOTE: MUST convert int to long before abs() since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE.\\n\\n        if ( (long)numerator * (long)denominator < 0) sb.append(\"-\");\\n        //NOTE:\\n        // -- This is mandatory when num < den.\\n        // -- Convert to long before * to avoid overflow.\\n\\n        //2) Add integral part and \".\"\\n        sb.append(num / den).append(\".\");\\n        //NOTE: Use ABS() value to avoid double \"-\" sign when abs(num)>abs(den).\\n\\n        //3) Handle fraction part\\n        long remainder = num % den;\\n        Map<Long/*current reminder*/, Integer/* current stringBuilder.length()*/> map =\\n                new HashMap<Long, Integer>();\\n        //Assumption: a repeat remainder indicate a recursion of fraction.\\n        while (!map.containsKey(remainder)) {\\n            map.put(remainder, sb.length());\\n            sb.append(remainder * 10 / den);    //current fraction digit\\n            remainder = remainder * 10 % den;   //next reminder\\n        }\\n\\n        sb.insert(map.get(remainder), \"(\"); //Insert \"(\" before the start of recursion.\\n        sb.append(\")\"); //Append \")\" at the end.\\n        return sb.toString().replace(\"(0)\", \"\");    //Remove \"(0)\" when no recursion.\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String fractionToDecimal(int numerator, int denominator) {\\n        //1. Handle 3 special cases and return directly.\\n        //1) Zero divisor\\n        if (denominator == 0) return \"Error: 0 cannot be a denominator!\";\\n        //2) Zero dividend\\n        if (numerator == 0) return \"0\";\\n        //3) Exact division\\n        if (numerator % denominator == 0) return String.valueOf((long)numerator / (long)denominator);\\n        //NOTE: Convert to long before dividing to avoid overflow.\\n\\n        //2. Handle indivisible case\\n        StringBuilder sb = new StringBuilder();\\n\\n        //1) Add \"-\" sign for negative numbers\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        //NOTE: MUST convert int to long before abs() since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE.\\n\\n        if ( (long)numerator * (long)denominator < 0) sb.append(\"-\");\\n        //NOTE:\\n        // -- This is mandatory when num < den.\\n        // -- Convert to long before * to avoid overflow.\\n\\n        //2) Add integral part and \".\"\\n        sb.append(num / den).append(\".\");\\n        //NOTE: Use ABS() value to avoid double \"-\" sign when abs(num)>abs(den).\\n\\n        //3) Handle fraction part\\n        long remainder = num % den;\\n        Map<Long/*current reminder*/, Integer/* current stringBuilder.length()*/> map =\\n                new HashMap<Long, Integer>();\\n        //Assumption: a repeat remainder indicate a recursion of fraction.\\n        while (!map.containsKey(remainder)) {\\n            map.put(remainder, sb.length());\\n            sb.append(remainder * 10 / den);    //current fraction digit\\n            remainder = remainder * 10 % den;   //next reminder\\n        }\\n\\n        sb.insert(map.get(remainder), \"(\"); //Insert \"(\" before the start of recursion.\\n        sb.append(\")\"); //Append \")\" at the end.\\n        return sb.toString().replace(\"(0)\", \"\");    //Remove \"(0)\" when no recursion.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51180,
                "title": "simple-java-solution-using-hashmap-and-stringbuilder",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        long n=numerator;\\n\\t\\tlong d=denominator;\\n\\t\\tif(n==0)return \"0\";\\n        int sign=1;\\n        if(numerator<0){sign=-sign;n=-n;}\\n        if(denominator<0){sign=-sign;d=-d;}   \\n        \\n        StringBuilder sb=new StringBuilder();\\n        if(sign==-1)sb.append(\"-\");\\n        sb.append(n/d);\\n        n%=d;\\n        if(n==0)return sb.toString();\\n        sb.append(\".\");\\n        \\n        HashMap<Long,Integer>map=new HashMap();\\n        List<Long>list=new ArrayList();\\n        int index=0;\\n        while(n!=0&&!map.containsKey(n)){\\n            map.put(n,index++);\\n            n*=10;\\n            list.add(n/d);\\n            n%=d;\\n        }\\n        //Divide process finished\\n        if(n==0){ //No repeat\\n            for(int i=0;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            return sb.toString();\\n        }else{ //Has repeat\\n            int startIndex=map.get(n);    \\n            for(int i=0;i<startIndex;i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\"(\");\\n            for(int i=startIndex;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\")\");\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        long n=numerator;\\n\\t\\tlong d=denominator;\\n\\t\\tif(n==0)return \"0\";\\n        int sign=1;\\n        if(numerator<0){sign=-sign;n=-n;}\\n        if(denominator<0){sign=-sign;d=-d;}   \\n        \\n        StringBuilder sb=new StringBuilder();\\n        if(sign==-1)sb.append(\"-\");\\n        sb.append(n/d);\\n        n%=d;\\n        if(n==0)return sb.toString();\\n        sb.append(\".\");\\n        \\n        HashMap<Long,Integer>map=new HashMap();\\n        List<Long>list=new ArrayList();\\n        int index=0;\\n        while(n!=0&&!map.containsKey(n)){\\n            map.put(n,index++);\\n            n*=10;\\n            list.add(n/d);\\n            n%=d;\\n        }\\n        //Divide process finished\\n        if(n==0){ //No repeat\\n            for(int i=0;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            return sb.toString();\\n        }else{ //Has repeat\\n            int startIndex=map.get(n);    \\n            for(int i=0;i<startIndex;i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\"(\");\\n            for(int i=startIndex;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\")\");\\n            return sb.toString();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51196,
                "title": "clean-ruby-solution-with-comments-72-ms",
                "content": "    def fraction_to_decimal(n, d)\\n    \\n    \\t# Get +/-\\n    \\tresult = n*d >= 0 ? '' : '-'\\n    \\n    \\t# Get whole number\\n    \\tn = n.abs\\n    \\td = d.abs\\n    \\tresult << (n/d).to_s\\n    \\tn %= d\\n    \\n    \\t# Check whole number\\n    \\treturn result if n == 0\\n    \\n    \\t# Get decimal\\n    \\tresult << '.'\\n    \\tcheck = Hash.new\\n    \\n    \\t# Division\\n    \\twhile not n.zero? and check[n].nil?\\n    \\t\\tcheck[n] = result.length\\n    \\t\\tn *= 10\\n    \\t\\tresult << (n/d).to_s\\n    \\t\\tn %= d\\n    \\tend\\n    \\n    \\t# Check repeating\\n    \\tresult.insert(check[n], '(') << ')' if check[n]\\n    \\n    \\treturn result\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def fraction_to_decimal(n, d)\\n    \\n    \\t# Get +/-\\n    \\tresult = n*d >= 0 ? '' : '-'\\n    \\n    \\t# Get whole number\\n    \\tn = n.abs\\n    \\td = d.abs\\n    \\tresult << (n/d).to_s\\n    \\tn %= d\\n    \\n    \\t# Check whole number\\n    \\treturn result if n == 0\\n    \\n    \\t# Get decimal\\n    \\tresult << '.'\\n    \\tcheck = Hash.new\\n    \\n    \\t# Division\\n    \\twhile not n.zero? and check[n].nil?\\n    \\t\\tcheck[n] = result.length\\n    \\t\\tn *= 10\\n    \\t\\tresult << (n/d).to_s\\n    \\t\\tn %= d\\n    \\tend\\n    \\n    \\t# Check repeating\\n    \\tresult.insert(check[n], '(') << ')' if check[n]\\n    \\n    \\treturn result\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 51236,
                "title": "my-java-solution-with-explanation-second-version",
                "content": "my trick:\\n1. use long to avoid overflow<br>\\n2. use StringBuffer to build String<br>\\n3.use class pair to keep track of numerator and denominator,if I find the same pair in the map,it means the fractional part is repeating.<br>\\n4.  using `res=numeratorl/denominatorl;numeratorl=(numeratorl%denominatorl)*10;` to simulate division,`res` is the value to append to buffer.\\n\\n   \\n     public class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n\\t    \\t//to avoid overflow\\n\\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n\\t        StringBuffer buffer=new StringBuffer();\\n\\t        //handle negatives \\n\\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n\\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n\\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n\\t        //map,key:pair to hold numerator and denominator;value:position of numerator/denominator \\n\\t        HashMap<pair, Integer>map=new HashMap<>();\\n\\t        //handle integer part\\n\\t        long res=numeratorl/denominatorl;\\n\\t        numeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t\\tbuffer.append(res);\\n\\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n\\t\\t\\t//handle float part\\n\\t\\t\\twhile(numeratorl != 0){\\n\\t\\t\\t\\tres=numeratorl/denominatorl;\\n\\t\\t\\t\\tpair p=new pair(denominatorl,numeratorl);\\n\\t\\t\\t\\tif(map.get(p)!=null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//handle repaeting part\\n\\t\\t\\t\\t\\tbuffer.insert(map.get(p).intValue(), '(');\\n\\t\\t\\t\\t\\tbuffer.append(')');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(p, buffer.length());\\n\\t\\t\\t\\tnumeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t        buffer.append(res);\\n\\t\\t\\t}\\n\\t        return buffer.toString();\\n\\t    }\\n\\t    //this class is used to hold numerator and denominator,override hashcode\\\\equals\\n\\t    private static class pair{\\n\\t    \\tpublic long d;\\n\\t    \\tpublic long n;\\n\\t    \\tpublic pair(long d,long n) {\\n\\t    \\t\\tthis.d=d;this.n=n;\\n\\t\\t\\t}\\n\\t    \\t@Override\\n\\t    \\tpublic int hashCode() {\\n\\t    \\t\\treturn Arrays.hashCode(new long[]{d,n});\\n\\t    \\t}\\n\\t    \\t@Override\\n\\t    \\tpublic boolean equals(Object obj) {\\n\\t    \\t\\tpair p = (pair) obj;\\n\\t    \\t\\treturn p.d==d&&p.n==n;\\n\\t    \\t}\\n\\t     }\\n        }\\n\\nI make this problem complicated,because if numerator repeating,the fractional part is repeating.so class `pair` is not needed.I give my second version\\n \\n\\n    public class Solution {\\n    \\t    public String fractionToDecimal(int numerator, int denominator) {\\n    \\t    \\t//to avoid overflow\\n    \\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n    \\t        StringBuffer buffer=new StringBuffer();\\n    \\t        //handle negetives \\n    \\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n    \\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n    \\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n    \\t        //map,key:  numerator ,because denominator never changes;value:position of numerator/denominator \\n    \\t        HashMap<Long, Integer>map=new HashMap<>();\\n    \\t        //handle integer part\\n    \\t        long res=numeratorl/denominatorl;\\n    \\t        numeratorl=(numeratorl%denominatorl)*10;\\n    \\t\\t\\tbuffer.append(res);\\n    \\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n    \\t\\t\\t//handle flaot part\\n    \\t\\t\\twhile(numeratorl != 0){\\n    \\t\\t\\t\\tres=numeratorl/denominatorl;\\n    \\t\\t\\t\\tif(map.get(numeratorl)!=null)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t//handle repaeting part\\n    \\t\\t\\t\\t\\tbuffer.insert(map.get(numeratorl).intValue(), '(');\\n    \\t\\t\\t\\t\\tbuffer.append(')');\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tmap.put(numeratorl, buffer.length());\\n    \\t\\t\\t\\tnumeratorl=(numeratorl%denominatorl)*10;\\n    \\t\\t        buffer.append(res);\\n    \\t\\t\\t}\\n    \\t        return buffer.toString();\\n    \\t    }\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n\\t    \\t//to avoid overflow\\n\\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n\\t        StringBuffer buffer=new StringBuffer();\\n\\t        //handle negatives \\n\\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n\\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n\\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n\\t        //map,key:pair to hold numerator and denominator;value:position of numerator/denominator \\n\\t        HashMap<pair, Integer>map=new HashMap<>();\\n\\t        //handle integer part\\n\\t        long res=numeratorl/denominatorl;\\n\\t        numeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t\\tbuffer.append(res);\\n\\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n\\t\\t\\t//handle float part\\n\\t\\t\\twhile(numeratorl != 0){\\n\\t\\t\\t\\tres=numeratorl/denominatorl;\\n\\t\\t\\t\\tpair p=new pair(denominatorl,numeratorl);\\n\\t\\t\\t\\tif(map.get(p)!=null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//handle repaeting part\\n\\t\\t\\t\\t\\tbuffer.insert(map.get(p).intValue(), '(');\\n\\t\\t\\t\\t\\tbuffer.append(')');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3791144,
                "title": "easy-to-understand-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        long long a = labs(n), b = labs(d);\\n        string ans = \"\";\\n        if( (n < 0 && d > 0) || (n > 0 && d < 0) ) ans += \"-\";\\n        long long res = a/b; ans += to_string(res);\\n        long long r = a%b;\\n        if(r == 0) return ans;\\n        ans += \".\";\\n        unordered_map<int,int>mp;\\n        mp[r] = ans.length();\\n\\n        while(r != 0){\\n            r *= 10;\\n            res = r/b; ans+= to_string(res);\\n            r = r%b;\\n            if(mp.find(r) != mp.end()){\\n                ans.insert(ans.begin()+mp[r],\\'(\\');\\n                ans += \")\";\\n                return ans;\\n            }\\n            mp[r] = ans.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        long long a = labs(n), b = labs(d);\\n        string ans = \"\";\\n        if( (n < 0 && d > 0) || (n > 0 && d < 0) ) ans += \"-\";\\n        long long res = a/b; ans += to_string(res);\\n        long long r = a%b;\\n        if(r == 0) return ans;\\n        ans += \".\";\\n        unordered_map<int,int>mp;\\n        mp[r] = ans.length();\\n\\n        while(r != 0){\\n            r *= 10;\\n            res = r/b; ans+= to_string(res);\\n            r = r%b;\\n            if(mp.find(r) != mp.end()){\\n                ans.insert(ans.begin()+mp[r],\\'(\\');\\n                ans += \")\";\\n                return ans;\\n            }\\n            mp[r] = ans.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051470,
                "title": "100-fast-fully-commented-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d)\\n    {\\n        string ans;\\n        if((n<0 && d>0) || (n>0 && d<0))\\n            ans+=\\'-\\';\\n        n=abs(n);\\n        d=abs(d);\\n        long long q=n/d;//initial quotient\\n        long long rem=n%d;//initial remainder\\n        ans+=to_string(q);\\n        if(rem==0) return ans;//there is no decimal part\\n        ans+=\\'.\\';\\n        int fl=0;//flag variable to determine if theb decimal is recurring\\n        int ind_start=-1;//starting index of the recurring part of the decimal\\n        int index=0;//to store the index of all the numbers after point\\n        unordered_map<int,unordered_map<int,int>>mp;//quotient-->remainder-->index of number\\n        string after_pt;//string to store all the numbers after point\\n        while(rem!=0)\\n        {\\n            rem*=10;\\n            long long q2=rem/d;\\n            rem=rem%d;\\n            if(mp[q2][rem])//means the quotient-->remainder already exists thus the decimal part is recurring\\n            {\\n                fl=1;\\n                ind_start=mp[q2][rem];//the index of the start of the recuuring part of the decimal\\n                break;\\n            }\\n            else\\n            {\\n                after_pt+=to_string(q2);\\n                mp[q2][rem]=index++;\\n            }\\n        }\\n        if(fl==0)//contains no recurring number just concatenate the strings\\n            ans+=after_pt;\\n        else\\n        {\\n            //contains a recurring part\\n            for(int i=0;i<after_pt.length();i++)\\n            {\\n                if(i==ind_start)//this is the start of the recurring part of the decimal nos\\n                    ans+=\\'(\\';\\n                ans+=after_pt[i];\\n            }\\n            ans+=\\')\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d)\\n    {\\n        string ans;\\n        if((n<0 && d>0) || (n>0 && d<0))\\n            ans+=\\'-\\';\\n        n=abs(n);\\n        d=abs(d);\\n        long long q=n/d;//initial quotient\\n        long long rem=n%d;//initial remainder\\n        ans+=to_string(q);\\n        if(rem==0) return ans;//there is no decimal part\\n        ans+=\\'.\\';\\n        int fl=0;//flag variable to determine if theb decimal is recurring\\n        int ind_start=-1;//starting index of the recurring part of the decimal\\n        int index=0;//to store the index of all the numbers after point\\n        unordered_map<int,unordered_map<int,int>>mp;//quotient-->remainder-->index of number\\n        string after_pt;//string to store all the numbers after point\\n        while(rem!=0)\\n        {\\n            rem*=10;\\n            long long q2=rem/d;\\n            rem=rem%d;\\n            if(mp[q2][rem])//means the quotient-->remainder already exists thus the decimal part is recurring\\n            {\\n                fl=1;\\n                ind_start=mp[q2][rem];//the index of the start of the recuuring part of the decimal\\n                break;\\n            }\\n            else\\n            {\\n                after_pt+=to_string(q2);\\n                mp[q2][rem]=index++;\\n            }\\n        }\\n        if(fl==0)//contains no recurring number just concatenate the strings\\n            ans+=after_pt;\\n        else\\n        {\\n            //contains a recurring part\\n            for(int i=0;i<after_pt.length();i++)\\n            {\\n                if(i==ind_start)//this is the start of the recurring part of the decimal nos\\n                    ans+=\\'(\\';\\n                ans+=after_pt[i];\\n            }\\n            ans+=\\')\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001970,
                "title": "java-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }   \\n        sb = new StringBuilder();\\n        \\n        addSign(numerator,denominator);\\n        divideNumbers(numerator,denominator);\\n\\n        return sb.toString();\\n    }\\n    private void addSign(int a , int b){\\n        \\n        if((a > 0 && b > 0) || (a < 0 && b < 0)){\\n            return;\\n        }    \\n        sb.append(\"-\");\\n    }\\n    private void divideNumbers(int a,int b){\\n        \\n        long num = Math.abs((long)a);\\n        long den = Math.abs((long)b);\\n\\n        sb.append(num/den);\\n        num %= den;\\n        if(num == 0){\\n            return;\\n        } \\n        appendDecimalPart(num,den);\\n    }\\n    private void appendDecimalPart(long num, long den){\\n\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        sb.append(\".\");\\n        while(num !=0){\\n\\n            num *= 10;\\n            sb.append(num/den);\\n            num %= den;\\n\\n            if(map.containsKey(num)){\\n                sb.insert(map.get(num),\"(\");\\n                sb.append(\")\");\\n                return;\\n            }\\n            else{\\n                map.put(num,sb.length());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }   \\n        sb = new StringBuilder();\\n        \\n        addSign(numerator,denominator);\\n        divideNumbers(numerator,denominator);\\n\\n        return sb.toString();\\n    }\\n    private void addSign(int a , int b){\\n        \\n        if((a > 0 && b > 0) || (a < 0 && b < 0)){\\n            return;\\n        }    \\n        sb.append(\"-\");\\n    }\\n    private void divideNumbers(int a,int b){\\n        \\n        long num = Math.abs((long)a);\\n        long den = Math.abs((long)b);\\n\\n        sb.append(num/den);\\n        num %= den;\\n        if(num == 0){\\n            return;\\n        } \\n        appendDecimalPart(num,den);\\n    }\\n    private void appendDecimalPart(long num, long den){\\n\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        sb.append(\".\");\\n        while(num !=0){\\n\\n            num *= 10;\\n            sb.append(num/den);\\n            num %= den;\\n\\n            if(map.containsKey(num)){\\n                sb.insert(map.get(num),\"(\");\\n                sb.append(\")\");\\n                return;\\n            }\\n            else{\\n                map.put(num,sb.length());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816835,
                "title": "simple-java-solution-beats-99",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) \\n    {\\n        long a = Math.abs((long)n);\\n        long b = Math.abs((long)d);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if( (n<0 && d>0) || (n>0 && d<0))\\n            sb.append(\\'-\\');\\n        \\n        sb.append(a/b);\\n        a = a%b;\\n        \\n        if(a > 0)\\n            sb.append(\\'.\\');\\n        \\n        HashMap<Long,Integer> map = new HashMap<>();\\n        \\n        while(!map.containsKey(a))\\n        {\\n            map.put(a , map.size());\\n            a = a*10;\\n            \\n            if(a > 0)\\n                sb.append(a/b);\\n            \\n            a = a%b;\\n        }\\n        \\n        if(a > 0)\\n        {\\n            sb.insert(sb.length()-(map.size()-map.get(a)) , \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) \\n    {\\n        long a = Math.abs((long)n);\\n        long b = Math.abs((long)d);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if( (n<0 && d>0) || (n>0 && d<0))\\n            sb.append(\\'-\\');\\n        \\n        sb.append(a/b);\\n        a = a%b;\\n        \\n        if(a > 0)\\n            sb.append(\\'.\\');\\n        \\n        HashMap<Long,Integer> map = new HashMap<>();\\n        \\n        while(!map.containsKey(a))\\n        {\\n            map.put(a , map.size());\\n            a = a*10;\\n            \\n            if(a > 0)\\n                sb.append(a/b);\\n            \\n            a = a%b;\\n        }\\n        \\n        if(a > 0)\\n        {\\n            sb.insert(sb.length()-(map.size()-map.get(a)) , \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174526,
                "title": "simple-to-understand",
                "content": "\\n    string fractionToDecimal(int a, int d) \\n    {\\n        long long n=a;\\n        if(n%d==0)\\n            return to_string(n/d);\\n        \\n        string ans;\\n        if(n<0^d<0)\\n            ans+=\\'-\\';\\n        \\n        n=abs(n),d=abs(d);\\n        \\n        ans+=to_string((n/d));\\n        ans+=\\'.\\';\\n        n%=d;\\n        n*=10;\\n        \\n        unordered_map<long long,int>mp;\\n        \\n        \\n        while(n)\\n        {\\n            if(mp.count(n))\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n            }\\n            mp[n]=ans.size();\\n            ans+=(n/d)+\\'0\\';  \\n            n%=d;\\n            n*=10;\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**upvode only when you understand this.**",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    string fractionToDecimal(int a, int d) \\n    {\\n        long long n=a;\\n        if(n%d==0)\\n            return to_string(n/d);\\n        \\n        string ans;\\n        if(n<0^d<0)\\n            ans+=\\'-\\';\\n        \\n        n=abs(n),d=abs(d);\\n        \\n        ans+=to_string((n/d));\\n        ans+=\\'.\\';\\n        n%=d;\\n        n*=10;\\n        \\n        unordered_map<long long,int>mp;\\n        \\n        \\n        while(n)\\n        {\\n            if(mp.count(n))\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n            }\\n            mp[n]=ans.size();\\n            ans+=(n/d)+\\'0\\';  \\n            n%=d;\\n            n*=10;\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**upvode only when you understand this.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1828185,
                "title": "java-1ms-100",
                "content": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator == 0)\\n            return \"0\";\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        if(numerator < 0 ^ denominator < 0)\\n            res.append(\"-\");\\n        \\n        long n = Math.abs((long) numerator);\\n        long d = Math.abs((long) denominator);\\n        \\n        long q = n / d;\\n        long r = n % d;\\n        res.append(q);\\n        \\n        if(r == 0)\\n            return res.toString();\\n        else{\\n            res.append(\".\");\\n            \\n            HashMap<Long, Integer> map = new HashMap<>();\\n            \\n            while(r != 0) {\\n                if(map.containsKey(r)){\\n                    int len = map.get(r);\\n                    res.insert(len,\"(\");\\n                    res.append(\")\");\\n                    break;\\n                }else{\\n                    map.put(r,res.length());\\n                    r = r * 10;\\n                    q = r / d;\\n                    r = r % d;\\n                    res.append(q);\\n                }\\n            }\\n        }\\n            \\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator == 0)\\n            return \"0\";\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        if(numerator < 0 ^ denominator < 0)\\n            res.append(\"-\");\\n        \\n        long n = Math.abs((long) numerator);\\n        long d = Math.abs((long) denominator);\\n        \\n        long q = n / d;\\n        long r = n % d;\\n        res.append(q);\\n        \\n        if(r == 0)\\n            return res.toString();\\n        else{\\n            res.append(\".\");\\n            \\n            HashMap<Long, Integer> map = new HashMap<>();\\n            \\n            while(r != 0) {\\n                if(map.containsKey(r)){\\n                    int len = map.get(r);\\n                    res.insert(len,\"(\");\\n                    res.append(\")\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1764668,
                "title": "c-solution-in-0-ms-unordered-map-clean-commented-code",
                "content": "\\tstring fractionToDecimal(long a, long b) {\\n\\t\\t//base case\\n        if(a==0) return \"0\";\\n        string res;\\n\\t\\t//checking if either of the numerator or denominator is negitive\\n        if(a<0 ^ b<0) res=\\'-\\'+res;\\n        a=abs(a);\\n        b=abs(b);\\n\\t\\t//append the result of a/b to string\\n        res+=to_string(a/b);\\n\\t\\t//If there is remainder for a/b then decimal point exists\\n        if(a%b==0) return res;\\n        res+=\".\";\\n        long rem=a%b;\\n\\t\\t//map to store the index of occurance particular remainder\\n\\t\\t//If the same remainder is seen again we will use the first occuarance of that remainder and put in paranthesis indicating that sequence is repeating\\n        unordered_map<long,long> m;\\n        while(rem){\\n            if(m.find(rem)!=m.end()){\\n                res.insert(res.begin()+m[rem],\\'(\\');\\n                res.push_back(\\')\\');\\n                break;\\n            }\\n            m[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/b);\\n            rem=rem%b;\\n        }\\n        return res;\\n    }\\n\\nPlease upvote : )",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tstring fractionToDecimal(long a, long b) {\\n\\t\\t//base case\\n        if(a==0) return \"0\";\\n        string res;\\n\\t\\t//checking if either of the numerator or denominator is negitive\\n        if(a<0 ^ b<0) res=\\'-\\'+res;\\n        a=abs(a);\\n        b=abs(b);\\n\\t\\t//append the result of a/b to string\\n        res+=to_string(a/b);\\n\\t\\t//If there is remainder for a/b then decimal point exists\\n        if(a%b==0) return res;\\n        res+=\".\";\\n        long rem=a%b;\\n\\t\\t//map to store the index of occurance particular remainder\\n\\t\\t//If the same remainder is seen again we will use the first occuarance of that remainder and put in paranthesis indicating that sequence is repeating\\n        unordered_map<long,long> m;\\n        while(rem){\\n            if(m.find(rem)!=m.end()){\\n                res.insert(res.begin()+m[rem],\\'(\\');\\n                res.push_back(\\')\\');\\n                break;\\n            }\\n            m[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/b);\\n            rem=rem%b;\\n        }\\n        return res;\\n    }\\n\\nPlease upvote : )",
                "codeTag": "Unknown"
            },
            {
                "id": 1668331,
                "title": "python3-with-explanation-runtime-around-40ms-65ms",
                "content": "Although this is not the most perfect solution, I would like to share this with you and please feel free to comment below!\\n### Logic\\n* I handle this problem with memorization. As shown in the code, there are 2 arrays, the remainders and the quotients records the values of each round of division respectively.\\n* During the while loop, we check the current numerator value.\\n\\t* If the numerator is 0, which means the original numerator does not have recurring decimal, we can break the loop.\\n\\t* Otherwise, we will power the current numerator by 10 and start the next division.\\n\\t\\t* If the new numerator is already stored in the remainders, which means the following division operations will lead to recurring decimal, we can break the loop and return the answer.\\n\\t\\t* Otherwise, record the remainder and quotient, and update the numerator to its remainder.\\n* Finally, we will add the negative sign if necessary.\\n\\n### Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        neg = True if numerator/denominator < 0 else False\\n        numerator = -numerator if numerator < 0 else numerator\\n        denominator = -denominator if denominator < 0 else denominator\\n        out = str(numerator//denominator)\\n        if numerator % denominator:\\n            out += \".\"\\n        remainders = []\\n        quotients = []\\n        numerator %= denominator\\n        while numerator:\\n            numerator *= 10\\n            if str(numerator) in remainders:\\n                duplicateStart = remainders.index(str(numerator))\\n                out += \"\".join(quotients[:duplicateStart])\\n                out += \"(\"+\"\".join(quotients[duplicateStart:])+\")\"\\n                return \"-\"+out if neg else out\\n            else:\\n                remainders.append(str(numerator))\\n                quotients.append(str(numerator // denominator))\\n                numerator %= denominator\\n        out += \"\".join(quotients)\\n        return \"-\"+out if neg else out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        neg = True if numerator/denominator < 0 else False\\n        numerator = -numerator if numerator < 0 else numerator\\n        denominator = -denominator if denominator < 0 else denominator\\n        out = str(numerator//denominator)\\n        if numerator % denominator:\\n            out += \".\"\\n        remainders = []\\n        quotients = []\\n        numerator %= denominator\\n        while numerator:\\n            numerator *= 10\\n            if str(numerator) in remainders:\\n                duplicateStart = remainders.index(str(numerator))\\n                out += \"\".join(quotients[:duplicateStart])\\n                out += \"(\"+\"\".join(quotients[duplicateStart:])+\")\"\\n                return \"-\"+out if neg else out\\n            else:\\n                remainders.append(str(numerator))\\n                quotients.append(str(numerator // denominator))\\n                numerator %= denominator\\n        out += \"\".join(quotients)\\n        return \"-\"+out if neg else out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651060,
                "title": "python-solution-with-a-bit-of-explanation",
                "content": "The time complexity of this method is O(1) because the resulting array cannot be longer than 10000, which means the loop doesn\\'t go beyond 10000 iterations. The space complexity is also O(1) for the same reason, which might not depend on either numerator or the denominator.\\n\\nLet us list the possible test cases that this problem might need to deal with later.\\n\\tA) 1/90                 => 0.0(1)\\n\\tB) -1/90               =>-0.0(1)\\n\\tC) 0/-10               =>0\\n\\tD)4/2                    =>2\\n\\tE)2565/100000  =>0.02565\\n\\t\\nNow, let us go through the solution below.\\n1) First, we will return if the numerator is 0 because the answer will always be 0.\\n2) Second, we will check the sign of the resulting number. If both are positive or negative, then the resulting number will be positive; otherwise, it will be negative.\\n3) Third, we will divide the numerator by the denominator, add that value to the result, and keep track of the reminder.\\n4) Forth, if the remainder is 0, the denominator perfectly divides the numerator, which means we can return the result.\\n5) Fifth, if there is a remainder, we will add \".\" to the result because we will further divide the remainder to get results after the decimal place.\\n6) Sixth, this is the central part because most of the portion before this is relatively straightforward. We will keep track of the remainder and the length of the resulting array in a hash map. If we have previously seen that remainder, the result will have recurring numbers in decimal. And by keeping track of the length of the resulting array, we will know where to place the start bracket in the result. So, if we have already seen the reminder earlier, we will return here by placing the start bracket and end bracket in the result. We will need to multiply the remainder by 10 in each step. If we want to do the following division 1/90, then the remainder will be 1 before the for loop begins. Then we will need to multiply it by 10, and the new remainder will be 10, and then we will multiply it by 10 again, and the new val will be 1 and the remainder will be 10 again.\\n7) Seventh, when the remainder becomes 0, like in the case 1/1000000000000000 where it might take a while, we will break the while loop and return the result.\\n(Sorry for the bad English)\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        negative_sign = (numerator < 0) ^ (denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        result = [\"-\"] if negative_sign else []\\n        result.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        seen_numerator = {}\\n        if remainder == 0:\\n            return \"\".join(result)\\n        \\n        result.append(\".\")\\n        while remainder != 0:\\n            if remainder in seen_numerator:\\n                result.append(\")\")\\n                small_pos = seen_numerator[remainder]\\n                return \"\".join(result[:small_pos]) + \"(\"+\"\".join(result[small_pos:])\\n            seen_numerator[remainder] = len(result)\\n            remainder *= 10\\n            val = remainder // denominator\\n            remainder %= denominator\\n            result.append(str(val))\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        negative_sign = (numerator < 0) ^ (denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        result = [\"-\"] if negative_sign else []\\n        result.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        seen_numerator = {}\\n        if remainder == 0:\\n            return \"\".join(result)\\n        \\n        result.append(\".\")\\n        while remainder != 0:\\n            if remainder in seen_numerator:\\n                result.append(\")\")\\n                small_pos = seen_numerator[remainder]\\n                return \"\".join(result[:small_pos]) + \"(\"+\"\".join(result[small_pos:])\\n            seen_numerator[remainder] = len(result)\\n            remainder *= 10\\n            val = remainder // denominator\\n            remainder %= denominator\\n            result.append(str(val))\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639085,
                "title": "clean-java-with-comment",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        // if negative, append -\\n        if(numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) builder.append(\"-\");\\n        \\n        // avoid integer overflow by converting to long\\n        long divisor = Math.abs((long) numerator);\\n        long dividend = Math.abs((long) denominator);\\n        \\n        long remainder = divisor % dividend;\\n        builder.append(divisor / dividend);\\n        \\n        // no decimal \\n        if(remainder == 0) return builder.toString();\\n        \\n        builder.append(\".\");\\n        \\n        // key is the remainder, value is the position in the result string\\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        while(remainder != 0) {\\n            // check if remainder is repeating\\n            if(map.containsKey(remainder)) {\\n                //insert ( before the repeating num\\n                builder.insert(map.get(remainder), \"(\");\\n                //insert ) after the repeatingn num\\n                builder.append(\")\");\\n                break;\\n            }\\n            \\n            // first time seeing the remainder\\n            // position is the end of the string\\n            map.put(remainder, builder.length());\\n            // continue to divide the dividend so we should *= 10 as per normal long division\\n            remainder *= 10;\\n            builder.append(remainder / dividend);\\n            remainder %= dividend;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        // if negative, append -\\n        if(numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) builder.append(\"-\");\\n        \\n        // avoid integer overflow by converting to long\\n        long divisor = Math.abs((long) numerator);\\n        long dividend = Math.abs((long) denominator);\\n        \\n        long remainder = divisor % dividend;\\n        builder.append(divisor / dividend);\\n        \\n        // no decimal \\n        if(remainder == 0) return builder.toString();\\n        \\n        builder.append(\".\");\\n        \\n        // key is the remainder, value is the position in the result string\\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        while(remainder != 0) {\\n            // check if remainder is repeating\\n            if(map.containsKey(remainder)) {\\n                //insert ( before the repeating num\\n                builder.insert(map.get(remainder), \"(\");\\n                //insert ) after the repeatingn num\\n                builder.append(\")\");\\n                break;\\n            }\\n            \\n            // first time seeing the remainder\\n            // position is the end of the string\\n            map.put(remainder, builder.length());\\n            // continue to divide the dividend so we should *= 10 as per normal long division\\n            remainder *= 10;\\n            builder.append(remainder / dividend);\\n            remainder %= dividend;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618999,
                "title": "a-fast-simple-and-easy-to-follow-python-solution",
                "content": "A lot of solutions out there are way too much for me. The following is a simplied python solution with explanation in plain language. I hope that helps. \\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        # base case\\n        if numerator == 0:\\n            return \\'0\\'\\n        \\n        # result\\n        res = \\'\\'\\n        \\n        # positive and negative\\n        if (numerator > 0 and denominator < 0) or \\\\\\n            (numerator < 0 and denominator > 0):\\n            res += \\'-\\'\\n        \\n        # absolute value\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # remainder as zero\\n        res += str(numerator//denominator)\\n        numerator %= denominator\\n        if numerator == 0:\\n            return res\\n        \\n        # add a dot .\\n        res += \\'.\\'\\n        \\n        # hashmap to write down the starting index of a repeated remainder\\n        hashmap = {}\\n        hashmap[numerator] = len(res)\\n        while numerator != 0:\\n            \\n            # continue to mutiply by 10\\n            numerator *= 10\\n            res += str(numerator//denominator)\\n            numerator %= denominator\\n            \\n            # check if it finds a repeated pattern\\n            if numerator in hashmap:\\n                index = hashmap[numerator]\\n                res = res[:index] + \\'(\\' + res[index:]\\n                res += \\')\\'\\n                break\\n            else:\\n                hashmap[numerator] = len(res)\\n                 \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        # base case\\n        if numerator == 0:\\n            return \\'0\\'\\n        \\n        # result\\n        res = \\'\\'\\n        \\n        # positive and negative\\n        if (numerator > 0 and denominator < 0) or \\\\\\n            (numerator < 0 and denominator > 0):\\n            res += \\'-\\'\\n        \\n        # absolute value\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # remainder as zero\\n        res += str(numerator//denominator)\\n        numerator %= denominator\\n        if numerator == 0:\\n            return res\\n        \\n        # add a dot .\\n        res += \\'.\\'\\n        \\n        # hashmap to write down the starting index of a repeated remainder\\n        hashmap = {}\\n        hashmap[numerator] = len(res)\\n        while numerator != 0:\\n            \\n            # continue to mutiply by 10\\n            numerator *= 10\\n            res += str(numerator//denominator)\\n            numerator %= denominator\\n            \\n            # check if it finds a repeated pattern\\n            if numerator in hashmap:\\n                index = hashmap[numerator]\\n                res = res[:index] + \\'(\\' + res[index:]\\n                res += \\')\\'\\n                break\\n            else:\\n                hashmap[numerator] = len(res)\\n                 \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501693,
                "title": "accepted-java-solution-through-long-division-using-a-string-builder-and-a-hash-map",
                "content": "```\\nclass Solution {\\n    private static final String MINUS = \"-\";\\n    private static final String DECIMAL_POINT = \".\";\\n    private static final String OPENING_BRACKET = \"(\";\\n    private static final String CLOSING_BRACKET = \")\";\\n    \\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(0==numerator){\\n            return \"0\";\\n        }\\n        \\n        StringBuilder formattedFraction = new StringBuilder();\\n        \\n        if(numerator<0 ^ denominator<0){\\n            formattedFraction.append(MINUS);\\n        }\\n        \\n        long dividend = Math.abs(Long.valueOf(numerator));\\n        long divisor = Math.abs(Long.valueOf(denominator));\\n        \\n        formattedFraction.append(String.valueOf(dividend/divisor));\\n        long remainder = dividend%divisor;\\n        \\n        if(0==remainder){\\n            return formattedFraction.toString();\\n        }\\n        \\n        formattedFraction.append(DECIMAL_POINT);\\n        \\n        //Structure to Hash and Store all the Remainder Sequences we have encountered so far\\n        Map<Long,Integer> seqeuences = new HashMap<Long,Integer>();\\n        \\n        while(0!=remainder){\\n            if(seqeuences.containsKey(remainder)){\\n                formattedFraction.insert(seqeuences.get(remainder),OPENING_BRACKET);\\n                formattedFraction.append(CLOSING_BRACKET);\\n                break;\\n            }\\n            \\n            seqeuences.put(remainder,formattedFraction.length());\\n            remainder*=10;\\n            formattedFraction.append(String.valueOf(remainder/divisor));\\n            remainder %= divisor; \\n        }\\n        \\n        return formattedFraction.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private static final String MINUS = \"-\";\\n    private static final String DECIMAL_POINT = \".\";\\n    private static final String OPENING_BRACKET = \"(\";\\n    private static final String CLOSING_BRACKET = \")\";\\n    \\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(0==numerator){\\n            return \"0\";\\n        }\\n        \\n        StringBuilder formattedFraction = new StringBuilder();\\n        \\n        if(numerator<0 ^ denominator<0){\\n            formattedFraction.append(MINUS);\\n        }\\n        \\n        long dividend = Math.abs(Long.valueOf(numerator));\\n        long divisor = Math.abs(Long.valueOf(denominator));\\n        \\n        formattedFraction.append(String.valueOf(dividend/divisor));\\n        long remainder = dividend%divisor;\\n        \\n        if(0==remainder){\\n            return formattedFraction.toString();\\n        }\\n        \\n        formattedFraction.append(DECIMAL_POINT);\\n        \\n        //Structure to Hash and Store all the Remainder Sequences we have encountered so far\\n        Map<Long,Integer> seqeuences = new HashMap<Long,Integer>();\\n        \\n        while(0!=remainder){\\n            if(seqeuences.containsKey(remainder)){\\n                formattedFraction.insert(seqeuences.get(remainder),OPENING_BRACKET);\\n                formattedFraction.append(CLOSING_BRACKET);\\n                break;\\n            }\\n            \\n            seqeuences.put(remainder,formattedFraction.length());\\n            remainder*=10;\\n            formattedFraction.append(String.valueOf(remainder/divisor));\\n            remainder %= divisor; \\n        }\\n        \\n        return formattedFraction.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427700,
                "title": "python-3-solution-using-hashmap",
                "content": "```\\ndef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\tneg = (numerator<0 and denominator>0) or (numerator>0 and denominator<0)\\n\\tnumerator = abs(numerator) \\n\\tdenominator = abs(denominator)\\n\\n\\tres = [str(numerator//denominator)]\\n\\tindex = 1\\n\\tnumerator%=denominator\\n\\tif numerator!=0:\\n\\t\\tres.append(\".\")\\n\\t\\tindex+=1\\n\\tdic = {}\\n\\n\\twhile numerator!=0:\\n\\t\\tif numerator in dic:\\n\\t\\t\\tres = res[:dic[numerator]] + [\"(\"] + res[dic[numerator]:] + [\")\"]\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tdic[numerator] = index\\n\\t\\tnumerator*=10\\n\\t\\tres.append(str(numerator//denominator))\\n\\t\\tindex+=1\\n\\t\\tnumerator%=denominator\\n\\treturn \"\".join(res) if not neg else \"-\"+\"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\tneg = (numerator<0 and denominator>0) or (numerator>0 and denominator<0)\\n\\tnumerator = abs(numerator) \\n\\tdenominator = abs(denominator)\\n\\n\\tres = [str(numerator//denominator)]\\n\\tindex = 1\\n\\tnumerator%=denominator\\n\\tif numerator!=0:\\n\\t\\tres.append(\".\")\\n\\t\\tindex+=1\\n\\tdic = {}\\n\\n\\twhile numerator!=0:\\n\\t\\tif numerator in dic:\\n\\t\\t\\tres = res[:dic[numerator]] + [\"(\"] + res[dic[numerator]:] + [\")\"]\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tdic[numerator] = index\\n\\t\\tnumerator*=10\\n\\t\\tres.append(str(numerator//denominator))\\n\\t\\tindex+=1\\n\\t\\tnumerator%=denominator\\n\\treturn \"\".join(res) if not neg else \"-\"+\"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1402927,
                "title": "c-4ms-explained-easy-to-understand",
                "content": "1. Calculate the decimal part and add to ans.\\n2. Run loop till remainder is 0 or remainder is seen already in the calculation.\\n3. Add the decimal part of remainder/denominator to the ans.\\n**Note:**\\n1. Using index because we need to insert \"(\" at the start of the remainder that is repeating.\\nFor ex: consider 2/30 = 0.0666..., so answer should be 0.0(6) not 0.(06).\\nFor the same reason, map is used instead of set.\\n2. Using long and labs for INT_MIN.\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n    if(numerator==0) return \"0\";\\n    string ans;\\n    unordered_map<long int,int> mp;\\n    if((numerator<0 && denominator>0) || (numerator>0 && denominator<0)) ans=ans+\"-\";\\n    long int num=labs(numerator),den=labs(denominator);    \\n    long int remainder,decimal=num/den;\\n    int curdigit,index;\\n    remainder=num%den,\\n    ans=ans+to_string(decimal);\\n    if(remainder!=0) ans=ans+\".\";\\n    index=ans.size();\\n    while(remainder!=0)\\n    {\\n        if(mp.find(remainder)!=mp.end())\\n        {\\n            ans.insert(mp[remainder],\"(\");\\n            ans=ans+\")\";\\n            break;\\n        }\\n        mp[remainder]=index;\\n        remainder=remainder*10 ;\\n        curdigit=remainder/den;\\n        ans=ans+to_string(curdigit);\\n        remainder=remainder%den;\\n        index++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n    if(numerator==0) return \"0\";\\n    string ans;\\n    unordered_map<long int,int> mp;\\n    if((numerator<0 && denominator>0) || (numerator>0 && denominator<0)) ans=ans+\"-\";\\n    long int num=labs(numerator),den=labs(denominator);    \\n    long int remainder,decimal=num/den;\\n    int curdigit,index;\\n    remainder=num%den,\\n    ans=ans+to_string(decimal);\\n    if(remainder!=0) ans=ans+\".\";\\n    index=ans.size();\\n    while(remainder!=0)\\n    {\\n        if(mp.find(remainder)!=mp.end())\\n        {\\n            ans.insert(mp[remainder],\"(\");\\n            ans=ans+\")\";\\n            break;\\n        }\\n        mp[remainder]=index;\\n        remainder=remainder*10 ;\\n        curdigit=remainder/den;\\n        ans=ans+to_string(curdigit);\\n        remainder=remainder%den;\\n        index++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087090,
                "title": "easy-python-solution",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, N: int, D: int) -> str:\\n        neg = True\\n        if (N < 0 and D < 0) or (N >= 0 and D >= 0): neg = False\\n        N = abs(N)\\n        D = abs(D)\\n        rem = N % D\\n        q = N // D\\n        res = [(\"-\" if neg else \"\") + str(q)]                \\n        maps = {}        \\n        if rem == 0:\\n            return str((-1 if neg else 1) * q)\\n        else:\\n            res.append(\\'.\\')\\n            while rem != 0:        \\n                if rem in maps:\\n                    res.append(\\')\\')\\n                    res.insert(maps[rem] , \\'(\\')\\n                    break;\\n                else:\\n                    maps[rem] = len(res)\\n                    rem *= 10\\n                    res.append(str(rem // D))\\n                    rem %= D\\n        return \"\".join(res)\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fractionToDecimal(self, N: int, D: int) -> str:\\n        neg = True\\n        if (N < 0 and D < 0) or (N >= 0 and D >= 0): neg = False\\n        N = abs(N)\\n        D = abs(D)\\n        rem = N % D\\n        q = N // D\\n        res = [(\"-\" if neg else \"\") + str(q)]                \\n        maps = {}        \\n        if rem == 0:\\n            return str((-1 if neg else 1) * q)\\n        else:\\n            res.append(\\'.\\')\\n            while rem != 0:        \\n                if rem in maps:\\n                    res.append(\\')\\')\\n                    res.insert(maps[rem] , \\'(\\')\\n                    break;\\n                else:\\n                    maps[rem] = len(res)\\n                    rem *= 10\\n                    res.append(str(rem // D))\\n                    rem %= D\\n        return \"\".join(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083481,
                "title": "very-clear-solution-with-python-with-detailed-comment",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # the key idea of solving this problem is how to detect repeating\\n        # and locate where to add parentheses\\n        # the answer is generate the decimal part with mod operation and recalculate\\n        # the remainer time by time. When meeting same remainer, there have repeating\\n        # and the begining of the repeating is the index where you first meet\\n        # the same remainer\\n        res = \"\"\\n        # determinate symbol with xor, remeber 0 have not negative one\\n        if numerator ^ denominator < 0 and numerator != 0:\\n            res += \"-\"\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        # calculate the integral part\\n        res += str(int(numerator / denominator))\\n        remainder_index = {}\\n        remainder = numerator % denominator\\n        # calculate the decimal part\\n        if remainder != 0:\\n            res += \".\"\\n        while remainder:\\n            # detect same remainer, so we can locate the repeating part\\n            if remainder in remainder_index:\\n                res = res[0:remainder_index[remainder]] + \\'(\\' + res[remainder_index[remainder]:] + \\')\\'\\n                # please notice that the rest calculate is repeating, so break now\\n                break\\n            \\n            remainder_index[remainder] = len(res)\\n            remainder *= 10\\n            res += str(int(remainder / denominator))\\n            remainder %= denominator\\n            \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # the key idea of solving this problem is how to detect repeating\\n        # and locate where to add parentheses\\n        # the answer is generate the decimal part with mod operation and recalculate\\n        # the remainer time by time. When meeting same remainer, there have repeating\\n        # and the begining of the repeating is the index where you first meet\\n        # the same remainer\\n        res = \"\"\\n        # determinate symbol with xor, remeber 0 have not negative one\\n        if numerator ^ denominator < 0 and numerator != 0:\\n            res += \"-\"\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        # calculate the integral part\\n        res += str(int(numerator / denominator))\\n        remainder_index = {}",
                "codeTag": "Java"
            },
            {
                "id": 907216,
                "title": "java-1-ms-faster-than-99-91-36-4-mb-less-than-20-75",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (numerator < 0 ^ denominator < 0) {\\n            sb.append(\"-\");\\n        }\\n        long up = Math.abs((long) numerator);\\n        long down = Math.abs((long) denominator);\\n        sb.append(up / down);\\n        long rem = up % down;\\n        if (rem == 0) {\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        Map<Long, Integer> idxs = new HashMap<>();\\n        while (rem != 0) {\\n            if (idxs.containsKey(rem)) {\\n                sb.insert(idxs.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            idxs.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / down);\\n            rem %= down;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (numerator < 0 ^ denominator < 0) {\\n            sb.append(\"-\");\\n        }\\n        long up = Math.abs((long) numerator);\\n        long down = Math.abs((long) denominator);\\n        sb.append(up / down);\\n        long rem = up % down;\\n        if (rem == 0) {\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        Map<Long, Integer> idxs = new HashMap<>();\\n        while (rem != 0) {\\n            if (idxs.containsKey(rem)) {\\n                sb.insert(idxs.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            idxs.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / down);\\n            rem %= down;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837008,
                "title": "python-solution-with-intuition",
                "content": "Intuition: First we handle the special case where numerator is zero. We build our final output in an array, and at the end we return this array. We take into account the signs initially so that we can do our division dealing with only positive numbers. XOR operation enables us to quickly determine if exactly one of numerator or denominator is negative. We separate our solution into two parts, the integral part and the decimal part.\\n\\nFor the integral part, we need to use integer division to see how many times denominator goes into numerator. This will be zero if denominator > numerator. This makes sense because if a denominator is bigger than a numerator, then the integral portion of our decimal will be zero. Once we handle the integral portion, we then move onto the decimal part. \\n\\nFor the decimal part, we are looking for the point at which remainders begin to repeat, in our long division. At the point in which we see a repeat remainder, we know that we have a cycle and that there will be repeats from here onward. If remainder gets to zero, that means the decimal part does not have a cycle, and we exit the while loop accordingly. \\n\\nWithin the while loop we handle the long division for the decimal part. At the same time, we maintain a dictionary of remainders we\\'ve seen so far, as well as the index we saw this remainder. The while loop has two ways of exiting:\\n- Case 1: We see a remainder we saw in the past, which indicates a cycle. So we insert parentheses where needed and we exit.\\n- Case 2: remainder makes it down to zero, which indicates that the decimal portion has no cycle. So we return.\\n\\n**Time complexity**: Similar to the space complexity analysis done below, this problem does not have a traditionally well defined large input, since if we consider an input like numerator = 9000, denominator = 1, Time complexity is constant, even though numerator is large. Time complexity really only depends on the size of the cycle. But size of cycle does not depend on the \"size\" of either numerator or denominator. So time complexity is not well defined here either. \\n**Space complexity**: This will depend on how much space our output array uses. Our output array uses as much space as the longest cycle. This does not directly depend on numerator, denominator, at least in the traditional way we do space complexity analyses. Because large inputs are not well defined in this case. Because a large input could be numerator = 9000, denominator = 1, but that has a constant time for output. So space complexity is not well defined, since we don\\'t have a traditonally well defined large input, with which our space complexity grows alongside. \\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        output = []\\n        \\n        if (numerator < 0) ^ (denominator < 0): \\n            output.append(\\'-\\')\\n            \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # integral part\\n        quotient = numerator // denominator\\n        output.append(str(quotient)) # do i need str here?\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(output)\\n        \\n        # decimal part\\n        output.append(\\'.\\')\\n        remainderToIndexSeen={}\\n        \\n        while remainder != 0:\\n            if remainder in remainderToIndexSeen:\\n                output.insert(remainderToIndexSeen[remainder], \"(\")\\n                output.append(\")\")\\n                break\\n            remainderToIndexSeen[remainder] = len(output)\\n            \\n            # Next 3 lines of code simulate 3 steps of long division:\\n            \\n            # 1) bring down the zero\\n            remainder *= 10 \\n            \\n            # 2) find the next part of quotient\\n            output.append(str(remainder // denominator)) \\n            \\n            # 3) subtract to find the new remainder\\n            remainder %= denominator \\n        \\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        output = []\\n        \\n        if (numerator < 0) ^ (denominator < 0): \\n            output.append(\\'-\\')\\n            \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # integral part\\n        quotient = numerator // denominator\\n        output.append(str(quotient)) # do i need str here?\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(output)\\n        \\n        # decimal part\\n        output.append(\\'.\\')\\n        remainderToIndexSeen={}\\n        \\n        while remainder != 0:\\n            if remainder in remainderToIndexSeen:\\n                output.insert(remainderToIndexSeen[remainder], \"(\")\\n                output.append(\")\")\\n                break\\n            remainderToIndexSeen[remainder] = len(output)\\n            \\n            # Next 3 lines of code simulate 3 steps of long division:\\n            \\n            # 1) bring down the zero\\n            remainder *= 10 \\n            \\n            # 2) find the next part of quotient\\n            output.append(str(remainder // denominator)) \\n            \\n            # 3) subtract to find the new remainder\\n            remainder %= denominator \\n        \\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827938,
                "title": "solution-without-storing-all-remainders-o-1-space-python",
                "content": "Explanations added in the code as comments\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        \\n        # Find sign of result\\n        sign = 1\\n        if numerator < 0:\\n            numerator = -numerator\\n            sign *= -1\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign *= -1\\n        \\n        # Calculate integer part before the decimal\\n        intPart = int(numerator / denominator)\\n        numerator %= denominator\\n        numerator = numerator = numerator\\n        \\n        # Ensure that the numerator and denominator do not have 2 or 5\\n        # as a common factor\\n        while numerator % 2 == 0 and denominator % 2 == 0:\\n            numerator /= 2\\n            denominator /= 2\\n        while numerator % 5 == 5 and denominator % 5 == 0:\\n            numerator /= 5\\n            denominator /= 5\\n            \\n        # At this point the number of non recurring digits after the decimal\\n        # point will be:\\n        # Max(m,n)\\n        # where m is the highest number for which 2^m divides denominator\\n        # and n is the highest number for which 5^n divides denominator\\n        num = denominator\\n        num2Factors = 0\\n        while num % (2 ** (num2Factors + 1)) == 0:\\n            num2Factors += 1\\n        num5Factors = 0\\n        while num % (5 ** (num5Factors + 1)) == 0:\\n            num5Factors += 1\\n        nonRecc = max(num2Factors, num5Factors)\\n        \\n        # Calculate the non recurring decimal part of the result\\n        decPart = \\'\\'\\n        while nonRecc and numerator:\\n            numerator *= 10\\n            decPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            nonRecc -= 1\\n            \\n        # firstNum is the numerator which will be repeated in the recurring part\\n        # of the result.\\n        # Calculate the recurring decimal part of the result by dividing until\\n        # we get firstNum again.\\n        firstNum = numerator\\n        reccPart = \\'\\'\\n        while numerator:\\n            numerator *= 10\\n            reccPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            if numerator == firstNum:\\n                break\\n        \\n        # Construct the result from the individual parts\\n        res = \\'\\' if sign == 1 else \\'-\\'\\n        res += str(intPart)\\n        if decPart or reccPart:\\n            res += \\'.\\'\\n        res += decPart\\n        if reccPart:\\n            res += \\'(\\' + reccPart + \\')\\'\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        \\n        # Find sign of result\\n        sign = 1\\n        if numerator < 0:\\n            numerator = -numerator\\n            sign *= -1\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign *= -1\\n        \\n        # Calculate integer part before the decimal\\n        intPart = int(numerator / denominator)\\n        numerator %= denominator\\n        numerator = numerator = numerator\\n        \\n        # Ensure that the numerator and denominator do not have 2 or 5\\n        # as a common factor\\n        while numerator % 2 == 0 and denominator % 2 == 0:\\n            numerator /= 2\\n            denominator /= 2\\n        while numerator % 5 == 5 and denominator % 5 == 0:\\n            numerator /= 5\\n            denominator /= 5\\n            \\n        # At this point the number of non recurring digits after the decimal\\n        # point will be:\\n        # Max(m,n)\\n        # where m is the highest number for which 2^m divides denominator\\n        # and n is the highest number for which 5^n divides denominator\\n        num = denominator\\n        num2Factors = 0\\n        while num % (2 ** (num2Factors + 1)) == 0:\\n            num2Factors += 1\\n        num5Factors = 0\\n        while num % (5 ** (num5Factors + 1)) == 0:\\n            num5Factors += 1\\n        nonRecc = max(num2Factors, num5Factors)\\n        \\n        # Calculate the non recurring decimal part of the result\\n        decPart = \\'\\'\\n        while nonRecc and numerator:\\n            numerator *= 10\\n            decPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            nonRecc -= 1\\n            \\n        # firstNum is the numerator which will be repeated in the recurring part\\n        # of the result.\\n        # Calculate the recurring decimal part of the result by dividing until\\n        # we get firstNum again.\\n        firstNum = numerator\\n        reccPart = \\'\\'\\n        while numerator:\\n            numerator *= 10\\n            reccPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            if numerator == firstNum:\\n                break\\n        \\n        # Construct the result from the individual parts\\n        res = \\'\\' if sign == 1 else \\'-\\'\\n        res += str(intPart)\\n        if decPart or reccPart:\\n            res += \\'.\\'\\n        res += decPart\\n        if reccPart:\\n            res += \\'(\\' + reccPart + \\')\\'\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777285,
                "title": "accepted-c-stringstream-with-unordered-set-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    // Updated the signature to int64_t to handle specific cases like abs(INT_MIN)\\n    string fractionToDecimal(int64_t numerator, int64_t denominator) {\\n        // special case\\n        if (numerator == 0) return \"0\";\\n        // we will use string stream to store the result\\n        stringstream res;        \\n        // if negative, we will add \"-\"\\n        if (numerator > 0 ^ denominator > 0) \\n            res << \"-\";\\n        \\n\\t\\t// working now with absolute values\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        // add the int result.\\n        res << (numerator/denominator);\\n        \\n        // working with the remainder \\n        numerator = numerator % denominator;\\n        \\n        // if we have a fraction, we need to add a \".\"\\n        if (numerator > 0) \\n            res << \".\";\\n        \\n        unordered_set<int> dups;        \\n        bool re = false;\\n        stringstream reStream;\\n        while (numerator != 0) {\\n            if (dups.count(numerator) > 0) {\\n\\t\\t\\t\\t// we have a repeat, let\\'s identify the repeated fraction or break if have already found it.\\n                if (!re) {\\n\\t\\t\\t\\t\\t// let\\'s find out the repeated fraction\\n\\t\\t\\t\\t\\tre = true;\\n\\t\\t\\t\\t\\t// clear the map for the next repeated segment.\\n                    dups.clear();\\n                } else { \\n                    break; \\n                }\\n            }\\n\\t\\t\\t// keep track of numerator values to detect the next duplicated fraction if it exists\\n            dups.insert(numerator);\\n            \\n            numerator *= 10;\\n            if (!re) {\\n                // non repeated fraction stream\\n                res << (numerator / denominator);\\n            } else {\\n                // repeated fraction stream.\\n                reStream << (numerator / denominator);\\n            }\\n            // working with the remainder of numerator\\n            numerator = numerator % denominator;\\n        }\\n        \\n        // in case we have a repeated fraction\\n        string repeatedFraction = reStream.str();\\n        if (!repeatedFraction.empty()) {\\n            string ans = res.str();\\n            // find the start position of the repeat\\n            auto repeat = ans.find(repeatedFraction);\\n            // reset the stream\\n            res.str(std::string());\\n            res << ans.substr(0, repeat) << \"(\" << ans.substr(repeat) << \")\";\\n        }\\n        return res.str();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Updated the signature to int64_t to handle specific cases like abs(INT_MIN)\\n    string fractionToDecimal(int64_t numerator, int64_t denominator) {\\n        // special case\\n        if (numerator == 0) return \"0\";\\n        // we will use string stream to store the result\\n        stringstream res;        \\n        // if negative, we will add \"-\"\\n        if (numerator > 0 ^ denominator > 0) \\n            res << \"-\";\\n        \\n\\t\\t// working now with absolute values\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        // add the int result.\\n        res << (numerator/denominator);\\n        \\n        // working with the remainder \\n        numerator = numerator % denominator;\\n        \\n        // if we have a fraction, we need to add a \".\"\\n        if (numerator > 0) \\n            res << \".\";\\n        \\n        unordered_set<int> dups;        \\n        bool re = false;\\n        stringstream reStream;\\n        while (numerator != 0) {\\n            if (dups.count(numerator) > 0) {\\n\\t\\t\\t\\t// we have a repeat, let\\'s identify the repeated fraction or break if have already found it.\\n                if (!re) {\\n\\t\\t\\t\\t\\t// let\\'s find out the repeated fraction\\n\\t\\t\\t\\t\\tre = true;\\n\\t\\t\\t\\t\\t// clear the map for the next repeated segment.\\n                    dups.clear();\\n                } else { \\n                    break; \\n                }\\n            }\\n\\t\\t\\t// keep track of numerator values to detect the next duplicated fraction if it exists\\n            dups.insert(numerator);\\n            \\n            numerator *= 10;\\n            if (!re) {\\n                // non repeated fraction stream\\n                res << (numerator / denominator);\\n            } else {\\n                // repeated fraction stream.\\n                reStream << (numerator / denominator);\\n            }\\n            // working with the remainder of numerator\\n            numerator = numerator % denominator;\\n        }\\n        \\n        // in case we have a repeated fraction\\n        string repeatedFraction = reStream.str();\\n        if (!repeatedFraction.empty()) {\\n            string ans = res.str();\\n            // find the start position of the repeat\\n            auto repeat = ans.find(repeatedFraction);\\n            // reset the stream\\n            res.str(std::string());\\n            res << ans.substr(0, repeat) << \"(\" << ans.substr(repeat) << \")\";\\n        }\\n        return res.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703787,
                "title": "python3-32ms-intuitive",
                "content": "\\tclass Solution:\\n\\t\\tdef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\t\\t\\tif denominator  == 0 : return \\'\\'\\n\\t\\t\\tif numerator == 0: return \\'0\\'\\n\\n\\t\\t\\t# sign part\\n\\t\\t\\tsign = \\'\\' if numerator*denominator >= 0 else \\'-\\'\\n\\n\\t\\t\\t# to non-negative vals\\n\\t\\t\\tnumerator = abs(numerator)\\n\\t\\t\\tdenominator = abs(denominator)\\n\\n\\t\\t\\t# int part\\n\\t\\t\\tint_part = str(numerator//denominator)\\n\\t\\t\\tif numerator%denominator == 0:\\n\\t\\t\\t\\treturn sign + int_part\\n\\n\\t\\t\\t# fractional part\\n\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\tfrac = []\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tvisited = dict()\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif numerator in visited: break # save numerator\\n\\t\\t\\t\\tvisited[numerator] = cnt\\n\\t\\t\\t\\tnumerator *= 10\\n\\t\\t\\t\\tif numerator < denominator:\\n\\t\\t\\t\\t\\tfrac.append(\\'0\\')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrac.append(str(numerator//denominator))\\n\\t\\t\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t# repeat part\\n\\t\\t\\ttail = \\'\\'.join(frac[visited[numerator]:cnt])\\n\\t\\t\\ttail = \\'(\\' + tail + \\')\\' if tail and tail != \\'0\\' else \\'\\'  \\n\\t\\t\\t# sign + int + dot + frac + repeat\\n\\t\\t\\treturn sign + int_part + \\'.\\' + \\'\\'.join(frac[:visited[numerator]]) + tail\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\t\\t\\tif denominator  == 0 : return \\'\\'\\n\\t\\t\\tif numerator == 0: return \\'0\\'\\n\\n\\t\\t\\t# sign part\\n\\t\\t\\tsign = \\'\\' if numerator*denominator >= 0 else \\'-\\'\\n\\n\\t\\t\\t# to non-negative vals\\n\\t\\t\\tnumerator = abs(numerator)\\n\\t\\t\\tdenominator = abs(denominator)\\n\\n\\t\\t\\t# int part\\n\\t\\t\\tint_part = str(numerator//denominator)\\n\\t\\t\\tif numerator%denominator == 0:\\n\\t\\t\\t\\treturn sign + int_part\\n\\n\\t\\t\\t# fractional part\\n\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\tfrac = []\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tvisited = dict()\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif numerator in visited: break # save numerator\\n\\t\\t\\t\\tvisited[numerator] = cnt\\n\\t\\t\\t\\tnumerator *= 10\\n\\t\\t\\t\\tif numerator < denominator:\\n\\t\\t\\t\\t\\tfrac.append(\\'0\\')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrac.append(str(numerator//denominator))\\n\\t\\t\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t# repeat part\\n\\t\\t\\ttail = \\'\\'.join(frac[visited[numerator]:cnt])\\n\\t\\t\\ttail = \\'(\\' + tail + \\')\\' if tail and tail != \\'0\\' else \\'\\'  \\n\\t\\t\\t# sign + int + dot + frac + repeat\\n\\t\\t\\treturn sign + int_part + \\'.\\' + \\'\\'.join(frac[:visited[numerator]]) + tail\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 691856,
                "title": "c-easy-to-understand-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        long long  n = numerator;\\n        long long  d = denominator;\\n        \\n        if(!n)return \"0\";\\n        \\n        string sign = ((n/abs(n)) != (d/abs(d)))?\"-\":\"\";\\n        \\n        n = abs(n);\\n        d = abs(d);\\n        \\n        \\n        string ans = to_string(n/d);\\n        \\n        if(!(n%d))return sign + ans;\\n\\n        ans+=\\'.\\';\\n        \\n        n = n%d;\\n        \\n        unordered_map<int,int>mp;\\n        mp[n]=ans.size();\\n     \\n        \\n        while(n){\\n            n*=10;\\n            while(n<d){\\n                n*=10;\\n                ans+=\\'0\\';\\n            }\\n            \\n            ans += to_string(n/d);\\n            n = n%d;\\n            if(mp[n]){\\n                string s1 = ans.substr(0,mp[n]);\\n                string s2 =\"(\" + ans.substr(mp[n]) + \")\";\\n                return sign + s1 + s2;\\n            }\\n            \\n            mp[n] = ans.size();\\n        }\\n        \\n        return sign + ans;\\n        \\n        \\n     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        long long  n = numerator;\\n        long long  d = denominator;\\n        \\n        if(!n)return \"0\";\\n        \\n        string sign = ((n/abs(n)) != (d/abs(d)))?\"-\":\"\";\\n        \\n        n = abs(n);\\n        d = abs(d);\\n        \\n        \\n        string ans = to_string(n/d);\\n        \\n        if(!(n%d))return sign + ans;\\n\\n        ans+=\\'.\\';\\n        \\n        n = n%d;\\n        \\n        unordered_map<int,int>mp;\\n        mp[n]=ans.size();\\n     \\n        \\n        while(n){\\n            n*=10;\\n            while(n<d){\\n                n*=10;\\n                ans+=\\'0\\';\\n            }\\n            \\n            ans += to_string(n/d);\\n            n = n%d;\\n            if(mp[n]){\\n                string s1 = ans.substr(0,mp[n]);\\n                string s2 =\"(\" + ans.substr(mp[n]) + \")\";\\n                return sign + s1 + s2;\\n            }\\n            \\n            mp[n] = ans.size();\\n        }\\n        \\n        return sign + ans;\\n        \\n        \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626411,
                "title": "c-solution",
                "content": "```\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool minus =false;\\n        long den = denominator;\\n        long num= numerator;\\n        if(den<0)\\n        {\\n            den = abs((long long)den);\\n            minus= !minus;\\n        }\\n        if(num<0)\\n        {\\n            num= abs((long long)num);\\n            minus= !minus;\\n        }\\n        \\n        long int rem = num%den;\\n        long int r = num/den;\\n        string result = to_string(r);\\n        if(minus && (r>0 || rem>0))\\n        {\\n            result =\"-\"+result;\\n        }\\n        if(rem==0)\\n        {\\n            return result;\\n        }\\n        int start=0;\\n        \\n        map<long,int> rem_res;\\n        string repeat=\"\";\\n        while(rem!=0 && rem_res.find(rem)==rem_res.end())\\n        {\\n            rem_res[rem]=start++;\\n            rem=rem*10;\\n            long temp = rem/den;\\n            \\n            repeat+=to_string(temp);\\n            \\n            rem = rem%den;\\n        }\\n        \\n        if(rem!=0)\\n        {\\n            int pos=rem_res[rem];\\n            if(pos > 0)\\n            {\\n                result+= \".\"+repeat.substr(0,pos)+\"(\"+ repeat.substr(pos)+\")\";\\n            }\\n            else \\n            {\\n                result+= \".(\"+ repeat.substr(pos)+\")\";\\n            }\\n            \\n        }\\n        else\\n        {\\n            result += \".\"+repeat;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool minus =false;\\n        long den = denominator;\\n        long num= numerator;\\n        if(den<0)\\n        {\\n            den = abs((long long)den);\\n            minus= !minus;\\n        }\\n        if(num<0)\\n        {\\n            num= abs((long long)num);\\n            minus= !minus;\\n        }\\n        \\n        long int rem = num%den;\\n        long int r = num/den;\\n        string result = to_string(r);\\n        if(minus && (r>0 || rem>0))\\n        {\\n            result =\"-\"+result;\\n        }\\n        if(rem==0)\\n        {\\n            return result;\\n        }\\n        int start=0;\\n        \\n        map<long,int> rem_res;\\n        string repeat=\"\";\\n        while(rem!=0 && rem_res.find(rem)==rem_res.end())\\n        {\\n            rem_res[rem]=start++;\\n            rem=rem*10;\\n            long temp = rem/den;\\n            \\n            repeat+=to_string(temp);\\n            \\n            rem = rem%den;\\n        }\\n        \\n        if(rem!=0)\\n        {\\n            int pos=rem_res[rem];\\n            if(pos > 0)\\n            {\\n                result+= \".\"+repeat.substr(0,pos)+\"(\"+ repeat.substr(pos)+\")\";\\n            }\\n            else \\n            {\\n                result+= \".(\"+ repeat.substr(pos)+\")\";\\n            }\\n            \\n        }\\n        else\\n        {\\n            result += \".\"+repeat;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617207,
                "title": "java-using-hash-map",
                "content": "Using long to avoid corner case;\\nconvert to long before get abs value to avoid overflow.\\n\\nusing map to remember last remainder, for period.\\n\\n```\\n    public String fractionToDecimal(int nm, int dm) {\\n        if (dm == 0 || nm == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append((dm > 0) ^ (nm > 0) ? \"-\" : \"\");\\n        long d = Math.abs((long)dm), n = Math.abs((long)nm);  // must use (long)dm for -1, -2147483648\\n        sb.append(n / d);\\n        long rem = n % d;\\n        if (rem == 0) return sb.toString();\\n        sb.append(\".\");\\n        Map<Long, Integer> map = new HashMap<>();\\n        while(rem != 0) {\\n            if (map.containsKey(rem)){\\n                sb.insert(map.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / d);\\n            rem = rem % d;\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String fractionToDecimal(int nm, int dm) {\\n        if (dm == 0 || nm == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append((dm > 0) ^ (nm > 0) ? \"-\" : \"\");\\n        long d = Math.abs((long)dm), n = Math.abs((long)nm);  // must use (long)dm for -1, -2147483648\\n        sb.append(n / d);\\n        long rem = n % d;\\n        if (rem == 0) return sb.toString();\\n        sb.append(\".\");\\n        Map<Long, Integer> map = new HashMap<>();\\n        while(rem != 0) {\\n            if (map.containsKey(rem)){\\n                sb.insert(map.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / d);\\n            rem = rem % d;\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 611572,
                "title": "concise-java-solution-intuition-explained-important-to-understand-the-edge-cases",
                "content": "Intution is that if repeation occurs in the remainder than something needs to done and something can be done only with help of memory as how will we know if same case has occurred. Intutition is same as that of happy number with a lot of edge cases. It is fun learning this problem #happycoding\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        /* we need to take care of \\n        a) sign\\n        b) overflow case of -ve case of Integer.MAX_VALUE;\\n        c) memory overflow\\n        */\\n        if(numerator==0)\\n            return new String(\"0\");\\n        StringBuilder result = new StringBuilder();\\n        /* handle the sign */\\n        if(numerator <0 ^ denominator <0)\\n            result.append(\"-\");\\n        \\n        /* converting to long other wise -ve case of Integer.MAX_VALUE will\\n        overflow */\\n        long num = Math.abs(Long.valueOf(numerator));\\n        long denom = Math.abs(Long.valueOf(denominator));\\n        result.append(num/denom);\\n        long remainder = num % denom;\\n        if(remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        Map<Long,Integer> store = new HashMap<>(); \\n        while(remainder!=0){\\n            \\n            /* if the same remainder comes then we know that everything will\\n            repeat */\\n            if(store.containsKey(remainder)){\\n                result.insert(store.get(remainder),\"(\");\\n                result.append(\")\");\\n                break;\\n            }\\n            \\n            store.put(remainder,result.length());\\n            remainder*=10;\\n            result.append(String.valueOf(remainder/denom));\\n            remainder = remainder % denominator;\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        /* we need to take care of \\n        a) sign\\n        b) overflow case of -ve case of Integer.MAX_VALUE;\\n        c) memory overflow\\n        */\\n        if(numerator==0)\\n            return new String(\"0\");\\n        StringBuilder result = new StringBuilder();\\n        /* handle the sign */\\n        if(numerator <0 ^ denominator <0)\\n            result.append(\"-\");\\n        \\n        /* converting to long other wise -ve case of Integer.MAX_VALUE will\\n        overflow */\\n        long num = Math.abs(Long.valueOf(numerator));\\n        long denom = Math.abs(Long.valueOf(denominator));\\n        result.append(num/denom);\\n        long remainder = num % denom;\\n        if(remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        Map<Long,Integer> store = new HashMap<>(); \\n        while(remainder!=0){\\n            \\n            /* if the same remainder comes then we know that everything will\\n            repeat */\\n            if(store.containsKey(remainder)){\\n                result.insert(store.get(remainder),\"(\");\\n                result.append(\")\");\\n                break;\\n            }\\n            \\n            store.put(remainder,result.length());\\n            remainder*=10;\\n            result.append(String.valueOf(remainder/denom));\\n            remainder = remainder % denominator;\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515772,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        if (denominator == 0)\\n        {\\n            //throw new IllegalArgumentException(\" denominator can not be zero\");\\n            throw new ArgumentException(\" denominator can not be zero\");\\n        }\\n\\n        // avoid overflow for minimum value of integer\\n        long newNum = (long)numerator;\\n        long newDeNom = (long)denominator;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        // detect sign\\n        if ((newNum > 0 && newDeNom < 0) || (newNum < 0 && newDeNom > 0))\\n            sb.Append(\"-\");\\n        \\n        // make sure it is postive value\\n        newNum = Math.Abs(newNum);\\n        newDeNom = Math.Abs(newDeNom);      \\n\\n        sb.Append(newNum / newDeNom);\\n\\n        long remainder = newNum % newDeNom;\\n        Dictionary<long, int> remainderMap = new Dictionary<long, int>();\\n\\n        if (remainder != 0)\\n            sb.Append(\".\");\\n\\n        while (remainder != 0 && !remainderMap.ContainsKey(remainder))\\n        {\\n            remainderMap.Add(remainder, sb.Length);\\n            remainder *= 10;\\n            sb.Append(remainder / newDeNom);\\n            remainder = remainder % newDeNom; \\n        }\\n\\n        if (remainderMap.ContainsKey(remainder))\\n        {\\n            sb.Insert(remainderMap[remainder], \"(\");\\n            sb.Append(\")\");\\n        }\\n        return sb.ToString();\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        if (denominator == 0)\\n        {\\n            //throw new IllegalArgumentException(\" denominator can not be zero\");\\n            throw new ArgumentException(\" denominator can not be zero\");\\n        }\\n\\n        // avoid overflow for minimum value of integer\\n        long newNum = (long)numerator;\\n        long newDeNom = (long)denominator;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        // detect sign\\n        if ((newNum > 0 && newDeNom < 0) || (newNum < 0 && newDeNom > 0))\\n            sb.Append(\"-\");\\n        \\n        // make sure it is postive value\\n        newNum = Math.Abs(newNum);\\n        newDeNom = Math.Abs(newDeNom);      \\n\\n        sb.Append(newNum / newDeNom);\\n\\n        long remainder = newNum % newDeNom;\\n        Dictionary<long, int> remainderMap = new Dictionary<long, int>();\\n\\n        if (remainder != 0)\\n            sb.Append(\".\");\\n\\n        while (remainder != 0 && !remainderMap.ContainsKey(remainder))\\n        {\\n            remainderMap.Add(remainder, sb.Length);\\n            remainder *= 10;\\n            sb.Append(remainder / newDeNom);\\n            remainder = remainder % newDeNom; \\n        }\\n\\n        if (remainderMap.ContainsKey(remainder))\\n        {\\n            sb.Insert(remainderMap[remainder], \"(\");\\n            sb.Append(\")\");\\n        }\\n        return sb.ToString();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425909,
                "title": "python3-two-100-clear-workflow",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        res = \\'\\'\\n        # sign\\n        if numerator*denominator<0:\\n            res+=\\'-\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        \\n        # before point\\n        res+= str(numerator//denominator)\\n        carrier = numerator%denominator\\n        \\n        # after point\\n        if carrier>0:\\n            res+=\\'.\\'\\n        memo = {}\\n        while carrier>0:\\n            if carrier in memo:\\n                index = memo[carrier]\\n                res = res[:index]+\\'(\\'+res[index:] +\\')\\'\\n                return res\\n            else:\\n                memo[carrier]=len(res)\\n                res+=str((carrier*10)//denominator)\\n                carrier = ((carrier*10)%denominator)\\n                \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        res = \\'\\'\\n        # sign\\n        if numerator*denominator<0:\\n            res+=\\'-\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        \\n        # before point\\n        res+= str(numerator//denominator)\\n        carrier = numerator%denominator\\n        \\n        # after point\\n        if carrier>0:\\n            res+=\\'.\\'\\n        memo = {}\\n        while carrier>0:\\n            if carrier in memo:\\n                index = memo[carrier]\\n                res = res[:index]+\\'(\\'+res[index:] +\\')\\'\\n                return res\\n            else:\\n                memo[carrier]=len(res)\\n                res+=str((carrier*10)//denominator)\\n                carrier = ((carrier*10)%denominator)\\n                \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 405994,
                "title": "python-easy-understanding",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # if this can be divided completely\\n        if numerator % denominator == 0: return str(numerator // denominator)\\n        \\n        # extract the symbol of negative or positive number of the result\\n        sign = \\'-\\' if numerator * denominator < 0 else \\'\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        ans = \\'\\'\\n        rem_pos = {} # store recurring number\\n        i = numerator // denominator # integer part\\n        rem = numerator % denominator\\n        \\n        while rem != 0 and rem not in rem_pos:\\n            rem_pos[rem] = len(rem_pos) # {remainder : position}\\n            numerator = rem * 10\\n            \\n            dec_part = numerator // denominator\\n            ans += str(dec_part)\\n            \\n            rem = numerator % denominator\\n        \\n        if rem == 0: return sign + str(i) + \\'.\\' + ans # no recurring\\n        return sign + str(i) + \\'.\\' + ans[:rem_pos[rem]] + \\'(\\' + ans[rem_pos[rem]:] + \\')\\' # recurring\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # if this can be divided completely\\n        if numerator % denominator == 0: return str(numerator // denominator)\\n        \\n        # extract the symbol of negative or positive number of the result\\n        sign = \\'-\\' if numerator * denominator < 0 else \\'\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        ans = \\'\\'\\n        rem_pos = {} # store recurring number\\n        i = numerator // denominator # integer part\\n        rem = numerator % denominator\\n        \\n        while rem != 0 and rem not in rem_pos:\\n            rem_pos[rem] = len(rem_pos) # {remainder : position}\\n            numerator = rem * 10\\n            \\n            dec_part = numerator // denominator\\n            ans += str(dec_part)\\n            \\n            rem = numerator % denominator\\n        \\n        if rem == 0: return sign + str(i) + \\'.\\' + ans # no recurring\\n        return sign + str(i) + \\'.\\' + ans[:rem_pos[rem]] + \\'(\\' + ans[rem_pos[rem]:] + \\')\\' # recurring\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330668,
                "title": "c-100-beat-o-1-run-time-koderz-kamp-l33t-solution-kool",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool aNegative = (numerator < 0) != (denominator < 0);\\n        long long aNum = numerator, aDen = denominator;\\n        \\n        aNum = abs(aNum);\\n        aDen = abs(aDen);\\n        \\n        long long aDigit = aNum / aDen;\\n        string aResult = to_string(aDigit);\\n        \\n        long long aRemainder = (aNum % aDen) * 10;\\n        \\n        if (aNegative && (aDigit != 0 || aRemainder != 0)) {\\n            aResult = string(\"-\") + aResult;\\n        }\\n        \\n        if (aRemainder != 0) { \\n            \\n            aResult.append(\".\");\\n            unordered_map<int, int> aRepeatMap(64);\\n            \\n            while (aRemainder != 0) {\\n                if (aRepeatMap[aRemainder] != 0) {\\n                    aResult.insert(aRepeatMap[aRemainder], \"(\");\\n                    aResult.append(\")\");\\n                    break;\\n                } else {\\n                    aRepeatMap[aRemainder] = aResult.size();\\n                    aResult.append(to_string(aRemainder / aDen));\\n                    aRemainder = (aRemainder % aDen) * 10;\\n                }   \\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nFor some reason, I kept thinking the numerator had to be in the loop? I was doing it by hand, translating into code makes me rip out hairs. Ahh!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool aNegative = (numerator < 0) != (denominator < 0);\\n        long long aNum = numerator, aDen = denominator;\\n        \\n        aNum = abs(aNum);\\n        aDen = abs(aDen);\\n        \\n        long long aDigit = aNum / aDen;\\n        string aResult = to_string(aDigit);\\n        \\n        long long aRemainder = (aNum % aDen) * 10;\\n        \\n        if (aNegative && (aDigit != 0 || aRemainder != 0)) {\\n            aResult = string(\"-\") + aResult;\\n        }\\n        \\n        if (aRemainder != 0) { \\n            \\n            aResult.append(\".\");\\n            unordered_map<int, int> aRepeatMap(64);\\n            \\n            while (aRemainder != 0) {\\n                if (aRepeatMap[aRemainder] != 0) {\\n                    aResult.insert(aRepeatMap[aRemainder], \"(\");\\n                    aResult.append(\")\");\\n                    break;\\n                } else {\\n                    aRepeatMap[aRemainder] = aResult.size();\\n                    aResult.append(to_string(aRemainder / aDen));\\n                    aRemainder = (aRemainder % aDen) * 10;\\n                }   \\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314537,
                "title": "use-python-to-resolve-o-n",
                "content": "class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n\\n\\n        tag = -1 if numerator * denominator < 0 else 1 #\\u5224\\u65AD\\u662F\\u5426\\u6709\\u6B63\\u8D1F\\u53F7\\uFF0C\\u4EE3\\u7801\\u4E2D\\u7528\\u6B63\\u6570\\u8FDB\\u884C\\u76F8\\u9664\\uFF0C\\u82E5\\u6709\\u8D1F\\u53F7\\u6700\\u540E\\u52A0\\u4E0A\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        re_num = \\'\\'\\n        dictionary = {}\\n        while 1:\\n            if not re_num:#\\u9996\\u6B21\\u8FDB\\u884C\\u8BA1\\u7B97\\n                value = numerator // denominator\\n                numerator = numerator % denominator\\n                # print(value,numerator)\\n                if numerator == 0:#\\u65E0\\u5FAA\\u73AF\\n                    re_num += str(value)\\n                    return re_num if tag == 1 else \\'-\\' + re_num\\n                else:\\n                    re_num = str(value) + \\'.\\'\\n            else: #\\u540E\\u7EED\\u8BA1\\u7B97\\uFF0C\\u5373\\u5BFB\\u627E\\u5FAA\\u73AF\\u9879\\uFF0C\\u82E5\\u6CA1\\u6709\\uFF0C\\u76F4\\u63A5return\\n                numerator *= 10\\n                value = numerator // denominator\\n                numerator = numerator % denominator\\n\\n                if numerator == 0:#\\u65E0\\u5FAA\\u73AF\\n                    re_num += str(value)\\n                    return re_num if tag == 1 else \\'-\\' + re_num\\n                else:#\\u6709\\u5FAA\\u73AF\\u65F6\\u8FD4\\u56DE\\n                    if str(value) + \\' \\' + str(numerator) in dictionary:\\n                        re_num = re_num[:dictionary[str(value) + \\' \\' + str(numerator)]] + \\'(\\' + re_num[dictionary[str(\\n                            value) + \\' \\' + str(numerator)]:] + \\')\\'\\n                        return re_num if tag == 1 else \\'-\\' + re_num\\n                    else:\\n                        dictionary[str(value) + \\' \\' + str(numerator)] = len(re_num)\\n                        re_num += str(value)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n\\n\\n        tag = -1 if numerator * denominator < 0 else 1 #\\u5224\\u65AD\\u662F\\u5426\\u6709\\u6B63\\u8D1F\\u53F7\\uFF0C\\u4EE3\\u7801\\u4E2D\\u7528\\u6B63\\u6570\\u8FDB\\u884C\\u76F8\\u9664\\uFF0C\\u82E5\\u6709\\u8D1F\\u53F7\\u6700\\u540E\\u52A0\\u4E0A\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        re_num = \\'\\'\\n        dictionary = {}",
                "codeTag": "Java"
            },
            {
                "id": 239616,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n- After the decimal point, we need to record all the remainders and the corresponding position to insert `(`. \\n - When we get a new remainder which is not present in `HashMap`, then add it to the `HashMap` along with its position. This position will be helpful later in order to insert `(` in case when the remainder gets repeated.\\n - When the remainder is already in the `HashMap`, then it means the fractional part is repeating, so insert `(` to the corresponding position, then append `)` and break the loop.\\n\\nTime complexity : `O(k)` - where `k` is the number of times we get the distinct non-zero `remainder` during the fractional part division.\\nSpace complexity : `O(k)` - space required for `HashMap` to store distinct non-zero `remainders`.\\n\\n```\\nclass Solution\\n{\\n    public String fractionToDecimal(int numerator, int denominator)\\n\\t{\\n        Map<Long, Integer> map = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\t\\tlong r = n % d;\\n\\t\\t\\n        if(numerator != 0 && numerator > 0 ^ denominator > 0) \\n            sb.append(\"-\");\\n\\t\\t\\n        sb.append(n / d);                       // Integral part\\n\\n        if(r > 0)\\n\\t\\t\\tsb.append(\".\");\\t\\t\\t\\t\\t\\t// Fractional part\\n\\t\\t\\n        while(r > 0)\\n\\t\\t{\\n            if(map.containsKey(r))\\n\\t\\t\\t{\\n                int index = map.get(r);\\n                sb.insert(index, \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            else\\n\\t\\t\\t{\\n                map.put(r, sb.length());\\n                r = r * 10;\\n                sb.append(r / d);\\n                r = r % d;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String fractionToDecimal(int numerator, int denominator)\\n\\t{\\n        Map<Long, Integer> map = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\t\\tlong r = n % d;\\n\\t\\t\\n        if(numerator != 0 && numerator > 0 ^ denominator > 0) \\n            sb.append(\"-\");\\n\\t\\t\\n        sb.append(n / d);                       // Integral part\\n\\n        if(r > 0)\\n\\t\\t\\tsb.append(\".\");\\t\\t\\t\\t\\t\\t// Fractional part\\n\\t\\t\\n        while(r > 0)\\n\\t\\t{\\n            if(map.containsKey(r))\\n\\t\\t\\t{\\n                int index = map.get(r);\\n                sb.insert(index, \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            else\\n\\t\\t\\t{\\n                map.put(r, sb.length());\\n                r = r * 10;\\n                sb.append(r / d);\\n                r = r % d;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183567,
                "title": "concise-python-solution",
                "content": "```\\ndef fractionToDecimal(self, a, b):\\n        sg = \\'-\\'*int(a*b < 0)\\n        a, b = abs(a), abs(b)\\n        d, a = str(a//b), a % b        \\n        \\n        vis, s = [], []\\n        a *= 10\\n        while a not in vis and a != 0:                        \\n            vis.append(a)            \\n            s.append(str(a//b))\\n            a = 10*(a % b)\\n                      \\n        i = 0 if a == 0 else vis.index(a)        \\n        return \\'\\'.join([sg, d, \\'.\\'* (len(s)>0)] + s[:i] + [\\'(\\'*(a>0)] + s[i:] + [\\')\\'*(a>0)]) ",
                "solutionTags": [],
                "code": "```\\ndef fractionToDecimal(self, a, b):\\n        sg = \\'-\\'*int(a*b < 0)\\n        a, b = abs(a), abs(b)\\n        d, a = str(a//b), a % b        \\n        \\n        vis, s = [], []\\n        a *= 10\\n        while a not in vis and a != 0:                        \\n            vis.append(a)            \\n            s.append(str(a//b))\\n            a = 10*(a % b)\\n                      \\n        i = 0 if a == 0 else vis.index(a)        \\n        return \\'\\'.join([sg, d, \\'.\\'* (len(s)>0)] + s[:i] + [\\'(\\'*(a>0)] + s[i:] + [\\')\\'*(a>0)]) ",
                "codeTag": "Python3"
            },
            {
                "id": 170235,
                "title": "c-neat",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) \\n            return \"0\"; // For example 0/m\\n        \\n        string ans;\\n        if (numerator < 0 ^ denominator < 0) \\n            ans += \\'-\\'; // -n/m, or n/-m\\n        \\n        long n, d, r; // numerator, denominator, and remainder\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        \\n        ans += to_string(n/d);\\n        r = n % d;\\n        if (!r)\\n            return ans;    // n/m where n is multiple of m\\n        \\n        // Here we know that, we should calculate the fraction part.\\n        unordered_map<long, int> m; // map for remainder to quotient index\\n        long                     q; // quotient;\\n        ans += \\'.\\';\\n        r *= 10;\\n        while(r) {\\n            q = r / d;\\n            if (m.count(r)) {\\n                // Here we know that remainder is repeating, \\n                // hence fraction part will repeat, but what is the starting position\\n                // of repeating fraction part? its the index of the quotient when\\n                // we last saw this remainder. That is m[r]!\\n                ans.insert(m[r], 1, \\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += to_string(q);\\n            r = (r % d) * 10;       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) \\n            return \"0\"; // For example 0/m\\n        \\n        string ans;\\n        if (numerator < 0 ^ denominator < 0) \\n            ans += \\'-\\'; // -n/m, or n/-m\\n        \\n        long n, d, r; // numerator, denominator, and remainder\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        \\n        ans += to_string(n/d);\\n        r = n % d;\\n        if (!r)\\n            return ans;    // n/m where n is multiple of m\\n        \\n        // Here we know that, we should calculate the fraction part.\\n        unordered_map<long, int> m; // map for remainder to quotient index\\n        long                     q; // quotient;\\n        ans += \\'.\\';\\n        r *= 10;\\n        while(r) {\\n            q = r / d;\\n            if (m.count(r)) {\\n                // Here we know that remainder is repeating, \\n                // hence fraction part will repeat, but what is the starting position\\n                // of repeating fraction part? its the index of the quotient when\\n                // we last saw this remainder. That is m[r]!\\n                ans.insert(m[r], 1, \\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += to_string(q);\\n            r = (r % d) * 10;       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51119,
                "title": "golang-solution-using-math",
                "content": "Basic analysis can be borrowed from here:\\nhttp://yucoding.blogspot.com/2015/03/leetcode-question-fraction-to-recurring.html\\nBut the code can be simplified a bit.\\n\\n```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tflag := \"\"\\n\\tswitch {\\n\\tcase numerator < 0 && denominator < 0:\\n\\t\\tnumerator, denominator = -numerator, -denominator\\n\\tcase numerator > 0 && denominator < 0:\\n\\t\\tdenominator, flag = -denominator, \"-\"\\n\\tcase numerator < 0 && denominator > 0:\\n\\t\\tnumerator, flag = -numerator, \"-\"\\n\\t}\\n\\n\\tqua, rem := numerator/denominator, numerator%denominator\\n\\tres := []byte(strconv.FormatInt(int64(qua), 10))\\n\\tif rem == 0 {\\n\\t\\treturn flag + string(res)\\n\\t}\\n\\n\\tres = append(res, '.')\\n\\tm, curIndex := make(map[int]int), len(res)-1\\n\\tfor rem != 0 {\\n\\t\\tnumerator = rem * 10\\n\\t\\tqua, rem = numerator/denominator, numerator%denominator\\n\\n\\t\\tif index, ok := m[numerator]; ok {\\n\\t\\t\\tres = append(res, ')', ' ')\\n\\t\\t\\tcopy(res[index+1:], res[index:])\\n\\t\\t\\tres[index] = '('\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres = append(res, digitToByte(qua))\\n\\t\\tcurIndex++\\n\\t\\tm[numerator] = curIndex\\n\\t}\\n\\treturn flag + string(res)\\n}\\n\\nfunc digitToByte(digit int) byte {\\n\\treturn byte('0' + digit)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tflag := \"\"\\n\\tswitch {\\n\\tcase numerator < 0 && denominator < 0:\\n\\t\\tnumerator, denominator = -numerator, -denominator\\n\\tcase numerator > 0 && denominator < 0:\\n\\t\\tdenominator, flag = -denominator, \"-\"\\n\\tcase numerator < 0 && denominator > 0:\\n\\t\\tnumerator, flag = -numerator, \"-\"\\n\\t}\\n\\n\\tqua, rem := numerator/denominator, numerator%denominator\\n\\tres := []byte(strconv.FormatInt(int64(qua), 10))\\n\\tif rem == 0 {\\n\\t\\treturn flag + string(res)\\n\\t}\\n\\n\\tres = append(res, '.')\\n\\tm, curIndex := make(map[int]int), len(res)-1\\n\\tfor rem != 0 {\\n\\t\\tnumerator = rem * 10\\n\\t\\tqua, rem = numerator/denominator, numerator%denominator\\n\\n\\t\\tif index, ok := m[numerator]; ok {\\n\\t\\t\\tres = append(res, ')', ' ')\\n\\t\\t\\tcopy(res[index+1:], res[index:])\\n\\t\\t\\tres[index] = '('\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres = append(res, digitToByte(qua))\\n\\t\\tcurIndex++\\n\\t\\tm[numerator] = curIndex\\n\\t}\\n\\treturn flag + string(res)\\n}\\n\\nfunc digitToByte(digit int) byte {\\n\\treturn byte('0' + digit)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51154,
                "title": "easy-understanding",
                "content": "public class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator == 0) return \"0\";\\n        if (denominator == 0) return \"\";\\n\\n        \\n        StringBuffer sb = new StringBuffer();\\n        boolean flag = (numerator < 0) ^ (denominator < 0);\\n        \\n        long num = Math.abs(numerator);\\n        long den = Math.abs(denominator);\\n        num = Math.abs(num);\\n        den = Math.abs(den);\\n\\n        long n = num / den;\\n        long remainder = (num % den) * 10;\\n        \\n        sb.append(flag ? \"-\" : \"\");\\n        sb.append(n);\\n        sb.append(remainder!=0?\".\":\"\");\\n\\n        HashMap<Long, Integer> hashMap = new HashMap<>();\\n        \\n        while (remainder != 0) {\\n\\n            if (hashMap.containsKey(remainder)) {\\n                int len = hashMap.get(remainder);\\n                sb.insert(len,'(');\\n                sb.append(')');\\n                break;\\n            } \\n\\n            hashMap.put(remainder, sb.length());\\n            n = remainder / den;\\n            sb.append(n);\\n            remainder = (remainder % den) * 10;\\n        }\\n\\n\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator == 0) return \"0\";\\n        if (denominator == 0) return \"\";\\n\\n        \\n        StringBuffer sb = new StringBuffer();\\n        boolean flag = (numerator < 0) ^ (denominator < 0);\\n        \\n        long num = Math.abs(numerator);\\n        long den = Math.abs(denominator);\\n        num = Math.abs(num);\\n        den = Math.abs(den);\\n\\n        long n = num / den;\\n        long remainder = (num % den) * 10;\\n        \\n        sb.append(flag ? \"-\" : \"\");\\n        sb.append(n);\\n        sb.append(remainder!=0?\".\":\"\");\\n\\n        HashMap<Long, Integer> hashMap = new HashMap<>();\\n        \\n        while (remainder != 0) {\\n\\n            if (hashMap.containsKey(remainder)) {\\n                int len = hashMap.get(remainder);\\n                sb.insert(len,'(');\\n                sb.append(')');\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51188,
                "title": "python-solution-with-map",
                "content": "    class Solution:\\n    # @param {integer} numerator\\n    # @param {integer} denominator\\n    # @return {string}\\n    def fractionToDecimal(self, numerator, denominator):\\n        neg = False\\n        if numerator<0 and denominator>0 or numerator>0 and denominator<0:\\n            neg = True\\n            \\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        ans = str(numerator/denominator)\\n        if neg:\\n            ans = '-' + ans\\n            \\n        if numerator%denominator == 0:\\n            return ans\\n            \\n        dic = {}\\n        ans += '.'\\n        count = len(ans)\\n        \\n        \\n        tmp = numerator%denominator\\n        while True:\\n            if tmp not in dic:\\n                dic[tmp] = len(ans)\\n            else:\\n                ans = ans[:dic[tmp]] + '(' + ans[dic[tmp]:] + ')'\\n                break\\n            \\n            tmp *= 10\\n            if tmp < denominator:\\n                ans += '0'\\n                continue\\n            if tmp%denominator == 0:\\n                ans += str(tmp/denominator)\\n                break\\n            else:\\n                tmpans = tmp/denominator\\n                tmp = tmp%denominator\\n                ans += str(tmpans)\\n            \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 51210,
                "title": "2ms-c-solution-share-a-poor-coding-style",
                "content": "    class Solution {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tostringstream os;\\n                //dealing with denominator == 0\\n    \\t\\tif (denominator == 0){\\n    \\t\\t\\tos << INT_MAX;\\n    \\t\\t\\treturn os.str();\\n    \\t\\t}\\n                //dealing with numerator == 0\\n    \\t\\tif(numerator==0)\\n    \\t\\t    return \"0\";\\n                //others\\n    \\t\\tif ((numerator<0) ^ (denominator < 0))\\n    \\t\\t\\tos << '-';\\n    \\t\\tlong long x = abs((long long)numerator), y = abs((long long)denominator);\\n    \\t\\tos << x / y;\\n    \\t\\tif ((x %= y) == 0)\\n    \\t\\t\\treturn os.str();\\n    \\t\\tos << '.';\\n\\n    \\t    long long ax = x, ay = y;\\n    \\t\\tint i = 0, j = 0;\\n               //find the count of non_repeating part,it depends on how many 2 or 5 factor \\n               // are there in denominator\\n    \\t\\twhile (y % 2 == 0){\\n    \\t\\t\\ty /= 2;\\n    \\t\\t\\t++i;\\n    \\t\\t}\\n    \\t\\twhile (y % 5 == 0){\\n    \\t\\t\\ty /= 5;\\n    \\t\\t\\t++j;\\n    \\t\\t}\\n    \\t\\tint k = max(i, j);\\n                //non_repeating part\\n    \\t\\twhile (k != 0 && ax != 0){\\n    \\t\\t\\tax = ax * 10;\\n    \\t\\t\\tos << ax / ay;\\n    \\t\\t\\tax %= ay;\\n    \\t\\t\\t--k;\\n    \\t\\t}\\n    \\t\\tif (ax == 0)\\n    \\t\\t\\treturn os.str();\\n    \\t\\tlong long m = ax;\\n    \\t\\tos << '(';\\n                //repeating part\\n                //to find the repeating part ,we need to find when the denominator(here it is ax) repeats,\\n                //then we stop;\\n    \\t\\twhile (true){\\n    \\t\\t\\tax = ax * 10;\\n    \\t\\t\\tos << ax / ay;\\n    \\t\\t\\tif ((ax %= ay) == m)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tos << ')';\\n    \\t\\treturn os.str();\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tostringstream os;\\n                //dealing with denominator == 0\\n    \\t\\tif (denominator == 0){\\n    \\t\\t\\tos << INT_MAX;\\n    \\t\\t\\treturn os.str();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51214,
                "title": "4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string fractionToDecimal(int num, int den) {\\n            if (den == 0 || num == 0) {\\n                return \"0\";\\n            }\\n            string res = ((num < 0) ^ (den < 0)) == 1 ? \"-\" : \"\";\\n            // store as long since INT_MAX might come\\n            // also no overflow needed since string for INT_MIN/-1\\n            long a = abs((long)num);\\n            long b = abs((long)den);\\n            ostringstream os;\\n            os << a/b;\\n            res += os.str();\\n            if (a%b == 0) {\\n                return res;\\n            }\\n            \\n            res += \".\";\\n            unordered_map<int, int> pos_map;\\n            long x = a%b;\\n            string frac = \"\";\\n            while(x) {\\n                long d = (x*10)/b;\\n                ostringstream os;\\n                os << d;\\n                frac += os.str();\\n                pos_map[x] = frac.size()-1;\\n                x = (x*10)%b;\\n                if (pos_map.find(x) != pos_map.end()) {\\n                    int i = pos_map[x];\\n                    res += string(frac, 0, i) + \"(\" + string(frac, i, frac.size()-i) + \")\";\\n                    return res;\\n                }\\n            }\\n            \\n            return (res +  frac);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string fractionToDecimal(int num, int den) {\\n            if (den == 0 || num == 0) {\\n                return \"0\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3604036,
                "title": "most-efficient-js-solution-with-easy-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function takes two parameters: numerator and denominator, representing the fraction to be converted.\\n\\n2. The code first checks if the numerator is zero. If it is, it returns \"0\" as the decimal representation of the fraction.\\n\\n3. A variable named result is initialized as an empty string. This variable will store the decimal representation of the fraction.\\n\\n4. The code handles the sign of the resulting decimal by checking if the signs of the numerator and denominator are the same. If they are not, a \"-\" sign is added to the result.\\n\\n5. The numerator and denominator are converted to their absolute values using the Math.abs() function. This ensures that the calculations are performed correctly regardless of the sign.\\n\\n6. The integer part of the fraction is determined by dividing the absolute numerator by the absolute denominator and using Math.floor() to round down the division result. The integer part is added to the result.\\n\\n7. The code calculates the remainder of the division using the modulus operator (%). If the remainder is zero, it means there is no fractional part, so the result is returned.\\n\\n8. If there is a fractional part, a decimal point is added to the result.\\n\\n9. The code uses a Map called map to track the remainders and their positions. This is done to detect repeating patterns in the decimal representation of the fraction.\\n\\n10. The code enters a loop that continues until the remainder becomes zero. In each iteration, it checks if the remainder is already in the map. If it is, it means a repeating pattern is detected. The code retrieves the position of the previous occurrence of the remainder and adds parentheses around the repeating pattern in the result.\\n\\n11. If the remainder is not in the map, it is added to the map with its current position.\\n\\n12. The remainder is then multiplied by 10 and divided by the denominator. The floor value of this division is added to the result.\\n\\n13. The remainder is updated by taking the modulus of the division result with the denominator.\\n\\n14. Once the loop ends, the final result is returned.\\n\\n# Complexity\\n- Time complexity:\\nO(denominator)\\nwhere the denominator represents the size of the input denominator. This is because the loop iterates until the remainder becomes zero, and in the worst case, the remainder can take values from 1 to the denominator.\\n\\n- Space complexity:\\n O(denominator)\\nas the map can store up to denominator number of entries in the worst case scenario where there is a repeating pattern of length denominator.\\n\\n# Code\\n```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; // Special case for numerator equal to zero\\n  }\\n\\n  let result = \"\";\\n\\n  // Handle sign\\n  if (Math.sign(numerator) !== Math.sign(denominator)) {\\n    result += \"-\";\\n  }\\n\\n  // Convert to positive values\\n  const numer = Math.abs(numerator);\\n  const denom = Math.abs(denominator);\\n\\n  // Integer part\\n  result += Math.floor(numer / denom);\\n\\n  let remainder = numer % denom;\\n  if (remainder === 0) {\\n    return result; // No fractional part, return result\\n  }\\n\\n  result += \".\";\\n\\n  const map = new Map(); // To track remainders and their positions\\n\\n  while (remainder !== 0) {\\n    if (map.has(remainder)) {\\n      // Repeating pattern detected\\n      const index = map.get(remainder);\\n      result = result.slice(0, index) + \"(\" + result.slice(index) + \")\";\\n      break;\\n    }\\n\\n    map.set(remainder, result.length); // Store remainder and position\\n\\n    remainder *= 10;\\n    result += Math.floor(remainder / denom);\\n    remainder %= denom;\\n  }\\n\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; // Special case for numerator equal to zero\\n  }\\n\\n  let result = \"\";\\n\\n  // Handle sign\\n  if (Math.sign(numerator) !== Math.sign(denominator)) {\\n    result += \"-\";\\n  }\\n\\n  // Convert to positive values\\n  const numer = Math.abs(numerator);\\n  const denom = Math.abs(denominator);\\n\\n  // Integer part\\n  result += Math.floor(numer / denom);\\n\\n  let remainder = numer % denom;\\n  if (remainder === 0) {\\n    return result; // No fractional part, return result\\n  }\\n\\n  result += \".\";\\n\\n  const map = new Map(); // To track remainders and their positions\\n\\n  while (remainder !== 0) {\\n    if (map.has(remainder)) {\\n      // Repeating pattern detected\\n      const index = map.get(remainder);\\n      result = result.slice(0, index) + \"(\" + result.slice(index) + \")\";\\n      break;\\n    }\\n\\n    map.set(remainder, result.length); // Store remainder and position\\n\\n    remainder *= 10;\\n    result += Math.floor(remainder / denom);\\n    remainder %= denom;\\n  }\\n\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591102,
                "title": "python-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, n: int, d: int) -> str:\\n        sol = \"\"\\n        if n == 0:\\n            return \"0\"\\n        negative = (n < 0) ^ (d < 0)\\n        n = abs(n)\\n        d = abs(d)\\n        sol+=str(n // d)\\n\\n        dec = \"\"\\n        if n % d:\\n            nums = {}\\n            sol += \".\"\\n            n = n % d\\n            while n:\\n                if n in nums:\\n                    dec += \")\"\\n                    pos = nums[n]\\n                    dec = dec[:pos] + \"(\" + dec[pos:]\\n                    break\\n\\n                nums[n] = len(dec)\\n                n *= 10\\n                dec += str(n // d)\\n                n = n % d\\n                \\n        sign = \"-\" if negative else \"\"\\n        return sign + sol + dec\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, n: int, d: int) -> str:\\n        sol = \"\"\\n        if n == 0:\\n            return \"0\"\\n        negative = (n < 0) ^ (d < 0)\\n        n = abs(n)\\n        d = abs(d)\\n        sol+=str(n // d)\\n\\n        dec = \"\"\\n        if n % d:\\n            nums = {}\\n            sol += \".\"\\n            n = n % d\\n            while n:\\n                if n in nums:\\n                    dec += \")\"\\n                    pos = nums[n]\\n                    dec = dec[:pos] + \"(\" + dec[pos:]\\n                    break\\n\\n                nums[n] = len(dec)\\n                n *= 10\\n                dec += str(n // d)\\n                n = n % d\\n                \\n        sign = \"-\" if negative else \"\"\\n        return sign + sol + dec\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549719,
                "title": "166-fraction-to-recurring-decimal",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173413,
                "title": "java-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String fractionToDecimal(int num,int deno) {\\n        boolean isNegative = false;\\n        StringBuilder ans = new StringBuilder();\\n\\n        if(num<0 && deno>0 || num>0 && deno<0){\\n            ans.append(\\'-\\');\\n        } \\n        \\n        long quo = num/deno,rem =num%deno;\\n       \\n        ans.append(Math.abs(quo));\\n        if(rem==0){\\n            return ans.toString();\\n        }else{\\n            ans.append(\".\");\\n\\n            HashMap<Long,Integer> map = new HashMap<>();\\n            while(rem!=0){\\n                if(map.containsKey(rem)){\\n                    int pos = map.get(rem);\\n                    ans.insert(pos,\\'(\\');\\n                    ans.append(\\')\\');\\n                    break;\\n                }else{\\n                    map.put(rem,ans.length());\\n                    rem*=10;\\n                    quo=rem/deno;\\n                    rem=rem%deno;\\n                    ans.append(Math.abs(quo)); \\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int num,int deno) {\\n        boolean isNegative = false;\\n        StringBuilder ans = new StringBuilder();\\n\\n        if(num<0 && deno>0 || num>0 && deno<0){\\n            ans.append(\\'-\\');\\n        } \\n        \\n        long quo = num/deno,rem =num%deno;\\n       \\n        ans.append(Math.abs(quo));\\n        if(rem==0){\\n            return ans.toString();\\n        }else{\\n            ans.append(\".\");\\n\\n            HashMap<Long,Integer> map = new HashMap<>();\\n            while(rem!=0){\\n                if(map.containsKey(rem)){\\n                    int pos = map.get(rem);\\n                    ans.insert(pos,\\'(\\');\\n                    ans.append(\\')\\');\\n                    break;\\n                }else{\\n                    map.put(rem,ans.length());\\n                    rem*=10;\\n                    quo=rem/deno;\\n                    rem=rem%deno;\\n                    ans.append(Math.abs(quo)); \\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153685,
                "title": "c-straight-ward-solution-64ms-97",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        var sb = new StringBuilder();\\n\\n        if (numerator < 0 ^ denominator < 0 && numerator != 0) \\n            sb.Append(\\'-\\');\\n\\n        long n = Math.Abs((long)numerator);\\n        long d = Math.Abs((long)denominator);            \\n\\n        sb.Append(n / d);\\n\\n        n = n % d;\\n\\n        if (n != 0)\\n        {\\n            sb.Append(\\'.\\');\\n\\n            var f2Pos = new Dictionary<long, int>();\\n\\n            while (n != 0 && !f2Pos.ContainsKey(n))\\n            {\\n                f2Pos.Add(n,  sb.Length);\\n\\n                n = n * 10;\\n\\n                sb.Append(n / d);\\n\\n                n = n % d;\\n            }\\n\\n            if (f2Pos.ContainsKey(n))\\n            {\\n                sb.Insert(f2Pos[n], \\'(\\').Append(\\')\\');\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        var sb = new StringBuilder();\\n\\n        if (numerator < 0 ^ denominator < 0 && numerator != 0) \\n            sb.Append(\\'-\\');\\n\\n        long n = Math.Abs((long)numerator);\\n        long d = Math.Abs((long)denominator);            \\n\\n        sb.Append(n / d);\\n\\n        n = n % d;\\n\\n        if (n != 0)\\n        {\\n            sb.Append(\\'.\\');\\n\\n            var f2Pos = new Dictionary<long, int>();\\n\\n            while (n != 0 && !f2Pos.ContainsKey(n))\\n            {\\n                f2Pos.Add(n,  sb.Length);\\n\\n                n = n * 10;\\n\\n                sb.Append(n / d);\\n\\n                n = n % d;\\n            }\\n\\n            if (f2Pos.ContainsKey(n))\\n            {\\n                sb.Insert(f2Pos[n], \\'(\\').Append(\\')\\');\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033967,
                "title": "easy-c-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        // If numerator is zero then return 0;\\n        if (numerator == 0) \\n            return \"0\";\\n\\n        string res = \"\";\\n\\n        // Maybe numerator & denominator can be negative\\n        if ((numerator < 0) ^ (denominator < 0)) \\n            res += \\'-\\';\\n        \\n        /*\\n        // Also you can check for negative like\\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\\n            res += \\'-\\';\\n        */   \\n\\n        // Remove the negative sign from the numerator | denominator\\n        long dividend = abs((long) numerator);\\n        long divisor = abs((long) denominator);\\n\\n        // Find the remainder\\n        long rem = dividend % divisor;\\n\\n        // Add the numeric result\\n        res += to_string(dividend / divisor);\\n\\n        // in case no fractional part\\n        if (rem == 0)\\n            return res;\\n\\n        // If remainder is not 0 then they having fractional part so add the point for fraction\\n        res += \\'.\\';\\n\\n        unordered_map<long, int> map;\\n\\n        // Calculate division\\n        while(rem != 0) {\\n\\n            // Check for repeating part, If exist then insert in ();\\n            if (map.count(rem) > 0) {\\n                res.insert(map[rem], 1, \\'(\\');\\n                res += \\')\\';\\n                break;\\n            }\\n\\n            map[rem] = res.size();\\n\\n            rem *= 10;\\n\\n            // Add the quotient in result\\n            res += to_string(rem / divisor);\\n            rem %= divisor;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n# Upvote if it is useful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        // If numerator is zero then return 0;\\n        if (numerator == 0) \\n            return \"0\";\\n\\n        string res = \"\";\\n\\n        // Maybe numerator & denominator can be negative\\n        if ((numerator < 0) ^ (denominator < 0)) \\n            res += \\'-\\';\\n        \\n        /*\\n        // Also you can check for negative like\\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\\n            res += \\'-\\';\\n        */   \\n\\n        // Remove the negative sign from the numerator | denominator\\n        long dividend = abs((long) numerator);\\n        long divisor = abs((long) denominator);\\n\\n        // Find the remainder\\n        long rem = dividend % divisor;\\n\\n        // Add the numeric result\\n        res += to_string(dividend / divisor);\\n\\n        // in case no fractional part\\n        if (rem == 0)\\n            return res;\\n\\n        // If remainder is not 0 then they having fractional part so add the point for fraction\\n        res += \\'.\\';\\n\\n        unordered_map<long, int> map;\\n\\n        // Calculate division\\n        while(rem != 0) {\\n\\n            // Check for repeating part, If exist then insert in ();\\n            if (map.count(rem) > 0) {\\n                res.insert(map[rem], 1, \\'(\\');\\n                res += \\')\\';\\n                break;\\n            }\\n\\n            map[rem] = res.size();\\n\\n            rem *= 10;\\n\\n            // Add the quotient in result\\n            res += to_string(rem / divisor);\\n            rem %= divisor;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830411,
                "title": "0-ms-faster-than-100",
                "content": "\\n```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tvar res bytes.Buffer\\n\\tif ((numerator < 0) && (denominator > 0)) || ((numerator > 0) && (denominator < 0)) {\\n\\t\\tres.WriteString(\"-\")\\n\\t}\\n\\tnum := int(math.Abs(float64(numerator)))\\n\\tden := int(math.Abs(float64(denominator)))\\n\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\tnum %= den\\n\\tif num == 0 {\\n\\t\\treturn res.String()\\n\\t}\\n\\tres.WriteString(\".\")\\n\\tremainder := make(map[int]int)\\n\\tremainder[num] = res.Len()\\n\\tfor num != 0 {\\n\\t\\tnum *= 10\\n\\t\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\t\\tnum %= den\\n\\t\\tif index, ok := remainder[num]; ok {\\n\\t\\t\\tresult := res.String()\\n\\t\\t\\treturn result[:index] + \"(\" + result[index:] + \")\"\\n\\t\\t}\\n\\t\\tremainder[num] = res.Len()\\n\\t}\\n\\treturn res.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tvar res bytes.Buffer\\n\\tif ((numerator < 0) && (denominator > 0)) || ((numerator > 0) && (denominator < 0)) {\\n\\t\\tres.WriteString(\"-\")\\n\\t}\\n\\tnum := int(math.Abs(float64(numerator)))\\n\\tden := int(math.Abs(float64(denominator)))\\n\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\tnum %= den\\n\\tif num == 0 {\\n\\t\\treturn res.String()\\n\\t}\\n\\tres.WriteString(\".\")\\n\\tremainder := make(map[int]int)\\n\\tremainder[num] = res.Len()\\n\\tfor num != 0 {\\n\\t\\tnum *= 10\\n\\t\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\t\\tnum %= den\\n\\t\\tif index, ok := remainder[num]; ok {\\n\\t\\t\\tresult := res.String()\\n\\t\\t\\treturn result[:index] + \"(\" + result[index:] + \")\"\\n\\t\\t}\\n\\t\\tremainder[num] = res.Len()\\n\\t}\\n\\treturn res.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549434,
                "title": "best-explanation-clean-crisp-hashmap",
                "content": "Lets simulate the process of converting fraction to decimal. Lets look at the part where we have already figured out the integer part which is floor(numerator / denominator).\\nNow you are left with ( remainder = numerator%denominator ) / denominator.\\nIf you remember the process of converting to decimal, at each step you do the following :\\n\\n1) multiply the remainder by 10,\\n2) append remainder / denominator to your decimals\\n3) remainder = remainder % denominator.\\n\\nAt any moment, if your remainder becomes 0, you are done.\\n\\nHowever, there is a problem with recurring decimals. For example if you look at 1/3, the remainder never becomes 0.\\n\\nNotice one more important thing.\\nIf you start with remainder = R at any point with denominator d, you will always get the same sequence of digits.\\nSo, if your remainder repeats at any point of time, you know that the digits between the last occurrence of R will keep repeating.\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n        return \"0\";\\n        }\\n        if (denominator == 0) {\\n            return \"\";\\n        }\\n        string result = \"\";\\n        //std::cout << numerator << \" \" << denominator << endl;\\n        if ((numerator < 0) ^ (denominator < 0)) {\\n            //std::cout << \"True\" << endl;\\n            result += \"-\";\\n        }\\n        //numerator = abs(numerator);\\n        //denominator = abs(denominator);\\n        long num = numerator, den = denominator;\\n        num = abs(num);\\n        den = abs(den);\\n        long res = num/den;\\n        result += to_string(res);\\n    \\n        long rem = (num%den)*10;\\n        if (rem == 0) {\\n            return result;\\n        }\\n    \\n        std::map<long, int> mp;\\n        result += \".\";\\n        while (rem != 0) {\\n            if (mp.find(rem) != mp.end()) {\\n                int beg = mp[rem];\\n                string part1 = result.substr(0,beg);\\n                string part2 = result.substr(beg, result.length()-beg);\\n                result = part1 + \"(\"+part2+\")\";\\n                return result;\\n            }\\n            mp[rem] = result.length();\\n            res = rem/den;\\n            result += to_string(res);\\n            rem = (rem%den) *10;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n        return \"0\";\\n        }\\n        if (denominator == 0) {\\n            return \"\";\\n        }\\n        string result = \"\";\\n        //std::cout << numerator << \" \" << denominator << endl;\\n        if ((numerator < 0) ^ (denominator < 0)) {\\n            //std::cout << \"True\" << endl;\\n            result += \"-\";\\n        }\\n        //numerator = abs(numerator);\\n        //denominator = abs(denominator);\\n        long num = numerator, den = denominator;\\n        num = abs(num);\\n        den = abs(den);\\n        long res = num/den;\\n        result += to_string(res);\\n    \\n        long rem = (num%den)*10;\\n        if (rem == 0) {\\n            return result;\\n        }\\n    \\n        std::map<long, int> mp;\\n        result += \".\";\\n        while (rem != 0) {\\n            if (mp.find(rem) != mp.end()) {\\n                int beg = mp[rem];\\n                string part1 = result.substr(0,beg);\\n                string part2 = result.substr(beg, result.length()-beg);\\n                result = part1 + \"(\"+part2+\")\";\\n                return result;\\n            }\\n            mp[rem] = result.length();\\n            res = rem/den;\\n            result += to_string(res);\\n            rem = (rem%den) *10;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2511125,
                "title": "java-solution",
                "content": "Calculation of the Integral part is simple. Its basic division. \\nAfter that we need to multply the remainder by 10 and make it the new numerator and keep calculating the decimal part.\\nWe will save the states of the numerator and if the states get repeated again, this would mean that we have recurring part. Then we can just insert are brackets around the recurring part.\\n\\nIts basically the division algorithm with just a hashmap to check if there exists a recurrence in the fractional part of the number.\\n\\n```\\nclass Solution {\\n    HashMap<Long, Integer> visited = new HashMap<>(); \\n    // Stores states(numerators) and indices where the \\'(\\' would come if this is the state that starts the recurrence.\\n\\t\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long n = numerator;\\n        long d = denominator;\\n        boolean negative = false;\\n\\t\\t\\n\\t\\t// We calculate the answer as positive numbers and then add the signs at the end.\\n        if(n < 0){\\n            n*=-1;\\n            negative = true;\\n        }\\n        if(d < 0){\\n            d*=-1;\\n            negative = !negative;\\n        }\\n        \\n        String sign = \"\";\\n\\t\\t\\n        if(negative && n != 0){\\n            sign =\"-\";\\n        }\\n\\t\\t\\n\\t\\t//Preprocessing. We get the part before the decimal first. Then check if there exists a remainder.\\n\\t\\t// Only then do we preoceed ahead with the fractional part.\\n\\t\\t\\n        long q = n/d;\\n        long r = n%d;\\n        StringBuilder str = new StringBuilder(sign);\\n        str.append(q);\\n        if(r == 0){\\n            return str.toString();\\n        }\\n        str.append(\\'.\\');\\n        n = 10 * r;\\n        while(n > 0){\\n            if(visited.containsKey(n)){\\n                str.append(\\')\\');\\n                break;\\n            }\\n            visited.put(n, str.length());\\n            q = n/d;\\n            r = n %d;\\n            str.append(q);\\n            n = 10 * r;\\n        }\\n        if(visited.containsKey(n)){\\n            str.insert(visited.get(n), \"(\");\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Long, Integer> visited = new HashMap<>(); \\n    // Stores states(numerators) and indices where the \\'(\\' would come if this is the state that starts the recurrence.\\n\\t\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long n = numerator;\\n        long d = denominator;\\n        boolean negative = false;\\n\\t\\t\\n\\t\\t// We calculate the answer as positive numbers and then add the signs at the end.\\n        if(n < 0){\\n            n*=-1;\\n            negative = true;\\n        }\\n        if(d < 0){\\n            d*=-1;\\n            negative = !negative;\\n        }\\n        \\n        String sign = \"\";\\n\\t\\t\\n        if(negative && n != 0){\\n            sign =\"-\";\\n        }\\n\\t\\t\\n\\t\\t//Preprocessing. We get the part before the decimal first. Then check if there exists a remainder.\\n\\t\\t// Only then do we preoceed ahead with the fractional part.\\n\\t\\t\\n        long q = n/d;\\n        long r = n%d;\\n        StringBuilder str = new StringBuilder(sign);\\n        str.append(q);\\n        if(r == 0){\\n            return str.toString();\\n        }\\n        str.append(\\'.\\');\\n        n = 10 * r;\\n        while(n > 0){\\n            if(visited.containsKey(n)){\\n                str.append(\\')\\');\\n                break;\\n            }\\n            visited.put(n, str.length());\\n            q = n/d;\\n            r = n %d;\\n            str.append(q);\\n            n = 10 * r;\\n        }\\n        if(visited.containsKey(n)){\\n            str.insert(visited.get(n), \"(\");\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357200,
                "title": "37ms-python-solution-with-comments-using-dictionary",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Get sign\\n        negative = numerator * denominator < 0\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # First division\\n        quotient, remainder = divmod(numerator, denominator)\\n        remainders = {}\\n        res = [str(quotient)]\\n        \\n        # If not divided exactly, repeat until remainder is zero or loop\\n        i = 0\\n        while remainder != 0 and remainder not in remainders:\\n            remainders[remainder] = i\\n            quotient, remainder = divmod(remainder * 10, denominator)\\n            res.append(str(quotient))\\n            i += 1\\n        \\n        # Add sign\\n        if negative:\\n            res[0] = \\'-\\' + res[0]\\n        \\n        # Return result\\n        if remainder == 0:\\n            if len(res) == 1:\\n                return res[0]\\n            else:\\n                return res[0] + \\'.\\' + \\'\\'.join(res[1:])\\n\\n        return res[0] + \\'.\\' + \\'\\'.join(res[1:remainders[remainder] + 1]) + \\'(\\' + \\'\\'.join(res[remainders[remainder] + 1:]) + \\')\\'\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Get sign\\n        negative = numerator * denominator < 0\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # First division\\n        quotient, remainder = divmod(numerator, denominator)\\n        remainders = {}\\n        res = [str(quotient)]\\n        \\n        # If not divided exactly, repeat until remainder is zero or loop\\n        i = 0\\n        while remainder != 0 and remainder not in remainders:\\n            remainders[remainder] = i\\n            quotient, remainder = divmod(remainder * 10, denominator)\\n            res.append(str(quotient))\\n            i += 1\\n        \\n        # Add sign\\n        if negative:\\n            res[0] = \\'-\\' + res[0]\\n        \\n        # Return result\\n        if remainder == 0:\\n            if len(res) == 1:\\n                return res[0]\\n            else:\\n                return res[0] + \\'.\\' + \\'\\'.join(res[1:])\\n\\n        return res[0] + \\'.\\' + \\'\\'.join(res[1:remainders[remainder] + 1]) + \\'(\\' + \\'\\'.join(res[remainders[remainder] + 1:]) + \\')\\'\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2303120,
                "title": "easy-c-with-comments-code",
                "content": "\\tstring fractionToDecimal(int num, int den) {\\n\\t\\t\\tbool neg = (num<0)^(den<0) ? true: false;\\n\\t\\t\\tlong long int n = num;\\n\\t\\t\\tlong long int d = den;\\n\\t\\t\\tn = abs(n);\\n\\t\\t\\td = abs(d);\\n\\t\\t\\tlong long int tmp = n/d;\\n\\t\\t\\tstring res = \"\";\\n\\t\\t\\tif(neg && n!=0)\\n\\t\\t\\t res += \"-\";\\n\\n\\t\\t\\tres += to_string(tmp);\\n\\t\\t\\tn %= d;\\n\\t\\t\\tif(n==0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tres += \".\";\\n\\t\\t\\t// now before decimal, work is over now after decimal\\n\\t\\t\\tbool repeat = false;\\n\\t\\t\\tunordered_map<long long int, int> mp; // mapping from remainder to size of string\\n\\t\\t\\twhile(n!=0 && !repeat){\\n\\t\\t\\t\\tif(mp.find(n)==mp.end())\\n\\t\\t\\t\\t\\tmp[n] = res.size();\\n\\t\\t\\t\\telse if(mp.find(n)!=mp.end()){\\n\\t\\t\\t\\t\\t// repeat found\\n\\t\\t\\t\\t\\trepeat = true; // no need of repeat variable as we are breaking explicitly\\n\\t\\t\\t\\t\\tres.push_back(\\')\\');\\n\\t\\t\\t\\t\\tres.insert(mp[n],\"(\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn = n*10;\\n\\t\\t\\t\\tres += to_string(n/d);\\n\\t\\t\\t\\tn %= d;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tstring fractionToDecimal(int num, int den) {\\n\\t\\t\\tbool neg = (num<0)^(den<0) ? true: false;\\n\\t\\t\\tlong long int n = num;\\n\\t\\t\\tlong long int d = den;\\n\\t\\t\\tn = abs(n);\\n\\t\\t\\td = abs(d);\\n\\t\\t\\tlong long int tmp = n/d;\\n\\t\\t\\tstring res = \"\";\\n\\t\\t\\tif(neg && n!=0)\\n\\t\\t\\t res += \"-\";\\n\\n\\t\\t\\tres += to_string(tmp);\\n\\t\\t\\tn %= d;\\n\\t\\t\\tif(n==0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tres += \".\";\\n\\t\\t\\t// now before decimal, work is over now after decimal\\n\\t\\t\\tbool repeat = false;\\n\\t\\t\\tunordered_map<long long int, int> mp; // mapping from remainder to size of string\\n\\t\\t\\twhile(n!=0 && !repeat){\\n\\t\\t\\t\\tif(mp.find(n)==mp.end())\\n\\t\\t\\t\\t\\tmp[n] = res.size();\\n\\t\\t\\t\\telse if(mp.find(n)!=mp.end()){\\n\\t\\t\\t\\t\\t// repeat found\\n\\t\\t\\t\\t\\trepeat = true; // no need of repeat variable as we are breaking explicitly\\n\\t\\t\\t\\t\\tres.push_back(\\')\\');\\n\\t\\t\\t\\t\\tres.insert(mp[n],\"(\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn = n*10;\\n\\t\\t\\t\\tres += to_string(n/d);\\n\\t\\t\\t\\tn %= d;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2296524,
                "title": "easy-java-solution-with-explanations-run-time-2ms",
                "content": "\\n* Check for base conditions\\n*  If numerator ==0 return \"0\"\\n* if denominator==0 return \"\"\\n* check for the sign => if true then append a negative sign to the string builder\\n* append num/den to the string builder\\n* check for the remainder if remainder == 0 return the stringbuilder formed so far\\n* append \".\" to the final answer\\n* create a  Map<Long,Integer>map  to store remainder\\n* lopp till remainder!=0\\n* if map already contains remainder insert \"(\" and the position of map.get(rem)\\n* append \")\"  then break\\n* if not => map.put(rem ,currentlength of stringbuilder)\\n* multiply rem *10 append  rem/den to string Builder \\n* remainder = reminder%den\\n\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0)return \"0\";\\n        if(denominator==0)return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0)\\n            sb.append(\"-\");\\n        long nume = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long rem = nume%den;\\n        sb.append(nume/den);\\n        if(rem==0)return sb.toString();\\n        sb.append(\".\");\\n        Map<Long,Integer>map = new HashMap<>();\\n        while(rem!=0){\\n            if(map.containsKey(rem)){\\n                sb.insert(map.get(rem),\"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n           map.put(rem,sb.length());\\n           rem*=10;\\n           sb.append(rem/den);\\n           rem %= den; \\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n***IF YOU LIKED THE APPROACH PLEASE UPVOTE !!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0)return \"0\";\\n        if(denominator==0)return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0)\\n            sb.append(\"-\");\\n        long nume = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long rem = nume%den;\\n        sb.append(nume/den);\\n        if(rem==0)return sb.toString();\\n        sb.append(\".\");\\n        Map<Long,Integer>map = new HashMap<>();\\n        while(rem!=0){\\n            if(map.containsKey(rem)){\\n                sb.insert(map.get(rem),\"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n           map.put(rem,sb.length());\\n           rem*=10;\\n           sb.append(rem/den);\\n           rem %= den; \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098202,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        pre = \"-\" if numerator * denominator < 0 else \"\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        q, r = divmod(numerator, denominator)\\n        q = str(q)\\n        if r == 0:\\n            return pre + q\\n        res = pre + q + \".\"\\n        dic = {}\\n        idx = len(res)\\n        r *= 10\\n        while r > 0:\\n            if r in dic:\\n                return res[:dic[r]] + f\"({res[dic[r]:]})\"\\n            dic[r] = idx\\n            q, r = divmod(r, denominator)\\n            res += (q := str(q))\\n            if r == 0:\\n                return res\\n            idx += len(q)\\n            r *= 10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        pre = \"-\" if numerator * denominator < 0 else \"\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        q, r = divmod(numerator, denominator)\\n        q = str(q)\\n        if r == 0:\\n            return pre + q\\n        res = pre + q + \".\"\\n        dic = {}\\n        idx = len(res)\\n        r *= 10\\n        while r > 0:\\n            if r in dic:\\n                return res[:dic[r]] + f\"({res[dic[r]:]})\"\\n            dic[r] = idx\\n            q, r = divmod(r, denominator)\\n            res += (q := str(q))\\n            if r == 0:\\n                return res\\n            idx += len(q)\\n            r *= 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085538,
                "title": "c-easy-approach-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        string ans = \"\";\\n        \\n        int sign = 0;\\n        \\n        if(numerator < 0 and denominator < 0)\\n            sign = 0;\\n        else if(numerator < 0 and denominator > 0 || numerator > 0 and denominator < 0 )\\n            sign = 1;\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        long q = (n / d);\\n        long r = (n % d);\\n        ans += to_string(q);\\n        \\n        if(r == 0){\\n            if(sign == 1)\\n                ans.insert(ans.begin(),\\'-\\');\\n            return ans;\\n        }\\n        else{\\n            ans += \\'.\\';\\n            unordered_map<long, int> mp; \\n            while(r != 0){\\n                if(mp.find(r) != mp.end()){\\n                    int len = mp[r];\\n                    ans.insert(ans.begin()+len, \\'(\\');\\n                    ans.push_back(\\')\\');\\n                    break;\\n                }\\n                else{\\n                    mp.insert({r,ans.length()});\\n                }\\n                r = r * 10;\\n                q = (r/d);\\n                r = r % d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(sign == 1)\\n            ans.insert(ans.begin(),\\'-\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        string ans = \"\";\\n        \\n        int sign = 0;\\n        \\n        if(numerator < 0 and denominator < 0)\\n            sign = 0;\\n        else if(numerator < 0 and denominator > 0 || numerator > 0 and denominator < 0 )\\n            sign = 1;\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        long q = (n / d);\\n        long r = (n % d);\\n        ans += to_string(q);\\n        \\n        if(r == 0){\\n            if(sign == 1)\\n                ans.insert(ans.begin(),\\'-\\');\\n            return ans;\\n        }\\n        else{\\n            ans += \\'.\\';\\n            unordered_map<long, int> mp; \\n            while(r != 0){\\n                if(mp.find(r) != mp.end()){\\n                    int len = mp[r];\\n                    ans.insert(ans.begin()+len, \\'(\\');\\n                    ans.push_back(\\')\\');\\n                    break;\\n                }\\n                else{\\n                    mp.insert({r,ans.length()});\\n                }\\n                r = r * 10;\\n                q = (r/d);\\n                r = r % d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(sign == 1)\\n            ans.insert(ans.begin(),\\'-\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072354,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n  def fractionToDecimal(self, n, d):\\n    if n%d==0: return str(n // d)\\n    \\n    rdict, ds= {0:-1}, []\\n    \\n    sign, n, d = \\'-\\' if bool(n<0) ^ bool(d<0) else \\'\\', abs(n), abs(d)\\n    I, r = sign + str(n // d), n % d\\n    \\n    while r not in rdict:\\n      rdict[r] = len(ds)\\n      ds.append(str(r * 10 // d))\\n      r = r * 10 % d\\n    \\n    if r:\\n      i = rdict[r]\\n      return \\'{}.{}({})\\'.format(I, \\'\\'.join(ds[:i]),\\'\\'.join(ds[i:]))\\n    else:\\n      return \\'{}.{}\\'.format(I, \\'\\'.join(ds))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def fractionToDecimal(self, n, d):\\n    if n%d==0: return str(n // d)\\n    \\n    rdict, ds= {0:-1}, []\\n    \\n    sign, n, d = \\'-\\' if bool(n<0) ^ bool(d<0) else \\'\\', abs(n), abs(d)\\n    I, r = sign + str(n // d), n % d\\n    \\n    while r not in rdict:\\n      rdict[r] = len(ds)\\n      ds.append(str(r * 10 // d))\\n      r = r * 10 % d\\n    \\n    if r:\\n      i = rdict[r]\\n      return \\'{}.{}({})\\'.format(I, \\'\\'.join(ds[:i]),\\'\\'.join(ds[i:]))\\n    else:\\n      return \\'{}.{}\\'.format(I, \\'\\'.join(ds))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985646,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(n, d) {\\n    if (n === 0) {\\n        return \"0\";\\n    }\\n    const sign = n > 0 && d > 0 || n < 0 && d < 0 ? \"\" : \"-\";\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    let r = String(Math.trunc(n / d));\\n    let rem = n % d;\\n    if (rem === 0) {\\n        return sign + r;\\n    }\\n    \\n    r += \".\";\\n    const map = new Map();\\n    map.set(rem, r.length);\\n    while (rem > 0) {\\n        rem *= 10;\\n        r += String(Math.trunc(rem/d));\\n        rem = rem % d;\\n        const ex = map.get(rem);\\n        if (ex !== undefined) {\\n            return sign + r.substring(0, ex) + \"(\" + r.substring(ex) + \")\";\\n        }\\n        map.set(rem, r.length);\\n    }\\n    \\n    return sign + r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(n, d) {\\n    if (n === 0) {\\n        return \"0\";\\n    }\\n    const sign = n > 0 && d > 0 || n < 0 && d < 0 ? \"\" : \"-\";\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    let r = String(Math.trunc(n / d));\\n    let rem = n % d;\\n    if (rem === 0) {\\n        return sign + r;\\n    }\\n    \\n    r += \".\";\\n    const map = new Map();\\n    map.set(rem, r.length);\\n    while (rem > 0) {\\n        rem *= 10;\\n        r += String(Math.trunc(rem/d));\\n        rem = rem % d;\\n        const ex = map.get(rem);\\n        if (ex !== undefined) {\\n            return sign + r.substring(0, ex) + \"(\" + r.substring(ex) + \")\";\\n        }\\n        map.set(rem, r.length);\\n    }\\n    \\n    return sign + r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898401,
                "title": "my-cpp-solution",
                "content": "Implementation\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(!numerator) return \"0\";\\n        \\n        string ans;\\n        \\n        if((numerator > 0) ^ (denominator > 0)){\\n            ans += \"-\";\\n        }\\n        \\n\\t\\t// basically converting into the long abs value\\n        long num = labs(numerator), den = labs(denominator);\\n        \\n        long quotient = num / den;\\n        long remainder = num % den;\\n        if(!remainder){\\n            ans += to_string(quotient);\\n            return ans;\\n        }\\n        ans += to_string(quotient) + \\'.\\';\\n        unordered_map<long, int> freq;\\n        \\n        while(remainder){\\n            if(freq.find(remainder) != freq.end()){\\n                ans.insert(freq[remainder], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                freq[remainder] = ans.size();\\n                remainder *= 10;\\n                quotient = remainder / den;\\n                remainder = remainder % den;\\n                ans += to_string(quotient);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(!numerator) return \"0\";\\n        \\n        string ans;\\n        \\n        if((numerator > 0) ^ (denominator > 0)){\\n            ans += \"-\";\\n        }\\n        \\n\\t\\t// basically converting into the long abs value\\n        long num = labs(numerator), den = labs(denominator);\\n        \\n        long quotient = num / den;\\n        long remainder = num % den;\\n        if(!remainder){\\n            ans += to_string(quotient);\\n            return ans;\\n        }\\n        ans += to_string(quotient) + \\'.\\';\\n        unordered_map<long, int> freq;\\n        \\n        while(remainder){\\n            if(freq.find(remainder) != freq.end()){\\n                ans.insert(freq[remainder], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                freq[remainder] = ans.size();\\n                remainder *= 10;\\n                quotient = remainder / den;\\n                remainder = remainder % den;\\n                ans += to_string(quotient);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850961,
                "title": "plain-c-no-additional-memory-floyd-s-cycle-detection-algorithm",
                "content": "```\\n\\ntypedef long long i64;\\n\\nvoid next(i64* r, i64* n, i64 b) {\\n    *n = (*r*10) / b;\\n    *r = (*r*10) % b;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }\\n\\n    int start = 0;\\n    int len = 1;\\n\\n    r1 = a%b;\\n    \\n    // cycle start\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        next(&r2, &n2, b);\\n        start ++;\\n    }\\n\\n    // cycle len\\n    next(&r1, &n1, b);\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        len ++;\\n    }\\n\\n    if ((i64)numerator*(i64)denominator < 0) {\\n        sprintf(ret, \"-%lld\", a/b);\\n    } else {\\n        sprintf(ret, \"%lld\", a/b);\\n    }\\n    p += strlen(ret);\\n    \\n    r1 = a%b;\\n    next(&r1, &n1, b);\\n    for (i = 0; i < start; i++) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++ = n1 + \\'0\\';\\n        next(&r1, &n1, b);\\n    }\\n    if (len > 1 || n1 != 0) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++= \\'(\\';\\n        for (i = 0; i < len; i++) {\\n            *p++ = n1 + \\'0\\';\\n            next(&r1, &n1, b);\\n        }\\n        *p++= \\')\\';\\n    }\\n    *p++= 0;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\ntypedef long long i64;\\n\\nvoid next(i64* r, i64* n, i64 b) {\\n    *n = (*r*10) / b;\\n    *r = (*r*10) % b;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }\\n\\n    int start = 0;\\n    int len = 1;\\n\\n    r1 = a%b;\\n    \\n    // cycle start\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        next(&r2, &n2, b);\\n        start ++;\\n    }\\n\\n    // cycle len\\n    next(&r1, &n1, b);\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        len ++;\\n    }\\n\\n    if ((i64)numerator*(i64)denominator < 0) {\\n        sprintf(ret, \"-%lld\", a/b);\\n    } else {\\n        sprintf(ret, \"%lld\", a/b);\\n    }\\n    p += strlen(ret);\\n    \\n    r1 = a%b;\\n    next(&r1, &n1, b);\\n    for (i = 0; i < start; i++) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++ = n1 + \\'0\\';\\n        next(&r1, &n1, b);\\n    }\\n    if (len > 1 || n1 != 0) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++= \\'(\\';\\n        for (i = 0; i < len; i++) {\\n            *p++ = n1 + \\'0\\';\\n            next(&r1, &n1, b);\\n        }\\n        *p++= \\')\\';\\n    }\\n    *p++= 0;\\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1782737,
                "title": "c-100-2ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator  == 0) return \"0\";\\n        string ans ;\\n        ans+=((numerator>0)^(denominator>0))?\"-\":\"\";\\n        long n=abs(numerator),d=abs(denominator);\\n        ans+=to_string(n/d);\\n        n=n%d;\\n        if(!n) return ans;\\n        ans+=\".\";\\n        unordered_map<long ,int> mp;\\n        mp[n]=ans.size();\\n        while(n)\\n        {\\n            n*=10;\\n            ans+=to_string(n/d);\\n            n=n%d;\\n            if(mp[n])\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n           }\\n            mp[n]=ans.size();\\n        }\\n        return ans ;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator  == 0) return \"0\";\\n        string ans ;\\n        ans+=((numerator>0)^(denominator>0))?\"-\":\"\";\\n        long n=abs(numerator),d=abs(denominator);\\n        ans+=to_string(n/d);\\n        n=n%d;\\n        if(!n) return ans;\\n        ans+=\".\";\\n        unordered_map<long ,int> mp;\\n        mp[n]=ans.size();\\n        while(n)\\n        {\\n            n*=10;\\n            ans+=to_string(n/d);\\n            n=n%d;\\n            if(mp[n])\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1732890,
                "title": "easy-to-understand-c",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n\\n    unordered_map<int,int>mp;\\n    string fractionToDecimal(long num, long d) {\\n        long e1=num; long e2=d;\\n         num=abs(num); d=abs(d);// Here I am converting to positive numbers bcz I will face with modulo operator later\\n        mp={};\\n        int n=1e4; string ans;\\n          if((e1<0&&e2>0)||(e1>0&&e2<0))  ans=\\'-\\'+ans;\\n            long p=num/d; num=num%d;              \\n         ans+=to_string(p);\\n        if(num==0) return ans;\\n       ans+=\\'.\\';\\n        int r=0;         \\n        int u=ans.size();\\n        while(n--&&num){\\n            int z=0;\\n            num=num*10;\\n            int t=num/d;          \\n\\n            if(mp[num]==0)mp[num]=u;\\n            else {r=mp[num];break;}\\n                 u++;\\n            ans+=(t+\\'0\\');    num=num%d;        \\n        }\\n        if(r){\\n            ans.insert(ans.begin()+r,\\'(\\');\\n            ans.push_back(\\')\\');\\n        }           \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<int,int>mp;\\n    string fractionToDecimal(long num, long d) {\\n        long e1=num; long e2=d;\\n         num=abs(num); d=abs(d);// Here I am converting to positive numbers bcz I will face with modulo operator later\\n        mp={}",
                "codeTag": "Java"
            },
            {
                "id": 1722894,
                "title": "c-unordered-map-easy",
                "content": "```\\nstring fractionToDecimal(int numerator, int denominator) \\n    {\\n        string res=\"\";\\n        if(numerator==0)\\n            return \"0\";\\n        if(numerator>0^denominator>0)\\n            res+=\\'-\\';\\n        long num=abs(numerator);\\n        long den=abs(denominator);\\n        unordered_map<long, int> mp;\\n        \\n        res+=to_string(num/den);\\n        if(num%den==0)\\n            return res;\\n        res+=\\'.\\';\\n        \\n        long rem=num%den;\\n        \\n        while(rem)\\n        {\\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res.insert(mp[rem], \"(\");\\n                res+=\\')\\';\\n                break;\\n            }\\n            \\n            mp[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/den);\\n            rem%=den;\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring fractionToDecimal(int numerator, int denominator) \\n    {\\n        string res=\"\";\\n        if(numerator==0)\\n            return \"0\";\\n        if(numerator>0^denominator>0)\\n            res+=\\'-\\';\\n        long num=abs(numerator);\\n        long den=abs(denominator);\\n        unordered_map<long, int> mp;\\n        \\n        res+=to_string(num/den);\\n        if(num%den==0)\\n            return res;\\n        res+=\\'.\\';\\n        \\n        long rem=num%den;\\n        \\n        while(rem)\\n        {\\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res.insert(mp[rem], \"(\");\\n                res+=\\')\\';\\n                break;\\n            }\\n            \\n            mp[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/den);\\n            rem%=den;\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1694135,
                "title": "unordered-map-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        unordered_map<long, int> mp;\\n        \\n        if(numerator == 0) return \"0\";\\n        string ans = (numerator < 0) ^ (denominator < 0)? \"-\": \"\";\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        \\n        if(n){\\n            ans += \".\";\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n = n*10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0,mp[n]) + \"(\" + ans.substr(mp[n]) + \")\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        unordered_map<long, int> mp;\\n        \\n        if(numerator == 0) return \"0\";\\n        string ans = (numerator < 0) ^ (denominator < 0)? \"-\": \"\";\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        \\n        if(n){\\n            ans += \".\";\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n = n*10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0,mp[n]) + \"(\" + ans.substr(mp[n]) + \")\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690553,
                "title": "two-python-solutions-using-either-dictionary-get-or-list-index-in-try-except",
                "content": "Both of these solutions run in about the same amount of time, but with multiple submissions it appears the dictionary method is faster (fastest run was 28 ms), while the list method consistently uses less memory (14.2 MB vs 14.6 for the dict method). This makes sense since the dict has to store twice as much data (keys and values).\\nThe try/except block for the list will be a little slower, although I think that dict.get uses a try/except internally to return None when the key isn\\'t found.\\n\\nBoth solutions are using the same algorithm for long division.  A modulo operation is run to get the remainder, while int division (//) is used to get the next digit of the quotient.  Multiply the remainder by 10 for the next pass. We track all of the remainders we have seen in a dictionary or list. \\n  If the remainder ever equals 0, then the decimal is non repeating and we have finished division.\\n  If the remainder is one we have seen before, than the decimal is starting to repeat, and we can stop division after constructing the repeating portion, and also extracting any non-repeating leading portion.\\n  \\nSome key test cases to run in your testing:\\nnumerator = 0, denominator < 0  (I failed this edge case once, with output \\'-0\\')\\nnumerator = 1 denominator = 6 (or 12).  Repeating decimals, but the first few digits don\\'t repeat.\\nnumerator = 1, denominator = 9967.  Repeating decimal with 9966 digits in the repeating portion.\\n### Solution using List.index with Try/Except:\\n```python\\n  class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a list to track remainders we have seen\\n        seen_remainders = [remainder]\\n        decimal = \\'\\'   # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            \\n            # Check if we have seen this remainder before\\n            try:\\n                pattern_start = seen_remainders.index(remainder)\\n            except ValueError:\\n                # If not, add it to remainders we have seen\\n                seen_remainders.append(remainder)\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\\n\\n### Solution using a dictionary to track remainders seen\\n```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a dict to track remainders we have seen, where\\n        # key = remainder, value = index in the string decimal where remainder was seen.\\n        seen_remainders = {}\\n        idx = 0\\n        seen_remainders[remainder] = idx\\n        decimal = \\'\\' # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            idx += 1  # Increment the tracking index for the dictionary\\n            \\n            # Use dict.get to check our our remainder has already been seen\\n            pattern_start = seen_remainders.get(remainder)\\n            \\n            if pattern_start is None:\\n                # If not, add it to remainders we have seen\\n                seen_remainders[remainder] = idx\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n  class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a list to track remainders we have seen\\n        seen_remainders = [remainder]\\n        decimal = \\'\\'   # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            \\n            # Check if we have seen this remainder before\\n            try:\\n                pattern_start = seen_remainders.index(remainder)\\n            except ValueError:\\n                # If not, add it to remainders we have seen\\n                seen_remainders.append(remainder)\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\n```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a dict to track remainders we have seen, where\\n        # key = remainder, value = index in the string decimal where remainder was seen.\\n        seen_remainders = {}\\n        idx = 0\\n        seen_remainders[remainder] = idx\\n        decimal = \\'\\' # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            idx += 1  # Increment the tracking index for the dictionary\\n            \\n            # Use dict.get to check our our remainder has already been seen\\n            pattern_start = seen_remainders.get(remainder)\\n            \\n            if pattern_start is None:\\n                # If not, add it to remainders we have seen\\n                seen_remainders[remainder] = idx\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630639,
                "title": "easy-fast-c-solution",
                "content": "\\t\\tstring ans;\\n        long n, d, r;\\n        unorderedmap<long, int> m;\\n        long q;\\n        \\n        if(numerator ==0) return \"0\"; // for n/m = 0/m\\n        if(numerator<0 ^ denominator<0) ans +=\\'-\\'; // for -n/m or n/-m\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        ans += tostring(n/d);\\n        r = n % d;\\n        if(r == 0) return ans; // absolute value with no remainder\\n        ans += \".\";\\n        r = 10;\\n        while(r){\\n            q = r / d;\\n            if(m.count(r)){\\n                ans.insert(m[r],1,\\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += tostring(q);\\n            r = (r%d) 10;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t\\tstring ans;\\n        long n, d, r;\\n        unorderedmap<long, int> m;\\n        long q;\\n        \\n        if(numerator ==0) return \"0\"; // for n/m = 0/m\\n        if(numerator<0 ^ denominator<0) ans +=\\'-\\'; // for -n/m or n/-m\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        ans += tostring(n/d);\\n        r = n % d;\\n        if(r == 0) return ans; // absolute value with no remainder\\n        ans += \".\";\\n        r = 10;\\n        while(r){\\n            q = r / d;\\n            if(m.count(r)){\\n                ans.insert(m[r],1,\\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += tostring(q);\\n            r = (r%d) 10;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605510,
                "title": "go-solution-faster-than-100",
                "content": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n res := \"\"\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tif numerator < 0 && denominator < 0 {\\n\\t\\tnumerator = -numerator\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tif numerator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tnumerator = -numerator\\n\\t}\\n\\tif denominator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tres += strconv.Itoa(numerator / denominator)\\n\\tnumerator = numerator % denominator\\n\\tif numerator == 0 {\\n\\t\\treturn res\\n\\t}\\n\\tres += \".\"\\n\\tm := map[int]int{}\\n\\tfor numerator != 0 {\\n\\t\\tif i, ok := m[numerator]; ok {\\n\\t\\t\\tres = res[:i] + \"(\" + res[i:] + \")\"\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tm[numerator] = len(res)\\n\\t\\tnumerator *= 10\\n\\t\\tres += strconv.Itoa(numerator / denominator)\\n\\t\\tnumerator = numerator % denominator\\n\\t}\\n\\treturn res\\n}\\n",
                "solutionTags": [],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n res := \"\"\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tif numerator < 0 && denominator < 0 {\\n\\t\\tnumerator = -numerator\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tif numerator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tnumerator = -numerator\\n\\t}\\n\\tif denominator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tres += strconv.Itoa(numerator / denominator)\\n\\tnumerator = numerator % denominator\\n\\tif numerator == 0 {\\n\\t\\treturn res\\n\\t}\\n\\tres += \".\"\\n\\tm := map[int]int{}\\n\\tfor numerator != 0 {\\n\\t\\tif i, ok := m[numerator]; ok {\\n\\t\\t\\tres = res[:i] + \"(\" + res[i:] + \")\"\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tm[numerator] = len(res)\\n\\t\\tnumerator *= 10\\n\\t\\tres += strconv.Itoa(numerator / denominator)\\n\\t\\tnumerator = numerator % denominator\\n\\t}\\n\\treturn res\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1584325,
                "title": "straightforward-java-solution-w-explanation",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        String sign = (numerator < 0 && denominator < 0 || numerator >= 0 && denominator >= 0) ? \"\" : \"-\";\\n        long n = Math.abs(Long.valueOf(numerator));\\n        long d = Math.abs(Long.valueOf(denominator));\\n        sb.append(sign);\\n        // integral part\\n        sb.append(n / d);\\n        if (n % d == 0) return sb.toString();\\n        sb.append(\".\");\\n        // fractional part\\n        // keeps track of seen numerators and the length of sb\\n        Map<Long, Integer> m = new HashMap<>();\\n        while (n % d != 0) {\\n            n %= d;\\n            if (m.containsKey(n)) {\\n                // found a cycle\\n                sb.insert(m.get(n), \"(\");\\n                sb.append(\")\");\\n                return sb.toString();\\n            }\\n            m.put(n, sb.length());\\n            n *= 10;\\n            sb.append(n / d);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        String sign = (numerator < 0 && denominator < 0 || numerator >= 0 && denominator >= 0) ? \"\" : \"-\";\\n        long n = Math.abs(Long.valueOf(numerator));\\n        long d = Math.abs(Long.valueOf(denominator));\\n        sb.append(sign);\\n        // integral part\\n        sb.append(n / d);\\n        if (n % d == 0) return sb.toString();\\n        sb.append(\".\");\\n        // fractional part\\n        // keeps track of seen numerators and the length of sb\\n        Map<Long, Integer> m = new HashMap<>();\\n        while (n % d != 0) {\\n            n %= d;\\n            if (m.containsKey(n)) {\\n                // found a cycle\\n                sb.insert(m.get(n), \"(\");\\n                sb.append(\")\");\\n                return sb.toString();\\n            }\\n            m.put(n, sb.length());\\n            n *= 10;\\n            sb.append(n / d);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584088,
                "title": "java-solution-explanation",
                "content": "**Idea:**\\n1. In order to have a recurring decimal, 2 conditions MUST satisfy\\n\\t1. remainders MUST match\\n\\t2. the quotient digit where remainders are same MUST also match\\n2. We store the indexes of remainders in a `Map` \\n3. Wenever we find a repeating remainder, \\nwe check whether the quotients are also matching or not. \\nTo find the quotient digit, `ans[map[remainder]]`, where ans is our fraction part\\n4. Also, we need to deal with -ve numbers, so we do\\n\\t1. Widening Conversion (int -> long)\\n\\t2. explicitly check whether if exactly one input is -ve or not. \\n\\tIf yes, then `ans` will also be -ve\\n\\nBelow is the implementation of above approach\\n\\n\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String fractionToDecimal(int num, int den) {\\n\\n        String ans = \"\";\\n        \\n        // widening conversion to handle INT_MIN/INT_MAX\\n        long numerator = num; \\n        long denominator = den;\\n\\n        // ans will be -ve; if exactly one is -ve\\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {\\n            ans += \"-\";\\n        }\\n\\n        numerator = Math.abs(numerator);\\n        denominator = Math.abs(denominator);\\n        \\n        // does not have fraction part\\n        if (numerator % denominator == 0) {\\n            return ans + (numerator / denominator);\\n        }\\n\\n        long quotient = numerator / denominator;\\n        long remainder = numerator % denominator;\\n\\n        // real part\\n        ans += quotient + \".\";\\n\\n        ans += findFractionPart(remainder * 10, denominator);\\n\\n        return ans;\\n    }\\n\\n    String findFractionPart(long numerator, long denominator) {\\n\\n        StringBuilder ans = new StringBuilder();\\n        Map<Long, Integer> remIdx = new HashMap<>(); // holds indexes of remainders\\n        int idx = 0;\\n\\n        while (true) {\\n\\n            long quotient = numerator / denominator;\\n            long remainder = numerator % denominator;\\n\\n            if (remainder == 0) { // no recurring part present\\n                ans.append(quotient);\\n                break;\\n            }\\n\\n            \\n            /*\\n                in order to have a recurring decimal, 2 conditions must satisfy\\n                1. remainder is repeating\\n                2. the quotients of repeating remainder positions MUST also match  \\n            */\\n            \\n            if (remIdx.containsKey(remainder) && \\n                ans.charAt(remIdx.get(remainder)) == (quotient + \\'0\\')) { // same quotient\\n                \\n                // found recurring\\n                ans.insert(remIdx.get(remainder), \"(\");\\n                ans.append(\")\");\\n                break;\\n            } else {\\n\\t\\t\\t\\t// no recurring\\n                ans.append(quotient);\\n                remIdx.put(remainder, idx);\\n            }\\n\\n            // continue checking for next iteration\\n            idx++;\\n            numerator = remainder * 10;\\n\\n        }\\n\\n        return ans.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String fractionToDecimal(int num, int den) {\\n\\n        String ans = \"\";\\n        \\n        // widening conversion to handle INT_MIN/INT_MAX\\n        long numerator = num; \\n        long denominator = den;\\n\\n        // ans will be -ve; if exactly one is -ve\\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {\\n            ans += \"-\";\\n        }\\n\\n        numerator = Math.abs(numerator);\\n        denominator = Math.abs(denominator);\\n        \\n        // does not have fraction part\\n        if (numerator % denominator == 0) {\\n            return ans + (numerator / denominator);\\n        }\\n\\n        long quotient = numerator / denominator;\\n        long remainder = numerator % denominator;\\n\\n        // real part\\n        ans += quotient + \".\";\\n\\n        ans += findFractionPart(remainder * 10, denominator);\\n\\n        return ans;\\n    }\\n\\n    String findFractionPart(long numerator, long denominator) {\\n\\n        StringBuilder ans = new StringBuilder();\\n        Map<Long, Integer> remIdx = new HashMap<>(); // holds indexes of remainders\\n        int idx = 0;\\n\\n        while (true) {\\n\\n            long quotient = numerator / denominator;\\n            long remainder = numerator % denominator;\\n\\n            if (remainder == 0) { // no recurring part present\\n                ans.append(quotient);\\n                break;\\n            }\\n\\n            \\n            /*\\n                in order to have a recurring decimal, 2 conditions must satisfy\\n                1. remainder is repeating\\n                2. the quotients of repeating remainder positions MUST also match  \\n            */\\n            \\n            if (remIdx.containsKey(remainder) && \\n                ans.charAt(remIdx.get(remainder)) == (quotient + \\'0\\')) { // same quotient\\n                \\n                // found recurring\\n                ans.insert(remIdx.get(remainder), \"(\");\\n                ans.append(\")\");\\n                break;\\n            } else {\\n\\t\\t\\t\\t// no recurring\\n                ans.append(quotient);\\n                remIdx.put(remainder, idx);\\n            }\\n\\n            // continue checking for next iteration\\n            idx++;\\n            numerator = remainder * 10;\\n\\n        }\\n\\n        return ans.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562827,
                "title": "short-python-with-line-by-line-explanation-faster-than-100",
                "content": "The idea is to just follow what you would do by hand.\\n\\n* Keep dividing and take the remainder * 10 to be the new dividend.\\n* If remainder is 0, the decimal terminates, i.e., no repeating pattern.\\n* If remainder has already been encountered before, the decimal repeats from there.\\n\\n\\n```python\\n# One corner case.\\nif numerator == 0:\\n\\treturn \\'0\\'\\n\\n# Sign character is either \\'\\' (positive) or \\'-\\' (negative)\\nsign = \\'\\' if numerator * denominator > 0 else \\'-\\'\\n\\n# Sign is now taken care of, no need to worry about signs anymore.\\nn, d = abs(numerator), abs(denominator)\\n\\n# Prepare result string (to be returned).\\ninteger, remainder = divmod(n, d)  # n // d, n % d\\nresult = sign + str(integer) + (\\'.\\' if remainder else \\'\\')\\n\\n# Save remainder and its corresponding position to this dict:\\nr2p = {}  # remainder -> position in result string.\\n\\n# Stop when either remainder == 0 or remainder existed in r2p\\nwhile remainder and remainder not in r2p:\\n\\tr2p[remainder] = len(result)  # remainder position is just current length\\n\\tdigit, remainder = divmod(remainder * 10, d)\\n\\tresult += str(digit)  # add the digit to result string.\\n\\nif remainder == 0:  # i.e. no repeating decimals.\\n\\treturn result\\n\\np = r2p[remainder]  # the point at which decimal starts repeating.\\nreturn result[:p] + \\'(\\' + result[p:] + \\')\\'  # add parenthesis around it.\\n```",
                "solutionTags": [],
                "code": "```python\\n# One corner case.\\nif numerator == 0:\\n\\treturn \\'0\\'\\n\\n# Sign character is either \\'\\' (positive) or \\'-\\' (negative)\\nsign = \\'\\' if numerator * denominator > 0 else \\'-\\'\\n\\n# Sign is now taken care of, no need to worry about signs anymore.\\nn, d = abs(numerator), abs(denominator)\\n\\n# Prepare result string (to be returned).\\ninteger, remainder = divmod(n, d)  # n // d, n % d\\nresult = sign + str(integer) + (\\'.\\' if remainder else \\'\\')\\n\\n# Save remainder and its corresponding position to this dict:\\nr2p = {}  # remainder -> position in result string.\\n\\n# Stop when either remainder == 0 or remainder existed in r2p\\nwhile remainder and remainder not in r2p:\\n\\tr2p[remainder] = len(result)  # remainder position is just current length\\n\\tdigit, remainder = divmod(remainder * 10, d)\\n\\tresult += str(digit)  # add the digit to result string.\\n\\nif remainder == 0:  # i.e. no repeating decimals.\\n\\treturn result\\n\\np = r2p[remainder]  # the point at which decimal starts repeating.\\nreturn result[:p] + \\'(\\' + result[p:] + \\')\\'  # add parenthesis around it.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525698,
                "title": "using-hashmap-easy-to-understand-commented-solution-100-faster-c",
                "content": "```\\nclass Solution {\\n    \\n    void ComputeAfterDecimal(long num , long den , string &res){\\n        unordered_map<long , long>history;\\n        long q , r;\\n        \\n        while(num){\\n            q = num/den;\\n            r = num%den;\\n            \\n            //i have seen q for first time\\n            if(history.find(num) == history.end()){\\n                history[num] = res.size();\\n                res+=to_string(q);\\n                num =r*10;\\n            }\\n            //found a recurring event\\n            else{\\n                //insert brackets\\n                res = res.substr(0 , history[num]) + \"(\" + res.substr(history[num] ,res.size() -history[num] ) + \")\";\\n                break;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string res = \"\";\\n        //for negative numbers division\\n        if(( numerator >0 && denominator < 0) || (numerator <0 && denominator > 0) )\\n            res +=\"-\";\\n        \\n        //absolute divison\\n        long num = (long)abs(numerator);\\n        long den = (long)abs(denominator);\\n        \\n        //part before decimal point\\n        long q = num/den;\\n        long rem = num % den;\\n        \\n        res+=to_string(q);\\n        \\n        if(rem == 0)\\n            return res;\\n        \\n        //non-zero remainder which means i need a decimal point\\n        res+=\".\";\\n        \\n        ComputeAfterDecimal(rem*10 , den , res);\\n        \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void ComputeAfterDecimal(long num , long den , string &res){\\n        unordered_map<long , long>history;\\n        long q , r;\\n        \\n        while(num){\\n            q = num/den;\\n            r = num%den;\\n            \\n            //i have seen q for first time\\n            if(history.find(num) == history.end()){\\n                history[num] = res.size();\\n                res+=to_string(q);\\n                num =r*10;\\n            }\\n            //found a recurring event\\n            else{\\n                //insert brackets\\n                res = res.substr(0 , history[num]) + \"(\" + res.substr(history[num] ,res.size() -history[num] ) + \")\";\\n                break;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string res = \"\";\\n        //for negative numbers division\\n        if(( numerator >0 && denominator < 0) || (numerator <0 && denominator > 0) )\\n            res +=\"-\";\\n        \\n        //absolute divison\\n        long num = (long)abs(numerator);\\n        long den = (long)abs(denominator);\\n        \\n        //part before decimal point\\n        long q = num/den;\\n        long rem = num % den;\\n        \\n        res+=to_string(q);\\n        \\n        if(rem == 0)\\n            return res;\\n        \\n        //non-zero remainder which means i need a decimal point\\n        res+=\".\";\\n        \\n        ComputeAfterDecimal(rem*10 , den , res);\\n        \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523395,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator2, int denominator2) {\\n        if(!numerator2)\\n            return \"0\";\\n        string ans = (numerator2 < 0) ^ (denominator2 < 0)? \"-\": \"\", tmp = \"\";\\n        long long numerator = labs(numerator2);\\n        long long denominator = labs(denominator2);\\n        ans += to_string(numerator / denominator);\\n        numerator %= denominator;\\n        if(numerator){\\n            ans += \\'.\\';\\n            unordered_map<int, int> mp;\\n            while(numerator && mp.find(numerator) == mp.end()){\\n                mp[numerator] = tmp.size();\\n                numerator *= 10;\\n                tmp += to_string(numerator / denominator);\\n                numerator %= denominator;\\n            }\\n            //has loop, handle speically\\n            if(numerator)\\n                tmp = tmp.substr(0, mp[numerator]) + \"(\" + tmp.substr(mp[numerator]) + \")\";\\n        }\\n        return ans + tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator2, int denominator2) {\\n        if(!numerator2)\\n            return \"0\";\\n        string ans = (numerator2 < 0) ^ (denominator2 < 0)? \"-\": \"\", tmp = \"\";\\n        long long numerator = labs(numerator2);\\n        long long denominator = labs(denominator2);\\n        ans += to_string(numerator / denominator);\\n        numerator %= denominator;\\n        if(numerator){\\n            ans += \\'.\\';\\n            unordered_map<int, int> mp;\\n            while(numerator && mp.find(numerator) == mp.end()){\\n                mp[numerator] = tmp.size();\\n                numerator *= 10;\\n                tmp += to_string(numerator / denominator);\\n                numerator %= denominator;\\n            }\\n            //has loop, handle speically\\n            if(numerator)\\n                tmp = tmp.substr(0, mp[numerator]) + \"(\" + tmp.substr(mp[numerator]) + \")\";\\n        }\\n        return ans + tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498058,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0) return \"0\";\\n        bool numNegative=0, denNegative=0;\\n        long long int num=long(numerator), den=long(denominator);\\n        string ans=\"\";\\n        if(numerator<0) {\\n            numNegative=1;\\n            num=-num;\\n        }\\n        if(denominator<0){\\n            denNegative=1;\\n            den=-den;\\n        }\\n        long long int q=num/den;\\n        long long int r=num%den;\\n        ans+=to_string(q);\\n        if(r==0) ans=ans;\\n        else{\\n            ans+=\".\";\\n            unordered_map<long long int, long long int> mp;\\n            while(r){\\n                if(mp.find(r)!=mp.end()){\\n                    long long int len=mp[r];\\n                    ans.insert(len, \"(\");\\n                    ans+=\")\";\\n                    break;\\n                }\\n                else{\\n                    mp[r]=ans.size();\\n                    r*=10;\\n                    q=r/den;\\n                    r=r%den;\\n                    ans+=to_string(q);\\n                }\\n            }\\n        }\\n        if(numNegative && denNegative) ans=ans;\\n        else if(numNegative || denNegative) ans.insert(0,\"-\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0) return \"0\";\\n        bool numNegative=0, denNegative=0;\\n        long long int num=long(numerator), den=long(denominator);\\n        string ans=\"\";\\n        if(numerator<0) {\\n            numNegative=1;\\n            num=-num;\\n        }\\n        if(denominator<0){\\n            denNegative=1;\\n            den=-den;\\n        }\\n        long long int q=num/den;\\n        long long int r=num%den;\\n        ans+=to_string(q);\\n        if(r==0) ans=ans;\\n        else{\\n            ans+=\".\";\\n            unordered_map<long long int, long long int> mp;\\n            while(r){\\n                if(mp.find(r)!=mp.end()){\\n                    long long int len=mp[r];\\n                    ans.insert(len, \"(\");\\n                    ans+=\")\";\\n                    break;\\n                }\\n                else{\\n                    mp[r]=ans.size();\\n                    r*=10;\\n                    q=r/den;\\n                    r=r%den;\\n                    ans+=to_string(q);\\n                }\\n            }\\n        }\\n        if(numNegative && denNegative) ans=ans;\\n        else if(numNegative || denNegative) ans.insert(0,\"-\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479774,
                "title": "c-solution",
                "content": "```\\nlong abs1(long a){\\n    return a < 0 ? -a : a;\\n}\\n\\nlong repIndex(long* arr, long len, long num){\\n    for(int i = 0; i < len; i++){\\n        if(arr[i] == num)\\n            return i;\\n    }\\n    return -1;\\n}\\n\\nint length(int num){\\n    int len = num == 0 ? 1 : 0;\\n    while(num != 0){\\n        num /= 10;\\n        len ++;\\n    }\\n    return len;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }\\n    \\n//=========================================================================================\\n    bool repeat = 0;\\n    int fLen = 0, index = -1;                               //fLen: Fraction length, index: repeat at index (0.16666 -> index = 1)\\n    if(num % den){                                          //mod is not 0\\n        fLen ++;                                            //if mod is not 0, it has dot.\\n        int maxUnrepeated = length(den) + 1 /*2*/, realUnrepeated = 0;\\n        long *mods = malloc(maxUnrepeated * sizeof(long));  //Store unrepeated mods * 10. In the case of 1/6, it would be 1 * 10 and 4 * 10.\\n        long n = num % den * 10;                            //0.16666 -> n = 10\\n        do{\\n            if(realUnrepeated < maxUnrepeated){\\n                mods[realUnrepeated] = n;\\n                realUnrepeated ++;\\n            }\\n            fLen ++;\\n            n = n % den * 10;\\n            index = repIndex(mods, realUnrepeated, n);      //0.16666 -> index = 1\\n            if(index != -1){                                //if index != -1, n is found in mods[] \\n                repeat = 1;\\n                fLen += 2;                                  //()\\n                break;\\n            }\\n        }while(n);\\n    }\\n//=========================================================================================\\n    int len = sign + iLen + fLen;                           //0.1(6) -> 0 + 1 + 5\\n    char* r = malloc((len + 1) * sizeof(char)), *p = r;\\n\\n    //copy sign\\n    if(sign) *p++ = \\'-\\';\\n    \\n    //copy integer\\n    for(int i = iLen - 1; i >= 0; i--){\\n        p[i] = (integer % 10) + \\'0\\';\\n        integer /= 10;\\n    }\\n    \\n    if(fLen){\\n        p += iLen;                                         //move the pointer to the fractional part\\n        *p++ = \\'.\\';\\n    }\\n\\n    if(repeat){\\n        p[index] = \\'(\\';\\n        r[len - 1] = \\')\\';\\n        fLen -= 3;\\n    }\\n    \\n    //copy fraction\\n    long n = num, mod;\\n    for(int i = 0; i < fLen; i++){\\n        mod = n % den; //4\\n        n = mod * 10;\\n        if(p[i]==\\'(\\')p++;\\n        p[i] = n / den + \\'0\\';\\n    }\\n    \\n    r[len] = \\'\\\\0\\';\\n    return r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong abs1(long a){\\n    return a < 0 ? -a : a;\\n}\\n\\nlong repIndex(long* arr, long len, long num){\\n    for(int i = 0; i < len; i++){\\n        if(arr[i] == num)\\n            return i;\\n    }\\n    return -1;\\n}\\n\\nint length(int num){\\n    int len = num == 0 ? 1 : 0;\\n    while(num != 0){\\n        num /= 10;\\n        len ++;\\n    }\\n    return len;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }\\n    \\n//=========================================================================================\\n    bool repeat = 0;\\n    int fLen = 0, index = -1;                               //fLen: Fraction length, index: repeat at index (0.16666 -> index = 1)\\n    if(num % den){                                          //mod is not 0\\n        fLen ++;                                            //if mod is not 0, it has dot.\\n        int maxUnrepeated = length(den) + 1 /*2*/, realUnrepeated = 0;\\n        long *mods = malloc(maxUnrepeated * sizeof(long));  //Store unrepeated mods * 10. In the case of 1/6, it would be 1 * 10 and 4 * 10.\\n        long n = num % den * 10;                            //0.16666 -> n = 10\\n        do{\\n            if(realUnrepeated < maxUnrepeated){\\n                mods[realUnrepeated] = n;\\n                realUnrepeated ++;\\n            }\\n            fLen ++;\\n            n = n % den * 10;\\n            index = repIndex(mods, realUnrepeated, n);      //0.16666 -> index = 1\\n            if(index != -1){                                //if index != -1, n is found in mods[] \\n                repeat = 1;\\n                fLen += 2;                                  //()\\n                break;\\n            }\\n        }while(n);\\n    }\\n//=========================================================================================\\n    int len = sign + iLen + fLen;                           //0.1(6) -> 0 + 1 + 5\\n    char* r = malloc((len + 1) * sizeof(char)), *p = r;\\n\\n    //copy sign\\n    if(sign) *p++ = \\'-\\';\\n    \\n    //copy integer\\n    for(int i = iLen - 1; i >= 0; i--){\\n        p[i] = (integer % 10) + \\'0\\';\\n        integer /= 10;\\n    }\\n    \\n    if(fLen){\\n        p += iLen;                                         //move the pointer to the fractional part\\n        *p++ = \\'.\\';\\n    }\\n\\n    if(repeat){\\n        p[index] = \\'(\\';\\n        r[len - 1] = \\')\\';\\n        fLen -= 3;\\n    }\\n    \\n    //copy fraction\\n    long n = num, mod;\\n    for(int i = 0; i < fLen; i++){\\n        mod = n % den; //4\\n        n = mod * 10;\\n        if(p[i]==\\'(\\')p++;\\n        p[i] = n / den + \\'0\\';\\n    }\\n    \\n    r[len] = \\'\\\\0\\';\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463059,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    string fractionToDecimal(int num, int den) {\\n        string res=\"\";\\n        bool isNeg=false;\\n        if((num>0&&den<0)||(num<0&&den>0)){\\n            isNeg=true;\\n        }\\n        ll n=(ll)abs(num);\\n        ll d=(ll)abs(den);\\n        if(n%d==0){\\n            res=to_string(n/d);\\n        }\\n        else{\\n            ll rem=n%d;\\n            res=to_string(n/d);\\n            res+=\".\";\\n            string temp=\"\";\\n            unordered_map<ll,string> mp;\\n            mp[rem]=\"\";\\n            while(rem!=0){\\n                rem=rem*10;\\n                if(rem<d){\\n                    temp+=\"0\";\\n                }\\n                else{\\n                    temp+=to_string(rem/d);\\n                    rem=rem%d;\\n                    if(mp.find(rem)!=mp.end()){\\n                        temp=mp[rem]+\"(\"+ temp.substr(mp[rem].size()) +\")\";\\n                        break;\\n                    }\\n                    else{\\n                        mp[rem]=temp;\\n                    }\\n                }\\n            }\\n            \\n            res=res+temp;\\n            \\n        }\\n        \\n        \\n        if(isNeg) return \"-\"+res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    string fractionToDecimal(int num, int den) {\\n        string res=\"\";\\n        bool isNeg=false;\\n        if((num>0&&den<0)||(num<0&&den>0)){\\n            isNeg=true;\\n        }\\n        ll n=(ll)abs(num);\\n        ll d=(ll)abs(den);\\n        if(n%d==0){\\n            res=to_string(n/d);\\n        }\\n        else{\\n            ll rem=n%d;\\n            res=to_string(n/d);\\n            res+=\".\";\\n            string temp=\"\";\\n            unordered_map<ll,string> mp;\\n            mp[rem]=\"\";\\n            while(rem!=0){\\n                rem=rem*10;\\n                if(rem<d){\\n                    temp+=\"0\";\\n                }\\n                else{\\n                    temp+=to_string(rem/d);\\n                    rem=rem%d;\\n                    if(mp.find(rem)!=mp.end()){\\n                        temp=mp[rem]+\"(\"+ temp.substr(mp[rem].size()) +\")\";\\n                        break;\\n                    }\\n                    else{\\n                        mp[rem]=temp;\\n                    }\\n                }\\n            }\\n            \\n            res=res+temp;\\n            \\n        }\\n        \\n        \\n        if(isNeg) return \"-\"+res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413300,
                "title": "c-easy-to-understand-0ms-faster-than-100",
                "content": "```\\nstring fractionToDecimal(int numerator, int denominator) {\\n    long long int num = numerator;\\n    long long int den = denominator;\\n    if(num == 0)\\n        return \"0\";\\n    string res;\\n    int sign = 1;\\n    sign *= num > 0?1:-1;\\n    sign *= den >= 0 ? 1: -1;\\n    num = abs(num);\\n    den = abs(den);\\n    long long int quotient = num / den;\\n    num = num % den;\\n    if(num == 0)\\n        res += to_string(quotient);\\n    else\\n        res += to_string(quotient) + \".\";\\n    int every;\\n    vector<int> m_v;\\n    int x = res.size();\\n    int st = 0;\\n    while(num!=0){\\n        m_v.push_back(num);\\n        num *= 10;\\n        every = num / den;\\n        res += to_string(every);\\n        num %= den;\\n        auto it = std::find(m_v.begin(), m_v.end(), num);\\n        if(it != m_v.end()){\\n            st = it - m_v.begin() + x;\\n            res = res.substr(0, st) + \"(\" + res.substr(st) + \")\";\\n            break;\\n        }\\n    }\\n    if(sign == -1)\\n        res = \"-\" + res;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring fractionToDecimal(int numerator, int denominator) {\\n    long long int num = numerator;\\n    long long int den = denominator;\\n    if(num == 0)\\n        return \"0\";\\n    string res;\\n    int sign = 1;\\n    sign *= num > 0?1:-1;\\n    sign *= den >= 0 ? 1: -1;\\n    num = abs(num);\\n    den = abs(den);\\n    long long int quotient = num / den;\\n    num = num % den;\\n    if(num == 0)\\n        res += to_string(quotient);\\n    else\\n        res += to_string(quotient) + \".\";\\n    int every;\\n    vector<int> m_v;\\n    int x = res.size();\\n    int st = 0;\\n    while(num!=0){\\n        m_v.push_back(num);\\n        num *= 10;\\n        every = num / den;\\n        res += to_string(every);\\n        num %= den;\\n        auto it = std::find(m_v.begin(), m_v.end(), num);\\n        if(it != m_v.end()){\\n            st = it - m_v.begin() + x;\\n            res = res.substr(0, st) + \"(\" + res.substr(st) + \")\";\\n            break;\\n        }\\n    }\\n    if(sign == -1)\\n        res = \"-\" + res;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400356,
                "title": "intuitive-python-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator < 0 and denominator > 0:\\n            return \\'-\\'+self.fractionToDecimal(-numerator, denominator)\\n        elif numerator < 0 and denominator < 0:\\n            return self.fractionToDecimal(-numerator, -denominator)\\n        elif numerator > 0 and denominator < 0:\\n            return \\'-\\'+self.fractionToDecimal(numerator, -denominator)\\n        first, residual = numerator // denominator, numerator % denominator\\n        if not residual:\\n            return str(first)\\n        cur = list(str(first))+[\\'.\\']\\n        digit_map = {}\\n        ind = len(cur)\\n        while residual:\\n            new_numerator = residual * 10\\n            if new_numerator  in digit_map:\\n                cur.insert(digit_map[new_numerator ],\\'(\\')\\n                cur.append(\\')\\')\\n                break\\n            \\n            new_digit, residual = new_numerator//denominator, new_numerator%denominator\\n            cur.append(str(new_digit))\\n            digit_map[new_numerator] = ind \\n            ind += 1\\n            \\n        return \\'\\'.join(cur)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator < 0 and denominator > 0:\\n            return \\'-\\'+self.fractionToDecimal(-numerator, denominator)\\n        elif numerator < 0 and denominator < 0:\\n            return self.fractionToDecimal(-numerator, -denominator)\\n        elif numerator > 0 and denominator < 0:\\n            return \\'-\\'+self.fractionToDecimal(numerator, -denominator)\\n        first, residual = numerator // denominator, numerator % denominator\\n        if not residual:\\n            return str(first)\\n        cur = list(str(first))+[\\'.\\']\\n        digit_map = {}\\n        ind = len(cur)\\n        while residual:\\n            new_numerator = residual * 10\\n            if new_numerator  in digit_map:\\n                cur.insert(digit_map[new_numerator ],\\'(\\')\\n                cur.append(\\')\\')\\n                break\\n            \\n            new_digit, residual = new_numerator//denominator, new_numerator%denominator\\n            cur.append(str(new_digit))\\n            digit_map[new_numerator] = ind \\n            ind += 1\\n            \\n        return \\'\\'.join(cur)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397685,
                "title": "c-solution-with-explanation-faster-than-100",
                "content": "The basic idea is when you divide the numerator by the denominator, if there are recurring digits, then it is the result of **recurring remainders** when you repeat the process of adding 0 to the end of remainders and keep dividing. \\n\\nIn order to save those remainder for checking later, a `map<int, int>` is used here: the keys are previous remainders and the values are the position. You need to keep the position for duplicate checkings; the first duplicated position is also **the start of recurring part** (for example: 1/6 = 0.1(6) in which the recurring part start at 6, not 1)\\n\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        bool sign = (numerator <= 0 && denominator < 0) || (numerator >= 0 && denominator > 0);\\n        long long num = numerator; \\n        long long den = denominator;\\n        num = abs(num); \\n        den = abs(den); \\n        string real = to_string(num/den);\\n        if (!sign) \\n            real = \\'-\\' + real;\\n        string decimal = \".\";\\n        map<int, int> mp;\\n        mp.clear();\\n        long long rem = num % den;\\n        if (rem == 0) \\n            return real;\\n        while (rem != 0 && (mp.find(rem) == mp.end())) {\\n            mp[rem] = decimal.length();\\n            rem = rem * 10;\\n            decimal += (char)(\\'0\\' + rem/den);\\n            rem = rem % den;\\n        }\\n        if (rem == 0)\\n            return real + decimal;\\n        return real + decimal.substr(0, mp[rem]) + \\'(\\' + decimal.substr(mp[rem]) + \\')\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        bool sign = (numerator <= 0 && denominator < 0) || (numerator >= 0 && denominator > 0);\\n        long long num = numerator; \\n        long long den = denominator;\\n        num = abs(num); \\n        den = abs(den); \\n        string real = to_string(num/den);\\n        if (!sign) \\n            real = \\'-\\' + real;\\n        string decimal = \".\";\\n        map<int, int> mp;\\n        mp.clear();\\n        long long rem = num % den;\\n        if (rem == 0) \\n            return real;\\n        while (rem != 0 && (mp.find(rem) == mp.end())) {\\n            mp[rem] = decimal.length();\\n            rem = rem * 10;\\n            decimal += (char)(\\'0\\' + rem/den);\\n            rem = rem % den;\\n        }\\n        if (rem == 0)\\n            return real + decimal;\\n        return real + decimal.substr(0, mp[rem]) + \\'(\\' + decimal.substr(mp[rem]) + \\')\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383933,
                "title": "clean-and-understandable-typescript-solution",
                "content": "```\\nfunction fractionToDecimal(numerator: number, denominator: number): string {\\n  if (numerator === 0) {\\n    return \"0\";\\n  }\\n\\n  /*\\n    If either the numerator or denominator is negative but not both, \\n    the fraction will be negative as well.\\n  */\\n  const sign = numerator > 0 === denominator > 0 ? \"\" : \"-\";\\n\\n  numerator = Math.abs(numerator);\\n  denominator = Math.abs(denominator);\\n\\n  const wholeNumber = Math.floor(numerator / denominator);\\n\\n  return sign + wholeNumber + fraction(numerator % denominator, denominator);\\n}\\n\\nconst fraction = (remainder: number, denominator: number): string => {\\n  /*\\n    remainder will be 0 when there is no fractional part\\n  */\\n  if (remainder === 0) {\\n    return \"\";\\n  }\\n\\n  let fraction = \".\";\\n  const map = new Map<number, number>();\\n\\n  while (remainder !== 0) {\\n    /*\\n      We use remainder as the key for the index as it is unique for\\n      non-repeating fractions. It also handles the case where we have\\n      a final string of \"0.02301\" where the 0 repeats twice. However,\\n      the 0s have different remainders at calculation and as such\\n      don\\'t trigger the repeating sequence logic we have below.\\n\\n      For repeating fractions like \"0.012012\", the remainders for the \\n      0s are the same at calculation. From a logical standpoint, it has\\n      to be the same in order for the 2nd \"012\" sequence to be calculated\\n      the same.\\n    */\\n    map.set(remainder, fraction.length);\\n\\n    /*\\n      Step the remainder once to the right so we can keep filling out\\n      the fraction.\\n      \"0.0_\" -> \"0.01_\"\\n\\n      Fill the blank spot with the integer result of how many times\\n      denominator goes into remainder.\\n\\n      Remainder is then reset to the remainder of that division operation.\\n    */\\n    remainder *= 10;\\n    fraction += Math.floor(remainder / denominator);\\n    remainder %= denominator;\\n\\n    const remainderIndex = map.get(remainder);\\n    if (remainderIndex !== undefined) {\\n      return (\\n        fraction.slice(0, remainderIndex) +\\n        \"(\" +\\n        fraction.slice(remainderIndex) +\\n        \")\"\\n      );\\n    }\\n  }\\n\\n  return fraction;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction fractionToDecimal(numerator: number, denominator: number): string {\\n  if (numerator === 0) {\\n    return \"0\";\\n  }\\n\\n  /*\\n    If either the numerator or denominator is negative but not both, \\n    the fraction will be negative as well.\\n  */\\n  const sign = numerator > 0 === denominator > 0 ? \"\" : \"-\";\\n\\n  numerator = Math.abs(numerator);\\n  denominator = Math.abs(denominator);\\n\\n  const wholeNumber = Math.floor(numerator / denominator);\\n\\n  return sign + wholeNumber + fraction(numerator % denominator, denominator);\\n}\\n\\nconst fraction = (remainder: number, denominator: number): string => {\\n  /*\\n    remainder will be 0 when there is no fractional part\\n  */\\n  if (remainder === 0) {\\n    return \"\";\\n  }\\n\\n  let fraction = \".\";\\n  const map = new Map<number, number>();\\n\\n  while (remainder !== 0) {\\n    /*\\n      We use remainder as the key for the index as it is unique for\\n      non-repeating fractions. It also handles the case where we have\\n      a final string of \"0.02301\" where the 0 repeats twice. However,\\n      the 0s have different remainders at calculation and as such\\n      don\\'t trigger the repeating sequence logic we have below.\\n\\n      For repeating fractions like \"0.012012\", the remainders for the \\n      0s are the same at calculation. From a logical standpoint, it has\\n      to be the same in order for the 2nd \"012\" sequence to be calculated\\n      the same.\\n    */\\n    map.set(remainder, fraction.length);\\n\\n    /*\\n      Step the remainder once to the right so we can keep filling out\\n      the fraction.\\n      \"0.0_\" -> \"0.01_\"\\n\\n      Fill the blank spot with the integer result of how many times\\n      denominator goes into remainder.\\n\\n      Remainder is then reset to the remainder of that division operation.\\n    */\\n    remainder *= 10;\\n    fraction += Math.floor(remainder / denominator);\\n    remainder %= denominator;\\n\\n    const remainderIndex = map.get(remainder);\\n    if (remainderIndex !== undefined) {\\n      return (\\n        fraction.slice(0, remainderIndex) +\\n        \"(\" +\\n        fraction.slice(remainderIndex) +\\n        \")\"\\n      );\\n    }\\n  }\\n\\n  return fraction;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352484,
                "title": "c-faster-solution-with-comments",
                "content": "```cpp\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n     \\n        // Output string to store the answer\\n        string result = \"\";\\n \\n        // Ensure numerator is non-zero,\\n        // if numerator is zero , then return \"0\"\\n        if (numerator == 0){\\n            return \"0\";\\n        }\\n        \\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){\\n            result.append(\"-\");\\n        }\\n            \\n        // getting the absolute value of the numerator and denominator\\n        long long int n = abs(numerator);\\n        long long int d = abs(denominator);\\n        \\n        // Calculate the absolute part\\n        // (before decimal point), which is quotitent\\n        long long int quotitent = n / d;\\n            \\n        // Append the quotitent\\n        result += to_string(abs(quotitent));\\n        \\n        // If completely divisible, return answer.\\n        if (n % d == 0){\\n            return result;\\n        }\\n        \\n        // append the decimal \".\" dot\\n        result += \".\";\\n        \\n        // Initialize Remainder\\n        long remainder = n % d;\\n        \\n        // create the map to store the remainder\\n        map<int, int> remMap;\\n     \\n        // Position at which fraction starts repeating, if it exists\\n        int index;\\n        \\n        \\n        // run the loop till remainder becomes \"0\" and repeathing becomes \"true\"\\n        while (remainder > 0) {\\n            \\n            // If the remainder is already seen,\\n            // then there exists a repeating fraction.\\n            // break the loop and print the result, after appending the remainder\\n            if (remMap.find(remainder) != remMap.end()) {\\n     \\n                result.insert( remMap[remainder], \"(\");\\n                \\n                result.append(\")\");\\n                \\n                break;\\n            }\\n            // if no remainder found\\n            // add the remainder to the map \\n            // with key as remainder and value as size of the result\\n            else{\\n                remMap[remainder] = result.size();\\n            }\\n            \\n            remainder = remainder * 10;\\n \\n            // Calculate quotient, append it to result and\\n            // calculate next remainder\\n            long long int temp = remainder / d;\\n            \\n            remainder = remainder % denominatr;\\n            \\n            result += to_string(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n     \\n        // Output string to store the answer\\n        string result = \"\";\\n \\n        // Ensure numerator is non-zero,\\n        // if numerator is zero , then return \"0\"\\n        if (numerator == 0){\\n            return \"0\";\\n        }\\n        \\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){\\n            result.append(\"-\");\\n        }\\n            \\n        // getting the absolute value of the numerator and denominator\\n        long long int n = abs(numerator);\\n        long long int d = abs(denominator);\\n        \\n        // Calculate the absolute part\\n        // (before decimal point), which is quotitent\\n        long long int quotitent = n / d;\\n            \\n        // Append the quotitent\\n        result += to_string(abs(quotitent));\\n        \\n        // If completely divisible, return answer.\\n        if (n % d == 0){\\n            return result;\\n        }\\n        \\n        // append the decimal \".\" dot\\n        result += \".\";\\n        \\n        // Initialize Remainder\\n        long remainder = n % d;\\n        \\n        // create the map to store the remainder\\n        map<int, int> remMap;\\n     \\n        // Position at which fraction starts repeating, if it exists\\n        int index;\\n        \\n        \\n        // run the loop till remainder becomes \"0\" and repeathing becomes \"true\"\\n        while (remainder > 0) {\\n            \\n            // If the remainder is already seen,\\n            // then there exists a repeating fraction.\\n            // break the loop and print the result, after appending the remainder\\n            if (remMap.find(remainder) != remMap.end()) {\\n     \\n                result.insert( remMap[remainder], \"(\");\\n                \\n                result.append(\")\");\\n                \\n                break;\\n            }\\n            // if no remainder found\\n            // add the remainder to the map \\n            // with key as remainder and value as size of the result\\n            else{\\n                remMap[remainder] = result.size();\\n            }\\n            \\n            remainder = remainder * 10;\\n \\n            // Calculate quotient, append it to result and\\n            // calculate next remainder\\n            long long int temp = remainder / d;\\n            \\n            remainder = remainder % denominatr;\\n            \\n            result += to_string(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310874,
                "title": "100-faster-and-easier-c-solution",
                "content": "What you need to crack this is a hashmap and your childhood memories that you have with you of dividing numbers\\uD83E\\uDD17!\\nNote : Do check for sign as well.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(denominator == 0)\\n            return \"\";\\n        \\n        if(numerator == 0) \\n            return \"0\"; \\n        \\n        unordered_map<long, int> ump;\\n        string res;\\n        \\n        long quo = abs((long)numerator / (long)denominator);\\n        int sgn = 1;\\n\\n        if(numerator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(denominator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(sgn == -1)\\n        res+=\\'-\\';\\n\\n        res += to_string(quo);\\n\\n        long rem = abs((long)numerator % (long)denominator);\\n\\n        if(rem == 0) \\n        return res;\\n        res += \".\";\\n        \\n        while(rem)\\n        {\\n            ump[rem] = res.size();\\n            rem *= 10;\\n            res += to_string(rem / abs((long)denominator));\\n            rem %= abs((long)denominator);\\n            if(ump.find(rem) != ump.end())\\n            {\\n                res.insert(ump[rem], \"(\");\\n                res += \")\";\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(denominator == 0)\\n            return \"\";\\n        \\n        if(numerator == 0) \\n            return \"0\"; \\n        \\n        unordered_map<long, int> ump;\\n        string res;\\n        \\n        long quo = abs((long)numerator / (long)denominator);\\n        int sgn = 1;\\n\\n        if(numerator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(denominator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(sgn == -1)\\n        res+=\\'-\\';\\n\\n        res += to_string(quo);\\n\\n        long rem = abs((long)numerator % (long)denominator);\\n\\n        if(rem == 0) \\n        return res;\\n        res += \".\";\\n        \\n        while(rem)\\n        {\\n            ump[rem] = res.size();\\n            rem *= 10;\\n            res += to_string(rem / abs((long)denominator));\\n            rem %= abs((long)denominator);\\n            if(ump.find(rem) != ump.end())\\n            {\\n                res.insert(ump[rem], \"(\");\\n                res += \")\";\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263033,
                "title": "one-imp-thing-to-learn-regarding-the-integers",
                "content": "Must notice that for nume=-2147483648. \\nnume=abs(nume) will be same as nume and not the positive equivalent of it.\\nSo whenenver the input constraint is INT_MIN<=nume<=INT_MAX then always always, recieve the numbers in the funciton signature only in long long format or cast the number into higher data type and then perform the operations on it. \\nEg: \\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=n1;\\n    n*=-1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> 2147483648\\n```\\n\\nand notice this : \\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=-1*n1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> -2147483648\\n```\\n\\nHere is the solution : \\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    string fractionToDecimal(ll nume, ll deno) {\\n        if(nume==0) return \"0\";\\n        string ans=\"\";\\n        if((nume<0 or deno<0)and not(nume<0 and deno<0))\\n            ans+=\"-\";\\n        nume=abs(nume);\\n        deno=abs(deno);\\n        \\n        ans+=to_string(nume/deno);\\n        ll rem=nume%deno;\\n        if(rem==0){\\n            return ans;\\n        }\\n        //dealing with after float value\\n        ans+=\".\";\\n        map<ll,ll> mm;\\n        while(rem){\\n            if(mm.find(rem)!=mm.end()){\\n                auto it=mm.find(rem);\\n                int pos=it->second;\\n                string str1=ans.substr(0,pos);\\n                string str2=ans.substr(pos);\\n                ans=str1+\"(\"+str2+\")\";\\n                break;\\n            }\\n            else{\\n                mm.insert(make_pair(rem,ans.length()));\\n                rem*=10;\\n                int q=rem/deno;\\n                ans+=to_string(q);\\n                rem%=deno;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=n1;\\n    n*=-1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> 2147483648\\n```\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=-1*n1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> -2147483648\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    string fractionToDecimal(ll nume, ll deno) {\\n        if(nume==0) return \"0\";\\n        string ans=\"\";\\n        if((nume<0 or deno<0)and not(nume<0 and deno<0))\\n            ans+=\"-\";\\n        nume=abs(nume);\\n        deno=abs(deno);\\n        \\n        ans+=to_string(nume/deno);\\n        ll rem=nume%deno;\\n        if(rem==0){\\n            return ans;\\n        }\\n        //dealing with after float value\\n        ans+=\".\";\\n        map<ll,ll> mm;\\n        while(rem){\\n            if(mm.find(rem)!=mm.end()){\\n                auto it=mm.find(rem);\\n                int pos=it->second;\\n                string str1=ans.substr(0,pos);\\n                string str2=ans.substr(pos);\\n                ans=str1+\"(\"+str2+\")\";\\n                break;\\n            }\\n            else{\\n                mm.insert(make_pair(rem,ans.length()));\\n                rem*=10;\\n                int q=rem/deno;\\n                ans+=to_string(q);\\n                rem%=deno;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1257265,
                "title": "python-solution-annoying-to-get-every-little-piece-right",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        ans = \\'-\\' if numerator // denominator < 0 else \\'\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        prefrac = numerator // denominator\\n        ans += str(prefrac) \\n        \\n        rem = numerator % denominator\\n        if not rem:\\n            return ans\\n        ans += \\'.\\'\\n        remainder = \\'\\'\\n        seen = {}\\n        \\n        while rem not in seen:\\n            if rem == 0:\\n                return ans + remainder\\n            \\n            seen[rem] = len(remainder)\\n            rem *= 10\\n            remainder += str(rem//denominator)\\n            rem %= denominator\\n            \\n        return ans + remainder[:seen[rem]] + \\'(\\' + remainder[seen[rem]:] + \\')\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        ans = \\'-\\' if numerator // denominator < 0 else \\'\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        prefrac = numerator // denominator\\n        ans += str(prefrac) \\n        \\n        rem = numerator % denominator\\n        if not rem:\\n            return ans\\n        ans += \\'.\\'\\n        remainder = \\'\\'\\n        seen = {}\\n        \\n        while rem not in seen:\\n            if rem == 0:\\n                return ans + remainder\\n            \\n            seen[rem] = len(remainder)\\n            rem *= 10\\n            remainder += str(rem//denominator)\\n            rem %= denominator\\n            \\n        return ans + remainder[:seen[rem]] + \\'(\\' + remainder[seen[rem]:] + \\')\\'\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566944,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566482,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573920,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567896,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567897,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1570001,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573343,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1680418,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573302,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573002,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566944,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566482,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573920,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567896,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567897,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1570001,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573343,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1680418,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573302,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573002,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1571365,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1568993,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1572225,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1571364,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2048998,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2031528,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1967412,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1852823,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1796595,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1769745,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Permutation",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1725956,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try to think about the frequency of each letter. What if all characters appear with even times? What if some characters appear with odd times? :)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\nEvery letter in the word must be matched, except for possibly the middle one"
                    },
                    {
                        "username": "LethalQ",
                        "content": "appreciate it man, this one helped a lot, I mean it."
                    }
                ]
            },
            {
                "id": 1797677,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try to think about the frequency of each letter. What if all characters appear with even times? What if some characters appear with odd times? :)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\nEvery letter in the word must be matched, except for possibly the middle one"
                    },
                    {
                        "username": "LethalQ",
                        "content": "appreciate it man, this one helped a lot, I mean it."
                    }
                ]
            }
        ]
    }
]