[
    {
        "title": "Minimum Number of Operations to Make All Array Elements Equal to 1",
        "question_content": "You are given a 0-indexed&nbsp;array nums consisiting of positive integers. You can do the following operation on the array any number of times:\n\n\tSelect an index i such that 0 <= i < n - 1 and replace either of&nbsp;nums[i] or nums[i+1] with their gcd value.\n\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\nThe gcd of two integers is the greatest common divisor of the two integers.\n&nbsp;\nExample 1:\n\nInput: nums = [2,6,3,4]\nOutput: 4\nExplanation: We can do the following operations:\n- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].\n- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].\n- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].\n- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].\n\nExample 2:\n\nInput: nums = [2,10,6,14]\nOutput: -1\nExplanation: It can be shown that it is impossible to make all the elements equal to 1.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 50\n\t1 <= nums[i] <= 106\n\n&nbsp;\nFollow-up:\nThe O(n) time complexity&nbsp;solution works, but could you find an O(1) constant time complexity solution?",
        "solutions": [
            {
                "id": 3445725,
                "title": "explained-easy-gcd-and-intuition",
                "content": "# Intuition\\nQ1. When is gcd of 2 numbers =1 ? \\nA1. when both the numbers have no common factor. The gcd of 1 and any other number is always 1 itself. \\n\\nQ2. How is the property stated above beneficial?\\nA2. I just need to find the number of operations required to make any element as 1 and then the remaining n-1 elements can be made 1 in just n-1 steps where n is the size of the array. \\nElaborated: if we have a 1 at index \\u201Ci\\u201D then we would make element at i-1 => gcd(nums[i-1],nums[i]) this would make the element at index i-1 as 1 too! Then we\\u2019ll perform the same with i-2,i-3\\u2026.1 . without loss of generality we would perform the similar operations to the right of I as well! \\n\\nQ3. How do you get the minimum number of operations required to make any of the elements as 1?\\nA3. given the constraints, for any element I we can traverse through all elements (say iterator j) from i+1 to n and take their gcd. As soon as the gcd becomes 1 we can conclude that taking gcd in the reverse fashion (from nums[j] to nums[i]) would make nums[i] equal to 1. \\n\\nQ4. what if some 1s are already present in the array?\\nA4. In that case we can say that we would use the operation mentioned in A2 and make the remaining elements equal to 1. \\n\\nThe code is self-explanatory, let me know if you have any doubts! Thanks!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=1e7;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==1e7?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=1e7;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==1e7?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446148,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "<iframe src=\"https://leetcode.com/playground/9gLg2fYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Greedy"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/9gLg2fYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3445895,
                "title": "smallest-subarray-gcd-equal-to-1-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution \\n# Approach\\n1. The key is to find at least one 1 in th the nums, once found then other can be made 1 with n -1 operations.\\n2. To have least no. of operations we need to find the smallest subarray whose gcd is 1.\\n3. For this, with greedy approach we will check each sub array and evaluate gcd and keep storing the minimum length for which GCD is 1.\\n\\nCorner case : if there is already x no. of 1s in the array, then simply needed n-x no of operation.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int t = INT_MAX, count = 0;\\n        for(auto n: nums){ if(n == 1) count++; }\\n        if(count > 0) { return nums.size() - count; }\\n        for(int i = 0; i<nums.size(); ++i ){\\n            int last = nums[i];\\n            for(int j = i+1; j < nums.size(); ++j ){\\n                last = __gcd(last, nums[j]);\\n                if(last == 1) { t = min(t, j-i); break; }\\n            }\\n        }\\n        if(t != INT_MAX) return t + nums.size()-1;\\n        return -1;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int t = INT_MAX, count = 0;\\n        for(auto n: nums){ if(n == 1) count++; }\\n        if(count > 0) { return nums.size() - count; }\\n        for(int i = 0; i<nums.size(); ++i ){\\n            int last = nums[i];\\n            for(int j = i+1; j < nums.size(); ++j ){\\n                last = __gcd(last, nums[j]);\\n                if(last == 1) { t = min(t, j-i); break; }\\n            }\\n        }\\n        if(t != INT_MAX) return t + nums.size()-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445773,
                "title": "python3-gcd",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones: return len(nums)-ones\\n        diff = inf \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: diff = min(diff, j-i)\\n        return -1 if diff == inf else diff + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones: return len(nums)-ones\\n        diff = inf \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: diff = min(diff, j-i)\\n        return -1 if diff == inf else diff + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445663,
                "title": "cpp-make-exactly-one-element-1",
                "content": "\\n\\n\\n#### Intution : \\n* If we have one element `1` then we can make all elements `1`\\n* So our task is make exacty one element `1`\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD = 0, n = nums.size();\\n        // If GCD of all numbers in nums not equal to 1 then we can not make all element 1 return -1\\n        for(int i = 0; i < n; i++) GCD = __gcd(nums[i], GCD);\\n        if(GCD != 1) return -1;\\n        \\n        // If number of ones in given array is present then return n - cntOne\\n        int cntOne = count(nums.begin(), nums.end(), 1);\\n        if(cntOne) return n - cntOne; \\n        \\n        // calculate how many mininum operations needed to make one element in array is 1\\n        int mi = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            int res = nums[i];\\n            for(int j = i; j < n; j++) {\\n                res = __gcd(nums[j], res);\\n                if(res == 1) mi = min(mi, j - i);\\n            }\\n        }\\n        return n + mi - 1;\\n    }\\n};\\n```\\n>Have a good day. Happy Coding!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD = 0, n = nums.size();\\n        // If GCD of all numbers in nums not equal to 1 then we can not make all element 1 return -1\\n        for(int i = 0; i < n; i++) GCD = __gcd(nums[i], GCD);\\n        if(GCD != 1) return -1;\\n        \\n        // If number of ones in given array is present then return n - cntOne\\n        int cntOne = count(nums.begin(), nums.end(), 1);\\n        if(cntOne) return n - cntOne; \\n        \\n        // calculate how many mininum operations needed to make one element in array is 1\\n        int mi = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            int res = nums[i];\\n            for(int j = i; j < n; j++) {\\n                res = __gcd(nums[j], res);\\n                if(res == 1) mi = min(mi, j - i);\\n            }\\n        }\\n        return n + mi - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445720,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n * k)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c > 0)\\n        {\\n            return n - c;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                num = gcd(num, nums[j]);\\n                if(num == 1)\\n                {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1)\\n            {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE)\\n        {\\n            return -1;\\n        }\\n        return n - 1 + ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a, a); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c > 0)\\n        {\\n            return n - c;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                num = gcd(num, nums[j]);\\n                if(num == 1)\\n                {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1)\\n            {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE)\\n        {\\n            return -1;\\n        }\\n        return n - 1 + ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a, a); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447561,
                "title": "c-solution-o-n-most-optimised-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int one = 0;\\n        for (int i = 0; i < n; i++) one += nums[i] == 1;\\n        if (one) return n - one;\\n        stack<int> la, ra, lg, rg;\\n        auto good = [&](){\\n            int g = 0;\\n            if (!la.empty()) g = gcd(g, lg.top());\\n            if (!ra.empty()) g = gcd(g, rg.top());\\n            return g == 1;\\n        };\\n        auto add  = [&](int x){\\n            ra.push(x);\\n            rg.push(gcd((rg.empty() ? 0 : rg.top()), x));\\n        };\\n        auto remove = [&](){\\n            if (la.empty()){\\n                while(!ra.empty()){\\n                    int x = ra.top(); la.push(x); ra.pop(), rg.pop();\\n                    lg.push(gcd((lg.empty() ? 0 : lg.top()), x));\\n                }\\n            }\\n            la.pop(), lg.pop();\\n        };\\n        int ans = n;\\n        for (int l = 0, r = 0; r < n; r++){\\n            add(nums[r]);\\n            while (l < n and good()){\\n                ans = min(ans, r - l);\\n                remove(), l++;\\n            }\\n        }\\n        if (ans == n) return -1;\\n        return n + ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int one = 0;\\n        for (int i = 0; i < n; i++) one += nums[i] == 1;\\n        if (one) return n - one;\\n        stack<int> la, ra, lg, rg;\\n        auto good = [&](){\\n            int g = 0;\\n            if (!la.empty()) g = gcd(g, lg.top());\\n            if (!ra.empty()) g = gcd(g, rg.top());\\n            return g == 1;\\n        };\\n        auto add  = [&](int x){\\n            ra.push(x);\\n            rg.push(gcd((rg.empty() ? 0 : rg.top()), x));\\n        };\\n        auto remove = [&](){\\n            if (la.empty()){\\n                while(!ra.empty()){\\n                    int x = ra.top(); la.push(x); ra.pop(), rg.pop();\\n                    lg.push(gcd((lg.empty() ? 0 : lg.top()), x));\\n                }\\n            }\\n            la.pop(), lg.pop();\\n        };\\n        int ans = n;\\n        for (int l = 0, r = 0; r < n; r++){\\n            add(nums[r]);\\n            while (l < n and good()){\\n                ans = min(ans, r - l);\\n                remove(), l++;\\n            }\\n        }\\n        if (ans == n) return -1;\\n        return n + ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445880,
                "title": "o-nlog-max-a-i-solution-cpp",
                "content": "We have to find the shortest subarray with gcd equal to 1. This is a standard problem and can be solved greedily.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int g=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            g=__gcd(g,nums[i]);\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        \\n        if(g!=1)\\n            return -1;\\n        if(ones)\\n            return n-ones;\\n        \\n        int ans=1e9;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> nmp;\\n            nmp[nums[i]]=i;\\n            \\n            for(auto &[ele,r] : mp)\\n            {\\n                int val=__gcd(ele,nums[i]);\\n                if(nmp.find(val)==nmp.end())\\n                    nmp[val]=r;\\n                else\\n                    nmp[val]=std::max(nmp[val],r);\\n            }\\n                        \\n            if(nmp.find(1)!=nmp.end())\\n                ans=std::min(ans,n-1+i-nmp[1]);\\n            \\n            swap(nmp,mp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(Nlog(Max(A[i])))**\\nSpace Complexity : **O(log(Max(A[i])))**\\n\\nplease set better constraints.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int g=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            g=__gcd(g,nums[i]);\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        \\n        if(g!=1)\\n            return -1;\\n        if(ones)\\n            return n-ones;\\n        \\n        int ans=1e9;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> nmp;\\n            nmp[nums[i]]=i;\\n            \\n            for(auto &[ele,r] : mp)\\n            {\\n                int val=__gcd(ele,nums[i]);\\n                if(nmp.find(val)==nmp.end())\\n                    nmp[val]=r;\\n                else\\n                    nmp[val]=std::max(nmp[val],r);\\n            }\\n                        \\n            if(nmp.find(1)!=nmp.end())\\n                ans=std::min(ans,n-1+i-nmp[1]);\\n            \\n            swap(nmp,mp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465421,
                "title": "follow-up-is-misleading",
                "content": "The follow up asks if you can find a O(1) time algorithm after assuming that you found a O(n) algorithm. Even though the input size is 50, it\\'s technically not possible to get a true O(1) time algorithm here nor should it be assumed that a O(n) time algorithm is the standard solution for this problem. The follow up should be removed or reworded as it\\'s misleading.",
                "solutionTags": [],
                "code": "The follow up asks if you can find a O(1) time algorithm after assuming that you found a O(n) algorithm. Even though the input size is 50, it\\'s technically not possible to get a true O(1) time algorithm here nor should it be assumed that a O(n) time algorithm is the standard solution for this problem. The follow up should be removed or reworded as it\\'s misleading.",
                "codeTag": "Unknown"
            },
            {
                "id": 3446929,
                "title": "gcd-simple-explanation-java",
                "content": "**\\uD83D\\uDD1D\\uD83D\\uDD1D\\u2B06\\uFE0F\\u2B06\\uFE0FPlease Upvote if you find it useful. \\u2B06\\uFE0F\\u2B06\\uFE0F\\uD83D\\uDD1D\\uD83D\\uDD1D**\\n\\n# Intuition & Approach\\n1. If there are `x` numbers of `1` present in nums, then every number other than the `1s` can be converted to `1` in `n-x` operations by taking `gcd(1, nums[i])`, where `nums[i]!=1`.\\n2. If there are zero 1s present in nums, then we might never get a 1, or we might get a 1.\\n3. Let\\'s say there is a range `[i, j]` and the GCD of this entire range is `1`. That means, we can convert one of the elements in the range `[i, j]` to `1` in `(j-i)` operations.\\n4. Now once we convert any element to `1`, we can simply convert other elements to `1` in `(n - 1)` steps. So the total number of operations would be `(j - i + n - 1)`.\\n5. The Answer would be the minimum of this value over all possible ranges, where GCD of range is `1`.\\n\\n# Complexity\\n- Time complexity:\\n`O(N^2 * log(MAX))`, where `MAX` is the maximum value in the input array.\\n\\n- Space complexity:\\n`O(log(N))`\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOnes = 0;\\n        for (int num : nums) {\\n            if (num == 1) noOfOnes++;\\n        }\\n        if (noOfOnes > 0) return nums.length - noOfOnes;\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i]; // Take initial GCD of the [i, j] range\\n            for (int j = i + 1; j < nums.length; j++) {\\n                gcd = findGCD(gcd, nums[j]);  // For every new j, take gcd(nums[j], previousGCD) \\n                if (gcd == 1) ans = Math.min(ans, j - i + nums.length - 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    private int findGCD(int a, int b) {\\n        if (a == 0) return b;\\n        return findGCD(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOnes = 0;\\n        for (int num : nums) {\\n            if (num == 1) noOfOnes++;\\n        }\\n        if (noOfOnes > 0) return nums.length - noOfOnes;\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i]; // Take initial GCD of the [i, j] range\\n            for (int j = i + 1; j < nums.length; j++) {\\n                gcd = findGCD(gcd, nums[j]);  // For every new j, take gcd(nums[j], previousGCD) \\n                if (gcd == 1) ans = Math.min(ans, j - i + nums.length - 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    private int findGCD(int a, int b) {\\n        if (a == 0) return b;\\n        return findGCD(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445980,
                "title": "c-easiest-solution-with-amazing-explanation",
                "content": "# For the Given Problem:\\n**Task:\\n\\tConvert all the numbers to 1.\\n        At One step for any index i, you can convert nums[i] or nums[i+1] to gcd of them.\\n\\t\\treturn minimum number of operations or -1(if not possible)**\\n# Solution:\\n**1. Check when answer is not possible:**\\nIf gcd of all the numbers comes out to be not 1 then answer is -1 as we can\\'t achieve our    results.  Logic: If gcd of all the numbers can\\'t be one then gcd of any two numbers can also be not equal to 1.\\n\\n**2. If answer exist.**\\n  1. Calculate count of 1 in the nums, if ct>0 then we ans is ***(length of nums -ct)***\\n     Logic: We can use 1 to make all the remaining numbers 1 and for each number it takes one step.\\n\\t2. If no 1 is present in the nums, then find out how many operation require to convert every number to 1, and select the number which is taking the least operations to convert itself to 1 and then return ***number of operation to convert that number to 1 plus remaining numbers(n-1)***\\n\\n**TC: O(n^2)**\\n\\t \\n\\tclass Solution {\\n\\tpublic:\\n    \\n    int fn(vector<int>&nums)\\n    {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int v = __gcd(nums[i],nums[i+1]);\\n            ans.push_back(v);\\n            if(v==1) return 1;\\n        }        \\n        int val = 1+fn(ans);\\n        return val;\\n    }\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        // Step:1: ans not exist\\n        int all=nums[0];\\n        for(auto i:nums)\\n        {\\n            all = __gcd(all,i);\\n        }\\n        if(all!=1) return -1;\\n        \\n        // step:2 checking one is present or note\\n        int n = nums.size();\\n        int ct_one =0;\\n        for(auto i:nums)\\n        {\\n            if(i==1) ct_one++;\\n        }\\n        \\n        if(ct_one>0) return n-ct_one;\\n        \\n        // step-3 : checking for minimum operations.\\n        int val = fn(nums);\\n        return n-1+val;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    int fn(vector<int>&nums)\\n    {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int v = __gcd(nums[i],nums[i+1]);\\n            ans.push_back(v);\\n            if(v==1) return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3445894,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If we have 1 as an element, then it can be propagated to other elements since Gcd of any number and 1 is 1. \\n- So the answer is number of operations required to make any element 1 + number of remaining elements. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            // Compute gcd of all elements\\n            g = gcd(g, num);\\n\\n            // Count number of ones\\n            if (num == 1) \\n                one++;\\n        }\\n        // If Gcd of all elements is not 1, then we cannot produce \\n        // a 1 in any number of operations.\\n        if (g != 1) \\n            return -1;\\n\\n        // If there are already 1s in the array, \\n        // then simply return the number of remaining elements.\\n        if (one > 0) \\n            return n-one;\\n\\n        int ans = 100000;\\n        for (int i = 0; i < n; i++) {\\n            g = 0;\\n            for (int j = i; j >= 0; j--) {\\n                g = gcd(g, nums[j]);\\n                // If GCD of the subarray becomes 1,\\n                // count the number of operations (i-j) + remaining elements (n-1)\\n                if (g == 1) {\\n                    ans = Math.min(ans, i-j+n-1);\\n                    break;\\n                }\\n            }\\n        } \\n        return ans; \\n    }\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            // Compute gcd of all elements\\n            g = gcd(g, num);\\n\\n            // Count number of ones\\n            if (num == 1) \\n                one++;\\n        }\\n        // If Gcd of all elements is not 1, then we cannot produce \\n        // a 1 in any number of operations.\\n        if (g != 1) \\n            return -1;\\n\\n        // If there are already 1s in the array, \\n        // then simply return the number of remaining elements.\\n        if (one > 0) \\n            return n-one;\\n\\n        int ans = 100000;\\n        for (int i = 0; i < n; i++) {\\n            g = 0;\\n            for (int j = i; j >= 0; j--) {\\n                g = gcd(g, nums[j]);\\n                // If GCD of the subarray becomes 1,\\n                // count the number of operations (i-j) + remaining elements (n-1)\\n                if (g == 1) {\\n                    ans = Math.min(ans, i-j+n-1);\\n                    break;\\n                }\\n            }\\n        } \\n        return ans; \\n    }\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449499,
                "title": "python-o-n-time-solution-two-pass",
                "content": "The goal of this problem is to get **the minimun size of subarray with gcd 1**\\n\\nFor the 1st pass, \\nWe can record the gcd of the element with previous ones by traversing the array.\\nWhen gcd becomes to 1, the gcd will be reset as the current element.\\nMeanwhile, we will record this index, because it is the **ENDING** of subarray with gcd 1.\\n\\nFor the 2nd pass, \\nWe will traverse the array from each **ENDING** point BACK to index 0.\\nThe goal is to find the **BEGINING** of subarray with gcd 1 for each ENDING.\\n\\nNote the previous 2-pass traveral is performed **from left to right**.\\nWe need another 2-pass traveral **from right to left**.\\n\\n```\\ndef minOperations(self, a: List[int]) -> int:\\n\\tif 1 in a:\\n\\t\\treturn len(a)-a.count(1)\\n\\tdef check(nums):\\n\\t\\tq, x, count = [0], nums[0], len(nums)+10\\n\\t\\t# index-0 is needed since it defines the left bound of our traversal\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\tif x==1:\\n\\t\\t\\t\\tq, x = q+[i], nums[i] \\n\\t\\t\\t# recording the ending of subarray with gcd 1\\n\\t\\tfor k in range(len(q)-1, 0, -1):\\n\\t\\t\\tx = nums[q[k]]\\n\\t\\t\\t# searching for the beginning of subarray with each ending\\n\\t\\t\\tfor i in range(q[k], q[k-1]-1, -1):\\n\\t\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\t\\tif x==1:\\n\\t\\t\\t\\t\\tcount = min(count, q[k]-i+1)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn count\\n\\tx = min(check(a), check(a[::-1]))\\n\\t# with x-length of subarry, we need \\'x-1\\' operation to get 1\\n\\treturn len(a)+x-2 if x<=len(a) else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, a: List[int]) -> int:\\n\\tif 1 in a:\\n\\t\\treturn len(a)-a.count(1)\\n\\tdef check(nums):\\n\\t\\tq, x, count = [0], nums[0], len(nums)+10\\n\\t\\t# index-0 is needed since it defines the left bound of our traversal\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\tif x==1:\\n\\t\\t\\t\\tq, x = q+[i], nums[i] \\n\\t\\t\\t# recording the ending of subarray with gcd 1\\n\\t\\tfor k in range(len(q)-1, 0, -1):\\n\\t\\t\\tx = nums[q[k]]\\n\\t\\t\\t# searching for the beginning of subarray with each ending\\n\\t\\t\\tfor i in range(q[k], q[k-1]-1, -1):\\n\\t\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\t\\tif x==1:\\n\\t\\t\\t\\t\\tcount = min(count, q[k]-i+1)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn count\\n\\tx = min(check(a), check(a[::-1]))\\n\\t# with x-length of subarry, we need \\'x-1\\' operation to get 1\\n\\treturn len(a)+x-2 if x<=len(a) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3446079,
                "title": "gcd-100-faster-c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/c4eaaed5-229a-49e3-9e72-9a74dd7a7c94_1682226829.9661312.png)\\n````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int i,g= 0;\\n        for(i = 0; i < nums.size(); i++){\\n            g = __gcd(g,nums[i]);\\n        }\\n        if(g>1)return -1;\\n        int y = 0;\\n        for(auto &i: nums){\\n            y += (i==1);\\n        }\\n        if(y)return nums.size()-y;\\n        int x = INT_MAX,j;\\n        for(i = 0; i < nums.size(); i++){\\n            int g = 0;\\n            for(j = i; j < nums.size(); j++){\\n                g = __gcd(g,nums[j]);\\n                if(g==1)break;\\n            }\\n            if(g==1&&j-i+1<x){x = j-i+1;}\\n        }\\n        return nums.size()+x-2;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int i,g= 0;\\n        for(i = 0; i < nums.size(); i++){\\n            g = __gcd(g,nums[i]);\\n        }\\n        if(g>1)return -1;\\n        int y = 0;\\n        for(auto &i: nums){\\n            y += (i==1);\\n        }\\n        if(y)return nums.size()-y;\\n        int x = INT_MAX,j;\\n        for(i = 0; i < nums.size(); i++){\\n            int g = 0;\\n            for(j = i; j < nums.size(); j++){\\n                g = __gcd(g,nums[j]);\\n                if(g==1)break;\\n            }\\n            if(g==1&&j-i+1<x){x = j-i+1;}\\n        }\\n        return nums.size()+x-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445942,
                "title": "simple-c-solution-using-smallest-subarray-having-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can find smallest subarray with gcd 1, and we can make other element in n-1 operation. if gcd of whole array is greater than 1 then ans does not exist\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise and define function for gcd and smallest subarrayy having gcd as 1.\\n2. Check if gcd of whole array is greater than 1 or not, if it is greater than 1 then return -1.\\n3. count ones and if gcd of any two consecutive number is 1 then return n-ones.\\n4. Find smallest sub array having gcd 1, ans will be length of subarray - 1 + n-1.\\n\\n# Complexity\\n- Time complexity:N*LOG(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n\\t  if (b == 0)\\n\\t  {\\n\\t  \\treturn a;\\n\\t  }\\n\\t  return gcd(b, a % b);\\n    }\\n    int findSmallestSubArr(vector<int> &arr, int n, int g){\\n        int ans=INT_MAX,gg=0;\\n        for(int i=0;i<n;i++){\\n            gg=arr[i];\\n            for(int j=i;j<n;j++){\\n                if(arr[j]%g!=0) break;\\n                gg=gcd(gg,arr[j]);\\n                if(gg==g){\\n                    ans=min(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX ? -1:ans;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int g=nums[0];\\n        int one=0;\\n        for(auto x:nums)\\n        {\\n            if(x==1) one++;\\n            g=gcd(g,x);\\n        }\\n        if(g>1) return -1;\\n        bool ok=false;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(gcd(nums[i],nums[i-1])==1){\\n                ok=true;\\n                break;\\n            }\\n        }\\n        if(ok) return n-one;\\n  \\n      int d= findSmallestSubArr(nums,n,1);\\n       int ans=d-1+n-1;\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n\\t  if (b == 0)\\n\\t  {\\n\\t  \\treturn a;\\n\\t  }\\n\\t  return gcd(b, a % b);\\n    }\\n    int findSmallestSubArr(vector<int> &arr, int n, int g){\\n        int ans=INT_MAX,gg=0;\\n        for(int i=0;i<n;i++){\\n            gg=arr[i];\\n            for(int j=i;j<n;j++){\\n                if(arr[j]%g!=0) break;\\n                gg=gcd(gg,arr[j]);\\n                if(gg==g){\\n                    ans=min(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX ? -1:ans;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int g=nums[0];\\n        int one=0;\\n        for(auto x:nums)\\n        {\\n            if(x==1) one++;\\n            g=gcd(g,x);\\n        }\\n        if(g>1) return -1;\\n        bool ok=false;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(gcd(nums[i],nums[i-1])==1){\\n                ok=true;\\n                break;\\n            }\\n        }\\n        if(ok) return n-one;\\n  \\n      int d= findSmallestSubArr(nums,n,1);\\n       int ans=d-1+n-1;\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445685,
                "title": "brute-force-full-explained-c",
                "content": "# Intuition\\n- Is it possible to make all numbers equal to one if the $gcd$ of all elements is not $1$?\\n- What if we already have some $1$?\\n- By the limits can be solved with brute force\\n# Analysis\\nThe answer to the first question is no, since there will always be some common divisor other than one for each subset. \\n\\nNow if the $gcd$ of the whole matrix is $1$ that means that there exists at least one subset $s$ whose $gcd_s=1$ but thinking in subsets is not useful since we have to choose adjacent elements however we can observe that: \\n\\nIf we have some subset $s$ of size $k$ and $gcd_s=1$ with index $s_1, s_2,s_3,\\\\dots s_k$ and $s_i<s_{i+1} \\\\;,\\\\;\\\\; 0\\\\leq i \\\\leq k-1$ it is logical that the subarray defined by the indices $[s_1,s_k]$ will also have $gcd = 1$ and we can apply the operations in this order $(s_1, s_{1+1}), (s_{1+1},s_{1+2}), (s_{1+len-2}, s_k)$ (always changing the one on the right) where $len = s_k-s_1+1$ denotes the length of the subarray. Doing these operations we will have a $1$ at position $s_k$ let\\'s see a small example: \\n\\n$A = [6,18,9,90,45,5]$ let\\'s see that the subset $S = {2,4}$ has $gcd==1$ so the subarray $[2,5]$ also has $gcd==1$ let\\'s apply the operations on the subset $S = {2,4}$.\\n \\n$Op1 = (2,3)$  $\\\\rightarrow$ $A = [6,18,9,9,9,45,5]$\\n$Op2 = (3,4)$  $\\\\rightarrow$ $A = [6,18,9,9,9,9,9,5]$\\n$Op2 = (4,5)$  $\\\\rightarrow$ $A = [6,18,9,9,9,9,9,1,1]$\\n\\nNow, what happens when we have some $1$ in the array? we just have to propagate until we fill the array with ones and this will cost , $n-ones$ where $n$ is the size of the array. I recommend dealing with ones at the beginning, that is, find out if there are ones at the beginning and simply return $n-ones$ as the answer. \\n\\nAfter dealing with ones we have a situation where we have to create this first $1$ then propagate it, in this case the answer will be $bestcost+n-1$ where $bestCost$ is the best way to create just a $1$. now the rest is to find the best way. \\nNotice how the bounds are very small $1 \\\\leq n \\\\leq 50$ that means we can iterate over all the subarrays and check if one of them has $gcd=1$ and use the one with the shortest length, by choosing the subarray with the shortest length we will get that $bestCost = len-1$ where $len$ is the length.  \\n\\n# Approach\\n- Count the number of ones at the beginning \\n- If there is at least $1$ the answer will be $n-ones$. \\n- If not, we have to find the smallest subarray with $gcd==1$ and the answer will be $len-1 +n-1$. \\n- To check the best subarray we can use brute force, since the bounds are very small. \\n\\n# Hard version. \\nThis problem could have been a good hard problem, I don\\'t know why they decided to put a medium difficulty one.  \\n$n$ could be at most $1000$ for this solution and probably still pass in time, but what happens if $n \\\\leq 10^5$.\\n- Solution: Binary search + some data structure that allows to get gcd in range getting a solution $o(n log(n)^2)$ but you can even optimize up to $O(n log(MAX))$ without an advanced data structure. \\n\\n# Complexity \\n$O(n^2 \\\\times log(MAX))$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1e9;\\n        int ones = 0;\\n        for(int i = 0;i<n;i++)ones+=nums[i]==1;\\n        \\n        if(ones)return n-ones;\\n        \\n        for(int i = 0;i<n;i++){\\n            int gcd = 0;\\n            \\n            for(int j = i;j<n;j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                \\n                if(gcd == 1){\\n                    int len = (j-i)+1;\\n                    ans = min(ans,(len-1)+(n-1));\\n                }\\n            }\\n            \\n         \\n        \\n        }\\n        if(ans == 1e9)ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1e9;\\n        int ones = 0;\\n        for(int i = 0;i<n;i++)ones+=nums[i]==1;\\n        \\n        if(ones)return n-ones;\\n        \\n        for(int i = 0;i<n;i++){\\n            int gcd = 0;\\n            \\n            for(int j = i;j<n;j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                \\n                if(gcd == 1){\\n                    int len = (j-i)+1;\\n                    ans = min(ans,(len-1)+(n-1));\\n                }\\n            }\\n            \\n         \\n        \\n        }\\n        if(ans == 1e9)ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446750,
                "title": "explained-step-by-step-with-examples-very-easy-to-understand-o-n-2-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key to this problem is to find the first \"1\" of GCD result. Once it has been found, it can be spread to all the rest elements by lenth of the array - 1 (len(nums)-1) steps.\\n\\nIt would be easy if the GCD of two adjacent elements is \"1\". But what if the coprime factors are far apart and require several steps to pass and meet together? Every adjacent GCDs will be calculated and stored, then the same process is done to all adjacent GCD results till a \"1\" has been found or only one result remains.\\n\\n# Explaination with examples\\n<!-- Describe your approach to solving the problem. -->\\nConsider this case: [2,6,6,6,3,9], calculate GCD for all adjacent elements. And do the same thing to the results, until there is a \"1\".\\n```\\n2 6 6 6 3 9\\n 2 6 6 3 3     step 1\\n  2 6 3 3      step 2\\n   2 3 3       step 3\\n    1 3        step 4\\n```\\nThe coprime factors are 2 and 3 and they are at two sides of the array. It takes at least 4 steps for them to meet and have the GCD \"1\". The final result will be 4 plus 6-1 steps to spread \"1\"s to the whole array. \\n\\nIf it never gets 1, then return -1. Check this case: [2,10,6,14]\\n```\\n2 10 6 14\\n 2  2  2    step 1\\n   2  2     step 2\\n    2       step 3\\n```\\n\\nAnd don\\'t forget the case that there are \"1\"s in the number array. So the array has to be checked first, and just need number of non-one elements steps to make the array full of ones.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), modify the array in place.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == 1)\\n                ct++;\\n        if(ct > 0)\\n            return nums.size() - ct;\\n        for(int steps=0; steps<nums.size()-1; steps++)\\n            for(int i=0; i<nums.size()-steps-1; i++){\\n                nums[i] = gcd(nums[i], nums[i+1]);\\n                if(nums[i] == 1)\\n                    return steps + nums.size();\\n            }\\n        return -1;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ct, n = 0, len(nums)\\n        for d in nums:\\n            if d == 1:\\n                ct += 1\\n        if ct > 0:\\n            return n - ct\\n        for steps in range(n):\\n            for i in range(n - steps - 1):\\n                nums[i] = gcd(nums[i], nums[i+1])\\n                if nums[i] == 1:\\n                    return steps + n\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n2 6 6 6 3 9\\n 2 6 6 3 3     step 1\\n  2 6 3 3      step 2\\n   2 3 3       step 3\\n    1 3        step 4\\n```\n```\\n2 10 6 14\\n 2  2  2    step 1\\n   2  2     step 2\\n    2       step 3\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == 1)\\n                ct++;\\n        if(ct > 0)\\n            return nums.size() - ct;\\n        for(int steps=0; steps<nums.size()-1; steps++)\\n            for(int i=0; i<nums.size()-steps-1; i++){\\n                nums[i] = gcd(nums[i], nums[i+1]);\\n                if(nums[i] == 1)\\n                    return steps + nums.size();\\n            }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ct, n = 0, len(nums)\\n        for d in nums:\\n            if d == 1:\\n                ct += 1\\n        if ct > 0:\\n            return n - ct\\n        for steps in range(n):\\n            for i in range(n - steps - 1):\\n                nums[i] = gcd(nums[i], nums[i+1])\\n                if nums[i] == 1:\\n                    return steps + n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446411,
                "title": "javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar minOperations = function (a) {\\n    let nori = a.length; // n original length of array\\n\\n    // edge case 1 - check if only 1 unique element exist, and that element is 1 => all ones\\n    let set = new Set(a);\\n    if (set.size === 1)\\n        if (a[0] === 1) {\\n            return 0;\\n        }\\n\\n    // edge case 2 - check if some ones exist - count ones if exist\\n    let ones = 0;\\n    for (let i = 0; i < nori; i++)\\n        if (a[i] === 1) {\\n            ones++;\\n        }\\n    if (ones) {\\n        return nori - ones;\\n    }\\n\\n    // main work - find gcds and repeatedly replace array a & repeat\\n    let cc = 0;\\n    while (a.length) {\\n        let n = a.length;\\n        let a2 = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            let g = gcd(a[i], a[i + 1]);\\n            if (g === 1) {\\n                return nori + cc; // when one can become 1, others can as well\\n            }\\n            a2.push(g);\\n        }\\n        a = a2;\\n        cc++;\\n    }\\n    return -1;\\n\\n    function gcd(a, b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function (a) {\\n    let nori = a.length; // n original length of array\\n\\n    // edge case 1 - check if only 1 unique element exist, and that element is 1 => all ones\\n    let set = new Set(a);\\n    if (set.size === 1)\\n        if (a[0] === 1) {\\n            return 0;\\n        }\\n\\n    // edge case 2 - check if some ones exist - count ones if exist\\n    let ones = 0;\\n    for (let i = 0; i < nori; i++)\\n        if (a[i] === 1) {\\n            ones++;\\n        }\\n    if (ones) {\\n        return nori - ones;\\n    }\\n\\n    // main work - find gcds and repeatedly replace array a & repeat\\n    let cc = 0;\\n    while (a.length) {\\n        let n = a.length;\\n        let a2 = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            let g = gcd(a[i], a[i + 1]);\\n            if (g === 1) {\\n                return nori + cc; // when one can become 1, others can as well\\n            }\\n            a2.push(g);\\n        }\\n        a = a2;\\n        cc++;\\n    }\\n    return -1;\\n\\n    function gcd(a, b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446266,
                "title": "video-explanation-includes-all-the-proofs",
                "content": "# Explanation\\n\\nhttps://youtu.be/ituCxE_aoyE\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/ituCxE_aoyE)\\n\\n# Code\\n```\\nclass Solution {    \\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int full_gcd = 0;\\n        for (auto i : nums) full_gcd = __gcd (full_gcd, i);\\n        if (full_gcd != 1) return -1;\\n        \\n        int ones = 0;\\n        for (auto i : nums) \\n            if (i == 1) ones ++;\\n        \\n        if (ones > 0) return (n - ones);\\n        \\n        vector<int> steps_to_1 (n, n);\\n        for (int j = 0; j < n; j ++) {\\n            int& steps = steps_to_1[j];\\n            \\n            for (int l = 0; l <= j; l ++) {\\n                for (int r = j; r < n; r ++) {\\n                    int gcd = 0;\\n                    for (int i = l; i <= r; i ++) gcd = __gcd (gcd, nums[i]);\\n                    \\n                    if (gcd == 1)\\n                        steps = min (steps, r-l);\\n                }\\n            }\\n        }\\n        \\n        int min_steps_to_1 = n;\\n        for (auto i : steps_to_1) min_steps_to_1 = min (min_steps_to_1, i);\\n        \\n        return (min_steps_to_1 + n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int full_gcd = 0;\\n        for (auto i : nums) full_gcd = __gcd (full_gcd, i);\\n        if (full_gcd != 1) return -1;\\n        \\n        int ones = 0;\\n        for (auto i : nums) \\n            if (i == 1) ones ++;\\n        \\n        if (ones > 0) return (n - ones);\\n        \\n        vector<int> steps_to_1 (n, n);\\n        for (int j = 0; j < n; j ++) {\\n            int& steps = steps_to_1[j];\\n            \\n            for (int l = 0; l <= j; l ++) {\\n                for (int r = j; r < n; r ++) {\\n                    int gcd = 0;\\n                    for (int i = l; i <= r; i ++) gcd = __gcd (gcd, nums[i]);\\n                    \\n                    if (gcd == 1)\\n                        steps = min (steps, r-l);\\n                }\\n            }\\n        }\\n        \\n        int min_steps_to_1 = n;\\n        for (auto i : steps_to_1) min_steps_to_1 = min (min_steps_to_1, i);\\n        \\n        return (min_steps_to_1 + n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446118,
                "title": "easy-to-understand-python-interview-solution",
                "content": "# Intuition\\nIdea: GCD of two numbers will be 1 only if:-\\n    1. Either of two number is 1.\\n    2. They don\\'t have any common factor.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. Check for count of 1\\'s in `nums`. If there are ones present in this `nums` then number of `operations = n - count(ones)`.\\n\\n2. Now, if there is no 1\\'s in `nums`, then just try to make 1 by calculating gcd for `nums[i]` and `nums[i+1]`. If we found gcd = 1 then, number of `operations = number of operations to achieve gcd=1` + `length of all non 1\\'s element in list (len(nums)-1)`.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) # not including for gcd recursion.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return abs(a)\\n        else:\\n            return self.gcd(b, a%b)\\n        \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ones = nums.count(1)\\n        if ones: return n - ones\\n        ans = float(\"inf\")\\n        \\n        for l in range(n):\\n            g = nums[l]\\n            for r in range(l+1, n):\\n                g = self.gcd(g, nums[r])\\n                if g == 1:\\n                    ans = min(ans, r-l + (n-1))\\n                    break\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```\\n\\n\\n## Note:\\n    - If you got something to learn from this solution please upvote, So I feel motivated doing same.\\n    - Also let me know if there is something better, I am happy to know that too.\\n\\n\\n# ********** Keep Learning @ Keep Coding **********",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return abs(a)\\n        else:\\n            return self.gcd(b, a%b)\\n        \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ones = nums.count(1)\\n        if ones: return n - ones\\n        ans = float(\"inf\")\\n        \\n        for l in range(n):\\n            g = nums[l]\\n            for r in range(l+1, n):\\n                g = self.gcd(g, nums[r])\\n                if g == 1:\\n                    ans = min(ans, r-l + (n-1))\\n                    break\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445772,
                "title": "cpp-simple-solution-with-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:\\n\\nSelect an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.\\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\\n\\nThe gcd of two integers is the greatest common divisor of the two integers.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, the code checks if there are any 1\\'s in the input vector. If there are, it returns the number of elements in the input vector that are not equal to 1, as we can make all the elements equal to 1 by repeatedly adding 1 to any non-1 element.\\n\\nIf there are no 1\\'s in the input vector, the code iterates through each pair of elements in the input vector and takes the GCD of each pair. If the resulting GCD ever becomes 1, the number of operations required to make all the elements equal is calculated as the difference between the indices of the two elements that produced the GCD of 1. The minimum number of operations required to make all the elements equal is updated as the minimum of its current value and the number of operations required for the current pair of elements. If it is not possible to make all the elements of the input vector equal, the function returns -1.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this C++ code is O(n^2 log(maximum value in the input vector)), where n is the size of the input vector. The nested loop iterates over all pairs of elements in the input vector and the __gcd function takes log(maximum value in the input vector) time to calculate the GCD of two numbers.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) as it only uses a constant amount of extra space for storing some integer variables. However, note that the __gcd function itself might use additional memory, which is not accounted for in the space complexity analysis of this code.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntOnes = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) cntOnes++;\\n        }\\n\\n        if(cntOnes > 0) return n - cntOnes;\\n\\n        int minOps = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = __gcd(num, nums[j]);\\n                if(num == 1) {\\n                    minOps = min(minOps, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) break;\\n        }\\n        return (minOps == INT_MAX) ? -1 : n-1+minOps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntOnes = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) cntOnes++;\\n        }\\n\\n        if(cntOnes > 0) return n - cntOnes;\\n\\n        int minOps = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = __gcd(num, nums[j]);\\n                if(num == 1) {\\n                    minOps = min(minOps, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) break;\\n        }\\n        return (minOps == INT_MAX) ? -1 : n-1+minOps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716673,
                "title": "easy-c-solution-simple-approach-with-explanation-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need to find **one element with value 1** and then the answer is `nums.size()-1`. If there are **k elements with value 1** then answer is `nums.size()-k`. This is because the **gcd of any value with 1 will be 1** and thus we can perform gcd of the element with 1 with its neighbouring elements to get every element equal to 1. \\n- If array does not have element with value 1 then perform gcd of adjacent elements from the start and `find the pair of elements with gcd = 1`. Starting from there, then we just need to follow the similar process as the earlier case when any element has value 1.  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=INT_MAX/2;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==INT_MAX/2?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=INT_MAX/2;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==INT_MAX/2?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545325,
                "title": "2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1-java",
                "content": "```\\nclass Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int minOperations(int[] nums) {\\n        int cnt1=0,minsubarray=Integer.MAX_VALUE;\\n        for(int x:nums)\\n            if(x==1)\\n            cnt1++;\\n        \\n        if(cnt1>0)\\n            return nums.length-cnt1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int curgcd=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                curgcd=(gcd(curgcd,nums[j]));\\n                    if(curgcd==1)\\n                    {\\n                        minsubarray=Math.min(minsubarray,j-i);\\n                        break;\\n                    }   \\n            }\\n        }\\n        if(minsubarray!=Integer.MAX_VALUE)\\n            return minsubarray+nums.length-1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int minOperations(int[] nums) {\\n        int cnt1=0,minsubarray=Integer.MAX_VALUE;\\n        for(int x:nums)\\n            if(x==1)\\n            cnt1++;\\n        \\n        if(cnt1>0)\\n            return nums.length-cnt1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int curgcd=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                curgcd=(gcd(curgcd,nums[j]));\\n                    if(curgcd==1)\\n                    {\\n                        minsubarray=Math.min(minsubarray,j-i);\\n                        break;\\n                    }   \\n            }\\n        }\\n        if(minsubarray!=Integer.MAX_VALUE)\\n            return minsubarray+nums.length-1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489076,
                "title": "c-brute-force",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int gcd=nums[0];\\n        for (int i=1; i<nums.size(); i++)gcd= __gcd(gcd,nums[i]);\\n        if (gcd!=1)return -1;\\n        if (count(nums.begin(),nums.end(),1)>0){\\n            return (nums.size()-count(nums.begin(),nums.end(),1));\\n        }\\n        int cnt=INT_MAX;\\n        for (int i=0; i<nums.size(); i++){\\n            int curr= nums[i];\\n            for (int j=i+1; j<nums.size(); j++){\\n                curr= __gcd(curr,nums[j]);\\n                if (curr==1){\\n                    cnt= min(cnt,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return nums.size()+cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int gcd=nums[0];\\n        for (int i=1; i<nums.size(); i++)gcd= __gcd(gcd,nums[i]);\\n        if (gcd!=1)return -1;\\n        if (count(nums.begin(),nums.end(),1)>0){\\n            return (nums.size()-count(nums.begin(),nums.end(),1));\\n        }\\n        int cnt=INT_MAX;\\n        for (int i=0; i<nums.size(); i++){\\n            int curr= nums[i];\\n            for (int j=i+1; j<nums.size(); j++){\\n                curr= __gcd(curr,nums[j]);\\n                if (curr==1){\\n                    cnt= min(cnt,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return nums.size()+cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476382,
                "title": "easiest-solution-c",
                "content": "```\\n int minOperations(vector<int>& nums) {\\n        \\n        int value = 0, n = nums.size(),ones = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            value = __gcd(value, nums[i]);\\n            if(nums[i] == 1)\\n                ones++;\\n        }\\n        //if the gcd of the total array is not equal to 1 then not possible\\n        if(value != 1)\\n            return -1;\\n        \\n        //gcd of 1 with any number is 1\\n        if(ones > 0)\\n            return n-ones;\\n        \\n        int min_size = 1e9;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            //generating all subsets\\n            for(int j = i; j<n; j++)\\n            {\\n                \\n                int val = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    val = __gcd(val, nums[k]);\\n                    \\n                    if(val == 1)\\n                    {\\n                        //minimum sized subarray whose gcd is 1\\n                         min_size = min(min_size, j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // step= minimum subarray -1, and the rest of the elements\\n        return min_size - 1 + n-1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n int minOperations(vector<int>& nums) {\\n        \\n        int value = 0, n = nums.size(),ones = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            value = __gcd(value, nums[i]);\\n            if(nums[i] == 1)\\n                ones++;\\n        }\\n        //if the gcd of the total array is not equal to 1 then not possible\\n        if(value != 1)\\n            return -1;\\n        \\n        //gcd of 1 with any number is 1\\n        if(ones > 0)\\n            return n-ones;\\n        \\n        int min_size = 1e9;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            //generating all subsets\\n            for(int j = i; j<n; j++)\\n            {\\n                \\n                int val = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    val = __gcd(val, nums[k]);\\n                    \\n                    if(val == 1)\\n                    {\\n                        //minimum sized subarray whose gcd is 1\\n                         min_size = min(min_size, j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // step= minimum subarray -1, and the rest of the elements\\n        return min_size - 1 + n-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476258,
                "title": "python3-solution",
                "content": "# Code\\n```\\nfrom math import gcd\\nclass Solution: \\n    def getGCDs(self, nums):\\n        gcdArr = []\\n        for i in range(len(nums) - 1):\\n            gcdArr.append(gcd(nums[i], nums[i + 1])) \\n        return gcdArr\\n    def minOperations(self, nums):\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        steps = 0\\n        gcdArr = self.getGCDs(nums)\\n        while len(gcdArr) >= 1 and 1 not in gcdArr:\\n            gcdArr = self.getGCDs(gcdArr)\\n            steps += 1\\n        if 1 not in gcdArr: return -1\\n        else: steps += 1\\n        return steps + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution: \\n    def getGCDs(self, nums):\\n        gcdArr = []\\n        for i in range(len(nums) - 1):\\n            gcdArr.append(gcd(nums[i], nums[i + 1])) \\n        return gcdArr\\n    def minOperations(self, nums):\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        steps = 0\\n        gcdArr = self.getGCDs(nums)\\n        while len(gcdArr) >= 1 and 1 not in gcdArr:\\n            gcdArr = self.getGCDs(gcdArr)\\n            steps += 1\\n        if 1 not in gcdArr: return -1\\n        else: steps += 1\\n        return steps + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464767,
                "title": "a-few-solutions",
                "content": "**Case 1:** If *any* value of the input array `A` is equal to `1`, then each adjacent value (*not* equal to `1`) can be transformed into `1` via one operation, ie. `gcd(1, x) == 1` for any `x`.  Let `ok` be the count of elements equal to `1`, if `ok` exceeds `0` then return `N - ok`, ie. the count of elements *not* equal to `1`.\\n\\n**Case 2:** Otherwise let `size` be the subarray size `i..j` inclusive for which `gcd(A[i..j]) == 1`, then the minimum operations to transform a single element of the subarray to the value `1` via the gcd function `f` is `size - 1`, ie. we can think of the gcd function `f` as an \"edge\" between each adjacent pair of indices (and each \"edge\" costs one operation).  After accounting for the minimum operations to transform a single element to the value `1`, then we need an additional `N - 1` operations to transform all remaining values *not* equal to `1` to the value `1`, ie. apply **Case 1** given `ok == 1`.\\n\\n* Note: if the `gcd` of all values of the input array `A` exceeds `1`, then we return `-1`, ie. we *cannot* transform *any* element to the value `1`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var ok = A.filter{ it == 1 }.size\\n        if (0 < ok)\\n            return N - ok\\n        var (best, size) = Pair(INF, INF)\\n        fun f(a: Int, b: Int): Int { return if (b == 0) a else f(b, a % b) }\\n        for (i in 0 until N) {\\n            var gcd = A[i]\\n            for (j in i + 1 until N) {\\n                gcd = f(gcd, A[j])\\n                if (gcd == 1) {\\n                    size = j - i + 1\\n                    best = Math.min(best, size - 1)\\n                    break\\n                }\\n            }\\n        }\\n        return if (best != INF) best + N - 1 else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, N = A.length) => {\\n    let ok = A.filter(x => x == 1).length;\\n    if (ok)\\n        return N - ok;\\n    let [best, size] = [Infinity, Infinity];\\n    let f = (a, b) => !b ? a : f(b, a % b);\\n    for (let i = 0; i < N; ++i) {\\n        let gcd = A[i];\\n        for (let j = i + 1; j < N; ++j) {\\n            gcd = f(gcd, A[j]);\\n            if (gcd == 1) {\\n                size = j - i + 1;\\n                best = Math.min(best, size - 1);\\n                break;\\n            }\\n        }\\n    }\\n    return best != Infinity ? best + N - 1 : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        ok = len([x for x in A if x == 1])\\n        if ok:\\n            return N - ok\\n        best, size = float(\\'inf\\'), float(\\'inf\\')\\n        f = lambda a, b: a if not b else f(b, a % b)\\n        for i in range(N):\\n            gcd = A[i]\\n            for j in range(i + 1, N):\\n                gcd = f(gcd, A[j])\\n                if gcd == 1:\\n                    size = j - i + 1\\n                    best = min(best, size - 1)\\n                    break\\n        return best + N - 1 if best != float(\\'inf\\') else -1\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>) -> i32 {\\n        let INF = 1e9 as usize + 1;\\n        let N = A.len();\\n        let ok = A.iter().filter(|&x| *x == 1).collect::<Vec<&i32>>().len();\\n        if 0 < ok {\\n            return (N - ok) as i32;\\n        }\\n        let (mut best, mut size) = (INF, INF);\\n        fn f(a: i32, b: i32) -> i32 { if b == 0 { a } else { f(b, a % b) } }\\n        for i in 0..N {\\n            let mut gcd = A[i];\\n            for j in i + 1..N {\\n                gcd = f(gcd, A[j]);\\n                if gcd == 1 {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        if best != INF { (best + N - 1) as i32 } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minOperations(VI& A, int INF = 1e9 + 7) {\\n        auto N = A.size();\\n        auto ok = count_if(A.begin(), A.end(), [](auto x) { return x == 1; });\\n        if (ok)\\n            return N - ok;\\n        auto [best, size] = make_pair(INF, INF);\\n        fun f = [&](auto a, auto b) { return !b ? a : f(b, a % b); };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto gcd = A[i];\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                gcd = f(gcd, A[j]);\\n                if (gcd == 1) {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return best != INF ? best + N - 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var ok = A.filter{ it == 1 }.size\\n        if (0 < ok)\\n            return N - ok\\n        var (best, size) = Pair(INF, INF)\\n        fun f(a: Int, b: Int): Int { return if (b == 0) a else f(b, a % b) }\\n        for (i in 0 until N) {\\n            var gcd = A[i]\\n            for (j in i + 1 until N) {\\n                gcd = f(gcd, A[j])\\n                if (gcd == 1) {\\n                    size = j - i + 1\\n                    best = Math.min(best, size - 1)\\n                    break\\n                }\\n            }\\n        }\\n        return if (best != INF) best + N - 1 else -1\\n    }\\n}\\n```\n```\\nlet minOperations = (A, N = A.length) => {\\n    let ok = A.filter(x => x == 1).length;\\n    if (ok)\\n        return N - ok;\\n    let [best, size] = [Infinity, Infinity];\\n    let f = (a, b) => !b ? a : f(b, a % b);\\n    for (let i = 0; i < N; ++i) {\\n        let gcd = A[i];\\n        for (let j = i + 1; j < N; ++j) {\\n            gcd = f(gcd, A[j]);\\n            if (gcd == 1) {\\n                size = j - i + 1;\\n                best = Math.min(best, size - 1);\\n                break;\\n            }\\n        }\\n    }\\n    return best != Infinity ? best + N - 1 : -1;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        ok = len([x for x in A if x == 1])\\n        if ok:\\n            return N - ok\\n        best, size = float(\\'inf\\'), float(\\'inf\\')\\n        f = lambda a, b: a if not b else f(b, a % b)\\n        for i in range(N):\\n            gcd = A[i]\\n            for j in range(i + 1, N):\\n                gcd = f(gcd, A[j])\\n                if gcd == 1:\\n                    size = j - i + 1\\n                    best = min(best, size - 1)\\n                    break\\n        return best + N - 1 if best != float(\\'inf\\') else -1\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>) -> i32 {\\n        let INF = 1e9 as usize + 1;\\n        let N = A.len();\\n        let ok = A.iter().filter(|&x| *x == 1).collect::<Vec<&i32>>().len();\\n        if 0 < ok {\\n            return (N - ok) as i32;\\n        }\\n        let (mut best, mut size) = (INF, INF);\\n        fn f(a: i32, b: i32) -> i32 { if b == 0 { a } else { f(b, a % b) } }\\n        for i in 0..N {\\n            let mut gcd = A[i];\\n            for j in i + 1..N {\\n                gcd = f(gcd, A[j]);\\n                if gcd == 1 {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        if best != INF { (best + N - 1) as i32 } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minOperations(VI& A, int INF = 1e9 + 7) {\\n        auto N = A.size();\\n        auto ok = count_if(A.begin(), A.end(), [](auto x) { return x == 1; });\\n        if (ok)\\n            return N - ok;\\n        auto [best, size] = make_pair(INF, INF);\\n        fun f = [&](auto a, auto b) { return !b ? a : f(b, a % b); };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto gcd = A[i];\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                gcd = f(gcd, A[j]);\\n                if (gcd == 1) {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return best != INF ? best + N - 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457695,
                "title": "brute-force-simple-c-smallest-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to find the smallest subarray with GCD 1. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will make one 1 with that subarray with cost of length - 1.\\nThe rest n-1 elements will be changed to 1 with n-1 operations.   \\n\\n# Complexity\\n- Time complexity:O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd = nums[0];\\n        int one = 0;\\n        for(auto x: nums) \\n        {\\n            gcd = __gcd(gcd,x);\\n            one += (x==1);\\n        }\\n        if(gcd>1) return -1;\\n        int n = nums.size();\\n        if(one) return n-one;\\n        for(int len = 1;len<=n;len++)\\n        {\\n            for(int i=0;i<=n-len;i++)\\n            {\\n                int curGCD = nums[i];\\n                for(int j=0;j<len;j++)  // for current window of [i, i+len]\\n                    curGCD = __gcd(curGCD,nums[i+j]);\\n                \\n                if(curGCD == 1)\\n                    return n-1 + len-1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd = nums[0];\\n        int one = 0;\\n        for(auto x: nums) \\n        {\\n            gcd = __gcd(gcd,x);\\n            one += (x==1);\\n        }\\n        if(gcd>1) return -1;\\n        int n = nums.size();\\n        if(one) return n-one;\\n        for(int len = 1;len<=n;len++)\\n        {\\n            for(int i=0;i<=n-len;i++)\\n            {\\n                int curGCD = nums[i];\\n                for(int j=0;j<len;j++)  // for current window of [i, i+len]\\n                    curGCD = __gcd(curGCD,nums[i+j]);\\n                \\n                if(curGCD == 1)\\n                    return n-1 + len-1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455938,
                "title": "explained-with-comments-easy-to-understand-soln",
                "content": "```\\n    //Case 1: if nums has 1 --> number of operations = no. of non 1s (1 operations for each)\\n    //Case 2: if gcd of entire nums != 1 --> not possible --> -1\\n    //Case 3: we want to make atleast 1 1 fastest(with least no of operations)\\n    // eg. [2,6,3,4] -- gcd(2,3,6) == 1 & gcd(3,4)==1 but 3,4 is faster\\n    // so basically we need to find smallest subarray with gcd 1\\n    \\n    //Constraints are small(50) we check for each subarray \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = count(nums.begin(),nums.end(),1);\\n        if(ones>0)\\n            return n - ones; //case 1\\n        //case3\\n        int minLength = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int hcf = nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                hcf = __gcd(hcf,nums[j]);\\n                if(hcf==1)\\n                {\\n                    minLength = min(minLength, j-i+1);\\n                    break; //found a subarray starting from i which has gcd = 1; we dont need to keep adding more elements --> gcd will be 1 but length increases and we need smallest subarray\\n                }    \\n            }\\n        }\\n        //case2\\n        if(minLength == INT_MAX) return -1;\\n        return (minLength-1) + n-1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    //Case 1: if nums has 1 --> number of operations = no. of non 1s (1 operations for each)\\n    //Case 2: if gcd of entire nums != 1 --> not possible --> -1\\n    //Case 3: we want to make atleast 1 1 fastest(with least no of operations)\\n    // eg. [2,6,3,4] -- gcd(2,3,6) == 1 & gcd(3,4)==1 but 3,4 is faster\\n    // so basically we need to find smallest subarray with gcd 1\\n    \\n    //Constraints are small(50) we check for each subarray \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = count(nums.begin(),nums.end(),1);\\n        if(ones>0)\\n            return n - ones; //case 1\\n        //case3\\n        int minLength = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int hcf = nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                hcf = __gcd(hcf,nums[j]);\\n                if(hcf==1)\\n                {\\n                    minLength = min(minLength, j-i+1);\\n                    break; //found a subarray starting from i which has gcd = 1; we dont need to keep adding more elements --> gcd will be 1 but length increases and we need smallest subarray\\n                }    \\n            }\\n        }\\n        //case2\\n        if(minLength == INT_MAX) return -1;\\n        return (minLength-1) + n-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455198,
                "title": "very-short-solution",
                "content": "\\n# Code\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if 1 in nums:\\n        return n - sum(int(x==1) for x in nums)\\n    for ret in range(n-1):\\n        for i in range(n-1-ret):\\n            nums[i] = gcd(nums[i], nums[i+1])\\n            if nums[i] == 1:\\n                return ret+n\\n    return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if 1 in nums:\\n        return n - sum(int(x==1) for x in nums)\\n    for ret in range(n-1):\\n        for i in range(n-1-ret):\\n            nums[i] = gcd(nums[i], nums[i+1])\\n            if nums[i] == 1:\\n                return ret+n\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3454051,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(count(nums.begin(), nums.end(), 1)){\\n            return nums.size()-count(nums.begin(), nums.end(), 1);\\n        }\\n        int cnt=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int val=nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                val=__gcd(val, nums[j]);\\n                if(val==1){\\n                    if(j+nums.size()-1-i<cnt){\\n                        cnt=j+nums.size()-1-i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==INT_MAX){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(count(nums.begin(), nums.end(), 1)){\\n            return nums.size()-count(nums.begin(), nums.end(), 1);\\n        }\\n        int cnt=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int val=nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                val=__gcd(val, nums[j]);\\n                if(val==1){\\n                    if(j+nums.size()-1-i<cnt){\\n                        cnt=j+nums.size()-1-i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==INT_MAX){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451672,
                "title": "brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = size(nums);\\n        int gcd = 0,one = 0;\\n        for(int&e: nums){\\n            gcd = __gcd(gcd,e);\\n            if(e == 1) one++;\\n        }\\n        if(gcd != 1) return -1;\\n        if(one) return n-one;\\n        int mn=1e9;\\n        for(int i=0; i<n; ++i){\\n            gcd = nums[i];\\n            int ct = 0;\\n            for(int j=i+1; j<n; ++j){\\n                gcd = __gcd(gcd,nums[j]);\\n                ct++;\\n                if(gcd == 1){\\n                    mn = min(mn,ct);\\n                    break;\\n                }\\n            }\\n        }\\n        return n+mn-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = size(nums);\\n        int gcd = 0,one = 0;\\n        for(int&e: nums){\\n            gcd = __gcd(gcd,e);\\n            if(e == 1) one++;\\n        }\\n        if(gcd != 1) return -1;\\n        if(one) return n-one;\\n        int mn=1e9;\\n        for(int i=0; i<n; ++i){\\n            gcd = nums[i];\\n            int ct = 0;\\n            for(int j=i+1; j<n; ++j){\\n                gcd = __gcd(gcd,nums[j]);\\n                ct++;\\n                if(gcd == 1){\\n                    mn = min(mn,ct);\\n                    break;\\n                }\\n            }\\n        }\\n        return n+mn-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449208,
                "title": "beats-90-cpp-sol",
                "content": "# Upvote if you liked the solution \\uD83E\\uDD79\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\n        // finding the size of the nums\\n        int n = nums.size();\\n\\n        // To create all the no of nums equal to 1, we need one number in nums to be equal to \\'1\\' \\n        // coz the gcd of 1 equal to 1\\n\\n        // if \\'1\\' is already present in the nums then count the no of \\'1\\'\\n        int oneCount = count(nums.begin(), nums.end(), 1);\\n\\n        // number of operation to make all other no equal to one will be\\n        if(oneCount > 0){\\n            return n-oneCount;\\n        }\\n\\n        int len = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            int g = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                g = gcd(g, nums[j]);\\n                if(g == 1){\\n                    len = min(len, j-i);\\n                }\\n            }\\n        }\\n\\n        if(len == INT_MAX){\\n            return -1;\\n        }\\n\\n        // len : no of operations to make a no equal to 1\\n        // n-1 : no of opeartion to make remaining all other element equal to one\\n        // total  = len + n-1\\n\\n        return len + (n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\n        // finding the size of the nums\\n        int n = nums.size();\\n\\n        // To create all the no of nums equal to 1, we need one number in nums to be equal to \\'1\\' \\n        // coz the gcd of 1 equal to 1\\n\\n        // if \\'1\\' is already present in the nums then count the no of \\'1\\'\\n        int oneCount = count(nums.begin(), nums.end(), 1);\\n\\n        // number of operation to make all other no equal to one will be\\n        if(oneCount > 0){\\n            return n-oneCount;\\n        }\\n\\n        int len = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            int g = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                g = gcd(g, nums[j]);\\n                if(g == 1){\\n                    len = min(len, j-i);\\n                }\\n            }\\n        }\\n\\n        if(len == INT_MAX){\\n            return -1;\\n        }\\n\\n        // len : no of operations to make a no equal to 1\\n        // n-1 : no of opeartion to make remaining all other element equal to one\\n        // total  = len + n-1\\n\\n        return len + (n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446583,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), nonOnes = 0, mn = 1e9;\\n        for(int i : nums) nonOnes += i != 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            int g = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                g = __gcd(g, nums[j]);\\n                if(g == 1) mn = min(mn, j - i);\\n            }\\n        }\\n        return mn == 1e9 ? -1 : nonOnes + mn - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), nonOnes = 0, mn = 1e9;\\n        for(int i : nums) nonOnes += i != 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            int g = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                g = __gcd(g, nums[j]);\\n                if(g == 1) mn = min(mn, j - i);\\n            }\\n        }\\n        return mn == 1e9 ? -1 : nonOnes + mn - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446195,
                "title": "easy-understandable-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            x = __gcd(x,nums[i]);\\n        }\\n        int one = 0;\\n        for(auto i : nums){\\n            if(i == 1)  one++;\\n        }\\n        if(one > 0) return n-one;\\n        if(x != 1)  return -1;\\n        int cnt = 0;\\n        while(1){\\n            vector<int> v;\\n            for(int i = 0 ; i < n-1; i++){\\n                int t = __gcd(nums[i],nums[i+1]);\\n                if(t == 1){\\n                    return n + cnt;\\n                }\\n                v.push_back(t);\\n            }\\n            cnt++;\\n            nums.resize(nums.size()-1);\\n            nums = v;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\nPlease Upvote !!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            x = __gcd(x,nums[i]);\\n        }\\n        int one = 0;\\n        for(auto i : nums){\\n            if(i == 1)  one++;\\n        }\\n        if(one > 0) return n-one;\\n        if(x != 1)  return -1;\\n        int cnt = 0;\\n        while(1){\\n            vector<int> v;\\n            for(int i = 0 ; i < n-1; i++){\\n                int t = __gcd(nums[i],nums[i+1]);\\n                if(t == 1){\\n                    return n + cnt;\\n                }\\n                v.push_back(t);\\n            }\\n            cnt++;\\n            nums.resize(nums.size()-1);\\n            nums = v;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446170,
                "title": "o-n-n-log-max-element-nums-i-solution",
                "content": "- If 1 exists in the array, it will be optimal to propagate it to non zero indexes\\n- Else create a one in minimum number of operations, in order to do that we will will the smallest subarray with gcd = 1, then propagate it.\\n- If no subarray exist with gcd = 1, return -1.\\n- The solution can be optimised further using segment tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Time complexity: O(N * N * log(max_element(nums[i]))) -->\\n    O(N * N * log(max_element(nums[i]))) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int>m;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) m[nums[i]]++;\\n        \\n        // if 1 is present in the array than we will propagate it.\\n        if(m.count(1)) return n - m[1];\\n        int ans = n + 1;\\n        \\n        // finding the smallest subarray with gcd 1.\\n        for(int i = 0; i < n; i++) {\\n            int curr = nums[i];\\n            for(int j = i + 1; j < n; j++) {\\n                curr = __gcd(curr, nums[j]);\\n                if(curr == 1) {\\n                    ans = min(ans, j - i + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    \\n        // if not found return -1.\\n        if(ans == n + 1) return -1;\\n        \\n        // in order to create first 1, we will need ans - 1 operations than n - 1 operations to propagate to complete array.\\n        return ans - 1 + n - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int>m;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) m[nums[i]]++;\\n        \\n        // if 1 is present in the array than we will propagate it.\\n        if(m.count(1)) return n - m[1];\\n        int ans = n + 1;\\n        \\n        // finding the smallest subarray with gcd 1.\\n        for(int i = 0; i < n; i++) {\\n            int curr = nums[i];\\n            for(int j = i + 1; j < n; j++) {\\n                curr = __gcd(curr, nums[j]);\\n                if(curr == 1) {\\n                    ans = min(ans, j - i + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    \\n        // if not found return -1.\\n        if(ans == n + 1) return -1;\\n        \\n        // in order to create first 1, we will need ans - 1 operations than n - 1 operations to propagate to complete array.\\n        return ans - 1 + n - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446029,
                "title": "easy-c-solution-smallest-subarray-with-gcd-1-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If vector contains integer 1 then answer is number of elements not equal to 1\\n2. If the gcd of whole array is not 1 then the answer doesn\\'t exist, return -1\\n3. Find the smallest subarray whose gcd is 1. \\n    - This (length of this subarray - 1) will be the operations required to convert an interger into 1\\n    - Answer would be **d + n - 2** (where d is length of subarray and n is size of vector) \\n\\n# Time Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(`N * N * log2(M)`) where N is size of vector and M is the max element in the vector\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int> &v)\\n    {\\n        int n = v.size();\\n        bool f = 0;\\n        int gcd = v[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (v[i] == 1) // If vector contains 1\\n            {\\n                int ans = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if (v[i] != 1) \\n                        ans++;\\n                }// return number of elements not equal to 1\\n                return ans;\\n            }\\n            if (i < n - 1)\\n            {\\n                gcd = __gcd(gcd, v[i + 1]);\\n            }\\n        }\\n        if (gcd != 1) // If GCD of whole vector != 1 then return -1 \\n            return -1;\\n        \\n        int cnt=0;\\n        int ans=1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            gcd = v[i];\\n            for (int j = i; j < n - 1; j++)\\n            {\\n                gcd = __gcd(gcd, v[j + 1]);\\n                if(gcd==1)\\n                    ans = min(ans,j-i+n);\\n                // Find minimum value of (d+n-2)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int> &v)\\n    {\\n        int n = v.size();\\n        bool f = 0;\\n        int gcd = v[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (v[i] == 1) // If vector contains 1\\n            {\\n                int ans = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if (v[i] != 1) \\n                        ans++;\\n                }// return number of elements not equal to 1\\n                return ans;\\n            }\\n            if (i < n - 1)\\n            {\\n                gcd = __gcd(gcd, v[i + 1]);\\n            }\\n        }\\n        if (gcd != 1) // If GCD of whole vector != 1 then return -1 \\n            return -1;\\n        \\n        int cnt=0;\\n        int ans=1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            gcd = v[i];\\n            for (int j = i; j < n - 1; j++)\\n            {\\n                gcd = __gcd(gcd, v[j + 1]);\\n                if(gcd==1)\\n                    ans = min(ans,j-i+n);\\n                // Find minimum value of (d+n-2)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445955,
                "title": "simple-observation-explained",
                "content": "# Intuition:If there is even a sigle one present we can make all the elemnts one by taking gcd of one with its adjacent elements so return size-cnt of one otherwise try to move in a subarray fashion as soon as you get your gcd equal to one it would mean that now you can make one eleent as one and keep doing this till the loop ends and return the minimum answer,so try to find shortest subarray whose gcd is equal to one.\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        bool f=false;\\n        int cnt=0;\\n        int cnt1=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)cnt1++;\\n        }\\n        if(cnt1)return n-cnt1;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    ans=min(ans,j-i+(n-1));\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        bool f=false;\\n        int cnt=0;\\n        int cnt1=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)cnt1++;\\n        }\\n        if(cnt1)return n-cnt1;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    ans=min(ans,j-i+(n-1));\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445819,
                "title": "c-soutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an array of integers, we need to find the minimum number of operations required to make all the elements of the array co-prime (i.e., having gcd equal to 1). An operation involves selecting any two elements of the array and replacing one of them with their gcd.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first check if the array already contains 1. If yes, then we need not perform any operations since 1 is already co-prime with all the other elements. Otherwise, we loop through the array and perform gcd operations between each pair of elements starting from the current element and moving forward. We keep track of the minimum number of operations required to make the elements co-prime.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n^2 * log(max(nums))) since we perform gcd operations between each pair of elements in the array, and the time complexity of gcd operation is log(max(nums)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is O(1) since we use only a few variables to keep track of the minimum number of operations and the count of 1\\'s in the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int numOnes = 0, minOps = INT_MAX;\\n        \\n        // Count the number of ones in the array\\n        for(int& num : nums){\\n            if(num == 1)\\n                numOnes++;\\n        }\\n        \\n        // If there are ones in the array, return the number of non-one elements\\n        if(numOnes != 0){\\n            return nums.size() - numOnes;\\n        }\\n        \\n        // Check all subarrays for gcd 1 and find the smallest subarray\\n        for(int i = 0; i < nums.size(); i++){\\n            int gcdVal = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                gcdVal = gcd(gcdVal, nums[j]);\\n                if(gcdVal == 1){\\n                    minOps = min(minOps, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // If no subarray with gcd 1 is found, return -1\\n        return minOps == INT_MAX ? -1 : nums.size() + minOps - 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int numOnes = 0, minOps = INT_MAX;\\n        \\n        // Count the number of ones in the array\\n        for(int& num : nums){\\n            if(num == 1)\\n                numOnes++;\\n        }\\n        \\n        // If there are ones in the array, return the number of non-one elements\\n        if(numOnes != 0){\\n            return nums.size() - numOnes;\\n        }\\n        \\n        // Check all subarrays for gcd 1 and find the smallest subarray\\n        for(int i = 0; i < nums.size(); i++){\\n            int gcdVal = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                gcdVal = gcd(gcdVal, nums[j]);\\n                if(gcdVal == 1){\\n                    minOps = min(minOps, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // If no subarray with gcd 1 is found, return -1\\n        return minOps == INT_MAX ? -1 : nums.size() + minOps - 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445808,
                "title": "o-n-2-greedy-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int gcd = nums[0];\\n        for(int i = 0; i < n; i++) gcd = __gcd(gcd, nums[i]);\\n        if(gcd > 1) return -1;\\n        \\n        int minOp = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            gcd = nums[i];\\n            for(int j = i; j < n; j++){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    minOp = min(minOp, (j - i));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(minOp == 0) return n - count(nums.begin(), nums.end() , 1);\\n        return minOp + n - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int gcd = nums[0];\\n        for(int i = 0; i < n; i++) gcd = __gcd(gcd, nums[i]);\\n        if(gcd > 1) return -1;\\n        \\n        int minOp = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            gcd = nums[i];\\n            for(int j = i; j < n; j++){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    minOp = min(minOp, (j - i));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(minOp == 0) return n - count(nums.begin(), nums.end() , 1);\\n        return minOp + n - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445706,
                "title": "minimum-steps-to-make-any-one-element-equal-to-1",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if nums.count(1) > 0:\\n            return n - nums.count(1)\\n        minops = float(\\'inf\\')\\n        for i in range(n):\\n            j = i\\n            g = nums[i]\\n            while j >= 0:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j -= 1\\n            if g == 1:\\n                minops = min(minops, i - j)\\n            j = i\\n            g = nums[i]\\n            while j < n:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j += 1\\n            if g == 1:\\n                minops = min(minops, j - i)\\n        if minops == float(\\'inf\\'):\\n            return -1\\n        return n - 1 + minops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if nums.count(1) > 0:\\n            return n - nums.count(1)\\n        minops = float(\\'inf\\')\\n        for i in range(n):\\n            j = i\\n            g = nums[i]\\n            while j >= 0:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j -= 1\\n            if g == 1:\\n                minops = min(minops, i - j)\\n            j = i\\n            g = nums[i]\\n            while j < n:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j += 1\\n            if g == 1:\\n                minops = min(minops, j - i)\\n        if minops == float(\\'inf\\'):\\n            return -1\\n        return n - 1 + minops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445701,
                "title": "east-solution-c-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ope =0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1){\\n                ope++;\\n            }\\n            \\n        }\\n        \\n        if(ope>0){\\n            return n - ope;\\n\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            int num = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                num = __gcd(num,nums[j]);\\n                if(num==1){\\n                    ans = min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(num!=1){\\n                break;\\n            }\\n            \\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ope =0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1){\\n                ope++;\\n            }\\n            \\n        }\\n        \\n        if(ope>0){\\n            return n - ope;\\n\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            int num = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                num = __gcd(num,nums[j]);\\n                if(num==1){\\n                    ans = min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(num!=1){\\n                break;\\n            }\\n            \\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971868,
                "title": "c-python-solution-with-explanation",
                "content": "1. if there has a 1 in nums, we can do len(nums) - 1 operations to make all element be 1.\\n2. if threre are multiple 1s, we can do len(nums) - number of 1 operations to make all element be 0.\\n3. if there are no 1 in nums, we should find a subarray whose gcd is 1, e.g., [3,6,2] in [3,6,2,4].\\n4. if a subarray whose gcd is 1 and its size is m, we just use m - 1 operations to generate a 1, and use len(nums) - 1 operations to make all element be 1, so total is m - 1 + len(nums) - 1.\\n\\nwe can eumerate left and right side of subarray to find a subarray whose gcd is 1.\\nand because of gcd(gcd(a, b), c) == gcd(gcd(b, c), a) == gcd(gcd(a, c), b), tc will less than O(n^2).\\n\\nhash map record number after gcd and its index, left side of subarray, add current number x to subarrays we get at last time, probably get a new gcd, but left side is the same.\\n![image](https://assets.leetcode.com/users/images/cabd14ec-7d4c-4d2a-80b8-9eab40f80e01_1693228767.3166149.png)\\n\\n\\ntc is O(n log(max(nums))), sc is O(log(max(nums)))\\n\\n\\n### python\\n```python\\ninf = int(1e9)\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt1 = sum(1 == x for x in nums)\\n        size = len(nums)\\n        if cnt1: return size - cnt1\\n        min_size = inf\\n        g0 = defaultdict(lambda: -1)\\n        g1 = defaultdict(lambda: -1)\\n        for i, x in enumerate(nums):\\n            for y, j in g0.items():\\n                z = gcd(x, y)\\n                g1[z] = max(g1[z], j)\\n            if 1 in g1: min_size = min(min_size, i - g1[1] + 1)\\n            g1[x] = i\\n            g0.clear()\\n            g0, g1 = g1, g0\\n        return -1 if min_size == inf else min_size - 1 + size - 1 \\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt1 = accumulate(nums.begin(), nums.end(), 0, [](int cnt, int &x) -> int {return cnt + (x == 1);});\\n        int size = nums.size();\\n        if (cnt1) return size - cnt1;\\n        unordered_map<int, int> g0, g1;\\n        int min_size = INT_MAX;\\n        for (int i = 0; i < size; i+=1) {\\n            int &x = nums[i];\\n            for (auto& [y, j]: g0) {\\n                int z = gcd(x, y);\\n                g1[z] = max(g1[z], j);\\n            }\\n            if (g1.count(1)) min_size = min(min_size, i - g1[1] + 1);\\n            g1[x] = i;\\n            g0.clear();\\n            swap(g0, g1);\\n        }\\n        return min_size == INT_MAX? -1: min_size - 1 + size - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math",
                    "Enumeration"
                ],
                "code": "```python\\ninf = int(1e9)\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt1 = sum(1 == x for x in nums)\\n        size = len(nums)\\n        if cnt1: return size - cnt1\\n        min_size = inf\\n        g0 = defaultdict(lambda: -1)\\n        g1 = defaultdict(lambda: -1)\\n        for i, x in enumerate(nums):\\n            for y, j in g0.items():\\n                z = gcd(x, y)\\n                g1[z] = max(g1[z], j)\\n            if 1 in g1: min_size = min(min_size, i - g1[1] + 1)\\n            g1[x] = i\\n            g0.clear()\\n            g0, g1 = g1, g0\\n        return -1 if min_size == inf else min_size - 1 + size - 1 \\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt1 = accumulate(nums.begin(), nums.end(), 0, [](int cnt, int &x) -> int {return cnt + (x == 1);});\\n        int size = nums.size();\\n        if (cnt1) return size - cnt1;\\n        unordered_map<int, int> g0, g1;\\n        int min_size = INT_MAX;\\n        for (int i = 0; i < size; i+=1) {\\n            int &x = nums[i];\\n            for (auto& [y, j]: g0) {\\n                int z = gcd(x, y);\\n                g1[z] = max(g1[z], j);\\n            }\\n            if (g1.count(1)) min_size = min(min_size, i - g1[1] + 1);\\n            g1[x] = i;\\n            g0.clear();\\n            swap(g0, g1);\\n        }\\n        return min_size == INT_MAX? -1: min_size - 1 + size - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960167,
                "title": "c-easy-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        map<int,int> p,q;\\n        int n=a.size();\\n        for(auto i : a)\\n        if(i==1)\\n        p[i]++;\\n\\n        q=p;\\n        int ans=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n         {\\n          int l=a[i];\\n          for(int j=i;j<n;j++)\\n          {\\n          l=__gcd(l,a[j]);\\n          if(a[j]==1)\\n          p[a[j]]--;\\n           if(l==1)\\n           {\\n               ans=min(ans,(j-i)+(n-1)-p[1]);\\n               p=q;\\n               break;\\n           }\\n          }\\n        }\\n         return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        map<int,int> p,q;\\n        int n=a.size();\\n        for(auto i : a)\\n        if(i==1)\\n        p[i]++;\\n\\n        q=p;\\n        int ans=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n         {\\n          int l=a[i];\\n          for(int j=i;j<n;j++)\\n          {\\n          l=__gcd(l,a[j]);\\n          if(a[j]==1)\\n          p[a[j]]--;\\n           if(l==1)\\n           {\\n               ans=min(ans,(j-i)+(n-1)-p[1]);\\n               p=q;\\n               break;\\n           }\\n          }\\n        }\\n         return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958758,
                "title": "golang-o-n-2-solution-w-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc gcd(a, b int) int {\\n    for b > 0 {\\n        a, b = b, a%b\\n    }\\n\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc minOperations(nums []int) int {\\n\\n    n := len(nums)\\n    ones := 0\\n\\n    for _, num := range nums {\\n        if num == 1{\\n            ones++\\n        }\\n    }\\n\\n\\n    // if there is 1s, there are gcds garanteed to be 1\\n    // so just flip any other non 1s to 1s\\n    if ones > 0 {\\n        return n - ones\\n    }\\n\\n    res := math.MaxInt64\\n\\n    for i:=0; i<n; i++ {\\n        g := nums[i]\\n        for j:=i+1; j<n; j++ {\\n            g = gcd(g, nums[j])\\n            if g == 1 {\\n                // j - i: how many flips to get first 1\\n                // n - 1: same case with there are 1s in the first place\\n                res = min(res, j - i + n - 1)\\n                break\\n            }\\n        }\\n    }\\n\\n    if res == math.MaxInt64 {\\n        return -1\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc gcd(a, b int) int {\\n    for b > 0 {\\n        a, b = b, a%b\\n    }\\n\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc minOperations(nums []int) int {\\n\\n    n := len(nums)\\n    ones := 0\\n\\n    for _, num := range nums {\\n        if num == 1{\\n            ones++\\n        }\\n    }\\n\\n\\n    // if there is 1s, there are gcds garanteed to be 1\\n    // so just flip any other non 1s to 1s\\n    if ones > 0 {\\n        return n - ones\\n    }\\n\\n    res := math.MaxInt64\\n\\n    for i:=0; i<n; i++ {\\n        g := nums[i]\\n        for j:=i+1; j<n; j++ {\\n            g = gcd(g, nums[j])\\n            if g == 1 {\\n                // j - i: how many flips to get first 1\\n                // n - 1: same case with there are 1s in the first place\\n                res = min(res, j - i + n - 1)\\n                break\\n            }\\n        }\\n    }\\n\\n    if res == math.MaxInt64 {\\n        return -1\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859119,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859117,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733125,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = __gcd(nums[i],GCD);\\n            if(nums[i]==1)count++;\\n        }\\n        if(GCD!=1)return -1;\\n        if(count>0)return nums.size()-count;\\n        int sum =INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                GCD = __gcd(GCD,nums[j]);\\n                if(GCD==1)sum = min(sum,j-i);\\n            }\\n        }\\n        return  nums.size()-1+sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = __gcd(nums[i],GCD);\\n            if(nums[i]==1)count++;\\n        }\\n        if(GCD!=1)return -1;\\n        if(count>0)return nums.size()-count;\\n        int sum =INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                GCD = __gcd(GCD,nums[j]);\\n                if(GCD==1)sum = min(sum,j-i);\\n            }\\n        }\\n        return  nums.size()-1+sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586189,
                "title": "c-efficient-solution-subarray-upvote-if-like-it",
                "content": "# Intuition and # Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIst part, the code counts the number of occurrences of the number 1 in the nums vector. \\nIf there is at least one occurrence of 1 (one > 0), it means that the number of operations required to make all elements equal would be n - one, where n is the size of the vector and one is the count of 1s. \\n\\nThis is because you can change all the non-1 elements to 1 in n - one operations\\n\\n2nd part, the code iterates through all possible subarrays of the nums vector.\\nFor each subarray, it calculates the greatest common divisor (currGcd) of all the elements in that subarray using the gcd function.\\n\\nIf the currGcd is equal to 1, it means all elements in that subarray are ***coprime***. \\n\\nThe code then updates currLen to the minimum length required to make all elements equal, which is the minimum value between the current currLen and **(j - i) + n - 1**, where j is the end index of the subarray and i is the start index.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*n-1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a ,int b){\\n        if(a%b ==0)\\n            return b;\\n        else\\n            return gcd(b,a%b);\\n    }\\n    \\n\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int one =0;\\n        for(int i=0 ;i<n;i++){\\n            if(nums[i] == 1)\\n                one++;\\n        }\\n        if(one>0)\\n            return n-one;\\n\\n        int currLen =INT_MAX;\\n        for(int i=0 ;i<n;i++){\\n            int currGcd = 0;\\n            for(int j=i;j<n;j++){\\n                currGcd = gcd(currGcd ,nums[j]);\\n                if(currGcd == 1){\\n                    currLen = min(currLen,(j-i)+n-1);\\n                }\\n            }\\n        }\\n        currLen = currLen == INT_MAX ? -1 : currLen;\\n        return currLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a ,int b){\\n        if(a%b ==0)\\n            return b;\\n        else\\n            return gcd(b,a%b);\\n    }\\n    \\n\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int one =0;\\n        for(int i=0 ;i<n;i++){\\n            if(nums[i] == 1)\\n                one++;\\n        }\\n        if(one>0)\\n            return n-one;\\n\\n        int currLen =INT_MAX;\\n        for(int i=0 ;i<n;i++){\\n            int currGcd = 0;\\n            for(int j=i;j<n;j++){\\n                currGcd = gcd(currGcd ,nums[j]);\\n                if(currGcd == 1){\\n                    currLen = min(currLen,(j-i)+n-1);\\n                }\\n            }\\n        }\\n        currLen = currLen == INT_MAX ? -1 : currLen;\\n        return currLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536078,
                "title": "java-c-python-nice-solution-well-explained",
                "content": "# TL;DR\\n```java []\\nclass Solution {\\n    private static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int n: nums) {\\n            if (n == 1) {\\n                ones++;\\n            }\\n        }\\n        if (ones > 0) {\\n            return nums.length - ones;\\n        }\\n        int ops = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((gcd = gcd(gcd, nums[j])) == 1) {\\n                    ops = Math.min(ops, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ops == Integer.MAX_VALUE ? -1 : ops;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums) {\\n        int onesCount = std::count(nums.begin(), nums.end(), 1);\\n        if (onesCount > 0) {\\n            return nums.size() - onesCount;\\n        }\\n\\n        int ops = INT_MAX;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int currentGCD = nums[i];\\n            for (size_t j = i + 1; j < nums.size(); ++j) {\\n                currentGCD = std::gcd(currentGCD, nums[j]);\\n                if (currentGCD == 1) {\\n                    ops = std::min(ops, static_cast<int>(j - i + nums.size() - 1));\\n                    break;\\n                }\\n            }\\n        }\\n        return (ops == INT_MAX) ? -1 : ops;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        onesCount = nums.count(1)\\n        if onesCount > 0:\\n            return len(nums) - onesCount\\n\\n        ops = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            currentGCD = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                currentGCD = gcd(currentGCD, nums[j])\\n                if currentGCD == 1:\\n                    ops = min(ops, j - i + len(nums) - 1)\\n                    break\\n        return -1 if ops == float(\\'inf\\') else ops\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n\\n# Intuition\\n\\nAn important property of `gcd` is that it\\'s associative. This means that `gcd(a, b, c) = gcd(gcd(a, b), c) = gcd(a, gcd(b, c))`. This property allows us to calculate the gcd of more than two numbers by successively applying the gcd operation on pairs of numbers.\\n\\n# Approach\\n\\nThe key idea behind this algorithm is to find a pair of numbers (or a number and a combination of numbers) in the array whose greatest common divisor (gcd) is 1. Once we find such a combination, we can use the operation defined in the problem to replace one number in the combination with 1, and then use this 1 to turn all other numbers in the array into 1s. This idea leverages the property of the gcd function: `gcd(a, b, c) = gcd(gcd(a, b), c)`.\\n\\nTo find such a pair, we iterate over the array, and for each element at index `i`, we calculate the gcd with the rest of the elements in the array (i.e., the elements at indices `j` where `i < j < nums.length`). We start with `gcd = nums[i]` and then iteratively compute `gcd = gcd(gcd, nums[j])` for increasing values of `j`.\\n\\nIf at any point, the gcd becomes 1, it means that number `nums[j]` and some number or combination of the previous elements `nums[i..j-1]` have a gcd of 1. At this point, the minimum number of operations required to turn all elements in the array into 1s is `j - i + nums.length - 1`. Here, `j - i` is the number of operations needed to transform the subarray `nums[i..j]` into 1s (by replacing `nums[j]` with the gcd of `nums[i..j]`, which is 1), and `nums.length - 1` is the number of operations needed to transform the rest of the array into 1s.\\n\\nAfter this, we continue the iteration to check if we can find another pair or combination that allows us to turn all elements into 1s with fewer operations. \\n\\nThe algorithm continues this process for all elements in the array and keeps track of the minimum number of operations found. If no pair or combination with a gcd of 1 is found after examining the entire array, the algorithm returns -1 to indicate that it\\'s impossible to make all elements of the array equal to 1.\\n\\n# Complexity Analysis\\n\\n- The time complexity is $$O(n^2)$$ because for each element, we potentially calculate the gcd with the rest of the elements in the array.\\n\\n- The space complexity is $$O(1)$$ because we only use a constant amount of space to store the intermediate results.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\nclass Solution {\\n    private static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int n: nums) {\\n            if (n == 1) {\\n                ones++;\\n            }\\n        }\\n        if (ones > 0) {\\n            return nums.length - ones;\\n        }\\n        int ops = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((gcd = gcd(gcd, nums[j])) == 1) {\\n                    ops = Math.min(ops, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ops == Integer.MAX_VALUE ? -1 : ops;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums) {\\n        int onesCount = std::count(nums.begin(), nums.end(), 1);\\n        if (onesCount > 0) {\\n            return nums.size() - onesCount;\\n        }\\n\\n        int ops = INT_MAX;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int currentGCD = nums[i];\\n            for (size_t j = i + 1; j < nums.size(); ++j) {\\n                currentGCD = std::gcd(currentGCD, nums[j]);\\n                if (currentGCD == 1) {\\n                    ops = std::min(ops, static_cast<int>(j - i + nums.size() - 1));\\n                    break;\\n                }\\n            }\\n        }\\n        return (ops == INT_MAX) ? -1 : ops;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        onesCount = nums.count(1)\\n        if onesCount > 0:\\n            return len(nums) - onesCount\\n\\n        ops = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            currentGCD = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                currentGCD = gcd(currentGCD, nums[j])\\n                if currentGCD == 1:\\n                    ops = min(ops, j - i + len(nums) - 1)\\n                    break\\n        return -1 if ops == float(\\'inf\\') else ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509361,
                "title": "rust-just-works-solution-runtime-100-memory-100",
                "content": "It picks every number and travels through the array(while executing gcd on every step) until the number\\'s value is equal to one or reaches the end of the array. It also skips some numbers if it\\'s possible.\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        if nums.contains(&1) {\\n            return nums.iter().filter(|n| **n != 1).count() as i32;\\n        }\\n        let mut distance: i32 = -1;\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let mut cur_num = nums[i];\\n            for j in i+1..nums.len() {\\n                let g = Self::gcd(nums[j], cur_num);\\n                if g == nums[j] {\\n                    i = j-1;\\n                    break;\\n                }\\n                if g == 1 {\\n                    if distance == -1 || distance > (j - i) as i32 {\\n                        distance = (j - i) as i32;\\n                        break;\\n                    }\\n                } else {\\n                    cur_num = g;\\n                }\\n            }\\n            i += 1;\\n        }\\n        \\n        if distance == -1 {\\n            -1\\n        } else {\\n            distance - 1 + nums.len() as i32\\n        }\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        let (mut a, mut b) = (a, b);\\n        while b != 0 {\\n            let temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        a\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        if nums.contains(&1) {\\n            return nums.iter().filter(|n| **n != 1).count() as i32;\\n        }\\n        let mut distance: i32 = -1;\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let mut cur_num = nums[i];\\n            for j in i+1..nums.len() {\\n                let g = Self::gcd(nums[j], cur_num);\\n                if g == nums[j] {\\n                    i = j-1;\\n                    break;\\n                }\\n                if g == 1 {\\n                    if distance == -1 || distance > (j - i) as i32 {\\n                        distance = (j - i) as i32;\\n                        break;\\n                    }\\n                } else {\\n                    cur_num = g;\\n                }\\n            }\\n            i += 1;\\n        }\\n        \\n        if distance == -1 {\\n            -1\\n        } else {\\n            distance - 1 + nums.len() as i32\\n        }\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        let (mut a, mut b) = (a, b);\\n        while b != 0 {\\n            let temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        a\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489907,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp(n);\\n        int ele = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = nums[i];\\n            if(nums[i]!=1)\\n            ele++;\\n        }\\n        int cnt=0;\\n        while(tmp.size()>1)\\n        {\\n            for(int i=0;i<tmp.size()-1;i++)\\n            {\\n                if(__gcd(tmp[i],tmp[i+1])==1)\\n                return cnt+ele;\\n                tmp[i] = __gcd(tmp[i],tmp[i+1]);\\n                if(tmp[i]==1)\\n                return cnt+ele;\\n            }\\n            cnt++;\\n            tmp.pop_back();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp(n);\\n        int ele = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = nums[i];\\n            if(nums[i]!=1)\\n            ele++;\\n        }\\n        int cnt=0;\\n        while(tmp.size()>1)\\n        {\\n            for(int i=0;i<tmp.size()-1;i++)\\n            {\\n                if(__gcd(tmp[i],tmp[i+1])==1)\\n                return cnt+ele;\\n                tmp[i] = __gcd(tmp[i],tmp[i+1]);\\n                if(tmp[i]==1)\\n                return cnt+ele;\\n            }\\n            cnt++;\\n            tmp.pop_back();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489274,
                "title": "python-bruteforce-o-n-3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minspan = float(\\'inf\\')\\n        for i in range(n):\\n            for j in range(i,n):\\n                curgcd = nums[i]\\n                for k in range(i,j+1):\\n                    curgcd = gcd(curgcd, nums[k])\\n                if curgcd == 1 and minspan > j - i + 1:\\n                    minspan = j - i + 1\\n        return -1 if minspan == float(\\'inf\\') else (n - nums.count(1) if minspan == 1 else minspan - 1 + n - 1)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minspan = float(\\'inf\\')\\n        for i in range(n):\\n            for j in range(i,n):\\n                curgcd = nums[i]\\n                for k in range(i,j+1):\\n                    curgcd = gcd(curgcd, nums[k])\\n                if curgcd == 1 and minspan > j - i + 1:\\n                    minspan = j - i + 1\\n        return -1 if minspan == float(\\'inf\\') else (n - nums.count(1) if minspan == 1 else minspan - 1 + n - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488968,
                "title": "c-very-easy-beginner-friendly-easy-approach-solution",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n              c++;\\n            }\\n        }\\n        if(c==n)  return 0;\\n        if(c>=1){\\n            return n-c;;\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int cg= nums[i];\\n            for(int j=i;j<n;j++){\\n                cg=__gcd(cg,nums[j]);\\n                if(cg==1){\\n                    mini=min(mini,j-i+1);\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        if(mini!=INT_MAX){\\n            return mini+n-2-c;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n              c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3478178,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let mut one = 0;\\n        for i in 0..n {\\n            if nums[i] == 1 {\\n                one += 1;\\n            }\\n        }\\n        if one > 0 {\\n            return (n - one) as i32;\\n        }\\n        let mut la = vec![];\\n        let mut ra = vec![];\\n        let mut lg = vec![];\\n        let mut rg = vec![];\\n\\n        fn gcd(mut a: i32, mut b: i32) -> i32 {\\n            while b != 0 {\\n                let t = b;\\n                b = a % b;\\n                a = t;\\n            }\\n            a\\n        }\\n        \\n        fn good(la: &Vec<i32>, ra: &Vec<i32>, lg: &Vec<i32>, rg: &Vec<i32>) -> bool {\\n            let mut g = 0;\\n            if !la.is_empty() {\\n                g = gcd(g, lg[lg.len() - 1]);\\n            }\\n            if !ra.is_empty() {\\n                g = gcd(g, rg[rg.len() - 1]);\\n            }\\n            g == 1\\n        }\\n\\n        fn add(ra: &mut Vec<i32>, rg: &mut Vec<i32>, x: i32) {\\n            ra.push(x);\\n            rg.push(gcd(if rg.is_empty() { 0 } else { rg[rg.len() - 1] }, x));\\n        }\\n\\n        fn remove(la: &mut Vec<i32>, ra: &mut Vec<i32>, lg: &mut Vec<i32>, rg: &mut Vec<i32>) {\\n            if la.is_empty() {\\n                while !ra.is_empty() {\\n                    let x = ra[ra.len() - 1];\\n                    la.push(x);\\n                    ra.pop();\\n                    rg.pop();\\n                    lg.push(gcd(if lg.is_empty() { 0 } else { lg[lg.len() - 1] }, x));\\n                }\\n            }\\n            la.pop();\\n            lg.pop();\\n        }\\n\\n\\n        let mut ans = n;\\n        let (mut l, mut r) = (0, 0);\\n        while r < n {\\n            add(&mut ra, &mut rg, nums[r]);\\n            while l < n && good(&la, &ra, &lg, &rg) {\\n                ans = ans.min(r - l);\\n                remove(&mut la, &mut ra, &mut lg, &mut rg);\\n                l += 1;\\n            }\\n            r += 1;\\n        }\\n        if ans == n {\\n            return -1;\\n        }\\n        (n + ans - 1) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let mut one = 0;\\n        for i in 0..n {\\n            if nums[i] == 1 {\\n                one += 1;\\n            }\\n        }\\n        if one > 0 {\\n            return (n - one) as i32;\\n        }\\n        let mut la = vec![];\\n        let mut ra = vec![];\\n        let mut lg = vec![];\\n        let mut rg = vec![];\\n\\n        fn gcd(mut a: i32, mut b: i32) -> i32 {\\n            while b != 0 {\\n                let t = b;\\n                b = a % b;\\n                a = t;\\n            }\\n            a\\n        }\\n        \\n        fn good(la: &Vec<i32>, ra: &Vec<i32>, lg: &Vec<i32>, rg: &Vec<i32>) -> bool {\\n            let mut g = 0;\\n            if !la.is_empty() {\\n                g = gcd(g, lg[lg.len() - 1]);\\n            }\\n            if !ra.is_empty() {\\n                g = gcd(g, rg[rg.len() - 1]);\\n            }\\n            g == 1\\n        }\\n\\n        fn add(ra: &mut Vec<i32>, rg: &mut Vec<i32>, x: i32) {\\n            ra.push(x);\\n            rg.push(gcd(if rg.is_empty() { 0 } else { rg[rg.len() - 1] }, x));\\n        }\\n\\n        fn remove(la: &mut Vec<i32>, ra: &mut Vec<i32>, lg: &mut Vec<i32>, rg: &mut Vec<i32>) {\\n            if la.is_empty() {\\n                while !ra.is_empty() {\\n                    let x = ra[ra.len() - 1];\\n                    la.push(x);\\n                    ra.pop();\\n                    rg.pop();\\n                    lg.push(gcd(if lg.is_empty() { 0 } else { lg[lg.len() - 1] }, x));\\n                }\\n            }\\n            la.pop();\\n            lg.pop();\\n        }\\n\\n\\n        let mut ans = n;\\n        let (mut l, mut r) = (0, 0);\\n        while r < n {\\n            add(&mut ra, &mut rg, nums[r]);\\n            while l < n && good(&la, &ra, &lg, &rg) {\\n                ans = ans.min(r - l);\\n                remove(&mut la, &mut ra, &mut lg, &mut rg);\\n                l += 1;\\n            }\\n            r += 1;\\n        }\\n        if ans == n {\\n            return -1;\\n        }\\n        (n + ans - 1) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464113,
                "title": "from-math-import-gcd",
                "content": "Remember the name : Debauch Casanova\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        one = nums.count(1)\\n        if one: \\n            return len(nums)-one\\n        diff = float(inf) \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    diff = min(diff, j-i)\\n        if diff == float(inf):\\n            return -1 \\n        else:\\n            return diff + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        one = nums.count(1)\\n        if one: \\n            return len(nums)-one\\n        diff = float(inf) \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    diff = min(diff, j-i)\\n        if diff == float(inf):\\n            return -1 \\n        else:\\n            return diff + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462638,
                "title": "kotlin-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        var g = nums[0]\\n        var list = mutableListOf<Int>()\\n        var padding = 0\\n        var result = nums.size\\n        \\n        for (i in 0 until nums.size) {\\n            val n = nums[i]\\n            if (n == 1) {\\n                result--\\n            }\\n            g = gcd(g, n)\\n            if (i == nums.size - 1) continue\\n            \\n            val m = nums[i + 1]\\n            list.add(gcd(m, n))\\n        }\\n        \\n        if (g > 1) return -1\\n        \\n        while(!list.any{ it == 1 }) {\\n            padding++\\n            val nlist = mutableListOf<Int>()\\n            \\n            for (i in 0 until list.size - 1) {\\n                val n = list[i]\\n                val m = list[i + 1]\\n                \\n                nlist.add(gcd(m,n))\\n            }\\n            \\n            list = nlist\\n        }\\n\\n        return result + padding\\n    }\\n    \\n    fun gcd(a: Int, b:Int): Int = if(b != 0) gcd(b, a % b) else a\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        var g = nums[0]\\n        var list = mutableListOf<Int>()\\n        var padding = 0\\n        var result = nums.size\\n        \\n        for (i in 0 until nums.size) {\\n            val n = nums[i]\\n            if (n == 1) {\\n                result--\\n            }\\n            g = gcd(g, n)\\n            if (i == nums.size - 1) continue\\n            \\n            val m = nums[i + 1]\\n            list.add(gcd(m, n))\\n        }\\n        \\n        if (g > 1) return -1\\n        \\n        while(!list.any{ it == 1 }) {\\n            padding++\\n            val nlist = mutableListOf<Int>()\\n            \\n            for (i in 0 until list.size - 1) {\\n                val n = list[i]\\n                val m = list[i + 1]\\n                \\n                nlist.add(gcd(m,n))\\n            }\\n            \\n            list = nlist\\n        }\\n\\n        return result + padding\\n    }\\n    \\n    fun gcd(a: Int, b:Int): Int = if(b != 0) gcd(b, a % b) else a\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462249,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n  public int MinOperations(int[] nums) {\\n    if (nums.Contains(1))\\n      return nums.Length - nums.Count(n => n == 1);\\n\\n    var res = int.MaxValue;\\n    for (var i = 0; i < nums.Length; i++) {\\n        var gcd = nums[i];\\n        for (var j = i + 1; j < nums.Length; j++) {\\n            gcd = GCD(gcd, nums[j]);\\n            if (gcd == 1){\\n                res = Math.Min(res, j - i + (nums.Length - 1));\\n                break;\\n            }\\n        } \\n    }     \\n    return res == int.MaxValue ? -1 : res;\\n  }\\n\\n  static int GCD(int num1, int num2) {\\n    while (num2 != 0) {\\n        int temp = num2;\\n        num2 = num1 % num2;\\n        num1 = temp;\\n    }\\n    return num1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MinOperations(int[] nums) {\\n    if (nums.Contains(1))\\n      return nums.Length - nums.Count(n => n == 1);\\n\\n    var res = int.MaxValue;\\n    for (var i = 0; i < nums.Length; i++) {\\n        var gcd = nums[i];\\n        for (var j = i + 1; j < nums.Length; j++) {\\n            gcd = GCD(gcd, nums[j]);\\n            if (gcd == 1){\\n                res = Math.Min(res, j - i + (nums.Length - 1));\\n                break;\\n            }\\n        } \\n    }     \\n    return res == int.MaxValue ? -1 : res;\\n  }\\n\\n  static int GCD(int num1, int num2) {\\n    while (num2 != 0) {\\n        int temp = num2;\\n        num2 = num1 % num2;\\n        num1 = temp;\\n    }\\n    return num1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460599,
                "title": "the-most-simple-not-the-most-efficient-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 2 * n\\n        non_one = sum(1 for num in nums if num != 1)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if gcd(*nums[i: j + 1]) == 1:\\n                    ans = min(ans, j - i + non_one - 1)\\n        return -1 if ans == 2 * n else ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 2 * n\\n        non_one = sum(1 for num in nums if num != 1)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if gcd(*nums[i: j + 1]) == 1:\\n                    ans = min(ans, j - i + non_one - 1)\\n        return -1 if ans == 2 * n else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459865,
                "title": "python3-gcd-traverses-from-left-to-right-then-right-to-left-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy\\nUse two loops traverse the array from left to right and from right to left, respectively, to find the minimum number of operations needed to make all elements of the array equal to 1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt = nums.count(1) # to check if any 1\\'s in the nums\\n        if cnt: \\n            return len(nums) - cnt\\n        # get the minium steps from left to right\\n        i = 0\\n        mins = len(nums)\\n        g = nums[0]\\n        for j in range(len(nums)):\\n            if nums[j] == 1:\\n                cnt += 1\\n            g = math.gcd(g, nums[j])\\n            if j and math.gcd(nums[j-1], nums[j]) == g:\\n                i = j-1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[j]\\n                i = j\\n        # get the minium steps from right to left\\n        j = len(nums) - 1\\n        g = nums[-1]\\n        for i in range(len(nums)-1, -1, -1):\\n            g = math.gcd(g, nums[i])\\n            if i < len(nums) - 1 and math.gcd(nums[i], nums[i+1]) == g:\\n                j = i + 1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[i]\\n                j = i\\n        return -1 if mins == len(nums) else mins + len(nums) - 1\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt = nums.count(1) # to check if any 1\\'s in the nums\\n        if cnt: \\n            return len(nums) - cnt\\n        # get the minium steps from left to right\\n        i = 0\\n        mins = len(nums)\\n        g = nums[0]\\n        for j in range(len(nums)):\\n            if nums[j] == 1:\\n                cnt += 1\\n            g = math.gcd(g, nums[j])\\n            if j and math.gcd(nums[j-1], nums[j]) == g:\\n                i = j-1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[j]\\n                i = j\\n        # get the minium steps from right to left\\n        j = len(nums) - 1\\n        g = nums[-1]\\n        for i in range(len(nums)-1, -1, -1):\\n            g = math.gcd(g, nums[i])\\n            if i < len(nums) - 1 and math.gcd(nums[i], nums[i+1]) == g:\\n                j = i + 1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[i]\\n                j = i\\n        return -1 if mins == len(nums) else mins + len(nums) - 1\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459753,
                "title": "easily-understandable-solution-uses-gcd-property-and-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the question asked us to make the whole array 1 by using gcd of adjacent .\\nso the intuition is that gcd of two or more number becomes 1 when their is no common factor between them and another thing is that gcd of any number with 1 is always 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, first we need to check that in the given array whether thier is 1 present or not ,if 1 is present then we can make the whole array 1 by just applying the n- countof(1) operation . You can understand it easily just dry run it with some tcs.\\nNow if 1 is not present then our goal is to find the smallest subarray whose gcd is 1 . We are doing this because once we create a single one from that subarray then in exactly n-1 moves we can make whole array equal to 1 .\\nso ans becomes smallest subarray of gcd 1 + n-1 moves.\\nBelow is the implementation of this..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) As nested for loop is running.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct=0;\\n        int n=nums.size();\\n        for(auto i:nums)if(i==1)ct++;\\n        if(ct>0)return n-ct;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int an=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                an=__gcd(an,nums[j]);\\n                if(an==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            }\\n        if(ans==INT_MAX)return -1;\\n        return ans+n-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct=0;\\n        int n=nums.size();\\n        for(auto i:nums)if(i==1)ct++;\\n        if(ct>0)return n-ct;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int an=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                an=__gcd(an,nums[j]);\\n                if(an==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            }\\n        if(ans==INT_MAX)return -1;\\n        return ans+n-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459697,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOne = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1)\\n               noOfOne++;\\n        }\\n\\n        if(noOfOne > 0)\\n          return nums.length - noOfOne;\\n        \\n        int currLen = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int currGcd = nums[i];\\n            for(int j = i + 1; j < nums.length; j++){\\n                 currGcd = gcd(currGcd, nums[j]);\\n                \\n                if(currGcd == 1){\\n                    currLen = Math.min(currLen, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (currLen == Integer.MAX_VALUE) ? -1 : currLen;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOne = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1)\\n               noOfOne++;\\n        }\\n\\n        if(noOfOne > 0)\\n          return nums.length - noOfOne;\\n        \\n        int currLen = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int currGcd = nums[i];\\n            for(int j = i + 1; j < nums.length; j++){\\n                 currGcd = gcd(currGcd, nums[j]);\\n                \\n                if(currGcd == 1){\\n                    currLen = Math.min(currLen, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (currLen == Integer.MAX_VALUE) ? -1 : currLen;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457911,
                "title": "fully-explained-easy-c",
                "content": "# Approach and Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Case-1: If there are \\'count\\' number of ones in nums array, then (n-count) will be the min ops, because each non-ones is gonna take 1 step to convert into 1, and (n-count) are the no-ones.\\n\\n        //Let\\'s count ones\\n        int count=0;\\n        for(auto num: nums) {\\n            if(num==1) {\\n                count++;\\n            }\\n        }\\n        if(count>0) {\\n            return n-count;\\n        }\\n\\n        //Case-2: If there are no ones in the array, the we\\'ll follow below algorithm\\n\\n        /*\\n        e.g. 4,8,6,9\\n        if any one of the above elements become 1, then rest will take (n-1) steps to get converted into 1.\\n        So, for example 6 takes x steps to get converted into 1, so overall (x+(n-1))steps will be required by the array to convert all into 1\\n        But then we\\'ll need to check for each element and find the minimal of (x+(n-1)) among all.\\n        It\\'s gonna take O(n2) time\\n\\n        By the way, how to find those x steps, so in the above example, 4 & 9 have gcd 1, and since it is given in the question that we can only change adjacent element to 1, so for 9 to convert into 1, it\\'s gonna take 3 steps i.e.(j-i) steps, where j is index of 9 and i is index of 4. \\n\\n        Hence the optimised approach is to find the smallest subarray, whose gcd is one so, we\\'ll have the minimum j-i value, and hence minimum x value and hence minimum (x+(n-1)) value !\\n        */\\n\\n        int x=INT_MAX;\\n\\n        for(int i=0;i<n-1;i++) {\\n\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++) {\\n\\n                g=__gcd(g,nums[j]);\\n\\n                if(g==1) {\\n                    x=min(x,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        //now we have got the minimum x\\n\\n        if(x!=INT_MAX) {\\n            return (x+(n-1));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Case-1: If there are \\'count\\' number of ones in nums array, then (n-count) will be the min ops, because each non-ones is gonna take 1 step to convert into 1, and (n-count) are the no-ones.\\n\\n        //Let\\'s count ones\\n        int count=0;\\n        for(auto num: nums) {\\n            if(num==1) {\\n                count++;\\n            }\\n        }\\n        if(count>0) {\\n            return n-count;\\n        }\\n\\n        //Case-2: If there are no ones in the array, the we\\'ll follow below algorithm\\n\\n        /*\\n        e.g. 4,8,6,9\\n        if any one of the above elements become 1, then rest will take (n-1) steps to get converted into 1.\\n        So, for example 6 takes x steps to get converted into 1, so overall (x+(n-1))steps will be required by the array to convert all into 1\\n        But then we\\'ll need to check for each element and find the minimal of (x+(n-1)) among all.\\n        It\\'s gonna take O(n2) time\\n\\n        By the way, how to find those x steps, so in the above example, 4 & 9 have gcd 1, and since it is given in the question that we can only change adjacent element to 1, so for 9 to convert into 1, it\\'s gonna take 3 steps i.e.(j-i) steps, where j is index of 9 and i is index of 4. \\n\\n        Hence the optimised approach is to find the smallest subarray, whose gcd is one so, we\\'ll have the minimum j-i value, and hence minimum x value and hence minimum (x+(n-1)) value !\\n        */\\n\\n        int x=INT_MAX;\\n\\n        for(int i=0;i<n-1;i++) {\\n\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++) {\\n\\n                g=__gcd(g,nums[j]);\\n\\n                if(g==1) {\\n                    x=min(x,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        //now we have got the minimum x\\n\\n        if(x!=INT_MAX) {\\n            return (x+(n-1));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457084,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int min = 100, ones = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                ones++;\\n                min = 1;\\n                continue;\\n            }\\n            for (int j = i + 1, a = nums[i]; j < n && j - i < min; j++) {\\n                int b = nums[j];\\n                while (b != 0) {\\n                    int t = a % b;\\n                    a = b;\\n                    b = t;\\n                }\\n                if (a == 1) min = j - i;\\n            }\\n        }\\n        return min < 100 ? n - 1 + min - ones : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int min = 100, ones = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                ones++;\\n                min = 1;\\n                continue;\\n            }\\n            for (int j = i + 1, a = nums[i]; j < n && j - i < min; j++) {\\n                int b = nums[j];\\n                while (b != 0) {\\n                    int t = a % b;\\n                    a = b;\\n                    b = t;\\n                }\\n                if (a == 1) min = j - i;\\n            }\\n        }\\n        return min < 100 ? n - 1 + min - ones : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455515,
                "title": "c-find-smallest-subarray-with-gcd-of-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> gcfs(nums);\\n        int pivot = -1, groupsz = 0; // to find smallest subarray [pivot, pivot+groupsz) to have gcd of 1\\n        while(pivot == -1 && ++groupsz <= nums.size()) {\\n            for(int i = 0; i <= nums.size() - groupsz; ++i) {\\n                if( (gcfs[i] = gcd(gcfs[i], nums[i + groupsz - 1])) == 1 ) {\\n                    pivot = i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(groupsz > nums.size()) return -1;\\n        nums[pivot] = 1;\\n        return groupsz - 1 + count_if(nums.begin(), nums.end(), binder2nd(not_equal_to<int>(), 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> gcfs(nums);\\n        int pivot = -1, groupsz = 0; // to find smallest subarray [pivot, pivot+groupsz) to have gcd of 1\\n        while(pivot == -1 && ++groupsz <= nums.size()) {\\n            for(int i = 0; i <= nums.size() - groupsz; ++i) {\\n                if( (gcfs[i] = gcd(gcfs[i], nums[i + groupsz - 1])) == 1 ) {\\n                    pivot = i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(groupsz > nums.size()) return -1;\\n        nums[pivot] = 1;\\n        return groupsz - 1 + count_if(nums.begin(), nums.end(), binder2nd(not_equal_to<int>(), 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453390,
                "title": "python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n1 = sum(i==1 for i in nums)      \\n        l = len(nums)\\n        res = l-n1\\n\\n        while l>1:\\n            new_nums = []\\n            for i in range(l-1):\\n                add = math.gcd(nums[i], nums[i + 1])\\n                if add == 1:\\n                    return res\\n                new_nums.append(add)\\n            nums = new_nums\\n            l = len(nums)\\n            res += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n1 = sum(i==1 for i in nums)      \\n        l = len(nums)\\n        res = l-n1\\n\\n        while l>1:\\n            new_nums = []\\n            for i in range(l-1):\\n                add = math.gcd(nums[i], nums[i + 1])\\n                if add == 1:\\n                    return res\\n                new_nums.append(add)\\n            nums = new_nums\\n            l = len(nums)\\n            res += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452354,
                "title": "python-find-min-subarray-with-gcd-1",
                "content": "This one is tricky.\\n\\n1. Find if the array has at least `1`. As `gcd(x, 1) => 1`, If yes, then you can turn in into all `1` in `N - count_of_1`\\n2. If there\\'s no `1` we need to findout if we can find `1` or not. If we can, we need to find the smallest subarray with `gcd(subarray) = 1`. This will require `len(subarray) - 1` operations to make at least one `1`, if possible. The result is *number of operations to make at least `1` one + number of elements that needs to be turned into 1 except that one `1` that we made earlier*\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        ones = sum((1 for n in nums if n == 1))\\n        if ones:\\n            return N - ones\\n        \\n        min_subarray = float(inf)\\n        for start in range(N - 1):\\n            i = start\\n            c = nums[i]\\n            while i < N - 1 and c != 1:\\n                c = gcd(c, nums[i + 1])\\n                i += 1\\n            if c == 1:\\n                min_subarray = min(min_subarray, i - start + 1)\\n        \\n        if min_subarray == float(inf):\\n            return -1\\n        \\n        return min_subarray - 1 + N - 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        ones = sum((1 for n in nums if n == 1))\\n        if ones:\\n            return N - ones\\n        \\n        min_subarray = float(inf)\\n        for start in range(N - 1):\\n            i = start\\n            c = nums[i]\\n            while i < N - 1 and c != 1:\\n                c = gcd(c, nums[i + 1])\\n                i += 1\\n            if c == 1:\\n                min_subarray = min(min_subarray, i - start + 1)\\n        \\n        if min_subarray == float(inf):\\n            return -1\\n        \\n        return min_subarray - 1 + N - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452267,
                "title": "python3-segment-tree-o-n-log-n-shortest-subarray-with-gcd-as-1",
                "content": "Follow the same logic as many other discussions:\\n* Check edge cases.\\n* Find the shortest subarray with GCD as 1 by sliding window: first move pointer hi to the right until GCD of nums[lo:hi] is 1, then shrink pointer lo from the left until it is no longer 1; after that move on to the next window...\\n* Use segment tree to calculate GCD of range nums[lo:hi] efficiently in O(log n).\\n```\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n\\t\\t# edge case 1: check existence of 1\\n        c1 = nums.count(1)\\n        if c1 > 0:\\n            return n - c1\\n        \\n\\t\\t# edge case 2: impossible if GCD of all numbers is not 1\\n        if gcd(*nums) != 1:\\n            return -1\\n        \\n\\t\\t# initialize segment tree: tree[i] = gcd(tree[k]: k + 1 has bit prefix as i + 1)\\n        tree = [0] * (n - 1) + nums\\n        for i in range(n - 2, -1, -1):\\n            tree[i] = gcd(tree[2*i + 1], tree[2*i + 2])\\n        \\n\\t\\t# helper function to calculate GCD of range nums[lo:hi]\\n        def gcd_range(lo, hi):\\n            g = nums[lo]\\n            lo += n - 1\\n            hi += n - 1 \\n            while lo < hi:\\n                if lo % 2 == 0:\\n                    g = gcd(g, tree[lo])\\n                    lo += 1\\n                if hi % 2 == 0:\\n                    hi -= 1\\n                    g = gcd(g, tree[hi])\\n                lo = (lo - 1) // 2\\n                hi = (hi - 1) // 2\\n            return g\\n        \\n        # find shortest subarray with GCD as 1\\n        w = n \\n        lo = hi = 1        \\n        g = nums[0]\\n        while hi < n:\\n            g = gcd(g, nums[hi])\\n            hi += 1\\n            if g == 1:\\n                while (g := gcd_range(lo, hi)) == 1:\\n                    lo += 1\\n                w = min(w, hi - lo + 1)\\n\\n        return n - 2 + w\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n\\t\\t# edge case 1: check existence of 1\\n        c1 = nums.count(1)\\n        if c1 > 0:\\n            return n - c1\\n        \\n\\t\\t# edge case 2: impossible if GCD of all numbers is not 1\\n        if gcd(*nums) != 1:\\n            return -1\\n        \\n\\t\\t# initialize segment tree: tree[i] = gcd(tree[k]: k + 1 has bit prefix as i + 1)\\n        tree = [0] * (n - 1) + nums\\n        for i in range(n - 2, -1, -1):\\n            tree[i] = gcd(tree[2*i + 1], tree[2*i + 2])\\n        \\n\\t\\t# helper function to calculate GCD of range nums[lo:hi]\\n        def gcd_range(lo, hi):\\n            g = nums[lo]\\n            lo += n - 1\\n            hi += n - 1 \\n            while lo < hi:\\n                if lo % 2 == 0:\\n                    g = gcd(g, tree[lo])\\n                    lo += 1\\n                if hi % 2 == 0:\\n                    hi -= 1\\n                    g = gcd(g, tree[hi])\\n                lo = (lo - 1) // 2\\n                hi = (hi - 1) // 2\\n            return g\\n        \\n        # find shortest subarray with GCD as 1\\n        w = n \\n        lo = hi = 1        \\n        g = nums[0]\\n        while hi < n:\\n            g = gcd(g, nums[hi])\\n            hi += 1\\n            if g == 1:\\n                while (g := gcd_range(lo, hi)) == 1:\\n                    lo += 1\\n                w = min(w, hi - lo + 1)\\n\\n        return n - 2 + w\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3451358,
                "title": "easy-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust think what will happen if there is atleast one \\'1\\' in the array then simply ans will be n-(number of 1\\'s).\\n\\nif 1 is not present then we have to find 2 elements such that their gcd is 1 then count the steps to do so. final answer will be :-\\n---->  steps required + n-steps.\\n\\nSee solution for clean code.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(), nums.end(), 1);\\n        if(c!=0) return n-c;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            int gcd=nums[i];\\n            for(int j=i+1; j<n; j++){\\n                gcd=__gcd(gcd, nums[j]);\\n\\n                if(gcd==1){\\n                    ans=min(ans, j-i+n-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n\\n// 2 6 3 4\\n// 2 2 1 -1\\n    \\n// 6 10 15\\n// 2 1 -2\\n\\n\\n// 6 10 15\\n// 2 10 15\\n// 2 1  15\\n// 1 1 15\\n// 1 1 1\\n    \\n// 2*3\\n// 2*5\\n// 3*5\\n\\n\\n// 1*2\\n// 2*3\\n// 1*3\\n// 2*2\\n\\n\\n// 010\\n// 110\\n// 011\\n// 100\\n    \\n    \\n// 0010\\n// 1010\\n// 0110\\n// 1110\\n\\n\\n// 2 6 3 9 4\\n// 2 6 3 9 1\\n// 2 6 3 1 1\\n// 2 1 3 1 1\\n// 1 1 3 1 1\\n// 1 1 1 1 1\\n\\n\\n\\n// If the gcd is 1, then we can start iterating through the array, keeping track of the current gcd of the current element and its neighbor to the right. If the current gcd is not already 1, we keep expanding the current gcd to the right until we reach the end of the array or the current gcd becomes 1. We count the number of operations needed to make the current gcd equal to 1 and move on to the next element.\\n\\n// Finally, we return the total number of operations needed to make all elements 1.\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(), nums.end(), 1);\\n        if(c!=0) return n-c;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            int gcd=nums[i];\\n            for(int j=i+1; j<n; j++){\\n                gcd=__gcd(gcd, nums[j]);\\n\\n                if(gcd==1){\\n                    ans=min(ans, j-i+n-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n\\n// 2 6 3 4\\n// 2 2 1 -1\\n    \\n// 6 10 15\\n// 2 1 -2\\n\\n\\n// 6 10 15\\n// 2 10 15\\n// 2 1  15\\n// 1 1 15\\n// 1 1 1\\n    \\n// 2*3\\n// 2*5\\n// 3*5\\n\\n\\n// 1*2\\n// 2*3\\n// 1*3\\n// 2*2\\n\\n\\n// 010\\n// 110\\n// 011\\n// 100\\n    \\n    \\n// 0010\\n// 1010\\n// 0110\\n// 1110\\n\\n\\n// 2 6 3 9 4\\n// 2 6 3 9 1\\n// 2 6 3 1 1\\n// 2 1 3 1 1\\n// 1 1 3 1 1\\n// 1 1 1 1 1\\n\\n\\n\\n// If the gcd is 1, then we can start iterating through the array, keeping track of the current gcd of the current element and its neighbor to the right. If the current gcd is not already 1, we keep expanding the current gcd to the right until we reach the end of the array or the current gcd becomes 1. We count the number of operations needed to make the current gcd equal to 1 and move on to the next element.\\n\\n// Finally, we return the total number of operations needed to make all elements 1.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451320,
                "title": "c-solution-o-n-2-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int g = nums[0];\\n        for(auto i : nums) {mp[i]++; g = __gcd(g, i);}\\n        if(g > 1) return -1;\\n        if(mp[1] > 0) return n-mp[1];\\n        for(int i=0;i<n-1;i++) if(__gcd(nums[i], nums[i+1]) == 1) return n;\\n        int count = 1e9;\\n        for(int ind=0;ind<n;ind++){\\n            g = 0;\\n            int cnt = 0, gc = 0;\\n            for(int i=ind;i<n;i++){\\n                g = __gcd(g, nums[i]);\\n                if(g == 1){\\n                    int k = nums[i];\\n                    int j = i-1; gc = nums[j];\\n                    while(__gcd(gc,k) != 1){\\n                        j--; cnt++;\\n                        gc = __gcd(gc, nums[j]);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(cnt > 0) count = min(count, cnt);\\n        }\\n        return n + count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int g = nums[0];\\n        for(auto i : nums) {mp[i]++; g = __gcd(g, i);}\\n        if(g > 1) return -1;\\n        if(mp[1] > 0) return n-mp[1];\\n        for(int i=0;i<n-1;i++) if(__gcd(nums[i], nums[i+1]) == 1) return n;\\n        int count = 1e9;\\n        for(int ind=0;ind<n;ind++){\\n            g = 0;\\n            int cnt = 0, gc = 0;\\n            for(int i=ind;i<n;i++){\\n                g = __gcd(g, nums[i]);\\n                if(g == 1){\\n                    int k = nums[i];\\n                    int j = i-1; gc = nums[j];\\n                    while(__gcd(gc,k) != 1){\\n                        j--; cnt++;\\n                        gc = __gcd(gc, nums[j]);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(cnt > 0) count = min(count, cnt);\\n        }\\n        return n + count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451155,
                "title": "intuitive-simulation-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int gcd(int a, int b) {\\n        if (a < b) swap(a, b);\\n        if (b == 0) return a;\\n\\n        return gcd(b, a % b);\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len = nums.size();\\n        int ones = 0;\\n        for (auto n : nums) {\\n            ones += n == 1;\\n        }\\n\\n        \\n        bool one = false;\\n        int step = -1;\\n\\n        while (nums.size() > 1 and !one) {\\n            vector<int> next;\\n            for (int i = 0; i < nums.size() - 1; ++i) {\\n                next.push_back(gcd(nums[i], nums[i + 1]));\\n                if (next.back() == 1) {\\n                    one = true;\\n                    break;\\n                }\\n            }\\n            nums = next;\\n            ++step;\\n        }\\n\\n        if (!one) return -1;\\n\\n        return len + step - ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int gcd(int a, int b) {\\n        if (a < b) swap(a, b);\\n        if (b == 0) return a;\\n\\n        return gcd(b, a % b);\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len = nums.size();\\n        int ones = 0;\\n        for (auto n : nums) {\\n            ones += n == 1;\\n        }\\n\\n        \\n        bool one = false;\\n        int step = -1;\\n\\n        while (nums.size() > 1 and !one) {\\n            vector<int> next;\\n            for (int i = 0; i < nums.size() - 1; ++i) {\\n                next.push_back(gcd(nums[i], nums[i + 1]));\\n                if (next.back() == 1) {\\n                    one = true;\\n                    break;\\n                }\\n            }\\n            nums = next;\\n            ++step;\\n        }\\n\\n        if (!one) return -1;\\n\\n        return len + step - ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450295,
                "title": "o-n-2-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ``O(n^2)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX, cnt = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1){\\n                cnt++;\\n            }\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            int gcd = nums[i];\\n            for(int j = i + 1; j < n; ++j){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    ans = min(ans, n - 1 + j - i);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX, cnt = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1){\\n                cnt++;\\n            }\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            int gcd = nums[i];\\n            for(int j = i + 1; j < n; ++j){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    ans = min(ans, n - 1 + j - i);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450166,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums)\\n    {\\n        if (nums.Contains(1))\\n            return nums.Length - nums.Count(n => n == 1);\\n\\n        var result = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                var d = nums.Skip(i).Take(j - i + 1).Aggregate(nums[j], Gcd);\\n\\n                if (d != 1)\\n                    continue;\\n\\n                result = result == -1\\n                    ? j - i + 1\\n                    : Math.Min(result, j - i + 1);\\n            }\\n\\n        return result == -1 ? -1 : nums.Length + result - 2;\\n    }\\n\\n    private static int Gcd(int a, int b)\\n    {\\n        return b == 0 ? a : Gcd(b, a % b);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums)\\n    {\\n        if (nums.Contains(1))\\n            return nums.Length - nums.Count(n => n == 1);\\n\\n        var result = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                var d = nums.Skip(i).Take(j - i + 1).Aggregate(nums[j], Gcd);\\n\\n                if (d != 1)\\n                    continue;\\n\\n                result = result == -1\\n                    ? j - i + 1\\n                    : Math.Min(result, j - i + 1);\\n            }\\n\\n        return result == -1 ? -1 : nums.Length + result - 2;\\n    }\\n\\n    private static int Gcd(int a, int b)\\n    {\\n        return b == 0 ? a : Gcd(b, a % b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449155,
                "title": "easy-explanation-java-code-silly-observation-need-to-solve-this-problem",
                "content": "**IF YOU LIKE THE SOLUTION THEN UPVOTE IT PLEASE**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ele = nums[0],numOpe = 0;\\n        \\n        //check if how many 1 present already\\n        //another check if the whole array gcd is not one atleast then not possible to make all one;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = gcd(nums[i],ele);\\n            \\n            if(nums[i] == 1)\\n                numOpe++;\\n        }\\n        if(ele != 1)return -1;\\n        \\n        //number of not one element\\n        int notOne = n - numOpe; \\n        \\n        \\n        /*\\n        calculate no operation to make atleast single one\\n        as the n constraint 50 we can use broute force method\\n        why we use broute foce\\n        let\\'s consider one example\\n        e.g : 2,4,6,3\\n        if you computer all those ele single time then it\\n        atleast min single one operation is 3 but actually it\\'s two\\n        how? \\n        gcd(4,3) --> 1\\n        */\\n        int finalMinOperationAtleastOne = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = nums[i];\\n            int minOpeAtleastOne = 0;\\n            for(int j = i+1; j < n; j++)\\n            {\\n                ele = gcd(ele,nums[j]);\\n                minOpeAtleastOne++;\\n                if(ele == 1){\\n                    finalMinOperationAtleastOne = Math.min(finalMinOperationAtleastOne,minOpeAtleastOne);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       //-1 because we already calculate one those gcd during interation\\n    return finalMinOperationAtleastOne + notOne - 1;\\n        \\n    }\\n    private int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ele = nums[0],numOpe = 0;\\n        \\n        //check if how many 1 present already\\n        //another check if the whole array gcd is not one atleast then not possible to make all one;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = gcd(nums[i],ele);\\n            \\n            if(nums[i] == 1)\\n                numOpe++;\\n        }\\n        if(ele != 1)return -1;\\n        \\n        //number of not one element\\n        int notOne = n - numOpe; \\n        \\n        \\n        /*\\n        calculate no operation to make atleast single one\\n        as the n constraint 50 we can use broute force method\\n        why we use broute foce\\n        let\\'s consider one example\\n        e.g : 2,4,6,3\\n        if you computer all those ele single time then it\\n        atleast min single one operation is 3 but actually it\\'s two\\n        how? \\n        gcd(4,3) --> 1\\n        */\\n        int finalMinOperationAtleastOne = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = nums[i];\\n            int minOpeAtleastOne = 0;\\n            for(int j = i+1; j < n; j++)\\n            {\\n                ele = gcd(ele,nums[j]);\\n                minOpeAtleastOne++;\\n                if(ele == 1){\\n                    finalMinOperationAtleastOne = Math.min(finalMinOperationAtleastOne,minOpeAtleastOne);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       //-1 because we already calculate one those gcd during interation\\n    return finalMinOperationAtleastOne + notOne - 1;\\n        \\n    }\\n    private int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448987,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf 1 is in the array, the result is length of array - number of 1.\\nElse we tries to find the smallest subset that has gcd of 1, the result would be the length of the array + length of subset - 1\\nIf we cannot find such subset, it is impossible to achieve the goal, so we return -1\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        self.res = [0, 100]\\n        def dfs(st, i, val):\\n            if i - st >= self.res[1] - self.res[0]:\\n                return\\n            if val == 1:\\n                if self.res[1] - self.res[0] > (i - st):\\n                    self.res = [st, i]\\n                return\\n            if i == len(nums): return\\n            dfs(st, i+1, math.gcd(val, nums[i]))\\n        \\n        for i in range(len(nums)):\\n            dfs(i, i+1, nums[i])\\n        \\n        return -1 if self.res == [0, 100] else len(nums) + (self.res[1] - self.res[0] - 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        self.res = [0, 100]\\n        def dfs(st, i, val):\\n            if i - st >= self.res[1] - self.res[0]:\\n                return\\n            if val == 1:\\n                if self.res[1] - self.res[0] > (i - st):\\n                    self.res = [st, i]\\n                return\\n            if i == len(nums): return\\n            dfs(st, i+1, math.gcd(val, nums[i]))\\n        \\n        for i in range(len(nums)):\\n            dfs(i, i+1, nums[i])\\n        \\n        return -1 if self.res == [0, 100] else len(nums) + (self.res[1] - self.res[0] - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448477,
                "title": "clean-and-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain intention is to make anyhow one element of the array as 1 which will help make all the elements as 1.\\n\\nIF GCD of complete array is not 1, then its impossible to have a element be made 1 which will make entire 1..\\nIf the array already consists of 1s, then no of operations = (n - no. of ones)\\n\\nIf no 1s are present, then we have to perform operations to make 1 and then total operations = **\"operations to make 1\"** + (n - 1)operations to make rest of the normal elements as 1. \\n\\nFor **\"operations to make 1\"**,\\nWe find the minimum size array which has a gcd of 1. The min size array will result in less operations to make a element 1. Then the rest no of operations need to make other operations 1 = (n - 1).\\nNote:- The -1 is because of the element which has been made 1 by gcd operations in the minimum size array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force since constraints allow us\\n# Complexity\\n- Time complexity: O(N*3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0, val = 0;\\n        for(auto ele: nums)\\n        {\\n            val = __gcd(val, ele);\\n            if(ele == 1)\\n                ones++;\\n        }\\n        \\n        //base cases of impossibility\\n        if(val != 1)\\n            return -1;\\n        \\n        //base case of some 1s being already present\\n        if(ones != 0)\\n            return n - ones;\\n        \\n        //if no 1s are present, and we need to make all elements 1\\n        int min_sz = 100;\\n        for(int i = 0; i < n; i++)\\n            for(int j = i; j < n; j++)\\n            {\\n                int el = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    el = __gcd(el, nums[k]);\\n                }\\n                if(el == 1)\\n                    min_sz = min(min_sz, j - i + 1);\\n            }\\n        \\n        return (min_sz - 1) + (n - 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0, val = 0;\\n        for(auto ele: nums)\\n        {\\n            val = __gcd(val, ele);\\n            if(ele == 1)\\n                ones++;\\n        }\\n        \\n        //base cases of impossibility\\n        if(val != 1)\\n            return -1;\\n        \\n        //base case of some 1s being already present\\n        if(ones != 0)\\n            return n - ones;\\n        \\n        //if no 1s are present, and we need to make all elements 1\\n        int min_sz = 100;\\n        for(int i = 0; i < n; i++)\\n            for(int j = i; j < n; j++)\\n            {\\n                int el = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    el = __gcd(el, nums[k]);\\n                }\\n                if(el == 1)\\n                    min_sz = min(min_sz, j - i + 1);\\n            }\\n        \\n        return (min_sz - 1) + (n - 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448373,
                "title": "simple-gcd-concept-solution",
                "content": "# Intuition\\n```\\n2 consecutive numbers gcd=1;__gcd(5,6)=1, __gcd(45,46)=1;\\n__gcd(1,any number)=1;\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt=0,maxi=INT_MAX;\\n        for(int x:nums){\\n            if(x==1)cnt++;\\n        }\\n        if(cnt>0){\\n            return nums.size()-cnt;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int last=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                last=__gcd(last,nums[j]);\\n                if(last==1){\\n                    maxi=min(maxi,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(maxi!=INT_MAX){\\n            return maxi+nums.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n2 consecutive numbers gcd=1;__gcd(5,6)=1, __gcd(45,46)=1;\\n__gcd(1,any number)=1;\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt=0,maxi=INT_MAX;\\n        for(int x:nums){\\n            if(x==1)cnt++;\\n        }\\n        if(cnt>0){\\n            return nums.size()-cnt;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int last=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                last=__gcd(last,nums[j]);\\n                if(last==1){\\n                    maxi=min(maxi,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(maxi!=INT_MAX){\\n            return maxi+nums.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447564,
                "title": "simple-brute-force-with-explanation-using-gcd-10-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int countOne=0;\\n        for(auto x: nums){\\n            if(x==1){\\n               countOne++;\\n            }\\n        }\\n        if(countOne>0){\\n             // 1 1 1 8 3 7\\n            return (nums.size() - countOne);\\n        }else{\\n            // 3 4 2 6\\n            // 1,1,1,1 8 10\\n            /// check if any pair gcd become 1;\\n            int ans=INT_MAX;\\n            int n = nums.size();\\n            for(int i=0;i<n-1;i++){\\n                int gcd = nums[i];\\n                for(int j=i+1;j<n;j++){\\n                    gcd = __gcd(gcd,nums[j]);\\n                    if(gcd==1){\\n                        // if means we start from the index i , and till jth index and which will make one value as 1 , in the\\n                        // operation of j-i, and then we will use this 1 to make all n-1 to become 1;\\n                        ans=min(ans,j-i+(n-1));\\n                    }\\n                }\\n            }\\n             if(ans==INT_MAX) ans=-1;\\n            return ans;\\n            \\n        }\\n    }\\n};\\n\\n// 6,10,15\\n// 6,2,15\\n// 6,2,1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int countOne=0;\\n        for(auto x: nums){\\n            if(x==1){\\n               countOne++;\\n            }\\n        }\\n        if(countOne>0){\\n             // 1 1 1 8 3 7\\n            return (nums.size() - countOne);\\n        }else{\\n            // 3 4 2 6\\n            // 1,1,1,1 8 10\\n            /// check if any pair gcd become 1;\\n            int ans=INT_MAX;\\n            int n = nums.size();\\n            for(int i=0;i<n-1;i++){\\n                int gcd = nums[i];\\n                for(int j=i+1;j<n;j++){\\n                    gcd = __gcd(gcd,nums[j]);\\n                    if(gcd==1){\\n                        // if means we start from the index i , and till jth index and which will make one value as 1 , in the\\n                        // operation of j-i, and then we will use this 1 to make all n-1 to become 1;\\n                        ans=min(ans,j-i+(n-1));\\n                    }\\n                }\\n            }\\n             if(ans==INT_MAX) ans=-1;\\n            return ans;\\n            \\n        }\\n    }\\n};\\n\\n// 6,10,15\\n// 6,2,15\\n// 6,2,1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447558,
                "title": "python-3-find-shortest-subarray-with-gcd-1",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)      \\n            \\n        vis = deque()\\n        \\n        def check(cands):\\n            tmp = cands[0]\\n            for i in range(1, len(cands)):\\n                tmp = math.gcd(tmp, cands[i])\\n                if tmp == 1: return True\\n            return tmp == 1\\n                \\n        \\n        size = n + 1\\n        for j in range(len(nums)):\\n            vis.append(nums[j])\\n            while vis and check(vis):\\n                size = min(size, len(vis))                \\n                vis.popleft()\\n        \\n\\t\\t# if 1 already existed, then just need to change non-1 elements\\n        if size == 1:\\n            return sum(num > 1 for num in nums)\\n\\t\\t# not able to find the subarray\\n        elif size == n + 1:\\n            return -1\\n        # all element > 1 but could find a subarray\\n\\t\\t# the ops need to transform the subarray to have at least one 1 is (size - 1), and then transofrm the rest of elements is (n - 1)\\n\\t\\telse:\\n            return n - 1 + size - 1\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)      \\n            \\n        vis = deque()\\n        \\n        def check(cands):\\n            tmp = cands[0]\\n            for i in range(1, len(cands)):\\n                tmp = math.gcd(tmp, cands[i])\\n                if tmp == 1: return True\\n            return tmp == 1\\n                \\n        \\n        size = n + 1\\n        for j in range(len(nums)):\\n            vis.append(nums[j])\\n            while vis and check(vis):\\n                size = min(size, len(vis))                \\n                vis.popleft()\\n        \\n\\t\\t# if 1 already existed, then just need to change non-1 elements\\n        if size == 1:\\n            return sum(num > 1 for num in nums)\\n\\t\\t# not able to find the subarray\\n        elif size == n + 1:\\n            return -1\\n        # all element > 1 but could find a subarray\\n\\t\\t# the ops need to transform the subarray to have at least one 1 is (size - 1), and then transofrm the rest of elements is (n - 1)\\n\\t\\telse:\\n            return n - 1 + size - 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3447549,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ones, diff = len(nums), nums.count(1), float(\"inf\")\\n\\n        if ones: return n-ones\\n\\n        for i in range(n):\\n            val = nums[i]\\n            for j in range(i+1,n):\\n                val = gcd(val,nums[j])\\n                if val == 1: diff = min(diff,j-i+1)\\n\\n        return -1 if diff == float(\"inf\") else diff + n - 2\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ones, diff = len(nums), nums.count(1), float(\"inf\")\\n\\n        if ones: return n-ones\\n\\n        for i in range(n):\\n            val = nums[i]\\n            for j in range(i+1,n):\\n                val = gcd(val,nums[j])\\n                if val == 1: diff = min(diff,j-i+1)\\n\\n        return -1 if diff == float(\"inf\") else diff + n - 2\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447440,
                "title": "my-thought-process-to-approach-it",
                "content": "Let\\'s estimate the lower/upper bound of the minimum number of operations to see\\nwhat happens.\\n\\n## Lower Bound\\n\\nIf we are lucky, each operation will convert a number to 1, then the lower bound\\nis `n = length(nums)`, or more precisely, `n - count(1, nums)`.\\nWhen this happens?\\nObviously, if we have 1 in the input array, we can spread it to the whole array.\\n\\nSo we have this pseudocode:\\n\\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        ...\\n```\\n\\n## Upper Bound\\n\\nThen we estimate the upper bound. The case there is no 1.\\n\\nThings start to become complex.\\n\\nLet us start with a simple example.\\nWe have two numbers: `[a, b]`, let `g = gcd(a, b)`.\\nWe might have this operation sequence:\\n\\n```\\na1 <- g\\nb1 <- gcd(a1, b) = gcd(g, b) = g\\na2 <- gcd(a1, b1) = gcd(g, g) = g\\n...\\n```\\n\\nYou might noticed that more operations are meaningless, because\\nthe result is always `g`, that means we can do at most 2 operations for 2\\nelements array, if it will succeed to make them to be 1.\\n\\nIt\\'s a good sign.\\nLet\\'s see what happens for 3 elements array `[a, b, c]`.\\nThis is a possible operation sequence:\\n\\n```\\na1 <- gcd(a, b)\\nb1 <- gcd(a1, b) = gcd(gcd(a, b), b) = gcd(a, b)\\nc1 <- gcd(b1, c) = gcd(gcd(a, b), c) = gcd(a, b, c)\\na2 <- gcd(a1, b1) = gcd(a, b)\\nb2 <- gcd(b2, c1) = gcd(a, b, c)\\nc2 <- gcd(b2, c1) = gcd(a, b, c)\\n...\\n```\\n\\nLook what happens! the new `a` will always be one of `gcd(a, b)`, `gcd(a, b, c)`\\nthe new `b` will always be one of `gcd(a, b)`, `gcd(b, c)`, or `gcd(a, b, c)`.\\n\\nIf these gcd values don\\'t contain 1, then it fails. Otherwise, we can do at most\\n2 operations to make the array appears 1.\\n\\nFinally, we can do at most `n-1` operations to make the `n` length array appears 1.\\n\\n## Generalize\\n\\nIn this case, suppose `nums[i]` will be the first 1, it might be the values\\n\\n```\\ngcd(nums[i], nums[i+1])\\ngcd(nums[i], nums[i+1], nums[i+2])\\n...\\ngcd(nums[i-1], nums[i])\\ngcd(nums[i-2], nums[i-1], nums[i])\\n...\\ngcd(nums[i-1], nums[i], nums[i+1])\\n...\\n```\\n\\nAny gcd of a subarray that contains `nums[i]` might be the first 1.\\n\\nWe can enumerate all subarrays to find the minimum length subarray that gcd is 1.\\n\\nFinally, the pseudocode:\\n\\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        min_len = inf\\n        for subarray in subarrays_of(nums):\\n            if gcd(subarray) == 1:\\n                min_len = min(min_len, subarray.len())\\n        if min_len == inf:\\n            return -1\\n        else:\\n            return (nums.len() - 1) + (min_len - 1)\\n```\\n\\n# Code\\n\\n```scheme\\n(define (min-operations nums)\\n  (define inf #e1e9)\\n  (define min-len inf)\\n  (define n (length nums))\\n  (for* ([j (inclusive-range 1 n)]\\n         [i j])\\n    (when (= 1 (apply gcd (sublist nums i j)))\\n      (set! min-len (min min-len (- j i)))))\\n\\n  (if (= min-len inf)\\n      -1\\n      (+ (- n (max 1 (count (\\u03BB (x) (= x 1)) nums)))\\n         (- min-len 1))))\\n\\n(define (sublist lst from to)\\n  (drop (take lst to) from))\\n\\n```\\n\\n## Conclusion\\n\\nThe only important idea is to estimate the space of the result.\\n\\nUpvote if you like it.\\n",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        ...\\n```\n```\\na1 <- g\\nb1 <- gcd(a1, b) = gcd(g, b) = g\\na2 <- gcd(a1, b1) = gcd(g, g) = g\\n...\\n```\n```\\na1 <- gcd(a, b)\\nb1 <- gcd(a1, b) = gcd(gcd(a, b), b) = gcd(a, b)\\nc1 <- gcd(b1, c) = gcd(gcd(a, b), c) = gcd(a, b, c)\\na2 <- gcd(a1, b1) = gcd(a, b)\\nb2 <- gcd(b2, c1) = gcd(a, b, c)\\nc2 <- gcd(b2, c1) = gcd(a, b, c)\\n...\\n```\n```\\ngcd(nums[i], nums[i+1])\\ngcd(nums[i], nums[i+1], nums[i+2])\\n...\\ngcd(nums[i-1], nums[i])\\ngcd(nums[i-2], nums[i-1], nums[i])\\n...\\ngcd(nums[i-1], nums[i], nums[i+1])\\n...\\n```\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        min_len = inf\\n        for subarray in subarrays_of(nums):\\n            if gcd(subarray) == 1:\\n                min_len = min(min_len, subarray.len())\\n        if min_len == inf:\\n            return -1\\n        else:\\n            return (nums.len() - 1) + (min_len - 1)\\n```\n```scheme\\n(define (min-operations nums)\\n  (define inf #e1e9)\\n  (define min-len inf)\\n  (define n (length nums))\\n  (for* ([j (inclusive-range 1 n)]\\n         [i j])\\n    (when (= 1 (apply gcd (sublist nums i j)))\\n      (set! min-len (min min-len (- j i)))))\\n\\n  (if (= min-len inf)\\n      -1\\n      (+ (- n (max 1 (count (\\u03BB (x) (= x 1)) nums)))\\n         (- min-len 1))))\\n\\n(define (sublist lst from to)\\n  (drop (take lst to) from))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447413,
                "title": "c-math-easy-understanding-n-2",
                "content": "shortest subarray having gcd==1\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        \\n        int maxi=1;\\n        for(int i=1;i<=min(a,b);i++){\\n            if(a%i==0 && b%i==0){\\n                maxi=max(maxi,i);\\n            }\\n        }\\n        return maxi;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        \\n        bool flag=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0){\\n            return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count>=1){\\n            return n-count;\\n        }\\n        flag=0;\\n        for(int i=0;i<n-1;i++){\\n            \\n            if(gcd(nums[i],nums[i+1])==1){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==1){\\n            return n;\\n        }\\n        int mini=1e9;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=gcd(g,nums[j]);\\n                if(g==1){\\n                    mini=min(mini,j-i+n-1);\\n                }\\n            }\\n        }\\n        return mini>=1e9? -1:mini;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int gcd(int a,int b){\\n        \\n        int maxi=1;\\n        for(int i=1;i<=min(a,b);i++){\\n            if(a%i==0 && b%i==0){\\n                maxi=max(maxi,i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3446670,
                "title": "simple-easy-to-understand-solution-with-explanation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCase 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\nCalculate gcdValue by taking GCD of all numbers. \\nIf gcdValue > 1 then return -1.\\n\\nCase 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\nif we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\nCase 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int gcd(int A, int B) {\\n        if(B == 0) {\\n            return A;\\n        }\\n        return gcd(B, A%B);\\n    }\\n    public int minOperations(int[] nums) {\\n        // Intuition - \\n        // Case 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\n        // Calculate gcdValue by taking GCD of all numbers. \\n        // If gcdValue > 1 then return -1.\\n\\n        // Case 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\n        // if we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\n        // Case 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n        // Time Complexity = O(N^2)\\n        // Space Complexity = O(1)\\n\\n\\n        int N = nums.length;\\n        int gcdValue = nums[0];\\n        int ones = 0;\\n        if(gcdValue == 1) {\\n            ones++;\\n        } \\n        for(int i = 1; i < N; i++) {\\n            if(nums[i] == 1) {\\n                ones++;\\n            }\\n            if(gcdValue > 1) {\\n                gcdValue = gcd(gcdValue, nums[i]);\\n            }\\n        }\\n        if(gcdValue > 1) {\\n            return -1;\\n        }\\n        if(ones > 0) {\\n            return N - ones;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < N; i++) {\\n            int value = nums[i];\\n            for(int j = i+1; j < N; j++) {\\n                value = gcd(value, nums[j]);\\n                if(value == 1) {\\n                    ans = Math.min(ans, (j-i) + (N-1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int A, int B) {\\n        if(B == 0) {\\n            return A;\\n        }\\n        return gcd(B, A%B);\\n    }\\n    public int minOperations(int[] nums) {\\n        // Intuition - \\n        // Case 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\n        // Calculate gcdValue by taking GCD of all numbers. \\n        // If gcdValue > 1 then return -1.\\n\\n        // Case 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\n        // if we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\n        // Case 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n        // Time Complexity = O(N^2)\\n        // Space Complexity = O(1)\\n\\n\\n        int N = nums.length;\\n        int gcdValue = nums[0];\\n        int ones = 0;\\n        if(gcdValue == 1) {\\n            ones++;\\n        } \\n        for(int i = 1; i < N; i++) {\\n            if(nums[i] == 1) {\\n                ones++;\\n            }\\n            if(gcdValue > 1) {\\n                gcdValue = gcd(gcdValue, nums[i]);\\n            }\\n        }\\n        if(gcdValue > 1) {\\n            return -1;\\n        }\\n        if(ones > 0) {\\n            return N - ones;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < N; i++) {\\n            int value = nums[i];\\n            for(int j = i+1; j < N; j++) {\\n                value = gcd(value, nums[j]);\\n                if(value == 1) {\\n                    ans = Math.min(ans, (j-i) + (N-1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446481,
                "title": "easy-simple-solution-c-code-c-c",
                "content": "# Intuition\\nTo find Minimum Number of Operations to Make All Array Elements Equal to 1\\n\\n# Approach\\nFirst find the total  number of 1 in the nums vector. The answer will be size(nums)- number of ones.\\n\\n\\nIf  1 not present then find if there exist a pair of consecutive coprime numbers. The answer in that case will also be size(nums).\\n\\n\\nNow make each element of nums from i=0 to n-2 be nums[i]=gcd(nums[i],nums[i+1]). Do this till it is further not possible or a 1 is found in the nums vector. Count the number of times this operation is performed. At the end if 1 is found then the answer will be        size(nums)-1+count(number of operations).\\n\\nOtherwise the final answer will be -1.\\n# Code\\n```\\nclass Solution {\\npublic:   \\n    int minOperations(vector<int>& nums) {\\n        int prime=0;\\n        int n=nums.size();\\n        map<int,int> mpp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mpp[nums[i]]++;\\n        }\\n        if(mpp[1]==n)\\n        {\\n            return 0;\\n        }\\n        if(mpp[1]>0)\\n        {\\n            return (n-mpp[1]);\\n        }\\n        int p=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(__gcd(nums[i],nums[i+1])==1)\\n            {   \\n                p++;\\n            }\\n        }\\n        if(p>0)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        \\n        \\n        \\n\\n        bool test=true;\\n        int count=0, o=0;\\n        while(test)\\n        {\\n            vector<int> prev=nums;\\n            \\n           \\n            for(int i=0;i<n-1;i++)\\n            {\\n                nums[i]=__gcd(nums[i],nums[i+1]);\\n            }\\n            \\n             o=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    o++;\\n                }\\n            }\\n            \\n            \\n            \\n            if(nums==prev)\\n            {\\n                test=false;\\n                break;\\n            }\\n            count++;\\n            if(o>0)\\n            {\\n                break;\\n            }\\n            prev=nums;\\n        }\\n      \\n        int one=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n            }\\n        }\\n        if(one>0)\\n        return (n-1+count);\\n        \\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int minOperations(vector<int>& nums) {\\n        int prime=0;\\n        int n=nums.size();\\n        map<int,int> mpp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mpp[nums[i]]++;\\n        }\\n        if(mpp[1]==n)\\n        {\\n            return 0;\\n        }\\n        if(mpp[1]>0)\\n        {\\n            return (n-mpp[1]);\\n        }\\n        int p=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(__gcd(nums[i],nums[i+1])==1)\\n            {   \\n                p++;\\n            }\\n        }\\n        if(p>0)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        \\n        \\n        \\n\\n        bool test=true;\\n        int count=0, o=0;\\n        while(test)\\n        {\\n            vector<int> prev=nums;\\n            \\n           \\n            for(int i=0;i<n-1;i++)\\n            {\\n                nums[i]=__gcd(nums[i],nums[i+1]);\\n            }\\n            \\n             o=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    o++;\\n                }\\n            }\\n            \\n            \\n            \\n            if(nums==prev)\\n            {\\n                test=false;\\n                break;\\n            }\\n            count++;\\n            if(o>0)\\n            {\\n                break;\\n            }\\n            prev=nums;\\n        }\\n      \\n        int one=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n            }\\n        }\\n        if(one>0)\\n        return (n-1+count);\\n        \\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446384,
                "title": "tricky-math-solution-could-not-able-to-solve-in-contest-but-able-to-solve-in-15mins-after-the-conte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith my experience I can say that GCD problems are bit complicated but after getting the logic it is pretty straight forward. Try to solve it with cool mind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn these problem we have 2 scenarious.\\n- Answer is -1\\n    - We should perform gcd for all n elements. If the gcd>1 then we can say that we can\\'t make all elements to 1. so the answer would be -1.\\n- Answer exists\\n    - For each pair, we calculate the greatest common divisor (GCD) of the pair using the __gcd function, which is a built-in function in C++ that calculates the GCD of two integers. It continues to calculate the GCD of the pair with the previous elements until the GCD is equal to 1. When the GCD becomes 1, the function records the length of the subarray between the two elements as the current answer, and then breaks out of the loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int n=v.size();\\n        int f=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==1)\\n                f=1;\\n            if(v[i]!=1)\\n                c++;\\n        }\\n        if(f==1)\\n            return c;\\n        int ans=500;\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=i-1,g=v[i];\\n            while(j>=0)\\n            {\\n                g=__gcd(g,v[j]);\\n                if(g==1)\\n                {\\n                    ans=min(ans,i-j);\\n                    break;\\n                }\\n                j--;\\n            }\\n        }\\n        if(ans==500)\\n            return -1;\\n        return n+ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int n=v.size();\\n        int f=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==1)\\n                f=1;\\n            if(v[i]!=1)\\n                c++;\\n        }\\n        if(f==1)\\n            return c;\\n        int ans=500;\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=i-1,g=v[i];\\n            while(j>=0)\\n            {\\n                g=__gcd(g,v[j]);\\n                if(g==1)\\n                {\\n                    ans=min(ans,i-j);\\n                    break;\\n                }\\n                j--;\\n            }\\n        }\\n        if(ans==500)\\n            return -1;\\n        return n+ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446378,
                "title": "easy-c-solution-in-three-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First Case**: If number of ones in array is non-zero than answer will (arr.size()-count of ones).\\n**Second Case**: As length of array is small. Then travel all subarray and find if gcd of that subarray is one. If its gcd is one then you can make any one element of that subarray as one in (subarray.size()-1) steps by taking repetative gcd with  any one single element. And take minimum sized subarray. Now with that element as one you can make other element as one in (array.size()-1) steps. So final answer will be((MinimumSizedSubarray.size()-1)+(array.size()-1)). \\n**Third Case**: if you cannot find any subarray with gcd equals one then return -1;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n         int n=nums.size(),ans=INT_MAX,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n     int gc=0;\\n        for(int j=i;j<n;j++){\\n            gc=__gcd(gc,nums[j]);\\n        \\n            if(gc==1){\\n                ans=min(ans,j-i+1);\\n            }\\n        }\\n        }\\n        if(cnt>0){\\n            return n-cnt;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        long long int res=n+ans-2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n         int n=nums.size(),ans=INT_MAX,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n     int gc=0;\\n        for(int j=i;j<n;j++){\\n            gc=__gcd(gc,nums[j]);\\n        \\n            if(gc==1){\\n                ans=min(ans,j-i+1);\\n            }\\n        }\\n        }\\n        if(cnt>0){\\n            return n-cnt;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        long long int res=n+ans-2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446339,
                "title": "simple-c-solution-intutive",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt = count(nums.begin(),nums.end(),1);\\n        if(cnt != 0) return n - cnt;\\n\\n        int res = INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(int j= i+1; j<nums.size(); j++){\\n                x = __gcd(x,nums[j]);\\n                if(x == 1){\\n                    res = min(res,(j-i)+(n-1)); // Min steps req to make GCD of this subarray 1 + (n-1) steps to make the remaining elment equals to 1.\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt = count(nums.begin(),nums.end(),1);\\n        if(cnt != 0) return n - cnt;\\n\\n        int res = INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(int j= i+1; j<nums.size(); j++){\\n                x = __gcd(x,nums[j]);\\n                if(x == 1){\\n                    res = min(res,(j-i)+(n-1)); // Min steps req to make GCD of this subarray 1 + (n-1) steps to make the remaining elment equals to 1.\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446315,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minOperations(const vector<int> &nums) {\\n    constexpr int one = 1;\\n    const int n = static_cast<int>(nums.size());\\n    int ones = 0;\\n    int min_length = n + 1;\\n    for (int start = 0; start < n; ++start) {\\n      if (nums[start] == one) {\\n        ++ones;\\n      }\\n      \\n      int g = nums[start];\\n      int end = start + 1;\\n      for (; ones == 0 && end < min(start + min_length, n); ++end) {\\n        g = gcd(g, nums[end]);\\n        if (g == 1) {\\n          break;\\n        }\\n      }\\n      if (g == one) {\\n        min_length = end - start + 1;\\n      }\\n    }\\n    \\n    return min_length == n + 1 ? -1 : (min_length - 1) + (n - 1) - ones;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minOperations(const vector<int> &nums) {\\n    constexpr int one = 1;\\n    const int n = static_cast<int>(nums.size());\\n    int ones = 0;\\n    int min_length = n + 1;\\n    for (int start = 0; start < n; ++start) {\\n      if (nums[start] == one) {\\n        ++ones;\\n      }\\n      \\n      int g = nums[start];\\n      int end = start + 1;\\n      for (; ones == 0 && end < min(start + min_length, n); ++end) {\\n        g = gcd(g, nums[end]);\\n        if (g == 1) {\\n          break;\\n        }\\n      }\\n      if (g == one) {\\n        min_length = end - start + 1;\\n      }\\n    }\\n    \\n    return min_length == n + 1 ? -1 : (min_length - 1) + (n - 1) - ones;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446177,
                "title": "best-clean-c-code-greedy",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(),count=0,count_1=0,x=nums[0],mini=n;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n            x=__gcd(x,nums[i]);\\n        }\\n        if(count_1 != 0)\\n            return n - count_1;\\n        if(x != 1)\\n            return -1;\\n        for(int i=0;i<n-1;i++){\\n            x=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x == 1){\\n                    mini = min(mini,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return n + mini;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/05af26e6-16dc-4493-aaf4-0d1cee2faea2_1682228417.2335925.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(),count=0,count_1=0,x=nums[0],mini=n;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n            x=__gcd(x,nums[i]);\\n        }\\n        if(count_1 != 0)\\n            return n - count_1;\\n        if(x != 1)\\n            return -1;\\n        for(int i=0;i<n-1;i++){\\n            x=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x == 1){\\n                    mini = min(mini,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return n + mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446131,
                "title": "simple-very-easy-normal-brute-force-solution-gcd-c",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones = 0;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones>0) return n-ones;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                nums[i]= __gcd(nums[i], nums[j]);\\n                if(nums[i]==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(nums[i]!=1) break;\\n        }\\n\\n        if(ans==INT_MAX) return -1;\\n        return n-1+ans;\\n    }\\n};\\n\\n```\\n\\n# Kindly, it you got the code solution, Do UPVOTE!\\n![upvote.png](https://assets.leetcode.com/users/images/83c566a6-16a0-43b4-8296-a2b2c44dd240_1682227798.0569692.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones = 0;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones>0) return n-ones;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                nums[i]= __gcd(nums[i], nums[j]);\\n                if(nums[i]==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(nums[i]!=1) break;\\n        }\\n\\n        if(ans==INT_MAX) return -1;\\n        return n-1+ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446130,
                "title": "esay-to-understand-beginer-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 1e7;\\n        int c=count(nums.begin(),nums.end(),1);\\n        if(c!=0){\\n            return n-c;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                k=__gcd(k,nums[j]);\\n                if(k==1){\\n                    res=min(res,j-i+(n-1));\\n                    break;\\n                }\\n            }\\n        \\n        }\\n\\nreturn res==1e7?-1:res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 1e7;\\n        int c=count(nums.begin(),nums.end(),1);\\n        if(c!=0){\\n            return n-c;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                k=__gcd(k,nums[j]);\\n                if(k==1){\\n                    res=min(res,j-i+(n-1));\\n                    break;\\n                }\\n            }\\n        \\n        }\\n\\nreturn res==1e7?-1:res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446120,
                "title": "java-gcd-euclid-s-algorithm-easy-and-simple-solution",
                "content": "**Time Complexity : - O(n^2)**\\n**Space Complexity : - O(1)**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int cntOne = 0;\\n        for (int n : nums) if (n == 1) cntOne++;\\n        if (cntOne != 0) return nums.length - cntOne;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                num = gcd(num, nums[j]);\\n                if (num == 1) {\\n                    res = Math.min(res, (j-i+(nums.length-1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t\\n\\t// Euclidean algorithm to Find GCD of two number \\n    private int gcd(int n1, int n2) {\\n        while (n2 != 0) {\\n            int m = n1 % n2;\\n            n1 = n2;\\n            n2 = m;\\n        }\\n        return n1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int cntOne = 0;\\n        for (int n : nums) if (n == 1) cntOne++;\\n        if (cntOne != 0) return nums.length - cntOne;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                num = gcd(num, nums[j]);\\n                if (num == 1) {\\n                    res = Math.min(res, (j-i+(nums.length-1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t\\n\\t// Euclidean algorithm to Find GCD of two number \\n    private int gcd(int n1, int n2) {\\n        while (n2 != 0) {\\n            int m = n1 % n2;\\n            n1 = n2;\\n            n2 = m;\\n        }\\n        return n1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446100,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countOnes = count(nums.begin(), nums.end(), 1);  \\n        if(countOnes != 0) return n - countOnes;\\n        int res = INT_MAX;     \\n        for(int i = 0; i < n; i++){\\n            int totalGcdValue = nums[i];\\n            for(int j = i + 1; j < n; j++){\\n                totalGcdValue = __gcd(totalGcdValue, nums[j]);\\n                if(totalGcdValue == 1){\\n                    res = min(res, j - i + (n-1)); \\n                    break;\\n                } \\n            }\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countOnes = count(nums.begin(), nums.end(), 1);  \\n        if(countOnes != 0) return n - countOnes;\\n        int res = INT_MAX;     \\n        for(int i = 0; i < n; i++){\\n            int totalGcdValue = nums[i];\\n            for(int j = i + 1; j < n; j++){\\n                totalGcdValue = __gcd(totalGcdValue, nums[j]);\\n                if(totalGcdValue == 1){\\n                    res = min(res, j - i + (n-1)); \\n                    break;\\n                } \\n            }\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446094,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ones=nums.count(1)\\n        if ones:\\n            return n-ones\\n        diff=inf\\n        for i in range(n):\\n            g=nums[i] \\n\\n            for j in range(i+1,n):\\n                g=gcd(g,nums[j])\\n                if g==1:\\n                    diff=min(diff,j-i)\\n\\n\\n        return -1 if diff==inf else  diff+n-1                     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ones=nums.count(1)\\n        if ones:\\n            return n-ones\\n        diff=inf\\n        for i in range(n):\\n            g=nums[i] \\n\\n            for j in range(i+1,n):\\n                g=gcd(g,nums[j])\\n                if g==1:\\n                    diff=min(diff,j-i)\\n\\n\\n        return -1 if diff==inf else  diff+n-1                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446091,
                "title": "find-the-smallest-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int count = 0;\\n        int gcdd = 1;\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                countone++;\\n            }\\n        }\\n        // find the samllest subarray with gcd = 1\\n        int len = 1e9;\\n        if(countone>0)return  n - countone;\\n        for(int i = 0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j = i+1;j<nums.size();j++){\\n                val = __gcd(val,nums[j]);\\n                if(val == 1){\\n                    len = min(len,(j-i));\\n                }\\n            }\\n        }\\n        if(len == 1e9)return -1;\\n        return nums.size() + len -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int count = 0;\\n        int gcdd = 1;\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                countone++;\\n            }\\n        }\\n        // find the samllest subarray with gcd = 1\\n        int len = 1e9;\\n        if(countone>0)return  n - countone;\\n        for(int i = 0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j = i+1;j<nums.size();j++){\\n                val = __gcd(val,nums[j]);\\n                if(val == 1){\\n                    len = min(len,(j-i));\\n                }\\n            }\\n        }\\n        if(len == 1e9)return -1;\\n        return nums.size() + len -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446081,
                "title": "gcd-java-find-smallest-way-to-compute-first-1",
                "content": "```\\nclass Solution {\\n\\n    int getgcd(int a, int b) {\\n        int soln = 1;\\n\\n        for (int i = 1; i <= a && i <= b; ++i) {\\n            if (a % i == 0 && b % i == 0) soln = i;\\n        }\\n        return soln;\\n    }\\n\\n    public boolean computeGCD(int[] nums, int i, int j) {\\n        int t = nums[i];\\n        for (int itr = i + 1; itr <= j; itr++) {\\n            t = getgcd(t, nums[itr]);\\n            if (t == 1) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int onecount = 0;\\n        for (int i : nums) if (i == 1) onecount++;\\n        if (onecount != 0) return nums.length - onecount;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (computeGCD(nums, i, j)) {\\n                    min = Math.min(min, j - i - 1 + nums.length);\\n                    break;\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int getgcd(int a, int b) {\\n        int soln = 1;\\n\\n        for (int i = 1; i <= a && i <= b; ++i) {\\n            if (a % i == 0 && b % i == 0) soln = i;\\n        }\\n        return soln;\\n    }\\n\\n    public boolean computeGCD(int[] nums, int i, int j) {\\n        int t = nums[i];\\n        for (int itr = i + 1; itr <= j; itr++) {\\n            t = getgcd(t, nums[itr]);\\n            if (t == 1) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int onecount = 0;\\n        for (int i : nums) if (i == 1) onecount++;\\n        if (onecount != 0) return nums.length - onecount;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (computeGCD(nums, i, j)) {\\n                    min = Math.min(min, j - i - 1 + nums.length);\\n                    break;\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446017,
                "title": "shortest-sub-array-with-gcd-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n ^ 2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        # If there is 1 in the array, return number of non-one directly\\n        ones = nums.count(1)\\n        if ones:\\n            return N - ones\\n        \\n        # Find shortest sub-array with gcd 1\\n        def shortest():\\n            ans = N + 1\\n            for i in range(N):\\n                cur = nums[i]\\n                for j in range(i + 1, N):\\n                    cur = gcd(cur, nums[j])\\n                    if cur == 1:\\n                        ans = min(ans, j - i + 1)\\n            return ans\\n\\n        L = shortest()\\n        return -1 if L == N + 1 else N + L - 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        # If there is 1 in the array, return number of non-one directly\\n        ones = nums.count(1)\\n        if ones:\\n            return N - ones\\n        \\n        # Find shortest sub-array with gcd 1\\n        def shortest():\\n            ans = N + 1\\n            for i in range(N):\\n                cur = nums[i]\\n                for j in range(i + 1, N):\\n                    cur = gcd(cur, nums[j])\\n                    if cur == 1:\\n                        ans = min(ans, j - i + 1)\\n            return ans\\n\\n        L = shortest()\\n        return -1 if L == N + 1 else N + L - 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446008,
                "title": "gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ones_count = nums.count(1)\\n\\n        if ones_count: \\n            return len(nums)-ones_count\\n\\n        steps = inf \\n\\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    steps = min(steps, j-i)\\n\\n        return -1 if steps == inf else steps + n - 1\\n                \\n\\n\\n        \\n        \\n        \\n        \\n        \\n    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ones_count = nums.count(1)\\n\\n        if ones_count: \\n            return len(nums)-ones_count\\n\\n        steps = inf \\n\\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    steps = min(steps, j-i)\\n\\n        return -1 if steps == inf else steps + n - 1\\n                \\n\\n\\n        \\n        \\n        \\n        \\n        \\n    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445960,
                "title": "gcd-of-multiple-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find gcd of multiple numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncall gcd n-1 times to find gcd of n numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^3 log(m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445957,
                "title": "gcd-of-multiple-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find gcd of multiple numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncall gcd n-1 times to find gcd of n numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^3 log(m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445941,
                "title": "c-java-brute-force-intuitive",
                "content": "## Explanation\\nCount the number of 1\\'s present in the array. If there are any 1\\'s present in the array, we can directly return the count of all elements except 1\\'s, as we can spread the 1\\'s by with the GCD operation. \\n\\nIf no 1\\'s are present , then a brute force approach is to iterate over all elements for each element and find the GCD of a subarray. If it equals to 1, then it means that we can convert it to 1 in `j - i` (length of subarray) steps.\\n\\nFind the minimum length of such subarray and return `n - minLength + 1`. If no subarray with GCD of 1 is found, return -1. \\n\\n## Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ones = 0, n = size(nums);\\n        for(int &val:nums) if(val==1) ones++;\\n        if(ones) return n - ones;\\n        else{\\n            int ans = 1e8;\\n            for(int i = 0; i < n; i++){\\n                int curr = nums[i];\\n                for(int j = i+1; j < n; j++){\\n                    curr = __gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = min(ans, j-i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) break;\\n            }\\n            return ans==1e8?-1:(n+ans-1);\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0, n = nums.length;\\n        for(int val : nums) {\\n            if(val == 1) {\\n                ones++;\\n            }\\n        }\\n        if(ones != 0) {\\n            return n - ones;\\n        }\\n        else {\\n            int ans = 100000000;\\n            for(int i = 0; i < n; i++) {\\n                int curr = nums[i];\\n                for(int j = i + 1; j < n; j++) {\\n                    curr = gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = Math.min(ans, j - i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) {\\n                    break;\\n                }\\n            }\\n            return ans == 100000000 ? -1 : (n + ans - 1);\\n        }\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ones = 0, n = size(nums);\\n        for(int &val:nums) if(val==1) ones++;\\n        if(ones) return n - ones;\\n        else{\\n            int ans = 1e8;\\n            for(int i = 0; i < n; i++){\\n                int curr = nums[i];\\n                for(int j = i+1; j < n; j++){\\n                    curr = __gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = min(ans, j-i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) break;\\n            }\\n            return ans==1e8?-1:(n+ans-1);\\n        }\\n        return 0;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0, n = nums.length;\\n        for(int val : nums) {\\n            if(val == 1) {\\n                ones++;\\n            }\\n        }\\n        if(ones != 0) {\\n            return n - ones;\\n        }\\n        else {\\n            int ans = 100000000;\\n            for(int i = 0; i < n; i++) {\\n                int curr = nums[i];\\n                for(int j = i + 1; j < n; j++) {\\n                    curr = gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = Math.min(ans, j - i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) {\\n                    break;\\n                }\\n            }\\n            return ans == 100000000 ? -1 : (n + ans - 1);\\n        }\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445937,
                "title": "easiest-c-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n       int nonOnes = 0 ;\\n        for(auto x:nums){\\n            if(x!=1) nonOnes++ ;\\n        }    \\n        \\n        if(nonOnes==0) return 0;\\n        \\n        // atleast 1 is present \\n        if(nonOnes!=nums.size()) return nonOnes ;\\n        \\n        int howFast = 1e9 ;\\n        // how fast can I create a one \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int step = 1 ;\\n            int gcd=__gcd(nums[i],nums[i+1]) ;\\n            for(int j=i+2; j<nums.size(); j++){\\n                if(gcd==1) break ;\\n                gcd=__gcd(gcd,nums[j]) ;\\n                step++;\\n            }\\n            if(gcd==1){\\n                howFast =  min(howFast,step) ;\\n            }\\n        }\\n        \\n        \\n        if(howFast==1e9) return -1; \\n        \\n        return howFast+nums.size()-1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n       int nonOnes = 0 ;\\n        for(auto x:nums){\\n            if(x!=1) nonOnes++ ;\\n        }    \\n        \\n        if(nonOnes==0) return 0;\\n        \\n        // atleast 1 is present \\n        if(nonOnes!=nums.size()) return nonOnes ;\\n        \\n        int howFast = 1e9 ;\\n        // how fast can I create a one \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int step = 1 ;\\n            int gcd=__gcd(nums[i],nums[i+1]) ;\\n            for(int j=i+2; j<nums.size(); j++){\\n                if(gcd==1) break ;\\n                gcd=__gcd(gcd,nums[j]) ;\\n                step++;\\n            }\\n            if(gcd==1){\\n                howFast =  min(howFast,step) ;\\n            }\\n        }\\n        \\n        \\n        if(howFast==1e9) return -1; \\n        \\n        return howFast+nums.size()-1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445932,
                "title": "c-intuitive-simple-approach-explained",
                "content": "# Intuition\\nAs soon as we will have a 1 in the array the whole array can be converted to ones by a single operation for each element.\\n\\n# Approach\\nInitially check if there are any ones in the array. If yes, then simply return the count of non-one values in the array.\\n\\nOtherwise:\\nKeep on checking if all the elements in the array are equal or not and if all elements are equal and not equal to 1 then its impossible to convert the array to all ones.\\n\\nFind the minimum number of operations to convert any element to one. As we are using adjacent elements we can keep on traversing the given array and save the gcd of them in the same array as the previous values don\\'t matter anymore.\\n\\nAs we have the minimum number of operations to convert a single element to one. Now, the minimum number of operations to convert the whole array to ones is the number of non-one values in the array i.e. n - 1.\\n\\n# Complexity\\n- Time complexity: O(M * N) where M denotes number of operations to convert an element to 1 (0 < M < N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        // initial check for ones\\n        int c1 = 0;\\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] == 1)\\n                c1++;\\n        }\\n        if(c1)\\n            return N - c1;\\n        \\n        int n = nums.size();\\n        int ans = 0;\\n        bool found1 = false;\\n        while(!found1 && n > 0) {\\n            // checking if we have a 1 in the modified array\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] == 1)\\n                    found1 = true;\\n            }\\n            // ans contains the minimum number of operations to get first 1\\n            // this 1 will be used to convert every other element to 1\\n            if(found1)\\n                ans += N - 1;\\n            else {\\n                // searching for first 1\\n                ans++;\\n                int equalC = 0;\\n                for(int i = 0; i < n - 1; i++) {\\n                    if(nums[i] == nums[i + 1])\\n                        equalC++;\\n                }\\n                // if all elements are equal and are not 1\\n                // its impossible to convert the array\\n                if(nums[0] != 1 && equalC + 1 == n)\\n                    return -1;\\n                // next array\\n                for(int i = 0; i < n - 1; i++)\\n                    nums[i] = __gcd(nums[i], nums[i + 1]);\\n                n--;\\n            }\\n        }\\n        if(n == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        // initial check for ones\\n        int c1 = 0;\\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] == 1)\\n                c1++;\\n        }\\n        if(c1)\\n            return N - c1;\\n        \\n        int n = nums.size();\\n        int ans = 0;\\n        bool found1 = false;\\n        while(!found1 && n > 0) {\\n            // checking if we have a 1 in the modified array\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] == 1)\\n                    found1 = true;\\n            }\\n            // ans contains the minimum number of operations to get first 1\\n            // this 1 will be used to convert every other element to 1\\n            if(found1)\\n                ans += N - 1;\\n            else {\\n                // searching for first 1\\n                ans++;\\n                int equalC = 0;\\n                for(int i = 0; i < n - 1; i++) {\\n                    if(nums[i] == nums[i + 1])\\n                        equalC++;\\n                }\\n                // if all elements are equal and are not 1\\n                // its impossible to convert the array\\n                if(nums[0] != 1 && equalC + 1 == n)\\n                    return -1;\\n                // next array\\n                for(int i = 0; i < n - 1; i++)\\n                    nums[i] = __gcd(nums[i], nums[i + 1]);\\n                n--;\\n            }\\n        }\\n        if(n == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445902,
                "title": "beginner-solution-easy-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=INT_MAX;\\n        int jat = 0;\\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                jat++;\\n            }\\n        }\\n        \\n        if(jat > 0) return nums.size() - jat;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            int num1 = nums[i];\\n            for(int j=i+1; j<nums.size(); j++) \\n            {\\n                num1 = __gcd(num1, nums[j]);\\n                if(num1 == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return nums.size()-1+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=INT_MAX;\\n        int jat = 0;\\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                jat++;\\n            }\\n        }\\n        \\n        if(jat > 0) return nums.size() - jat;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            int num1 = nums[i];\\n            for(int j=i+1; j<nums.size(); j++) \\n            {\\n                num1 = __gcd(num1, nums[j]);\\n                if(num1 == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return nums.size()-1+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445889,
                "title": "javascript-with-explaination",
                "content": "run an iteration though the array and update all gcd value.\\nif it cannot be one then no matter how many time we do gcd the arrray will be the same.\\ndo gcd on all elements and increase operations by 1.\\nif the values changed then run again. if they dont change and dont have a 1 it means its not possible.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445859,
                "title": "c-9-liners-solution",
                "content": "```\\nint minOperations(vector<int>& nums) \\n{\\n\\tint n=nums.size(),c=nums[0],ones=nums[0]==1;\\n\\tfor(int i=1;i<n;i++) c=__gcd(c,nums[i]),ones+=nums[i]==1;\\n\\tif(c!=1) return -1;\\n\\twhile(true)\\n\\t{\\n\\t\\tfor(int i=0;i<n-1;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i]=__gcd(nums[i],nums[i+1]);\\n\\t\\t\\tif(nums[i]==1) return 2*nums.size()-n-ones;\\n\\t\\t}\\n\\t\\tn--;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums) \\n{\\n\\tint n=nums.size(),c=nums[0],ones=nums[0]==1;\\n\\tfor(int i=1;i<n;i++) c=__gcd(c,nums[i]),ones+=nums[i]==1;\\n\\tif(c!=1) return -1;\\n\\twhile(true)\\n\\t{\\n\\t\\tfor(int i=0;i<n-1;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i]=__gcd(nums[i],nums[i+1]);\\n\\t\\t\\tif(nums[i]==1) return 2*nums.size()-n-ones;\\n\\t\\t}\\n\\t\\tn--;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445857,
                "title": "c-simple-easy-intuitive-solution-youtube-solution",
                "content": "Do Checkhttps://youtu.be/mmi8OHGLFyA\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd  = nums[0];\\n        int cnt =0;\\n        int p = gcd;\\n        int f=1;\\n        for(auto c:nums){\\n            gcd = __gcd(c,gcd);\\n            if(c>1) cnt++;\\n            int r = __gcd(p,c);\\n            if( r == 1) { f = 0;}\\n            p=c;\\n        }\\n        if(gcd > 1) return -1;\\n       \\n        if(f == 0)\\n        return cnt;\\n        \\n        \\n        int c = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd, nums[j]);\\n            \\n            if(gcd == 1){\\n                c=min(c,j-i);\\n            }\\n            }\\n        }\\n        return cnt-1 + c ;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd  = nums[0];\\n        int cnt =0;\\n        int p = gcd;\\n        int f=1;\\n        for(auto c:nums){\\n            gcd = __gcd(c,gcd);\\n            if(c>1) cnt++;\\n            int r = __gcd(p,c);\\n            if( r == 1) { f = 0;}\\n            p=c;\\n        }\\n        if(gcd > 1) return -1;\\n       \\n        if(f == 0)\\n        return cnt;\\n        \\n        \\n        int c = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd, nums[j]);\\n            \\n            if(gcd == 1){\\n                c=min(c,j-i);\\n            }\\n            }\\n        }\\n        return cnt-1 + c ;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445829,
                "title": "python-dp",
                "content": "**Idea:**\\n- The size is small 50 so we can hash all the array and do dp on it.\\n- For each pair in array we do ans = min(ans, 1 + dp(new array with replacement as gcd)) if that replacement not equal value itself\\n- Speed up: if gcd == 1 we return all non 1s\\n\\n\\n```python\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def dp(A):\\n            if sum(A) == N: return 0\\n            A = list(A)\\n            ans = inf\\n            for i in range(N-1):\\n                \\n                c = gcd(A[i],A[i+1])\\n                if c == 1:\\n                    s = 0\\n                    for x in A:\\n                        if x != 1:\\n                            s += 1\\n                    return s\\n                if A[i] != c:\\n                    x = A[i]\\n                    A[i] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i] = x\\n                \\n                if A[i+1] != c:\\n                    x = A[i+1]\\n                    A[i+1] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i+1] = x\\n            return ans\\n        \\n        ans = dp(tuple(A))\\n        \\n        return  -1  if inf == ans else ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def dp(A):\\n            if sum(A) == N: return 0\\n            A = list(A)\\n            ans = inf\\n            for i in range(N-1):\\n                \\n                c = gcd(A[i],A[i+1])\\n                if c == 1:\\n                    s = 0\\n                    for x in A:\\n                        if x != 1:\\n                            s += 1\\n                    return s\\n                if A[i] != c:\\n                    x = A[i]\\n                    A[i] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i] = x\\n                \\n                if A[i+1] != c:\\n                    x = A[i+1]\\n                    A[i+1] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i+1] = x\\n            return ans\\n        \\n        ans = dp(tuple(A))\\n        \\n        return  -1  if inf == ans else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445823,
                "title": "brute-force-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is a one in the array you can spread it to an adjacent indice every iteration in a loop until the whole array is one because the gcd(a, 1) = 1. If there is no one but we knew the smallest window where the gcd(values in window) = 1. then the min operations would be the length of the array  + window - 2. Since no values are one in the array, we must perform an operation on every indice. We must also add the size of the smallest window - 2 because we have to create a one to spread throughout the array first. We subtract two because if 2 adjacent elements in the array has a gcd of one then the min operations is the size of the array (we create a one in the first operation) else its the size of the array + elements in excess of two.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1a) if there are ones in the array returns length of array - number of ones\\n1b) find smallest window to create a gcd of 1 and return length of the array + window - 2\\n# Complexity\\n- Time complexity: O((N^2)*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums)\\n            if (num == 1)\\n                ones++;\\n        if (ones > 0)\\n            return nums.length - ones;\\n        int minLength = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                val = gcd(val, nums[j]);\\n                if (val == 1) {\\n                    if (j - i + 1 < minLength) {\\n                        minLength = j - i + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (minLength == Integer.MAX_VALUE)\\n            return -1;\\n        return n + (minLength - 2);\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        else if (b == 0)\\n            return a;\\n        int rem = a % b;\\n        return gcd(b, rem);\\n    }\\n    \\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums)\\n            if (num == 1)\\n                ones++;\\n        if (ones > 0)\\n            return nums.length - ones;\\n        int minLength = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                val = gcd(val, nums[j]);\\n                if (val == 1) {\\n                    if (j - i + 1 < minLength) {\\n                        minLength = j - i + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (minLength == Integer.MAX_VALUE)\\n            return -1;\\n        return n + (minLength - 2);\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        else if (b == 0)\\n            return a;\\n        int rem = a % b;\\n        return gcd(b, rem);\\n    }\\n    \\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445820,
                "title": "java-intuitive-solution",
                "content": "```\\nclass Solution {\\n    int getGcd(int val1, int val2)\\n    {\\n        if (val1 == 0) return val2;\\n        return getGcd(val2 % val1, val1);\\n    }\\n    public int minOperations(int[] arr) {\\n        int onesCount = 0, n = arr.length, min = Integer.MAX_VALUE;;\\n        for (int i = 0; i < n; i++) if (arr[i] == 1) onesCount++;\\n        if (onesCount != 0) return n - onesCount;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcd = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = getGcd(arr[j], gcd);\\n                if (gcd == 1) {\\n                    min = Math.min(min, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (min == Integer.MAX_VALUE) return -1; \\n        return n + min - 1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int getGcd(int val1, int val2)\\n    {\\n        if (val1 == 0) return val2;\\n        return getGcd(val2 % val1, val1);\\n    }\\n    public int minOperations(int[] arr) {\\n        int onesCount = 0, n = arr.length, min = Integer.MAX_VALUE;;\\n        for (int i = 0; i < n; i++) if (arr[i] == 1) onesCount++;\\n        if (onesCount != 0) return n - onesCount;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcd = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = getGcd(arr[j], gcd);\\n                if (gcd == 1) {\\n                    min = Math.min(min, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (min == Integer.MAX_VALUE) return -1; \\n        return n + min - 1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445785,
                "title": "best-solution-ever-hindi",
                "content": "# Intuition\\nbest solution ever\\n# Approach\\nin hindi\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int coo = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                coo++;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        if(coo > 0) {\\n            return n - coo;\\n        }\\n        \\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = gcd(num, nums[j]);\\n                if(num == 1) {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n    public static int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b%a, a);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int coo = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                coo++;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        if(coo > 0) {\\n            return n - coo;\\n        }\\n        \\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = gcd(num, nums[j]);\\n                if(num == 1) {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n    public static int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b%a, a);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445778,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int ones = 0 ;\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == 1)\\n                ones++ ;\\n        if(ones > 0)\\n            return n - ones ;\\n        \\n        int ret = INT_MAX ;\\n        for(int i = 0; i < n; i++){\\n            vector<int>numT = nums ;\\n            for(int j = i+1; j < n; j++){\\n                numT[j] = gcd(numT[j], numT[j-1]);\\n                if(numT[j] == 1)\\n                    ret = min(ret , j-i + n-1) ;\\n            }\\n        }       \\n        return (ret== INT_MAX) ? -1 : ret  ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int ones = 0 ;\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == 1)\\n                ones++ ;\\n        if(ones > 0)\\n            return n - ones ;\\n        \\n        int ret = INT_MAX ;\\n        for(int i = 0; i < n; i++){\\n            vector<int>numT = nums ;\\n            for(int j = i+1; j < n; j++){\\n                numT[j] = gcd(numT[j], numT[j-1]);\\n                if(numT[j] == 1)\\n                    ret = min(ret , j-i + n-1) ;\\n            }\\n        }       \\n        return (ret== INT_MAX) ? -1 : ret  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445775,
                "title": "python-o-n-2",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums:\\n            return sum(num!=1 for num in nums)\\n        small = inf\\n        g = nums[:]\\n        for di in range(1, len(nums)):\\n            for i in range(len(nums)):\\n                if i + di >= len(nums):\\n                    break\\n                g[i] = gcd(g[i], nums[i+di])\\n                if g[i] == 1:\\n                    return di-1+len(nums)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums:\\n            return sum(num!=1 for num in nums)\\n        small = inf\\n        g = nums[:]\\n        for di in range(1, len(nums)):\\n            for i in range(len(nums)):\\n                if i + di >= len(nums):\\n                    break\\n                g[i] = gcd(g[i], nums[i+di])\\n                if g[i] == 1:\\n                    return di-1+len(nums)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445723,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int k=0,mini=INT_MAX;\\n        for(int&i:nums){\\n            if(i==1)\\n                k++;\\n        }\\n        if(k!=0){\\n            return nums.size()-k;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int p=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                p=gcd(p,nums[j]);\\n                if(p==1){\\n                    mini=min(mini,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return mini==INT_MAX?-1:nums.size()+mini-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int k=0,mini=INT_MAX;\\n        for(int&i:nums){\\n            if(i==1)\\n                k++;\\n        }\\n        if(k!=0){\\n            return nums.size()-k;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int p=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                p=gcd(p,nums[j]);\\n                if(p==1){\\n                    mini=min(mini,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return mini==INT_MAX?-1:nums.size()+mini-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445719,
                "title": "no-need-of-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        int n=a.size();\\n        bool check=false;\\n        int gcd=0,num;\\n        for(int i=0;i<n;i++){\\n            gcd=__gcd(gcd,a[i]);\\n        }\\n        if(gcd!=1) return -1;\\n        //check number of 1\\'s;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==1) cnt++;\\n        }\\n        if(cnt) return n-cnt;\\n        else {\\n            for(int i=1;i<n;i++){\\n                for(int j=0;j<n-i;j++){\\n                    gcd=0;\\n                    for(int k=j;k<=j+i;k++){\\n                        // cout<<j<<\" \"<<k<<endl;\\n                        gcd=__gcd(a[k],gcd);\\n                    }\\n                    if(gcd==1){\\n                        // cout<<i<<endl;\\n                        num=i+n-1;\\n                        check=true;\\n                        break;\\n                    }\\n                }\\n                if(check) break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        int n=a.size();\\n        bool check=false;\\n        int gcd=0,num;\\n        for(int i=0;i<n;i++){\\n            gcd=__gcd(gcd,a[i]);\\n        }\\n        if(gcd!=1) return -1;\\n        //check number of 1\\'s;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==1) cnt++;\\n        }\\n        if(cnt) return n-cnt;\\n        else {\\n            for(int i=1;i<n;i++){\\n                for(int j=0;j<n-i;j++){\\n                    gcd=0;\\n                    for(int k=j;k<=j+i;k++){\\n                        // cout<<j<<\" \"<<k<<endl;\\n                        gcd=__gcd(a[k],gcd);\\n                    }\\n                    if(gcd==1){\\n                        // cout<<i<<endl;\\n                        num=i+n-1;\\n                        check=true;\\n                        break;\\n                    }\\n                }\\n                if(check) break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445700,
                "title": "the-edge-case-that-costed-most-of-us-1-wa-c-intuition-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/121a8662-6e86-4218-87fd-323f5b913c7c_1682222218.3598685.png)\\n\\nSo, here is the test case that should be given maximum credit for taking the responsibility to decrease the accuracy of the problem to less than 25%.\\n```\\nnums = [1,1]\\n```\\n\\n\\n\\n<!--# Intuition\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!--# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!--- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Approach\\nLooking at the constraints will give a hint that we can loop through the array more than one time. So lets go through all the subarrays and find the size of the subarray with minimum size having GCD as 1.\\nSo to achieve the first 1 in the array will take size of subarray -1 moves. To make all the elements equal to 1 will take more nums.size()-1 moves.\\n\\n**Handling the edge case:** Check if there are already 1s existing in the array. If yes then just return nums.size()-no of ones present in the array. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=INT_MAX,hcf=nums[0];\\n        int flag=(nums[0]==1?1:0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            hcf=__gcd(nums[i],hcf);\\n            if(nums[i]==1)flag++;\\n        }\\n        if(flag>0)\\n            return nums.size()-(flag); \\n        if(hcf!=1)\\n            return -1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hcf=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                hcf=__gcd(nums[j],hcf);\\n                if(hcf==1)\\n                {\\n                    len=min(len,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(len==INT_MAX)return -1;\\n        return len+nums.size()-1;\\n    }\\n};\\n```\\n\\n**Please Upvote if u could relate with me or liked the approach**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [1,1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=INT_MAX,hcf=nums[0];\\n        int flag=(nums[0]==1?1:0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            hcf=__gcd(nums[i],hcf);\\n            if(nums[i]==1)flag++;\\n        }\\n        if(flag>0)\\n            return nums.size()-(flag); \\n        if(hcf!=1)\\n            return -1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hcf=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                hcf=__gcd(nums[j],hcf);\\n                if(hcf==1)\\n                {\\n                    len=min(len,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(len==INT_MAX)return -1;\\n        return len+nums.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445674,
                "title": "c-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int GCD(int a,int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return GCD(b,a%b);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 1)\\n                countone++;\\n        }\\n        if(countone > 0)\\n             return n-countone;\\n        \\n        int minop = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int gcdres = nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                gcdres = GCD(nums[j],gcdres);\\n                if(gcdres == 1)\\n                {\\n                    minop = min(minop,j-i+1);\\n                    break;\\n                }\\n            }\\n        }\\n        if(minop == INT_MAX)\\n            return -1;\\n        return n+minop-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GCD(int a,int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return GCD(b,a%b);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 1)\\n                countone++;\\n        }\\n        if(countone > 0)\\n             return n-countone;\\n        \\n        int minop = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int gcdres = nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                gcdres = GCD(nums[j],gcdres);\\n                if(gcdres == 1)\\n                {\\n                    minop = min(minop,j-i+1);\\n                    break;\\n                }\\n            }\\n        }\\n        if(minop == INT_MAX)\\n            return -1;\\n        return n+minop-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445673,
                "title": "minimum-size-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int com=nums[0], oc=0;\\n        // com is the cumulative gcd\\n        //oc means one count\\n        if(nums[0]==1){oc++;}\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1){oc++;}\\n            com=__gcd(com,nums[i]);\\n        }\\n        // if there is some common factor between every element then its impossible to make array 1\\n        if(com!=1){return -1;}\\n        //if there is even a single one in the array then we can convert any element to 1 with a single operation\\n        // so in this case the total operations required = the number of non one elements\\n        if(oc){return nums.size()-oc;}\\n        \\n        // here we try to find the subarray of minimum size whose gcd=1\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int com=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                com=__gcd(nums[j],com);\\n                if(com==1){\\n                    mini=min(mini,j-i+1);break;\\n                }\\n            }\\n        }\\n        //mini-2 is the extra operations required to make an element 1 in the array and once we get a single 1 we can convert all elements to 1 each with a single operation\\n        return nums.size()+(mini-2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int com=nums[0], oc=0;\\n        // com is the cumulative gcd\\n        //oc means one count\\n        if(nums[0]==1){oc++;}\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1){oc++;}\\n            com=__gcd(com,nums[i]);\\n        }\\n        // if there is some common factor between every element then its impossible to make array 1\\n        if(com!=1){return -1;}\\n        //if there is even a single one in the array then we can convert any element to 1 with a single operation\\n        // so in this case the total operations required = the number of non one elements\\n        if(oc){return nums.size()-oc;}\\n        \\n        // here we try to find the subarray of minimum size whose gcd=1\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int com=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                com=__gcd(nums[j],com);\\n                if(com==1){\\n                    mini=min(mini,j-i+1);break;\\n                }\\n            }\\n        }\\n        //mini-2 is the extra operations required to make an element 1 in the array and once we get a single 1 we can convert all elements to 1 each with a single operation\\n        return nums.size()+(mini-2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445670,
                "title": "i-will-stop-as-soon-as-i-find-number-1-greedy",
                "content": "I am just trying to find the number 1 because gcd of anynumber with 1 will be 1 and we want to make elements to 1 .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums,int ans = INT_MAX,int ones = 0) {\\n        for(auto ele:nums)ones+=ele==1;\\n        if(ones > 0)  return (int)nums.size() - ones;\\n        for(int i=0; i<(int)nums.size(); i++) {\\n            auto ele = nums[i];\\n            for(int j=i+1;j<(int)nums.size(); j++) {\\n                ele = gcd(ele, nums[j]);\\n                if(ele == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(!ele)break;\\n        }\\n        return ans == INT_MAX?-1:(int)nums.size() -1+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums,int ans = INT_MAX,int ones = 0) {\\n        for(auto ele:nums)ones+=ele==1;\\n        if(ones > 0)  return (int)nums.size() - ones;\\n        for(int i=0; i<(int)nums.size(); i++) {\\n            auto ele = nums[i];\\n            for(int j=i+1;j<(int)nums.size(); j++) {\\n                ele = gcd(ele, nums[j]);\\n                if(ele == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(!ele)break;\\n        }\\n        return ans == INT_MAX?-1:(int)nums.size() -1+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460557,
                "title": "java-simple-solution-o-n-k-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObervations  : \\n    1 - If GCD of whole array is not equal to 1 then we cannot convert the array to 1 so return -1;\\n    2 - Find the smallest subarray whose GCD is 1 then use the formula to calculate the final answer.\\n\\n    Formula is designed is based on the conditions - \\n        answer = total no.of elements - 1 + minimum size of the subarray whose gcd = 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gcd(b % a,a);\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        int gcd = 0;\\n        for(int i : nums){\\n            if(i == 1){\\n                cnt++;\\n            }\\n            gcd = gcd(gcd,i);\\n        }\\n\\n        if(gcd != 1){\\n            return -1;\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0;i < n;i++){\\n            int num = nums[i];\\n            for(int j = i + 1;j < n;j++){\\n                num = gcd(num,nums[j]);\\n                if(num == 1){\\n                    ans = Math.min(ans,j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        return n - 1 + ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gcd(b % a,a);\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        int gcd = 0;\\n        for(int i : nums){\\n            if(i == 1){\\n                cnt++;\\n            }\\n            gcd = gcd(gcd,i);\\n        }\\n\\n        if(gcd != 1){\\n            return -1;\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0;i < n;i++){\\n            int num = nums[i];\\n            for(int j = i + 1;j < n;j++){\\n                num = gcd(num,nums[j]);\\n                if(num == 1){\\n                    ans = Math.min(ans,j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        return n - 1 + ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1873923,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1878342,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873206,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871447,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1898536,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1880916,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1872644,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871729,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871577,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873923,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1878342,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873206,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871447,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1898536,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1880916,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1872644,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871729,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871577,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            }
        ]
    }
]