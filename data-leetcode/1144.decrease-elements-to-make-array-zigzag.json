[
    {
        "title": "Valid Tic-Tac-Toe State",
        "question_content": "Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\nThe board is a 3 x 3 array that consists of characters ' ', 'X', and 'O'. The ' ' character represents an empty square.\nHere are the rules of Tic-Tac-Toe:\n\n\tPlayers take turns placing characters into empty squares ' '.\n\tThe first player always places 'X' characters, while the second player always places 'O' characters.\n\t'X' and 'O' characters are always placed into empty squares, never filled ones.\n\tThe game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n\tThe game also ends if all squares are non-empty.\n\tNo more moves can be played if the game is over.\n\n&nbsp;\nExample 1:\n\nInput: board = [\"O  \",\"   \",\"   \"]\nOutput: false\nExplanation: The first player always plays \"X\".\n\nExample 2:\n\nInput: board = [\"XOX\",\" X \",\"   \"]\nOutput: false\nExplanation: Players take turns making moves.\n\nExample 3:\n\nInput: board = [\"XOX\",\"O O\",\"XOX\"]\nOutput: true\n\n&nbsp;\nConstraints:\n\n\tboard.length == 3\n\tboard[i].length == 3\n\tboard[i][j] is either 'X', 'O', or ' '.",
        "solutions": [
            {
                "id": 117580,
                "title": "straightforward-java-solution-with-explaination",
                "content": "When `turns` is 1, X moved. When `turns` is 0, O moved. `rows` stores the number of X or O in each row. `cols` stores the number of X or O in each column. `diag` stores the number of X or O in diagonal. `antidiag` stores the number of X or O in antidiagonal. When any of the value gets to 3, it means X wins. When any of the value gets to -3, it means O wins.\\n\\nWhen X wins, O cannot move anymore, so `turns` must be 1. When O wins, X cannot move anymore, so `turns` must be 0. Finally, when we return, `turns` must be either 0 or 1, and X and O cannot win at same time.\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int turns = 0;\\n        boolean xwin = false; \\n        boolean owin = false;\\n        int[] rows = new int[3];\\n        int[] cols = new int[3];\\n        int diag = 0;\\n        int antidiag = 0;\\n\\t\\t\\t\\t\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    turns++; rows[i]++; cols[j]++;\\n                    if (i == j) diag++;\\n                    if (i + j == 2) antidiag++;\\n                } else if (board[i].charAt(j) == \\'O\\') {\\n                    turns--; rows[i]--; cols[j]--;\\n                    if (i == j) diag--;\\n                    if (i + j == 2) antidiag--;\\n                }\\n            }\\n        }\\n\\t\\t\\n        xwin = rows[0] == 3 || rows[1] == 3 || rows[2] == 3 || \\n               cols[0] == 3 || cols[1] == 3 || cols[2] == 3 || \\n               diag == 3 || antidiag == 3;\\n        owin = rows[0] == -3 || rows[1] == -3 || rows[2] == -3 || \\n               cols[0] == -3 || cols[1] == -3 || cols[2] == -3 || \\n               diag == -3 || antidiag == -3;\\n        \\n        if (xwin && turns == 0 || owin && turns == 1) {\\n            return false;\\n        }\\n        return (turns == 0 || turns == 1) && (!xwin || !owin);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int turns = 0;\\n        boolean xwin = false; \\n        boolean owin = false;\\n        int[] rows = new int[3];\\n        int[] cols = new int[3];\\n        int diag = 0;\\n        int antidiag = 0;\\n\\t\\t\\t\\t\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    turns++; rows[i]++; cols[j]++;\\n                    if (i == j) diag++;\\n                    if (i + j == 2) antidiag++;\\n                } else if (board[i].charAt(j) == \\'O\\') {\\n                    turns--; rows[i]--; cols[j]--;\\n                    if (i == j) diag--;\\n                    if (i + j == 2) antidiag--;\\n                }\\n            }\\n        }\\n\\t\\t\\n        xwin = rows[0] == 3 || rows[1] == 3 || rows[2] == 3 || \\n               cols[0] == 3 || cols[1] == 3 || cols[2] == 3 || \\n               diag == 3 || antidiag == 3;\\n        owin = rows[0] == -3 || rows[1] == -3 || rows[2] == -3 || \\n               cols[0] == -3 || cols[1] == -3 || cols[2] == -3 || \\n               diag == -3 || antidiag == -3;\\n        \\n        if (xwin && turns == 0 || owin && turns == 1) {\\n            return false;\\n        }\\n        return (turns == 0 || turns == 1) && (!xwin || !owin);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117592,
                "title": "simple-python-solution-with-explanation",
                "content": "To find the validity of a given board, we could first think about the cases where the board is invalid\n1) Since X starts first, x_count >= o_count. So if o_count > x_count, we can return False\n2) Since the players take turns, we could also return False if x_count-o_count>1\n\nAfter the corner cases, this is the algorithm used:\n\n1)  If player O has a winning condition, also check the following:\n     a)     If player X also has a winning condition, return False\n     b)     If x_count != o_count , return False (Since player O always plays second, it has to meet this condition always)\n2)  If player X has a winning condition,  check the following:\n\t  a)  If x_count != o_count + 1, return False (Since player X plays the first move, if player X wins, the player X's count would be 1 more than player O)\n\t\n\n\n```\nclass Solution(object):\n    def check_win_positions(self, board, player):\n\t\"\"\"\n\tCheck if the given player has a win position.\n\tReturn True if there is a win position. Else return False.\n\t\"\"\"\n        #Check the rows\n        for i in range(len(board)):\n            if board[i][0] == board[i][1] == board[i][2] == player:\n                return True                        \n\n        #Check the columns\n        for i in range(len(board)):\n            if board[0][i] == board[1][i] == board[2][i] == player:\n                return True \n\t\t\t\t\t\t\t\t\t\t\n        #Check the diagonals\n        if board[0][0] == board[1][1] == board[2][2]  == player or \\\n               board[0][2] == board[1][1] == board[2][0] == player:\n            return True\n\t\t\t\t\t\t\n        return False\n        \n    def validTicTacToe(self, board):\n        \"\"\"\n        :type board: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        x_count, o_count = 0, 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == \"X\":\n                    x_count += 1\n                elif  board[i][j] == \"O\":\n                    o_count += 1\n\t\t\t\t\t\t\t\t\t\t\n        if o_count > x_count or x_count-o_count>1:\n            return False\n        \n        if self.check_win_positions(board, 'O'):\n            if self.check_win_positions(board, 'X'):\n                return False\n            return o_count == x_count\n        \n        if self.check_win_positions(board, 'X') and x_count!=o_count+1:\n            return False\n\n        return True\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def check_win_positions(self, board, player):\n\t\"\"\"\n\tCheck if the given player has a win position.\n\tReturn True if there is a win position. Else return False.\n\t\"\"\"\n        #Check the rows\n        for i in range(len(board)):\n            if board[i][0] == board[i][1] == board[i][2] == player:\n                return True                        \n\n        #Check the columns\n        for i in range(len(board)):\n            if board[0][i] == board[1][i] == board[2][i] == player:\n                return True \n\t\t\t\t\t\t\t\t\t\t\n        #Check the diagonals\n        if board[0][0] == board[1][1] == board[2][2]  == player or \\\n               board[0][2] == board[1][1] == board[2][0] == player:\n            return True\n\t\t\t\t\t\t\n        return False\n        \n    def validTicTacToe(self, board):\n        \"\"\"\n        :type board: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        x_count, o_count = 0, 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == \"X\":\n                    x_count += 1\n                elif  board[i][j] == \"O\":\n                    o_count += 1\n\t\t\t\t\t\t\t\t\t\t\n        if o_count > x_count or x_count-o_count>1:\n            return False\n        \n        if self.check_win_positions(board, 'O'):\n            if self.check_win_positions(board, 'X'):\n                return False\n            return o_count == x_count\n        \n        if self.check_win_positions(board, 'X') and x_count!=o_count+1:\n            return False\n\n        return True\n```",
                "codeTag": "Java"
            },
            {
                "id": 318887,
                "title": "java-faster-than-100-memory-99-66",
                "content": "I was attempting to use some of the principles of \"Clean Code\" on this particular solution.  The purpose of this solution was to ensure proper naming of functions/variables and to keep functions/methods short and limited to one principle. I also attempted to maintain readablility of the code from top to bottom.\\n\\nThe solution doesn\\'t require the 2D gameBoard array, I just find that it makes processing a little more straightforward with minimal memory cost.\\n\\n\\'\\'\\'\\nclass Solution {\\n    \\n    private char[][] gameBoard = new char[3][3]; \\n    \\n    public boolean validTicTacToe(String[] board) {\\n        \\n        unpackBoard(board);\\n\\n        return gameBoardValidation();\\n    }\\n    \\n    private void unpackBoard(String[] board){\\n        for(int i=0; i<3;i++){\\n            for(int j=0; j<3; j++){\\n                this.gameBoard[i][j] = board[i].charAt(j);\\n            }\\n        }\\n    }\\n    \\n    private boolean gameBoardValidation(){\\n        \\n        int numX, numO;\\n        \\n        numX = count(\\'X\\');\\n        numO = count(\\'O\\');\\n        \\n        //X goes first\\n        if(numO>numX) return false;\\n        \\n        //players take turns\\n        if(numX>numO+1) return false;\\n        \\n        //both players can\\'t win\\n        if(winner(\\'X\\') && winner(\\'O\\')) return false;\\n        \\n        //game ends when one player wins\\n        if(winner(\\'X\\') && numX==numO) return false;\\n        \\n        //game ends when one player wins\\n        if(winner(\\'O\\') && numX>numO) return false;\\n        \\n        return true;\\n    }\\n    \\n    private int count(char player){\\n        \\n        int num = 0;\\n        \\n        for(int i=0; i<3;i++){\\n            for(int j=0; j<3; j++){\\n                if(gameBoard[i][j] == player) num++;\\n            }\\n        }\\n        \\n        return num;\\n    }\\n    \\n    private boolean winner(char player){\\n        \\n        if(validateRows(player)) return true;\\n        if(validateColumns(player)) return true;\\n        if(validateDiagonal(player)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean validateRows(char player){\\n        for(int i=0; i<3; i++){\\n            if(gameBoard[i][0] == player && gameBoard[i][1] == player && gameBoard[i][2] == player) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean validateColumns(char player){\\n        for(int i=0; i<3; i++){\\n            if(gameBoard[0][i] == player && gameBoard[1][i] == player && gameBoard[2][i] == player) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean validateDiagonal(char player){\\n        if(gameBoard[0][0] == player && gameBoard[1][1] == player && gameBoard[2][2] == player) return true;\\n        if(gameBoard[0][2] == player && gameBoard[1][1] == player && gameBoard[2][0] == player) return true;\\n        \\n        return false;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private char[][] gameBoard = new char[3][3]; \\n    \\n    public boolean validTicTacToe(String[] board) {\\n        \\n        unpackBoard(board);\\n\\n        return gameBoardValidation();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 117716,
                "title": "4-lines-python",
                "content": "    def validTicTacToe(self, board):\n        b = '|'.join(board)\n        x, o = (any(p*3 in b[s::d] for s in range(9) for d in (1, 3, 4, 5)) for p in 'XO')\n        m = b.count('X') - b.count('O')\n        return m == (not o) if m else not x\n\n<br>\n\n### Explanation and stuff\n\nI first join a board like `\"XOX\", \"O O\", \"XOX\"` into a single string like `\"XOX|O O|XOX\"`. Then I can easily get rows/columns/diagonals by one-dimensional slicing. For example the main diagonal (with digits for clarity):\n```\n>>> \"123|456|789\"[::5]\n'159'\n```\nIn general index delta `d=1` goes to the right, `d=4` goes down, `d=5` goes down-right and `d=3` goes down-left. And I try that from every needed start index `s` and a few more. The slices aren't exactly the rows/columns/diagonals, but they include them and they don't include anything they shouldn't (thanks to the `|` row separator).\n\nSo to find out whether player `'X'` has a winning line, I just check whether `\"XXX\"` is in any of those slices.\n\nThen I also determine the move difference `m`, how many more moves player `'X'` made. Again it is helpful to have the board in a single string that I can just ask for the counts.\n\nIf they players made the same number of moves, then I just need to check that `'X'` has no winning line. Otherwise `'X`' must have made exactly one more move and `'O'` must not have a winning line. That's what my last line checks. You could also do\n\n        return (m == 0 and not x) or (m == 1 and not o)\n\nbut I just had some fun making it smaller. I also considered negative the meaning of `x` and `o` so they tell whether the players *don't* have winning lines:\n\n    def validTicTacToe(self, board):\n        b = '|'.join(board)\n        x, o = (not any(p*3 in b[s::d] for s in range(9) for d in (1, 3, 4, 5)) for p in 'XO')\n        m = b.count('X') - b.count('O')\n        return m == o if m else x\n\t\t\t\t\nThat saves a bit overall but made the already longest line longer, plus I just don't like the negative view.\n\nGolf-ish version just for fun (that's for Python 3, for Python 2 the deltas need to be (1,7,8,9)):\n\n    def validTicTacToe(self, b):\n        b=str(b);x,o=(not any(p*3in\n        b[s::d]for s in range(99)for\n        d in(1,6,7,8))for p in'XO')\n        c=b.count;m=c('X')-c('O')\n        return m==o if m else x\n",
                "solutionTags": [],
                "code": "```\n>>> \"123|456|789\"[::5]\n'159'\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208209,
                "title": "so-simple-i-wanna-cry-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int nx, no;\\n    bool xwin, owin;\\npublic:\\n    Solution() : nx(0), no(0), xwin(false), owin(false)\\n    {}\\n    \\n    bool validTicTacToe(vector<string>& board) \\n    {\\n        for(int i = 0; i < 3; i++)\\n        {\\n            for(auto c : board[i])\\n            {\\n                if(c == \\'X\\') nx++;\\n                else if(c == \\'O\\') no++;\\n            }\\n        }\\n        if(!(nx == no || nx == no + 1)) return false;\\n        else if(nx == no)\\n        {\\n            return !isWin(board, \\'X\\');\\n        }\\n        else\\n        {\\n            return !isWin(board, \\'O\\');\\n        }\\n        return true;\\n    }\\n    \\n    bool isWin(vector<string> &board, char c)\\n    {\\n        for(int i = 0; i < 3; i++)\\n        {\\n            if(board[i][0] == c && \\\\\\n               board[i][0] == board[i][1] && board[i][1] == board[i][2])\\n            {\\n                return true;\\n            }\\n            else if(board[0][i] == c && \\\\\\n                    (board[0][i] == board[1][i] && board[1][i] == board[2][i]))\\n            {\\n                return true;\\n            }\\n        }\\n        if(board[0][0] == c && \\\\\\n           board[1][1] == board[0][0] && board[2][2] == board[0][0])\\n        {\\n            return true;\\n        }\\n        else if(board[0][2] == c && \\\\\\n           board[1][1] == board[0][2] && board[2][0] == board[0][2])\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int nx, no;\\n    bool xwin, owin;\\npublic:\\n    Solution() : nx(0), no(0), xwin(false), owin(false)\\n    {}\\n    \\n    bool validTicTacToe(vector<string>& board) \\n    {\\n        for(int i = 0; i < 3; i++)\\n        {\\n            for(auto c : board[i])\\n            {\\n                if(c == \\'X\\') nx++;\\n                else if(c == \\'O\\') no++;\\n            }\\n        }\\n        if(!(nx == no || nx == no + 1)) return false;\\n        else if(nx == no)\\n        {\\n            return !isWin(board, \\'X\\');\\n        }\\n        else\\n        {\\n            return !isWin(board, \\'O\\');\\n        }\\n        return true;\\n    }\\n    \\n    bool isWin(vector<string> &board, char c)\\n    {\\n        for(int i = 0; i < 3; i++)\\n        {\\n            if(board[i][0] == c && \\\\\\n               board[i][0] == board[i][1] && board[i][1] == board[i][2])\\n            {\\n                return true;\\n            }\\n            else if(board[0][i] == c && \\\\\\n                    (board[0][i] == board[1][i] && board[1][i] == board[2][i]))\\n            {\\n                return true;\\n            }\\n        }\\n        if(board[0][0] == c && \\\\\\n           board[1][1] == board[0][0] && board[2][2] == board[0][0])\\n        {\\n            return true;\\n        }\\n        else if(board[0][2] == c && \\\\\\n           board[1][1] == board[0][2] && board[2][0] == board[0][2])\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117597,
                "title": "java-solution-with-explain",
                "content": "Cases which leads to invalid status - \n1. There are less X than O or (# of X - # of O) > 1\n2. Ether X or O has more than 1 winning pattern\n3. If X wins, then O cannot win, and there must be more X than O\n4. If O wins, X cannot win, and there must equal number of X and O\n\nAll other cases are valid!\n```\npublic boolean validTicTacToe(String[] board) {\n        int cntx = 0, cnto = 0;\n        for (String row: board) {\n            for (char cell: row.toCharArray()) {\n                if (cell == 'X') {\n                    cntx++;\n                } else if (cell == 'O') {\n                    cnto++;\n                }\n            }\n        }\n        if (cntx < cnto || cntx - cnto > 1) return false;\n        int xwon = cntWon(board, 'X');\n        int owon = cntWon(board, 'O');\n        if (xwon > 1 || owon > 1) return false;\n        \n        if (xwon == 1) return owon == 0 && cntx > cnto;\n        if (owon == 1) return xwon == 0 && cntx == cnto;\n        \n        return true;\n    }\n    \n    int cntWon(String[] board, char p) {\n        int cnt = 0;\n        for (int i = 0; i < 3; i++) {\n            if (board[i].charAt(0) == p && board[i].charAt(1) == p && board[i].charAt(2) == p) {\n                cnt++;\n            }\n            if (board[0].charAt(i) == p && board[1].charAt(i) == p && board[2].charAt(i) == p) {\n                cnt++;\n            }\n        }\n        if (board[1].charAt(1) == p) {\n            if (board[0].charAt(0) == p && board[2].charAt(2) == p) cnt++;\n            if (board[0].charAt(2) == p && board[2].charAt(0) == p) cnt++;\n        }\n        return cnt;\n    }\n\t\t",
                "solutionTags": [],
                "code": "1. There are less X than O or (# of X - # of O) > 1\npublic boolean validTicTacToe(String[] board) {\n        int cntx = 0, cnto = 0;\n        for (String row: board) {\n            for (char cell: row.toCharArray()) {\n                if (cell == 'X') {\n                    cntx++;\n                } else if (cell == 'O') {\n                    cnto++;\n                }\n            }\n        }\n        if (cntx < cnto || cntx - cnto > 1) return false;\n        int xwon = cntWon(board, 'X');\n        int owon = cntWon(board, 'O');\n        if (xwon > 1 || owon > 1) return false;\n        if (xwon == 1) return owon == 0 && cntx > cnto;\n        if (owon == 1) return xwon == 0 && cntx == cnto;\n        return true;\n    }\n    int cntWon(String[] board, char p) {\n        int cnt = 0;\n        for (int i = 0; i < 3; i++) {\n            if (board[i].charAt(0) == p && board[i].charAt(1) == p && board[i].charAt(2) == p) {\n                cnt++;\n            }\n            if (board[0].charAt(i) == p && board[1].charAt(i) == p && board[2].charAt(i) == p) {\n                cnt++;\n            }\n        }\n        if (board[1].charAt(1) == p) {\n            if (board[0].charAt(0) == p && board[2].charAt(2) == p) cnt++;\n            if (board[0].charAt(2) == p && board[2].charAt(0) == p) cnt++;\n        }\n        return cnt;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1517556,
                "title": "java-tc-o-n-2-sc-o-1-space-optimized-no-extra-arrays-used-to-store-the-scores",
                "content": "**Space Optimized solution (True constant space solution)**\\n```java\\n/**\\n * Space Optimized solution (True constant space solution)\\n *\\n * Calculate net score of each row, column and diagonal. Here the score of each\\n * row, column and diagonal is stored in an int. For Player1 add 1 and for\\n * Player2 add -1.\\n *\\n * Time Complexity:\\n * Every non-diagonal element is visited 2 times. --> N^2-(2N-1)\\n * Center element is visited 4 times --> 1\\n * Remaining diagonal elements are visited 3 times. --> 2N-1-1 = 2N-2\\n * Total Time Complexity = O( 2*(N^2-(2N-1)) + 3*(2N-2) + 4*(1) )\\n *                       = O(2*N^2 + 2*N)\\n *                       = O(N^2)\\n *\\n * Space Complexity: O(1) --> True constant space solution. No arrays are used\\n * to store the scores of each row and column.\\n *\\n * N = Board Size (Number of Rows or Number of Columns)\\n */\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }\\n\\n        int n = board.length;\\n        int diag1 = 0;\\n        int diag2 = 0;\\n        int turnsDiff = 0;\\n        boolean xWin = false;\\n        boolean oWin = false;\\n        char c;\\n\\n        for (int i = 0; i < n; i++) { // ith row OR ith column\\n            int row = 0;\\n            int col = 0;\\n            for (int j = 0; j < n; j++) {\\n                c = board[i].charAt(j);\\n                if (c == \\'X\\') {\\n                    row++;\\n                    turnsDiff++;\\n                } else if (c == \\'O\\') {\\n                    row--;\\n                    turnsDiff--;\\n                }\\n                c = board[j].charAt(i);\\n                if (c == \\'X\\') {\\n                    col++;\\n                } else if (c == \\'O\\') {\\n                    col--;\\n                }\\n            }\\n\\n            c = board[i].charAt(i);\\n            if (c == \\'X\\') {\\n                diag1++;\\n            } else if (c == \\'O\\') {\\n                diag1--;\\n            }\\n            c = board[i].charAt(n - 1 - i);\\n            if (c == \\'X\\') {\\n                diag2++;\\n            } else if (c == \\'O\\') {\\n                diag2--;\\n            }\\n\\n            if (row == n || col == n || diag1 == n || diag2 == n) {\\n                if (oWin) {\\n                    return false;\\n                }\\n                xWin = true;\\n            }\\n            if (row == -n || col == -n || diag1 == -n || diag2 == -n) {\\n                if (xWin) {\\n                    return false;\\n                }\\n                oWin = true;\\n            }\\n        }\\n\\n        if (turnsDiff < 0 || turnsDiff > 1) {\\n            return false;\\n        }\\n        /**\\n         * X Wins only after odd number of turns, thus the diff will be 1.\\n         *\\n         * O wins only after even number of turns, thus the diff will be 0.\\n         */\\n        if ((turnsDiff == 0 && xWin) || (turnsDiff == 1 && oWin)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n**Uses array for rows and columns to store the score of each row and column**\\n\\n```java\\n/**\\n * Calculate net score of each row, column and diagonal.\\n *\\n * Not Space Optimized. Here the score of each row, column and diagonal is\\n * stored in an int array. For Player1 add 1 and for Player2 add -1.\\n *\\n * Time Complexity: O(N^2) or O(1)\\n *\\n * Space Complexity: O(N) or O(1)\\n *\\n * N = Board Size (Number of Rows or Number of Columns)\\n */\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }\\n\\n        int n = board.length;\\n        int[] rows = new int[n];\\n        int[] cols = new int[n];\\n        int diag1 = 0;\\n        int diag2 = 0;\\n        int turnsDiff = 0;\\n        boolean xWin = false;\\n        boolean oWin = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                char c = board[i].charAt(j);\\n                if (c == \\' \\') {\\n                    continue;\\n                }\\n                int val = c == \\'X\\' ? 1 : -1;\\n                turnsDiff += val;\\n                rows[i] += val;\\n                cols[j] += val;\\n                if (i == j) {\\n                    diag1 += val;\\n                }\\n                if (i + j == n - 1) {\\n                    diag2 += val;\\n                }\\n                if (rows[i] == n || cols[j] == n || diag1 == n || diag2 == n) {\\n                    if (oWin) {\\n                        return false;\\n                    }\\n                    xWin = true;\\n                }\\n                if (rows[i] == -n || cols[j] == -n || diag1 == -n || diag2 == -n) {\\n                    if (xWin) {\\n                        return false;\\n                    }\\n                    oWin = true;\\n                }\\n            }\\n        }\\n\\n        if (turnsDiff < 0 || turnsDiff > 1) {\\n            return false;\\n        }\\n        if ((turnsDiff == 0 && xWin) || (turnsDiff == 1 && oWin)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Tic-Tac-Toe questions on LeetCode:\\n- [348. Design Tic-Tac-Toe](https://leetcode.com/problems/design-tic-tac-toe/discuss/1517545/Java-or-TC:-O(1)-or-SC:-O(N)-or-Space-Optimized-solution)\\n- [1275. Find Winner on a Tic Tac Toe Game](https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/discuss/1517563/Java-or-TC:-O(M)-or-SC:-O(1)-or-Space-Optimized-solution)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```java\\n/**\\n * Space Optimized solution (True constant space solution)\\n *\\n * Calculate net score of each row, column and diagonal. Here the score of each\\n * row, column and diagonal is stored in an int. For Player1 add 1 and for\\n * Player2 add -1.\\n *\\n * Time Complexity:\\n * Every non-diagonal element is visited 2 times. --> N^2-(2N-1)\\n * Center element is visited 4 times --> 1\\n * Remaining diagonal elements are visited 3 times. --> 2N-1-1 = 2N-2\\n * Total Time Complexity = O( 2*(N^2-(2N-1)) + 3*(2N-2) + 4*(1) )\\n *                       = O(2*N^2 + 2*N)\\n *                       = O(N^2)\\n *\\n * Space Complexity: O(1) --> True constant space solution. No arrays are used\\n * to store the scores of each row and column.\\n *\\n * N = Board Size (Number of Rows or Number of Columns)\\n */\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }\\n\\n        int n = board.length;\\n        int diag1 = 0;\\n        int diag2 = 0;\\n        int turnsDiff = 0;\\n        boolean xWin = false;\\n        boolean oWin = false;\\n        char c;\\n\\n        for (int i = 0; i < n; i++) { // ith row OR ith column\\n            int row = 0;\\n            int col = 0;\\n            for (int j = 0; j < n; j++) {\\n                c = board[i].charAt(j);\\n                if (c == \\'X\\') {\\n                    row++;\\n                    turnsDiff++;\\n                } else if (c == \\'O\\') {\\n                    row--;\\n                    turnsDiff--;\\n                }\\n                c = board[j].charAt(i);\\n                if (c == \\'X\\') {\\n                    col++;\\n                } else if (c == \\'O\\') {\\n                    col--;\\n                }\\n            }\\n\\n            c = board[i].charAt(i);\\n            if (c == \\'X\\') {\\n                diag1++;\\n            } else if (c == \\'O\\') {\\n                diag1--;\\n            }\\n            c = board[i].charAt(n - 1 - i);\\n            if (c == \\'X\\') {\\n                diag2++;\\n            } else if (c == \\'O\\') {\\n                diag2--;\\n            }\\n\\n            if (row == n || col == n || diag1 == n || diag2 == n) {\\n                if (oWin) {\\n                    return false;\\n                }\\n                xWin = true;\\n            }\\n            if (row == -n || col == -n || diag1 == -n || diag2 == -n) {\\n                if (xWin) {\\n                    return false;\\n                }\\n                oWin = true;\\n            }\\n        }\\n\\n        if (turnsDiff < 0 || turnsDiff > 1) {\\n            return false;\\n        }\\n        /**\\n         * X Wins only after odd number of turns, thus the diff will be 1.\\n         *\\n         * O wins only after even number of turns, thus the diff will be 0.\\n         */\\n        if ((turnsDiff == 0 && xWin) || (turnsDiff == 1 && oWin)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```java\\n/**\\n * Calculate net score of each row, column and diagonal.\\n *\\n * Not Space Optimized. Here the score of each row, column and diagonal is\\n * stored in an int array. For Player1 add 1 and for Player2 add -1.\\n *\\n * Time Complexity: O(N^2) or O(1)\\n *\\n * Space Complexity: O(N) or O(1)\\n *\\n * N = Board Size (Number of Rows or Number of Columns)\\n */\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }\\n\\n        int n = board.length;\\n        int[] rows = new int[n];\\n        int[] cols = new int[n];\\n        int diag1 = 0;\\n        int diag2 = 0;\\n        int turnsDiff = 0;\\n        boolean xWin = false;\\n        boolean oWin = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                char c = board[i].charAt(j);\\n                if (c == \\' \\') {\\n                    continue;\\n                }\\n                int val = c == \\'X\\' ? 1 : -1;\\n                turnsDiff += val;\\n                rows[i] += val;\\n                cols[j] += val;\\n                if (i == j) {\\n                    diag1 += val;\\n                }\\n                if (i + j == n - 1) {\\n                    diag2 += val;\\n                }\\n                if (rows[i] == n || cols[j] == n || diag1 == n || diag2 == n) {\\n                    if (oWin) {\\n                        return false;\\n                    }\\n                    xWin = true;\\n                }\\n                if (rows[i] == -n || cols[j] == -n || diag1 == -n || diag2 == -n) {\\n                    if (xWin) {\\n                        return false;\\n                    }\\n                    oWin = true;\\n                }\\n            }\\n        }\\n\\n        if (turnsDiff < 0 || turnsDiff > 1) {\\n            return false;\\n        }\\n        if ((turnsDiff == 0 && xWin) || (turnsDiff == 1 && oWin)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117603,
                "title": "a-few-solutions",
                "content": "There are 4 use cases to consider:\\n\\n* **Case 1:** if `X` won and `O` won, then return `false` since there cannot be more than one winner\\n* **Case 2:** if `X` won, then return `true` if and only if there exists one more `X` than `O`\\n* **Case 3:** if `O` won, then return `true` if and only if there exists the same amount `X` and `O`\\n* **Case 4:** if no winner, then return `true` if and only if there exists either one more `X` than `O` xor the same amount `X` and `O`\\n\\n---\\n\\n*Javascript*\\n```\\nlet validTicTacToe = A => {\\n    let X = _.sum(A.map(row => row.split(\\'\\').filter(c => c == \\'X\\').length)),\\n        O = _.sum(A.map(row => row.split(\\'\\').filter(c => c == \\'O\\').length));\\n    let win = c => {\\n        let target = c.repeat(3);\\n        if (A.some(row => row == target))\\n            return true;\\n        for (let j = 0; j < 3; ++j) {\\n            let col = A[0][j] + A[1][j] + A[2][j];\\n            if (col == target)\\n                return true;\\n        }\\n        return A[0][0] + A[1][1] + A[2][2] == target || A[0][2] + A[1][1] + A[2][0] == target;\\n    };\\n    let winX = win(\\'X\\'),\\n        winO = win(\\'O\\');\\n    if (winX && winO)       return false;  // case 1: if X won and O won\\n    if (winX && X - O != 1) return false;  // case 2: if X won, then there must be one more X than O\\n    if (winO && X - O != 0) return false;  // case 3: if O won, then there must be the same amount of X and O\\n    return X - O == 0 || X - O == 1;       // case 4: if no winner, then there must be the same amount of X and O xor one more X than O\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def validTicTacToe(self, A: List[str], winX = False, winO = False) -> bool:\\n        X = sum([row.count(\\'X\\') for row in A])\\n        O = sum([row.count(\\'O\\') for row in A])\\n        def win(c):\\n            target = c * 3\\n            for row in A:\\n                if row == target: return True\\n            for j in range(3):\\n                col = A[0][j] + A[1][j] + A[2][j]\\n                if col == target: return True\\n            return A[0][0] + A[1][1] + A[2][2] == target or A[0][2] + A[1][1] + A[2][0] == target\\n        winX = win(\\'X\\')\\n        winO = win(\\'O\\')\\n        if winX and winO:       return False  # case 1: if X won and O won\\n        if winX and X - O != 1: return False  # case 2: if X won, then there must be one more X than O\\n        if winO and X - O != 0: return False  # case 3: if O won, then there must be the same amount of X and O\\n        return X - O in [0, 1]                # case 4: if no winner, then there must be the same amount of X and O xor one more X than O\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    bool validTicTacToe(VS& A, string S = {}) {\\n        for (auto& row: A)\\n            S.append(row);\\n        int X = count_if(S.begin(), S.end(), [](auto c) { return c == \\'X\\'; }),\\n            O = count_if(S.begin(), S.end(), [](auto c) { return c == \\'O\\'; });\\n        auto win = [&](auto c) {\\n            auto target = string(3, c);\\n            if (any_of(A.begin(), A.end(), [&](auto& row) { return row == target; }))\\n                return true;\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                stringstream col; col << A[0][j] << A[1][j] << A[2][j];\\n                if (col.str() == target)\\n                    return true;\\n            }\\n            stringstream diag1; diag1 << A[0][0] << A[1][1] << A[2][2];\\n            stringstream diag2; diag2 << A[0][2] << A[1][1] << A[2][0];\\n            return diag1.str() == target || diag2.str() == target;\\n        };\\n        auto winX = win(\\'X\\'),\\n             winO = win(\\'O\\');\\n        if (winX && winO)       return false;  // case 1: if X won and O won\\n        if (winX && X - O != 1) return false;  // case 2: if X won, then there must be one more X than O\\n        if (winO && X - O != 0) return false;  // case 3: if O won, then there must be the same amount of X and O\\n        return X - O == 0 || X - O == 1;       // case 4: if no winner, then there must be the same amount of X and O xor one more X than O\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet validTicTacToe = A => {\\n    let X = _.sum(A.map(row => row.split(\\'\\').filter(c => c == \\'X\\').length)),\\n        O = _.sum(A.map(row => row.split(\\'\\').filter(c => c == \\'O\\').length));\\n    let win = c => {\\n        let target = c.repeat(3);\\n        if (A.some(row => row == target))\\n            return true;\\n        for (let j = 0; j < 3; ++j) {\\n            let col = A[0][j] + A[1][j] + A[2][j];\\n            if (col == target)\\n                return true;\\n        }\\n        return A[0][0] + A[1][1] + A[2][2] == target || A[0][2] + A[1][1] + A[2][0] == target;\\n    };\\n    let winX = win(\\'X\\'),\\n        winO = win(\\'O\\');\\n    if (winX && winO)       return false;  // case 1: if X won and O won\\n    if (winX && X - O != 1) return false;  // case 2: if X won, then there must be one more X than O\\n    if (winO && X - O != 0) return false;  // case 3: if O won, then there must be the same amount of X and O\\n    return X - O == 0 || X - O == 1;       // case 4: if no winner, then there must be the same amount of X and O xor one more X than O\\n};\\n```\n```\\nclass Solution:\\n    def validTicTacToe(self, A: List[str], winX = False, winO = False) -> bool:\\n        X = sum([row.count(\\'X\\') for row in A])\\n        O = sum([row.count(\\'O\\') for row in A])\\n        def win(c):\\n            target = c * 3\\n            for row in A:\\n                if row == target: return True\\n            for j in range(3):\\n                col = A[0][j] + A[1][j] + A[2][j]\\n                if col == target: return True\\n            return A[0][0] + A[1][1] + A[2][2] == target or A[0][2] + A[1][1] + A[2][0] == target\\n        winX = win(\\'X\\')\\n        winO = win(\\'O\\')\\n        if winX and winO:       return False  # case 1: if X won and O won\\n        if winX and X - O != 1: return False  # case 2: if X won, then there must be one more X than O\\n        if winO and X - O != 0: return False  # case 3: if O won, then there must be the same amount of X and O\\n        return X - O in [0, 1]                # case 4: if no winner, then there must be the same amount of X and O xor one more X than O\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    bool validTicTacToe(VS& A, string S = {}) {\\n        for (auto& row: A)\\n            S.append(row);\\n        int X = count_if(S.begin(), S.end(), [](auto c) { return c == \\'X\\'; }),\\n            O = count_if(S.begin(), S.end(), [](auto c) { return c == \\'O\\'; });\\n        auto win = [&](auto c) {\\n            auto target = string(3, c);\\n            if (any_of(A.begin(), A.end(), [&](auto& row) { return row == target; }))\\n                return true;\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                stringstream col; col << A[0][j] << A[1][j] << A[2][j];\\n                if (col.str() == target)\\n                    return true;\\n            }\\n            stringstream diag1; diag1 << A[0][0] << A[1][1] << A[2][2];\\n            stringstream diag2; diag2 << A[0][2] << A[1][1] << A[2][0];\\n            return diag1.str() == target || diag2.str() == target;\\n        };\\n        auto winX = win(\\'X\\'),\\n             winO = win(\\'O\\');\\n        if (winX && winO)       return false;  // case 1: if X won and O won\\n        if (winX && X - O != 1) return false;  // case 2: if X won, then there must be one more X than O\\n        if (winO && X - O != 0) return false;  // case 3: if O won, then there must be the same amount of X and O\\n        return X - O == 0 || X - O == 1;       // case 4: if no winner, then there must be the same amount of X and O xor one more X than O\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479695,
                "title": "concise-code-beat-100-python-solution-with-explanation",
                "content": "There is only four situation that Tic-Tac-Toe is invalid:\\n1. two players are not taking turns making move\\n2. \"O\" player makes move before \"X\" player\\n3. \"X\" player wins but \"O\" player continues to make move\\n4. \"O\" player wins but \"X\" player continues to make move\\n\\n```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        def win(s): # return True if the player who use s wins\\n            if board[0][0]==s and board[0][1]==s and board[0][2]==s: return True\\n            if board[1][0]==s and board[1][1]==s and board[1][2]==s: return True\\n            if board[2][0]==s and board[2][1]==s and board[2][2]==s: return True\\n            if board[0][0]==s and board[1][0]==s and board[2][0]==s: return True\\n            if board[0][1]==s and board[1][1]==s and board[2][1]==s: return True\\n            if board[0][2]==s and board[1][2]==s and board[2][2]==s: return True\\n            if board[0][0]==s and board[1][1]==s and board[2][2]==s: return True\\n            if board[0][2]==s and board[1][1]==s and board[2][0]==s: return True\\n            return False\\n        \\n        xNo, oNo=0, 0\\n        for row in board:\\n            xNo+=row.count(\\'X\\')\\n            oNo+=row.count(\\'O\\')\\n        if oNo>xNo or xNo-oNo>=2: # \"X\" not making move first or not taking turns making move\\n            return False\\n        if xNo>=3:\\n            if xNo==oNo and win(\\'X\\'): # put another \"O\" after \"X\" player winning\\n                return False\\n            if xNo!=oNo and win(\\'O\\'): # put another \"X\" after \"O\" player winning\\n                return False\\n        return True\\n```\\n![image](https://assets.leetcode.com/users/ytp27/image_1578954871.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        def win(s): # return True if the player who use s wins\\n            if board[0][0]==s and board[0][1]==s and board[0][2]==s: return True\\n            if board[1][0]==s and board[1][1]==s and board[1][2]==s: return True\\n            if board[2][0]==s and board[2][1]==s and board[2][2]==s: return True\\n            if board[0][0]==s and board[1][0]==s and board[2][0]==s: return True\\n            if board[0][1]==s and board[1][1]==s and board[2][1]==s: return True\\n            if board[0][2]==s and board[1][2]==s and board[2][2]==s: return True\\n            if board[0][0]==s and board[1][1]==s and board[2][2]==s: return True\\n            if board[0][2]==s and board[1][1]==s and board[2][0]==s: return True\\n            return False\\n        \\n        xNo, oNo=0, 0\\n        for row in board:\\n            xNo+=row.count(\\'X\\')\\n            oNo+=row.count(\\'O\\')\\n        if oNo>xNo or xNo-oNo>=2: # \"X\" not making move first or not taking turns making move\\n            return False\\n        if xNo>=3:\\n            if xNo==oNo and win(\\'X\\'): # put another \"O\" after \"X\" player winning\\n                return False\\n            if xNo!=oNo and win(\\'O\\'): # put another \"X\" after \"O\" player winning\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117606,
                "title": "only-one-iteration-on-board-c-only-3ms-can-be-easily-scaled-for-any-size-board",
                "content": "\\nclass Solution {\\n\\tpublic:\\n\\n\\t// solved using only one iteration over board\\n    bool validTicTacToe(vector<string>& board) {\\n        bool wony = false, wonx = false;\\n        int rows = board.size();\\n        int cols = rows ? board[0].size() : 0;\\n        int diax = 0, diay = 0, xdiax = 0, xdiay = 0, x_count = 0, y_count = 0;\\n        \\n        for(int i = 0; i < rows; i++) {\\n            int rowsx = 0, rowsy = 0;\\n            int colsx = 0, colsy = 0;\\n            for(int j = 0; j < cols; j++) {\\n                // see current row\\n                if(board[i][j] == \\'X\\')\\n                    rowsx++,x_count++;\\n                if(board[i][j] == \\'O\\')\\n                    rowsy++, y_count++;\\n                // see ith column\\n                if(board[j][i] == \\'X\\')\\n                    colsx++;\\n                if (board[j][i] == \\'O\\')\\n                    colsy++;\\n            }\\n            \\n            // see both the diagonals\\n            if(board[i][i] == \\'X\\')\\n                diax++;\\n            if(board[i][i] == \\'O\\')\\n                diay++;\\n            if(board[i][cols - 1 - i] == \\'X\\')\\n                xdiax++;\\n            if(board[i][cols - 1 - i] == \\'O\\')\\n                xdiay++;\\n            \\n            if(rowsx == 3 || colsx == 3 || diax == 3 || xdiax == 3)\\n                wonx = true;\\n            \\n             if(rowsy == 3 || colsy == 3 || diay == 3 || xdiay == 3)\\n                wony = true;\\n        }\\n        \\n        if(!(x_count == y_count || x_count == y_count + 1))\\n            return false;\\n        \\n        if((wonx && wony) || (wonx && x_count == y_count) || (wony && x_count != y_count))\\n            return false;\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t// solved using only one iteration over board\\n    bool validTicTacToe(vector<string>& board) {\\n        bool wony = false, wonx = false;\\n        int rows = board.size();\\n        int cols = rows ? board[0].size() : 0;\\n        int diax = 0, diay = 0, xdiax = 0, xdiay = 0, x_count = 0, y_count = 0;\\n        \\n        for(int i = 0; i < rows; i++) {\\n            int rowsx = 0, rowsy = 0;\\n            int colsx = 0, colsy = 0;\\n            for(int j = 0; j < cols; j++) {\\n                // see current row\\n                if(board[i][j] == \\'X\\')\\n                    rowsx++,x_count++;\\n                if(board[i][j] == \\'O\\')\\n                    rowsy++, y_count++;\\n                // see ith column\\n                if(board[j][i] == \\'X\\')\\n                    colsx++;\\n                if (board[j][i] == \\'O\\')\\n                    colsy++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 269831,
                "title": "simple-python-solution",
                "content": "# take turn and the first player always plays \\'X\\', so xc must >=oc and xc<=oc+1.\\n\\t\\t# if the first player wins, the \\'X\\' count number(c1) should be one more than \\'O\\'(c2).\\n\\t\\t# if the second player wins, the \\'X\\' count number should be equal to \\'O\\'.\\n\\t\\t# they cannot both win, no need to check. bcoz otherwise c1==c2-1==c2, which is never true.\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def win(board,c):\\n            for line in board:\\n                if line[0]==line[1]==line[2]==c:return True\\n            for col in range(3):\\n                if board[0][col]==board[1][col]==board[2][col]==c:return True\\n            if board[0][0]==board[1][1]==board[2][2]==c:return True\\n            if board[0][2]==board[1][1]==board[2][0]==c:return True\\n            return False\\n        c=collections.Counter(\\'\\'.join(board))\\n        xc,oc=c[\\'X\\'],c[\\'O\\']\\n        if xc<oc or xc>oc+1:return False\\n        if win(board,\\'X\\') and oc!=xc-1:return False\\n        if win(board,\\'O\\') and oc!=xc:return False\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def win(board,c):\\n            for line in board:\\n                if line[0]==line[1]==line[2]==c:return True\\n            for col in range(3):\\n                if board[0][col]==board[1][col]==board[2][col]==c:return True\\n            if board[0][0]==board[1][1]==board[2][2]==c:return True\\n            if board[0][2]==board[1][1]==board[2][0]==c:return True\\n            return False\\n        c=collections.Counter(\\'\\'.join(board))\\n        xc,oc=c[\\'X\\'],c[\\'O\\']\\n        if xc<oc or xc>oc+1:return False\\n        if win(board,\\'X\\') and oc!=xc-1:return False\\n        if win(board,\\'O\\') and oc!=xc:return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117868,
                "title": "java-20-lines-with-a-cute-trick",
                "content": "**Note** - Code updated to fix a failed testcase, thanks nkallen for pointing it out.\\n\\nThe idea is simple.\\n**Step 1** -  get a count of the \\'X\\' and \\'O\\'.\\n**Step 2** (optional) - Now we can exlude any state with X < O or X > O+1. (we could fold this into the last return statement but that would be quite unreadable.)\\n**Step 3** - Look at all possible 3-Rows (There is 8 of them), if we find 3x \\'X\\' increment a counter by 1, if we find 3x \\'O\\' decrement a counter by some number greater than 8 (here -10 is used).\\n**Step 4** - If the counter is 0 noone won, if the counter is 1 OR 2 \\'X\\' won and the state is legal if x has one more piece, if the counter is -10 \\'O\\' won exactly once and the state is legal if the num pieces is equal, if the counter is anything else then the state is illegal.\\n\\n\\n``` \\npublic boolean validTicTacToe(String[] board) {\\n    int xCount = 0, oCount = 0;\\n    char[] arr = (board[0] + board[1] + board[2]).toCharArray();\\n    for (char c : arr) {\\n        if (c == \\'O\\') oCount++;\\n        if (c == \\'X\\') xCount++;\\n    }\\n    if (oCount != xCount && oCount+1 != xCount)\\n        return false;\\n    int winState = getWinState(arr[0], arr[4], arr[8]);\\n       winState += getWinState(arr[6], arr[4], arr[2]);\\n    for (int i = 0; i < 3; i++) {\\n        winState += getWinState(arr[i*3], arr[i*3+1], arr[i*3+2]);\\n        winState += getWinState(arr[i], arr[i+3], arr[i+6]);\\n    }\\n    return winState == 0 || (winState == -10 && oCount == xCount) || ((winState == 1 || winState == 2) && oCount+1 == xCount);\\n}\\nprivate int getWinState(char c1, char c2, char c3) {\\n    if (c1 != \\' \\' && c1 == c2 && c2 == c3) return c1 == \\'X\\' ? 1 : -10;\\n    else return 0;\\n} \\n``` \\n------------\\nFor fun here is the same solution with a little bit more complicated logic but a few less lines of code:\\n\\n``` \\npublic boolean validTicTacToe(String[] board) {\\n    int xCount = 0, oCount = 0;\\n    char[] arr = (board[0] + board[1] + board[2]).toCharArray();\\n    for (char c : arr) {\\n        if (c == \\'O\\') oCount++;\\n        if (c == \\'X\\') xCount++;\\n    }\\n    int winState = getWinState(arr[0], arr[4], arr[8]);\\n       winState += getWinState(arr[6], arr[4], arr[2]);\\n    for (int i = 0; i < 3; i++) {\\n        winState += getWinState(arr[i*3], arr[i*3+1], arr[i*3+2]);\\n        winState += getWinState(arr[i], arr[i+3], arr[i+6]);\\n    }\\n    return (winState%10 == 0 && oCount == xCount) || (winState < 3 && oCount+1 == xCount);\\n}\\nprivate int getWinState(char c1, char c2, char c3) {\\n    if (c1 != \\' \\' && c1 == c2 && c2 == c3) return c1 == \\'X\\' ? 1 : 10;\\n    else return 0;\\n}",
                "solutionTags": [],
                "code": "``` \\npublic boolean validTicTacToe(String[] board) {\\n    int xCount = 0, oCount = 0;\\n    char[] arr = (board[0] + board[1] + board[2]).toCharArray();\\n    for (char c : arr) {\\n        if (c == \\'O\\') oCount++;\\n        if (c == \\'X\\') xCount++;\\n    }\\n    if (oCount != xCount && oCount+1 != xCount)\\n        return false;\\n    int winState = getWinState(arr[0], arr[4], arr[8]);\\n       winState += getWinState(arr[6], arr[4], arr[2]);\\n    for (int i = 0; i < 3; i++) {\\n        winState += getWinState(arr[i*3], arr[i*3+1], arr[i*3+2]);\\n        winState += getWinState(arr[i], arr[i+3], arr[i+6]);\\n    }\\n    return winState == 0 || (winState == -10 && oCount == xCount) || ((winState == 1 || winState == 2) && oCount+1 == xCount);\\n}\\nprivate int getWinState(char c1, char c2, char c3) {\\n    if (c1 != \\' \\' && c1 == c2 && c2 == c3) return c1 == \\'X\\' ? 1 : -10;\\n    else return 0;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269469,
                "title": "python3-int-array-7-lines-w-explanation-t-m-98-49",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n                                            # The two criteria for a valid board are:\\n                                            #   1) num of Xs - num of Os is 0 or 1\\n                                            #   2) X is not a winner if the # of moves is even, and\\n                                            #      O is not a winner if the # of moves is odd.\\n\\n        d = {\\'X\\': 1, \\'O\\': -1, \\' \\': 0}               # transform the 1x3 str array to a 1x9 int array\\n        s = [d[ch] for ch in \\'\\'.join(board)]        # Ex: [\"XOX\",\" X \",\"   \"] --> [1,-1,1,0,1,0,0,0,0]\\n        sm = sum(s)\\n\\n        if sm>>1: return False                                      # <-- criterion 1\\n        \\n        n = -3 if sm == 1 else 3                                    # <-- criterion 2.\\n        if n in {s[0]+s[1]+s[2], s[3]+s[4]+s[5], s[6]+s[7]+s[8], \\n                 s[0]+s[3]+s[6], s[1]+s[4]+s[7], s[2]+s[5]+s[8],         # the elements of the set are \\n                 s[0]+s[4]+s[8], s[2]+s[4]+s[6]}: return False           # the rows, cols, and diags\\n        \\n        return True                                                 # <-- both criteria are true",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n                                            # The two criteria for a valid board are:\\n                                            #   1) num of Xs - num of Os is 0 or 1\\n                                            #   2) X is not a winner if the # of moves is even, and\\n                                            #      O is not a winner if the # of moves is odd.\\n\\n        d = {\\'X\\': 1, \\'O\\': -1, \\' \\': 0}",
                "codeTag": "Java"
            },
            {
                "id": 703273,
                "title": "java-explained-100-runtime",
                "content": "There are 4 conditions that make an invalid board:\\n1) since X starts it must either have the same number of moves as O or exactly one more\\n2) both X and O can\\'t win, since if one of them wins the game stops\\n3) If X wins, it will always have played on more move than O (since it starts)\\n4) If O wins, it must have played the same number of times as O\\n\\nIf all of these conditions succeed, then we have a successful board, if any of them break our board is broken.\\n\\n```\\nclass Solution {\\n    \\n    int numX;\\n    int numO;\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        // can\\'t be two winners AND X has as many spots as O or 1 more max\\n        \\n        // numbers don\\'t add up\\n        if (!numXPossible(board))\\n            return false;\\n        \\n        boolean winnerO = checkForWin(board, \\'O\\');\\n        boolean winnerX = checkForWin(board, \\'X\\');\\n        \\n        // can\\'t both be winners\\n        if (winnerO && winnerX)\\n            return false;\\n        \\n        // if X won, it must have had an extra move\\n        if (winnerX && this.numX - this.numO != 1)\\n            return false;\\n        \\n        // if O won, the moves must be equal\\n        if (winnerO && this.numX - this.numO != 0)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    // true indicates the number of Xs to Os is possible\\n    public boolean numXPossible(String[] board) {\\n        \\n        this.numX = 0;\\n        this.numO = 0;\\n        \\n        for (String ln : board) {\\n            for (int i = 0; i < 3; i++) {\\n                if (ln.charAt(i) == \\'X\\')\\n                    this.numX++;\\n                else if (ln.charAt(i) == \\'O\\')\\n                    this.numO++;\\n            }\\n        }\\n        \\n        // X must either be one ahead or the same\\n        return this.numX - this.numO == 0 || this.numX - this.numO == 1;\\n    }\\n    \\n    public boolean checkForWin(String[] board, char c) {\\n        // check horizontal\\n        for (String ln : board) {\\n            for (int i = 0; i < 3; i++) {\\n                if (ln.charAt(0) == c && ln.charAt(1) == c && ln.charAt(2) == c) {\\n                    return true;\\n                }\\n            }    \\n        }\\n        \\n        // check vert\\n        if ((board[0].charAt(0) == c && board[1].charAt(0) == c && board[2].charAt(0) == c) || (board[0].charAt(1) == c && board[1].charAt(1) == c && board[2].charAt(1) == c) || (board[0].charAt(2) == c && board[1].charAt(2) == c && board[2].charAt(2) == c))\\n            return true;\\n        \\n        // check diagonal\\n        if ((board[0].charAt(0) == c && board[1].charAt(1) == c && board[2].charAt(2) == c) || (board[0].charAt(2) == c && board[1].charAt(1)  == c && board[2].charAt(0) == c))\\n            return true;\\n\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    int numX;\\n    int numO;\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        // can\\'t be two winners AND X has as many spots as O or 1 more max\\n        \\n        // numbers don\\'t add up\\n        if (!numXPossible(board))\\n            return false;\\n        \\n        boolean winnerO = checkForWin(board, \\'O\\');\\n        boolean winnerX = checkForWin(board, \\'X\\');\\n        \\n        // can\\'t both be winners\\n        if (winnerO && winnerX)\\n            return false;\\n        \\n        // if X won, it must have had an extra move\\n        if (winnerX && this.numX - this.numO != 1)\\n            return false;\\n        \\n        // if O won, the moves must be equal\\n        if (winnerO && this.numX - this.numO != 0)\\n            return false;\\n        \\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 822435,
                "title": "java-faster-than-100-one-pass",
                "content": "```\\nclass Solution {\\n    private int[] playerX = new int[8]; // eight ways to win the game\\n    private int[] playerO = new int[8];\\n    private int countX, countO;\\n    public boolean validTicTacToe(String[] board) {\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                char c = board[i].charAt(j);\\n                if (c == \\'X\\') {\\n                    playerX[i]++;\\n                    playerX[j + 3]++;\\n                    if (i == j) playerX[6]++;\\n                    if (i == 2 - j) playerX[7]++;\\n                    countX++;\\n                }\\n                if (c == \\'O\\') {\\n                    playerO[i]++;\\n                    playerO[j + 3]++;\\n                    if (i == j) playerO[6]++;\\n                    if (i == 2 - j) playerO[7]++;\\n                    countO++;\\n                }\\n            }\\n        }\\n        return boardValidation();\\n    }\\n\\n    private boolean boardValidation() {\\n\\t\\tif (countX > countO + 1 || countX < countO) return false;\\n        boolean winnerX = false;\\n        boolean winnerO = false;\\n        for (int i = 0; i < 8; i++) {\\n            if (playerX[i] == 3) {\\n                winnerX = true;\\n            }\\n            if (playerO[i] == 3) {\\n                winnerO = true;\\n            }\\n        }\\n        if (winnerX && winnerO) return false;\\n        else if (winnerX) return countX == countO + 1;\\n        else if (winnerO) return countX == countO;\\n        else return true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] playerX = new int[8]; // eight ways to win the game\\n    private int[] playerO = new int[8];\\n    private int countX, countO;\\n    public boolean validTicTacToe(String[] board) {\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                char c = board[i].charAt(j);\\n                if (c == \\'X\\') {\\n                    playerX[i]++;\\n                    playerX[j + 3]++;\\n                    if (i == j) playerX[6]++;\\n                    if (i == 2 - j) playerX[7]++;\\n                    countX++;\\n                }\\n                if (c == \\'O\\') {\\n                    playerO[i]++;\\n                    playerO[j + 3]++;\\n                    if (i == j) playerO[6]++;\\n                    if (i == 2 - j) playerO[7]++;\\n                    countO++;\\n                }\\n            }\\n        }\\n        return boardValidation();\\n    }\\n\\n    private boolean boardValidation() {\\n\\t\\tif (countX > countO + 1 || countX < countO) return false;\\n        boolean winnerX = false;\\n        boolean winnerO = false;\\n        for (int i = 0; i < 8; i++) {\\n            if (playerX[i] == 3) {\\n                winnerX = true;\\n            }\\n            if (playerO[i] == 3) {\\n                winnerO = true;\\n            }\\n        }\\n        if (winnerX && winnerO) return false;\\n        else if (winnerX) return countX == countO + 1;\\n        else if (winnerO) return countX == countO;\\n        else return true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343420,
                "title": "c-clean-and-easy-to-understand-with-comments-beats-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool iswin(vector<string> &board, char c) {\\n        return ((board[0][0] == c && board[0][1] == c && board[0][2] == c) ||\\n          (board[1][0] == c && board[1][1] == c && board[1][2] == c) ||\\n          (board[2][0] == c && board[2][1] == c && board[2][2] == c) ||\\n          (board[0][0] == c && board[1][0] == c && board[2][0] == c) ||\\n          (board[0][1] == c && board[1][1] == c && board[2][1] == c) ||\\n          (board[0][2] == c && board[1][2] == c && board[2][2] == c) ||\\n          (board[0][0] == c && board[1][1] == c && board[2][2] == c) ||\\n          (board[0][2] == c && board[1][1] == c && board[2][0] == c));\\n    }\\n    bool validTicTacToe(vector<string>& board) {\\n        int xcnt = 0, ocnt = 0;\\n        for(string s: board) {\\n            for(char c: s) {\\n                if(c == \\'X\\') xcnt++;\\n                else if(c == \\'O\\') ocnt++;\\n            }\\n        }\\n        if(xcnt != ocnt && xcnt != ocnt + 1) return false;          // X can have equal or only 1 more move than O\\n        if(iswin(board, \\'X\\') && xcnt != ocnt + 1) return false;     // X will win by having one additional move\\n        if(iswin(board, \\'O\\') && xcnt != ocnt) return false;         // since X played first, O can win only when both have made same number of moves\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool iswin(vector<string> &board, char c) {\\n        return ((board[0][0] == c && board[0][1] == c && board[0][2] == c) ||\\n          (board[1][0] == c && board[1][1] == c && board[1][2] == c) ||\\n          (board[2][0] == c && board[2][1] == c && board[2][2] == c) ||\\n          (board[0][0] == c && board[1][0] == c && board[2][0] == c) ||\\n          (board[0][1] == c && board[1][1] == c && board[2][1] == c) ||\\n          (board[0][2] == c && board[1][2] == c && board[2][2] == c) ||\\n          (board[0][0] == c && board[1][1] == c && board[2][2] == c) ||\\n          (board[0][2] == c && board[1][1] == c && board[2][0] == c));\\n    }\\n    bool validTicTacToe(vector<string>& board) {\\n        int xcnt = 0, ocnt = 0;\\n        for(string s: board) {\\n            for(char c: s) {\\n                if(c == \\'X\\') xcnt++;\\n                else if(c == \\'O\\') ocnt++;\\n            }\\n        }\\n        if(xcnt != ocnt && xcnt != ocnt + 1) return false;          // X can have equal or only 1 more move than O\\n        if(iswin(board, \\'X\\') && xcnt != ocnt + 1) return false;     // X will win by having one additional move\\n        if(iswin(board, \\'O\\') && xcnt != ocnt) return false;         // since X played first, O can win only when both have made same number of moves\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838675,
                "title": "modular-and-extensible-python-solution-beats-90",
                "content": "O(1) time complexity, O(1) space complesity\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        n = 3\\n        rows = [0] * n\\n        cols = [0] * n\\n        diag = antidiag = balance = 0\\n        \\n        def win(v):\\n            if v in rows or v in cols or v in [diag, antidiag]: return True\\n            return False\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if board[i][j] != \" \":\\n                    balance += 1 if board[i][j] == \"X\" else -1\\n                    rows[i] += 1 if board[i][j] == \"X\" else -1\\n                    cols[j] += 1 if board[i][j] == \"X\" else -1\\n                    if i == j: diag += 1 if board[i][j] == \"X\" else -1\\n                    if i + j == n - 1: antidiag += 1 if board[i][j] == \"X\" else -1\\n        \\n        if not 0 <= balance <= 1: return False\\n            \\n        if balance == 0 and win(n): return False\\n        if balance == 1 and win(-n): return False\\n        \\n        return True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "O(1) time complexity, O(1) space complesity\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        n = 3\\n        rows = [0] * n\\n        cols = [0] * n\\n        diag = antidiag = balance = 0\\n        \\n        def win(v):\\n            if v in rows or v in cols or v in [diag, antidiag]: return True\\n            return False\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if board[i][j] != \" \":\\n                    balance += 1 if board[i][j] == \"X\" else -1\\n                    rows[i] += 1 if board[i][j] == \"X\" else -1\\n                    cols[j] += 1 if board[i][j] == \"X\" else -1\\n                    if i == j: diag += 1 if board[i][j] == \"X\" else -1\\n                    if i + j == n - 1: antidiag += 1 if board[i][j] == \"X\" else -1\\n        \\n        if not 0 <= balance <= 1: return False\\n            \\n        if balance == 0 and win(n): return False\\n        if balance == 1 and win(-n): return False\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 652900,
                "title": "c-time-0ms-explained",
                "content": "Simple & intuitive Rule based solution.\\nTime: 0ms, faster than 100%.\\n![image](https://assets.leetcode.com/users/3_harshit_3/image_1590472583.png)\\n\\n\\nMessy but understandable colde.\\n\\nSimply Check for various rules.\\n1. \\'X\\' count should always be same or greater by 1 than \\'O\\' count.\\n2.  \\'XXX\\' & \\'OOO\\' cannot co-exist.\\n3. If a player won already, then another player turn won\\'t come. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool rules_check_pass(vector<string>& board) {\\n        // 1. count(\\'X\\') == count(\\'0\\') || count(\\'X\\') - count(\\'0\\') == 1\\n        int x_count = 0, o_count = 0;\\n        for (auto &v:  board) {\\n            for (char ch: v) {\\n                if (ch == \\'O\\')\\n                    o_count++;\\n                else if(ch == \\'X\\')\\n                    x_count++;\\n            }\\n        }\\n        if (o_count > x_count || (x_count-o_count) > 1 )\\n            return false;\\n        \\n        // 2. 3 continous \\'XXX\\' and \\'000\\' cannot co-exist\\n        bool all_x = false, all_o = false;\\n        // row win\\n        for (auto &v: board) {\\n            if (v == \"XXX\")\\n                all_x = true;\\n            if (v == \"OOO\")\\n                all_o = true;            \\n        }\\n        // col win\\n        for (int c = 0 ; c < 3 ; c++) {\\n            if (board[0][c] == \\'X\\' && board[1][c]==\\'X\\' && board[2][c]==\\'X\\')\\n                all_x = true;\\n            if (board[0][c] == \\'O\\' && board[1][c]==\\'O\\' && board[2][c]==\\'O\\')\\n                all_o = true;\\n        }\\n        \\n        // diagnol win\\n        // left to right\\n        if (board[0][0] == \\'X\\' && board[1][1]==\\'X\\' && board[2][2]==\\'X\\')\\n            all_x = true;\\n        if (board[0][0] == \\'O\\' && board[1][1]==\\'O\\' && board[2][2]==\\'O\\')\\n            all_o = true;\\n        // right to left\\n        if (board[0][2] == \\'X\\' && board[1][1]==\\'X\\' && board[2][0]==\\'X\\')\\n            all_x = true;\\n        if (board[0][2] == \\'O\\' && board[1][1]==\\'O\\' && board[2][0]==\\'O\\')\\n            all_o = true;\\n        \\n        \\n        \\n        if ( all_x & all_o)\\n            return false;\\n        \\n        // 3. A player already won, then another player turn won\\'t come\\n        cout << \"all_x\" << all_x\\n             << \", x_count :\" << x_count\\n             << \", o_count : \" << o_count << endl;\\n        if (all_x) {\\n            if (x_count <= o_count) // 3-X, 3-O\\n                return false;\\n        }\\n        if (all_o) {\\n            if (o_count < x_count)  // 3-X 4-O\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool validTicTacToe(vector<string>& board) {\\n        return rules_check_pass(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool rules_check_pass(vector<string>& board) {\\n        // 1. count(\\'X\\') == count(\\'0\\') || count(\\'X\\') - count(\\'0\\') == 1\\n        int x_count = 0, o_count = 0;\\n        for (auto &v:  board) {\\n            for (char ch: v) {\\n                if (ch == \\'O\\')\\n                    o_count++;\\n                else if(ch == \\'X\\')\\n                    x_count++;\\n            }\\n        }\\n        if (o_count > x_count || (x_count-o_count) > 1 )\\n            return false;\\n        \\n        // 2. 3 continous \\'XXX\\' and \\'000\\' cannot co-exist\\n        bool all_x = false, all_o = false;\\n        // row win\\n        for (auto &v: board) {\\n            if (v == \"XXX\")\\n                all_x = true;\\n            if (v == \"OOO\")\\n                all_o = true;            \\n        }\\n        // col win\\n        for (int c = 0 ; c < 3 ; c++) {\\n            if (board[0][c] == \\'X\\' && board[1][c]==\\'X\\' && board[2][c]==\\'X\\')\\n                all_x = true;\\n            if (board[0][c] == \\'O\\' && board[1][c]==\\'O\\' && board[2][c]==\\'O\\')\\n                all_o = true;\\n        }\\n        \\n        // diagnol win\\n        // left to right\\n        if (board[0][0] == \\'X\\' && board[1][1]==\\'X\\' && board[2][2]==\\'X\\')\\n            all_x = true;\\n        if (board[0][0] == \\'O\\' && board[1][1]==\\'O\\' && board[2][2]==\\'O\\')\\n            all_o = true;\\n        // right to left\\n        if (board[0][2] == \\'X\\' && board[1][1]==\\'X\\' && board[2][0]==\\'X\\')\\n            all_x = true;\\n        if (board[0][2] == \\'O\\' && board[1][1]==\\'O\\' && board[2][0]==\\'O\\')\\n            all_o = true;\\n        \\n        \\n        \\n        if ( all_x & all_o)\\n            return false;\\n        \\n        // 3. A player already won, then another player turn won\\'t come\\n        cout << \"all_x\" << all_x\\n             << \", x_count :\" << x_count\\n             << \", o_count : \" << o_count << endl;\\n        if (all_x) {\\n            if (x_count <= o_count) // 3-X, 3-O\\n                return false;\\n        }\\n        if (all_o) {\\n            if (o_count < x_count)  // 3-X 4-O\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool validTicTacToe(vector<string>& board) {\\n        return rules_check_pass(board);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 117638,
                "title": "easy-to-understand-in-c",
                "content": "```\nbool validTicTacToe(char** board, int n) {\n    int x_row_count[3] = {0}, x_col_count[3] = {0};\n    int o_row_count[3] = {0}, o_col_count[3] = {0};\n    int diag1_x = 0, diag1_o = 0, diag2_x = 0, diag2_o = 0;\n    int i, j, x = 0, o = 0;\n    bool x_wins = false, o_wins = false;\n    \n    for(i = 0; i < n; i++){\n        for(j = 0; j < n; j++){\n            if(board[i][j] == 'X'){\n                x_row_count[i]++;\n                x_col_count[j]++;\n                if(i == j) diag1_x++;\n                if(i+j == 2) diag2_x++;\n                x++;\n            } else if (board[i][j] == 'O'){\n                o_row_count[i]++;\n                o_col_count[j]++;\n                if(i == j) diag1_o++;\n                if(i+j == 2) diag2_o++;\n                o++;\n            } \n\n            if((x_row_count[i] == 3) || (x_col_count[j] == 3) || \n               (diag1_x == 3) || (diag2_x == 3)) x_wins = true;\n            \n            if((o_row_count[i] == 3) || (o_col_count[j] == 3) || \n               (diag1_o == 3) || (diag2_o == 3)) o_wins = true; \n        }\n    }\n    \n    // x should be equal to o or 1 greater than o as x always starts the game\n    if(!((x == o) || (x == o+1))) return false;\n    \n    //if x wins, count of x should be greater than o\n    if(x_wins && (x <= o)) return false;\n    \n    //if o wins, count of x should be equal to o\n    if(o_wins && (x!= o)) return false;    \n    \n    return true;\n}\n```",
                "solutionTags": [],
                "code": "```\nbool validTicTacToe(char** board, int n) {\n    int x_row_count[3] = {0}, x_col_count[3] = {0};\n    int o_row_count[3] = {0}, o_col_count[3] = {0};\n    int diag1_x = 0, diag1_o = 0, diag2_x = 0, diag2_o = 0;\n    int i, j, x = 0, o = 0;\n    bool x_wins = false, o_wins = false;\n    \n    for(i = 0; i < n; i++){\n        for(j = 0; j < n; j++){\n            if(board[i][j] == 'X'){\n                x_row_count[i]++;\n                x_col_count[j]++;\n                if(i == j) diag1_x++;\n                if(i+j == 2) diag2_x++;\n                x++;\n            } else if (board[i][j] == 'O'){\n                o_row_count[i]++;\n                o_col_count[j]++;\n                if(i == j) diag1_o++;\n                if(i+j == 2) diag2_o++;\n                o++;\n            } \n\n            if((x_row_count[i] == 3) || (x_col_count[j] == 3) || \n               (diag1_x == 3) || (diag2_x == 3)) x_wins = true;\n            \n            if((o_row_count[i] == 3) || (o_col_count[j] == 3) || \n               (diag1_o == 3) || (diag2_o == 3)) o_wins = true; \n        }\n    }\n    \n    // x should be equal to o or 1 greater than o as x always starts the game\n    if(!((x == o) || (x == o+1))) return false;\n    \n    //if x wins, count of x should be greater than o\n    if(x_wins && (x <= o)) return false;\n    \n    //if o wins, count of x should be equal to o\n    if(o_wins && (x!= o)) return false;    \n    \n    return true;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117610,
                "title": "easy-to-understand-python-solution",
                "content": "```\nclass Solution:\n    def isWin(self, board, c):\n        for i in range(3):  # Row check\n            if board[i] == c*3:\n                return True\n        for i in range(3):  # Column check\n            if board[i][0] == c and board[i][1] == c and board[i][2] == c:\n                return True\n        if board[0][0] == c and board[1][1] == c and board[2][2] == c or \\\n                board[0][2] == c and board[1][1] == c and board[2][0] == c:  # Diagonal check\n            return True\n        return False\n\n    def validTicTacToe(self, board):\n        count_X = count_O = 0\n        for i in range(3):\n            for j in range(3):\n                count_X += 1 if board[i][j] == 'X' else 0\n                count_O += 1 if board[i][j] == 'O' else 0\n        if count_O > count_X or count_X > count_O + 1:\n            return False\n        if count_O == count_X and self.isWin(board, 'X') or count_X == count_O + 1 and self.isWin(board, 'O'):\n            return False\n        return True\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def isWin(self, board, c):\n        for i in range(3):  # Row check\n            if board[i] == c*3:\n                return True\n        for i in range(3):  # Column check\n            if board[i][0] == c and board[i][1] == c and board[i][2] == c:\n                return True\n        if board[0][0] == c and board[1][1] == c and board[2][2] == c or \\\n                board[0][2] == c and board[1][1] == c and board[2][0] == c:  # Diagonal check\n            return True\n        return False\n\n    def validTicTacToe(self, board):\n        count_X = count_O = 0\n        for i in range(3):\n            for j in range(3):\n                count_X += 1 if board[i][j] == 'X' else 0\n                count_O += 1 if board[i][j] == 'O' else 0\n        if count_O > count_X or count_X > count_O + 1:\n            return False\n        if count_O == count_X and self.isWin(board, 'X') or count_X == count_O + 1 and self.isWin(board, 'O'):\n            return False\n        return True\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842934,
                "title": "c-faster-than-100-o-1-explained-with-approach",
                "content": "**Please upvote if you like my solution.**\\n# Approach\\n1. Number of \\'O\\' > Number of X -> return false\\n    2. Number of X - Number of Os > 1 -> Return false\\n    3. If O wins -\\n        a) Number of Os  == Number of Xs\\n        b) And X should not be winning\\n    4. If X wins -\\n        a) O should not win\\n         b) no. of x should be 1 more than no. of O\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// 1. Number of \\'O\\' > Number of X -> return false\\n//     2. Number of X - Number of Os > 1 -> Return false\\n//     3. If O wins -\\n//         a) Number of Os  == Number of Xs\\n//         b) And X should not be winning\\n//     4. If X wins -\\n//         a) O should not win\\n//         b) no. of x should be 1 more than no. of O\\n    bool validTicTacToe(vector<string>& board) {\\n        int o=0,x=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(auto j:board[i])\\n            {\\n                if(j == \\'X\\')\\n                x++;\\n                else if(j == \\'O\\')\\n                o++;\\n            }\\n        }\\n        if(o>x || (x-o > 1))return false;\\n        bool winx = false,wino = false;\\n        if(board[0] == \"XXX\" || board[1] == \"XXX\" || board[2] == \"XXX\")\\n        winx=true;\\n        if(board[0] == \"OOO\" || board[1] == \"OOO\" || board[2] == \"OOO\")\\n        wino=true;\\n\\n        if(!winx || !wino)\\n        {\\n            string s1,s2,s3,s4,s5;\\n            s1.push_back(board[0][0]);\\n            s1.push_back(board[1][0]);\\n            s1.push_back(board[2][0]);\\n            s2.push_back(board[0][1]);\\n            s2.push_back(board[1][1]);\\n            s2.push_back(board[2][1]);\\n            s3.push_back(board[0][2]);\\n            s3.push_back(board[1][2]);\\n            s3.push_back(board[2][2]);\\n            s4.push_back(board[0][0]);\\n            s4.push_back(board[1][1]);\\n            s4.push_back(board[2][2]);\\n            s5.push_back(board[0][2]);\\n            s5.push_back(board[1][1]);\\n            s5.push_back(board[2][0]);\\n            if(s1 == \"XXX\" || s2 == \"XXX\" || s3== \"XXX\" || s4 == \"XXX\" || s5==\"XXX\")\\n            winx=true;\\n            \\n            if(s1 == \"OOO\" || s2 == \"OOO\" || s3== \"OOO\" || s4 == \"OOO\" || s5==\"OOO\")\\n            wino=true;\\n\\n        }\\n        if(wino && winx)\\n        return false;\\n        if(wino)\\n        {\\n            if(o==x)\\n            return true;\\n            return false;\\n        }\\n        if(winx)\\n        {\\n            if(o+1 == x)\\n            return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// 1. Number of \\'O\\' > Number of X -> return false\\n//     2. Number of X - Number of Os > 1 -> Return false\\n//     3. If O wins -\\n//         a) Number of Os  == Number of Xs\\n//         b) And X should not be winning\\n//     4. If X wins -\\n//         a) O should not win\\n//         b) no. of x should be 1 more than no. of O\\n    bool validTicTacToe(vector<string>& board) {\\n        int o=0,x=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(auto j:board[i])\\n            {\\n                if(j == \\'X\\')\\n                x++;\\n                else if(j == \\'O\\')\\n                o++;\\n            }\\n        }\\n        if(o>x || (x-o > 1))return false;\\n        bool winx = false,wino = false;\\n        if(board[0] == \"XXX\" || board[1] == \"XXX\" || board[2] == \"XXX\")\\n        winx=true;\\n        if(board[0] == \"OOO\" || board[1] == \"OOO\" || board[2] == \"OOO\")\\n        wino=true;\\n\\n        if(!winx || !wino)\\n        {\\n            string s1,s2,s3,s4,s5;\\n            s1.push_back(board[0][0]);\\n            s1.push_back(board[1][0]);\\n            s1.push_back(board[2][0]);\\n            s2.push_back(board[0][1]);\\n            s2.push_back(board[1][1]);\\n            s2.push_back(board[2][1]);\\n            s3.push_back(board[0][2]);\\n            s3.push_back(board[1][2]);\\n            s3.push_back(board[2][2]);\\n            s4.push_back(board[0][0]);\\n            s4.push_back(board[1][1]);\\n            s4.push_back(board[2][2]);\\n            s5.push_back(board[0][2]);\\n            s5.push_back(board[1][1]);\\n            s5.push_back(board[2][0]);\\n            if(s1 == \"XXX\" || s2 == \"XXX\" || s3== \"XXX\" || s4 == \"XXX\" || s5==\"XXX\")\\n            winx=true;\\n            \\n            if(s1 == \"OOO\" || s2 == \"OOO\" || s3== \"OOO\" || s4 == \"OOO\" || s5==\"OOO\")\\n            wino=true;\\n\\n        }\\n        if(wino && winx)\\n        return false;\\n        if(wino)\\n        {\\n            if(o==x)\\n            return true;\\n            return false;\\n        }\\n        if(winx)\\n        {\\n            if(o+1 == x)\\n            return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618572,
                "title": "c-0ms-solution-with-10-testcases-examples",
                "content": "```class Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n      \\n        int countO = 0 , countX = 0 ;\\n        for(int i = 0 ; i<3 ; i++)\\n        {\\n            for(auto c : board[i])\\n            {\\n                if(c == \\'X\\')\\n                    countX++;\\n                else if(c == \\'O\\')\\n                    countO++;\\n            }\\n        }\\n        \\n      Observations - \\n    1. Number of \\'O\\' > Number of X -> return false\\n    2. Number of X - Number of Os > 1 -> Return false\\n    3. If O wins -\\n        a) Number of Os  == Number of Xs\\n        b) And X should not be winning\\n    4. If X wins -\\n        a) O should not win\\n        if(countX != countO  && countX - countO != 1 )\\n            return false;\\n        \\n        bool checkX = false ,  checkO = false;\\n        \\n        \\n        // Checking in Horizontal Line having saming digit \\n        if(board[0] == \"XXX\" ||  board[1] == \"XXX\" ||  board[2] == \"XXX\"  )\\n            checkX = true;\\n    \\n        if(board[0] == \"OOO\" ||  board[1] == \"OOO\" ||  board[2] == \"OOO\")\\n           checkO = true;\\n        \\n        if(checkX  || checkO)\\n        {\\n            if(countX - countO == 1)\\n            {\\n                 if(checkX)\\n                   return !checkO;\\n                return false;\\n            } \\n            else\\n            {\\n                if(checkX)\\n                    return false;\\n                return true;\\n            }\\n        }\\n        \\n        \\n        string s1 , s2 , s3 ;\\n        \\n        s1.push_back(board[0][0]);\\n        s1.push_back(board[1][0]);\\n        s1.push_back(board[2][0]);\\n        \\n        s2.push_back(board[0][1]);\\n        s2.push_back(board[1][1]);\\n        s2.push_back(board[2][1]);\\n        \\n        s3.push_back(board[0][2]);\\n        s3.push_back(board[1][2]);\\n        s3.push_back(board[2][2]);\\n        \\n        // Checking in Vertical Line  having saming digit \\n        if(s1 == \"XXX\" ||  s2 == \"XXX\" ||  s3 == \"XXX\"  )\\n            checkX = true;\\n        \\n        if(s1 == \"OOO\" ||  s2 == \"OOO\" ||  s3 == \"OOO\")\\n           checkO = true;\\n        \\n        \\n        \\n        if(checkX  || checkO)\\n        {\\n            if(countX - countO == 1)\\n            {\\n                 if(checkX)\\n                   return !checkO;\\n                 return false;\\n            } \\n            else\\n               if(checkX)\\n                    return false;\\n                return true;\\n        }\\n        \\n        \\n        string diag1 , diag2;\\n        \\n        diag1.push_back(board[0][0]);\\n        diag1.push_back(board[1][1]);\\n        diag1.push_back(board[2][2]);\\n        \\n        diag2.push_back(board[0][2]);\\n        diag2.push_back(board[1][1]);\\n        diag2.push_back(board[2][0]);\\n        \\n        \\n        // Checking in Diagonal  having saming digit \\n        if(diag1 == \"XXX\" ||  diag2 == \"XXX\"  )\\n            checkX = true;\\n        \\n        if(diag1 == \"OOO\" ||  diag2 == \"OOO\"  )\\n            checkO = true;\\n        \\n        if(checkX || checkO)\\n        {\\n            if(countX - countO == 1)\\n                return checkX;\\n            else\\n                return checkO;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n};\\n\\n// [\"XO \",\"XO \",\"XO \"]\\n// [\"XOX\",\" X \",\"   \"]\\n// [\"XOX\",\"O O\",\"XOX\"]\\n// [\"XOX\",\"OOO\",\"XOX\"]\\n// [\"XOX\",\"OOO\",\"XXX\"]\\n// [\"XOX\",\"XXO\",\"OXO\"]\\n// [\"XXX\",\"OOO\",\"   \"]\\n// [\"XOX\",\"OOO\",\"XXX\"]\\n// [\"XOX\",\"XOO\",\"XOX\"]\\n// [\"OXX\",\"XOX\",\"OXO\"]\\n\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5d4aa5b4-b619-4a1c-a71f-c44699ad45f6_1664030843.5149136.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n      \\n        int countO = 0 , countX = 0 ;\\n        for(int i = 0 ; i<3 ; i++)\\n        {\\n            for(auto c : board[i])\\n            {\\n                if(c == \\'X\\')\\n                    countX++;\\n                else if(c == \\'O\\')\\n                    countO++;\\n            }\\n        }\\n        \\n      Observations - \\n    1. Number of \\'O\\' > Number of X -> return false\\n    2. Number of X - Number of Os > 1 -> Return false\\n    3. If O wins -\\n        a) Number of Os  == Number of Xs\\n        b) And X should not be winning\\n    4. If X wins -\\n        a) O should not win\\n        if(countX != countO  && countX - countO != 1 )\\n            return false;\\n        \\n        bool checkX = false ,  checkO = false;\\n        \\n        \\n        // Checking in Horizontal Line having saming digit \\n        if(board[0] == \"XXX\" ||  board[1] == \"XXX\" ||  board[2] == \"XXX\"  )\\n            checkX = true;\\n    \\n        if(board[0] == \"OOO\" ||  board[1] == \"OOO\" ||  board[2] == \"OOO\")\\n           checkO = true;\\n        \\n        if(checkX  || checkO)\\n        {\\n            if(countX - countO == 1)\\n            {\\n                 if(checkX)\\n                   return !checkO;\\n                return false;\\n            } \\n            else\\n            {\\n                if(checkX)\\n                    return false;\\n                return true;\\n            }\\n        }\\n        \\n        \\n        string s1 , s2 , s3 ;\\n        \\n        s1.push_back(board[0][0]);\\n        s1.push_back(board[1][0]);\\n        s1.push_back(board[2][0]);\\n        \\n        s2.push_back(board[0][1]);\\n        s2.push_back(board[1][1]);\\n        s2.push_back(board[2][1]);\\n        \\n        s3.push_back(board[0][2]);\\n        s3.push_back(board[1][2]);\\n        s3.push_back(board[2][2]);\\n        \\n        // Checking in Vertical Line  having saming digit \\n        if(s1 == \"XXX\" ||  s2 == \"XXX\" ||  s3 == \"XXX\"  )\\n            checkX = true;\\n        \\n        if(s1 == \"OOO\" ||  s2 == \"OOO\" ||  s3 == \"OOO\")\\n           checkO = true;\\n        \\n        \\n        \\n        if(checkX  || checkO)\\n        {\\n            if(countX - countO == 1)\\n            {\\n                 if(checkX)\\n                   return !checkO;\\n                 return false;\\n            } \\n            else\\n               if(checkX)\\n                    return false;\\n                return true;\\n        }\\n        \\n        \\n        string diag1 , diag2;\\n        \\n        diag1.push_back(board[0][0]);\\n        diag1.push_back(board[1][1]);\\n        diag1.push_back(board[2][2]);\\n        \\n        diag2.push_back(board[0][2]);\\n        diag2.push_back(board[1][1]);\\n        diag2.push_back(board[2][0]);\\n        \\n        \\n        // Checking in Diagonal  having saming digit \\n        if(diag1 == \"XXX\" ||  diag2 == \"XXX\"  )\\n            checkX = true;\\n        \\n        if(diag1 == \"OOO\" ||  diag2 == \"OOO\"  )\\n            checkO = true;\\n        \\n        if(checkX || checkO)\\n        {\\n            if(countX - countO == 1)\\n                return checkX;\\n            else\\n                return checkO;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n};\\n\\n// [\"XO \",\"XO \",\"XO \"]\\n// [\"XOX\",\" X \",\"   \"]\\n// [\"XOX\",\"O O\",\"XOX\"]\\n// [\"XOX\",\"OOO\",\"XOX\"]\\n// [\"XOX\",\"OOO\",\"XXX\"]\\n// [\"XOX\",\"XXO\",\"OXO\"]\\n// [\"XXX\",\"OOO\",\"   \"]\\n// [\"XOX\",\"OOO\",\"XXX\"]\\n// [\"XOX\",\"XOO\",\"XOX\"]\\n// [\"OXX\",\"XOX\",\"OXO\"]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236512,
                "title": "python-simple-state-representation-for-any-tictactoe-memory-99-38",
                "content": "Everyone has solved this question pretty smoothly and efficiently.\\nI just wanted to add a way of representing the state in a different way.\\n\\nI am using an **array of size 8** for the representation.\\nThe **first 3 indexes** represent the state of the **rows**\\nThe **next 3** represent the **columns**\\nThe **last 2** represent the **diagonals**\\n\\nAfter that we just check for win condition in the array and design our cases in that way\\nI have tried to explain it in the code itself.\\nIf you have any doubts, please feel free to ask in the comments below\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # count the number of x and o\\n        xCount = oCount = 0\\n        \\n        # Easy state representation of valid win lines\\n        # Indexes: 0,1,2 represent rows. 3,4,5 represent columns. 6,7 represent diagonals (6 - \\\\, 7 - /)\\n        arr = [0]*8\\n\\n        # Check over the whole board\\n        for i, row in enumerate(board):\\n            for j, ch in enumerate(row):\\n\\n                # Check for X\\n                # steps: \\n                # 1. increment xCount \\n                # 2. add 1 to the row\\n                # 3. add 1 to the column\\n                # 4. add 1 to the diagonals if coordinates lie on diagonals\\n                if ch == \\'X\\': \\n                    xCount += 1\\n                    \\n                    arr[i] += 1\\n                    arr[j+3] += 1\\n                    \\n                    # check left to right diagonal (\\\\)\\n                    if i == j: arr[6] += 1\\n                    # check right to left diagonal (/)\\n                    if i == 2-j: arr[7] += 1\\n\\n                # Check for O\\n                # steps: \\n                # 1. increment oCount \\n                # 2. subtract 1 from the row\\n                # 3. subtract 1 from the column\\n                # 4. subtract 1 from the diagonals if coordinates lie on diagonals\\n                if ch == \\'O\\': \\n                    oCount += 1\\n                    \\n                    arr[i] -= 1\\n                    arr[j+3] -= 1\\n                    \\n                    # check left to right diagonal (\\\\)\\n                    if i == j: arr[6] -= 1\\n                    # check right to left diagonal (/)\\n                    if i == 2-j: arr[7] -= 1\\n                        \\n        # win conditions:\\n        # if 3 exists in array: X wins\\n        # if -3 exists: O wins\\n        # For more visualization, try drawing this\\n        xWin, oWin = 3 in arr, -3 in arr\\n        \\n        # Case 1: both are shown as winning (invalid state as X wins before O) eg: [\"XXX\",\"   \",\"OOO\"]\\n        if xWin and oWin: return False\\n\\n        # Case 2: X wins that indicates that the difference in count should be 1. As X plays before O\\n        if xWin and xCount - oCount != 1 : return False\\n        \\n        # Case 3: O wins that indicates that the difference in count should be 0. As X plays before O\\n        if oWin and xCount - oCount != 0 : return False\\n        \\n        # Case 4: both of them have to play alternate moves, hence difference can only be 1 or 0\\n        if xCount - oCount not in (0,1): return False\\n        \\n        # If all cases pass, board is valid\\n        return True\\n```\\n\\nOutput: \\n![image](https://assets.leetcode.com/users/images/a5c5553d-a65e-4918-b609-9e33de8950ac_1656934391.704926.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # count the number of x and o\\n        xCount = oCount = 0\\n        \\n        # Easy state representation of valid win lines\\n        # Indexes: 0,1,2 represent rows. 3,4,5 represent columns. 6,7 represent diagonals (6 - \\\\, 7 - /)\\n        arr = [0]*8\\n\\n        # Check over the whole board\\n        for i, row in enumerate(board):\\n            for j, ch in enumerate(row):\\n\\n                # Check for X\\n                # steps: \\n                # 1. increment xCount \\n                # 2. add 1 to the row\\n                # 3. add 1 to the column\\n                # 4. add 1 to the diagonals if coordinates lie on diagonals\\n                if ch == \\'X\\': \\n                    xCount += 1\\n                    \\n                    arr[i] += 1\\n                    arr[j+3] += 1\\n                    \\n                    # check left to right diagonal (\\\\)\\n                    if i == j: arr[6] += 1\\n                    # check right to left diagonal (/)\\n                    if i == 2-j: arr[7] += 1\\n\\n                # Check for O\\n                # steps: \\n                # 1. increment oCount \\n                # 2. subtract 1 from the row\\n                # 3. subtract 1 from the column\\n                # 4. subtract 1 from the diagonals if coordinates lie on diagonals\\n                if ch == \\'O\\': \\n                    oCount += 1\\n                    \\n                    arr[i] -= 1\\n                    arr[j+3] -= 1\\n                    \\n                    # check left to right diagonal (\\\\)\\n                    if i == j: arr[6] -= 1\\n                    # check right to left diagonal (/)\\n                    if i == 2-j: arr[7] -= 1\\n                        \\n        # win conditions:\\n        # if 3 exists in array: X wins\\n        # if -3 exists: O wins\\n        # For more visualization, try drawing this\\n        xWin, oWin = 3 in arr, -3 in arr\\n        \\n        # Case 1: both are shown as winning (invalid state as X wins before O) eg: [\"XXX\",\"   \",\"OOO\"]\\n        if xWin and oWin: return False\\n\\n        # Case 2: X wins that indicates that the difference in count should be 1. As X plays before O\\n        if xWin and xCount - oCount != 1 : return False\\n        \\n        # Case 3: O wins that indicates that the difference in count should be 0. As X plays before O\\n        if oWin and xCount - oCount != 0 : return False\\n        \\n        # Case 4: both of them have to play alternate moves, hence difference can only be 1 or 0\\n        if xCount - oCount not in (0,1): return False\\n        \\n        # If all cases pass, board is valid\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729707,
                "title": "java-0ms-concise-solution-easy-understand",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        // count the turns of each player\\n        int[] count = new int[3];\\n        boolean xWins = false;\\n        boolean oWins = false;\\n        \\n        for (String s : board){\\n            //check each row\\n            if (s.equals(\"XXX\")) xWins = true;\\n            if (s.equals(\"OOO\")) oWins = true;\\n            for (int i = 0; i < s.length(); i++){\\n                char cur = s.charAt(i);\\n                if (cur == \\' \\') count[0]++;\\n                else if (cur == \\'X\\') count[1]++;\\n                else count[2]++;\\n            }\\n        }\\n        int diff = count[1] - count[2]; \\n        if (diff < 0 || diff > 1) return false;\\n        \\n        // check each colomn\\n        for (int i = 0; i < 3; i++){\\n            if (board[0].charAt(i) == board[1].charAt(i) && board[1].charAt(i) == board[2].charAt(i)){\\n                if (board[0].charAt(i) == \\'X\\') xWins = true;\\n                if (board[0].charAt(i) == \\'O\\') oWins = true;\\n            }\\n        }\\n        //check diagonal\\n        if (board[0].charAt(0) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(2)){\\n            if (board[0].charAt(0) == \\'X\\') xWins = true;\\n            if (board[0].charAt(0) == \\'O\\') oWins = true;\\n        }\\n        //check antidiagonal\\n        if (board[0].charAt(2) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(0)){\\n            if (board[1].charAt(1) == \\'X\\') xWins = true;\\n            if (board[1].charAt(1) == \\'O\\') oWins = true;\\n        }\\n        // if X wins, turns difference between two player must be 1; \\n        // if O wins, turns difference between two player must be 0;\\n        if ( xWins && diff != 1) return false;\\n        if ( oWins && diff != 0) return false;\\n\\n        return true;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        // count the turns of each player\\n        int[] count = new int[3];\\n        boolean xWins = false;\\n        boolean oWins = false;\\n        \\n        for (String s : board){\\n            //check each row\\n            if (s.equals(\"XXX\")) xWins = true;\\n            if (s.equals(\"OOO\")) oWins = true;\\n            for (int i = 0; i < s.length(); i++){\\n                char cur = s.charAt(i);\\n                if (cur == \\' \\') count[0]++;\\n                else if (cur == \\'X\\') count[1]++;\\n                else count[2]++;\\n            }\\n        }\\n        int diff = count[1] - count[2]; \\n        if (diff < 0 || diff > 1) return false;\\n        \\n        // check each colomn\\n        for (int i = 0; i < 3; i++){\\n            if (board[0].charAt(i) == board[1].charAt(i) && board[1].charAt(i) == board[2].charAt(i)){\\n                if (board[0].charAt(i) == \\'X\\') xWins = true;\\n                if (board[0].charAt(i) == \\'O\\') oWins = true;\\n            }\\n        }\\n        //check diagonal\\n        if (board[0].charAt(0) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(2)){\\n            if (board[0].charAt(0) == \\'X\\') xWins = true;\\n            if (board[0].charAt(0) == \\'O\\') oWins = true;\\n        }\\n        //check antidiagonal\\n        if (board[0].charAt(2) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(0)){\\n            if (board[1].charAt(1) == \\'X\\') xWins = true;\\n            if (board[1].charAt(1) == \\'O\\') oWins = true;\\n        }\\n        // if X wins, turns difference between two player must be 1; \\n        // if O wins, turns difference between two player must be 0;\\n        if ( xWins && diff != 1) return false;\\n        if ( oWins && diff != 0) return false;\\n\\n        return true;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092458,
                "title": "elegant-bit-manipulation-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\n    private int[] winnings = new int[] { \\n            0b000000111, 0b000111000, 0b111000000, \\n            0b100100100, 0b010010010, 0b001001001, \\n            0b100010001, 0b001010100\\n    };\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        String s = String.join(\"\", board);\\n        int x = toInteger(s, \\'X\\');\\n        int o = toInteger(s, \\'O\\');\\n        boolean xWon = isWon(x);\\n        boolean oWon = isWon(o);\\n        int xExtraStep = Integer.bitCount(x) - Integer.bitCount(o);\\n        if (xWon && oWon) return false;\\n        else if (xExtraStep == 0) return !xWon;\\n        else if (xExtraStep == 1) return !oWon;\\n        else return false;\\n    }\\n\\n    private int toInteger(String s, char k) {\\n        int x = 0;\\n        for (char c : s.toCharArray()) x = (x << 1) | (c == k ? 1 : 0);\\n        return x;\\n    }\\n\\n    private boolean isWon(int x) {\\n        for (int w : winnings) {\\n            if ((w & x) == w) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int[] winnings = new int[] { \\n            0b000000111, 0b000111000, 0b111000000, \\n            0b100100100, 0b010010010, 0b001001001, \\n            0b100010001, 0b001010100\\n    };\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        String s = String.join(\"\", board);\\n        int x = toInteger(s, \\'X\\');\\n        int o = toInteger(s, \\'O\\');\\n        boolean xWon = isWon(x);\\n        boolean oWon = isWon(o);\\n        int xExtraStep = Integer.bitCount(x) - Integer.bitCount(o);\\n        if (xWon && oWon) return false;\\n        else if (xExtraStep == 0) return !xWon;\\n        else if (xExtraStep == 1) return !oWon;\\n        else return false;\\n    }\\n\\n    private int toInteger(String s, char k) {\\n        int x = 0;\\n        for (char c : s.toCharArray()) x = (x << 1) | (c == k ? 1 : 0);\\n        return x;\\n    }\\n\\n    private boolean isWon(int x) {\\n        for (int w : winnings) {\\n            if ((w & x) == w) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374949,
                "title": "java-runtime-faster-than-100-memory-less-than-100-very-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\n    char[] nBoard = null;\\n    //This matrix is used to find indexes to check all possible winning triplets in board[0..8]\\n    int[][] win = new int[][]{{0,1,2},{3,4,5},{6,7,8},{0,4,8},{2,4,6},{0,3,6},{1,4,7},{2,5,8}};\\n                                \\n\\n    //Convert 1D String array to 1D char array                             \\n    public boolean validTicTacToe(String[] board) {\\n    \\tnBoard = new char[9];\\n    \\tint k=0 ;\\n\\t    for(int i=0;i<3;i++){\\n\\t        for(int j=0;j<3;j++){\\n\\t            nBoard[k]=board[i].charAt(j);\\n\\t            k++;\\n\\t        }\\n\\t    }\\n\\t    return isValid(nBoard);\\n    }\\n    \\n        \\n    boolean isValid(char[] board){\\n    \\t//Count the numbers of X\\'s and O\\'s in the given board\\n        int xCount=0, oCount=0;\\n        for(int i=0;i<9;i++){\\n            if(board[i]==\\'X\\'){\\n                xCount++;\\n            }\\n            if(board[i]==\\'O\\'){\\n                oCount++;\\n            }\\n        }\\n        \\n        //Since we have to start with \\'X\\', xCount has to be equal to oCount or 1 more than oCount\\n        if(xCount==oCount || xCount==oCount+1){\\n        \\t//Check if \\'O\\' is winner\\n            if(isWin(board,\\'O\\')){\\n            \\t//Check if \\'X\\' is winner, both cannot be winner \\n                if(isWin(board,\\'X\\')){\\n                    return false;\\n                }\\n                //if \\'O\\' is winner it\\'s count has to be equal to \\'X\\'\\n                return xCount==oCount;\\n            } \\n            \\n            //if \\'X\\' wins, then it\\'s count has to 1 greater than \\'O\\' count\\n            if(isWin(board,\\'X\\') && xCount!=oCount+1){\\n                return false;\\n            }\\n            \\n            return true;                \\n        }\\n        return false;            \\n    }\\n    \\n    //Return true if char \\'c\\' wins, \\'c\\' can be either \\'O\\' or \\'X\\'\\n    boolean isWin(char[] board, char c){\\n        for(int i=0;i<8;i++){\\n            if(nBoard[win[i][0]]==c && nBoard[win[i][1]]==c && \\n               nBoard[win[i][2]]==c){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n//Credits : GeeksForGeeks(https://www.youtube.com/watch?v=RqOFx7Waehc)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] nBoard = null;\\n    //This matrix is used to find indexes to check all possible winning triplets in board[0..8]\\n    int[][] win = new int[][]{{0,1,2},{3,4,5},{6,7,8},{0,4,8},{2,4,6},{0,3,6},{1,4,7},{2,5,8}};\\n                                \\n\\n    //Convert 1D String array to 1D char array                             \\n    public boolean validTicTacToe(String[] board) {\\n    \\tnBoard = new char[9];\\n    \\tint k=0 ;\\n\\t    for(int i=0;i<3;i++){\\n\\t        for(int j=0;j<3;j++){\\n\\t            nBoard[k]=board[i].charAt(j);\\n\\t            k++;\\n\\t        }\\n\\t    }\\n\\t    return isValid(nBoard);\\n    }\\n    \\n        \\n    boolean isValid(char[] board){\\n    \\t//Count the numbers of X\\'s and O\\'s in the given board\\n        int xCount=0, oCount=0;\\n        for(int i=0;i<9;i++){\\n            if(board[i]==\\'X\\'){\\n                xCount++;\\n            }\\n            if(board[i]==\\'O\\'){\\n                oCount++;\\n            }\\n        }\\n        \\n        //Since we have to start with \\'X\\', xCount has to be equal to oCount or 1 more than oCount\\n        if(xCount==oCount || xCount==oCount+1){\\n        \\t//Check if \\'O\\' is winner\\n            if(isWin(board,\\'O\\')){\\n            \\t//Check if \\'X\\' is winner, both cannot be winner \\n                if(isWin(board,\\'X\\')){\\n                    return false;\\n                }\\n                //if \\'O\\' is winner it\\'s count has to be equal to \\'X\\'\\n                return xCount==oCount;\\n            } \\n            \\n            //if \\'X\\' wins, then it\\'s count has to 1 greater than \\'O\\' count\\n            if(isWin(board,\\'X\\') && xCount!=oCount+1){\\n                return false;\\n            }\\n            \\n            return true;                \\n        }\\n        return false;            \\n    }\\n    \\n    //Return true if char \\'c\\' wins, \\'c\\' can be either \\'O\\' or \\'X\\'\\n    boolean isWin(char[] board, char c){\\n        for(int i=0;i<8;i++){\\n            if(nBoard[win[i][0]]==c && nBoard[win[i][1]]==c && \\n               nBoard[win[i][2]]==c){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n//Credits : GeeksForGeeks(https://www.youtube.com/watch?v=RqOFx7Waehc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351950,
                "title": "simple-python-simple-conditions",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        SIZE = 3\\n        turns = 0\\n        rows, cols  = [0] * SIZE, [0] * SIZE\\n        diag1 = diag2 = 0\\n        for i in range(SIZE):\\n            for j in range(SIZE):\\n                if board[i][j] == \\'X\\':\\n                    turns += 1\\n                    rows[i] += 1\\n                    cols[j] += 1\\n                    if i == j:\\n                        diag1 += 1\\n                    if i + j == SIZE - 1:\\n                        diag2 += 1\\n                elif board[i][j] == \\'O\\':\\n                    turns -= 1\\n                    rows[i] -= 1\\n                    cols[j] -= 1\\n                    if i == j:\\n                        diag1 -= 1\\n                    if i + j == SIZE - 1:\\n                        diag2 -= 1\\n        \\n        wonX = (3 in rows) or (3 in cols) or diag1 == 3 or diag2 == 3\\n        wonO = (-3 in rows) or (-3 in cols) or diag1 == -3 or diag2 == -3\\n        \\n        if turns == 0 and not wonX or turns == 1 and not wonO:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        SIZE = 3\\n        turns = 0\\n        rows, cols  = [0] * SIZE, [0] * SIZE\\n        diag1 = diag2 = 0\\n        for i in range(SIZE):\\n            for j in range(SIZE):\\n                if board[i][j] == \\'X\\':\\n                    turns += 1\\n                    rows[i] += 1\\n                    cols[j] += 1\\n                    if i == j:\\n                        diag1 += 1\\n                    if i + j == SIZE - 1:\\n                        diag2 += 1\\n                elif board[i][j] == \\'O\\':\\n                    turns -= 1\\n                    rows[i] -= 1\\n                    cols[j] -= 1\\n                    if i == j:\\n                        diag1 -= 1\\n                    if i + j == SIZE - 1:\\n                        diag2 -= 1\\n        \\n        wonX = (3 in rows) or (3 in cols) or diag1 == 3 or diag2 == 3\\n        wonO = (-3 in rows) or (-3 in cols) or diag1 == -3 or diag2 == -3\\n        \\n        if turns == 0 and not wonX or turns == 1 and not wonO:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212768,
                "title": "python-o-1-concise-code",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        X, O = self.countBoard(board)\\n        if X - O not in {0, 1}:\\n            return False\\n        \\n        if self.checkBoard(board, \\'X\\') and X == O:\\n            return False\\n        if self.checkBoard(board, \\'O\\') and X - 1 == O:\\n            return False\\n        \\n        return True\\n        \\n    def checkBoard(self, board, player):\\n        for i in range(3):\\n            if board[i] == player * 3:\\n                return True\\n            if all(board[j][i] == player for j in range(3)):\\n                return True\\n        \\n        if player == board[1][1] == board[0][0] == board[2][2]:\\n            return True\\n        if player == board[1][1] == board[0][2] == board[2][0]:\\n            return True\\n            \\n    \\n    def countBoard(self, board):\\n        X, O = 0, 0\\n        for row in board:\\n            X += row.count(\\'X\\')\\n            O += row.count(\\'O\\')\\n        return X, O\\n        \\n        \\n        \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        X, O = self.countBoard(board)\\n        if X - O not in {0, 1}:\\n            return False\\n        \\n        if self.checkBoard(board, \\'X\\') and X == O:\\n            return False\\n        if self.checkBoard(board, \\'O\\') and X - 1 == O:\\n            return False\\n        \\n        return True\\n        \\n    def checkBoard(self, board, player):\\n        for i in range(3):\\n            if board[i] == player * 3:\\n                return True\\n            if all(board[j][i] == player for j in range(3)):\\n                return True\\n        \\n        if player == board[1][1] == board[0][0] == board[2][2]:\\n            return True\\n        if player == board[1][1] == board[0][2] == board[2][0]:\\n            return True\\n            \\n    \\n    def countBoard(self, board):\\n        X, O = 0, 0\\n        for row in board:\\n            X += row.count(\\'X\\')\\n            O += row.count(\\'O\\')\\n        return X, O\\n        \\n        \\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 124024,
                "title": "simple-rule-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int cntX = 0, cntO = 0, winX = 0, winO = 0; \\n        char[][] BD = new char[3][3];  \\n        for (int i = 0; i < 3; i++) \\n            for (int j = 0; j < 3; j++) { \\n                BD[i][j] = board[i].charAt(j); \\n                if (BD[i][j] == \\'X\\') cntX++;\\n                if (BD[i][j] == \\'O\\') cntO++;\\n            }\\n        \\n        if (cntX < cntO || cntX > cntO + 1) return false;\\n\\n        if ((BD[0][0] == BD[1][0] && BD[1][0] == BD[2][0]) || (BD[0][0] == BD[0][1] && BD[0][1] == BD[0][2]))\\n            if (BD[0][0] == \\'X\\') winX++; \\n            else if (BD[0][0] == \\'O\\') winO++; \\n\\n        if ((BD[0][2] == BD[1][2] && BD[1][2] == BD[2][2]) || (BD[2][0] == BD[2][1] && BD[2][1] == BD[2][2]))\\n            if (BD[2][2] == \\'X\\') winX++; \\n            else if (BD[2][2] == \\'O\\') winO++; \\n\\n        if ((BD[0][0] == BD[1][1] && BD[1][1] == BD[2][2]) || (BD[0][2] == BD[1][1] && BD[1][1] == BD[2][0]) ||\\n           (BD[0][1] == BD[1][1] && BD[1][1] == BD[2][1]) || (BD[1][0] == BD[1][1] && BD[1][1] == BD[1][2]))\\n            if (BD[1][1] == \\'X\\') winX++; \\n            else if (BD[1][1] == \\'O\\') winO++; \\n        \\n        return !((winX > 0 && winO > 0) || (cntX == cntO && winX > 0) || (cntX == cntO + 1 && winO > 0)) ;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int cntX = 0, cntO = 0, winX = 0, winO = 0; \\n        char[][] BD = new char[3][3];  \\n        for (int i = 0; i < 3; i++) \\n            for (int j = 0; j < 3; j++) { \\n                BD[i][j] = board[i].charAt(j); \\n                if (BD[i][j] == \\'X\\') cntX++;\\n                if (BD[i][j] == \\'O\\') cntO++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3468205,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) \\n    {\\n        int turn = 0, diag = 0, adg = 0, i, j;\\n        bool xwin = false, owin = false;\\n        vector<int> row(3), col(3);\\n        for(i = 0; i < 3; i ++)\\n        {\\n            for(j = 0; j < 3; j ++)\\n            {\\n                if(\\'X\\' == board[i][j])\\n                {\\n                    turn ++;\\n                    row[i] ++;\\n                    col[j] ++;\\n                    \\n                    if(i == j)\\n                    {\\n                        diag ++;\\n                    }\\n                    if(i + j == 2)\\n                    {\\n                        adg ++;\\n                    }\\n                }\\n                else if(\\'O\\' == board[i][j])\\n                {\\n                    turn --;\\n                    row[i] --;\\n                    col[j] --;\\n                    \\n                    if(i == j)\\n                    {\\n                        diag --;\\n                    }\\n                    if(i + j == 2)\\n                    {\\n                        adg --;\\n                    }\\n                }\\n            }\\n        }\\n        for(i = 0; i < 3; i ++)\\n        {\\n            if(3 == row[i] || 3 == col[i])\\n            {\\n                xwin = true;\\n            }\\n            if(-3 == row[i] || -3 == col[i])\\n            {\\n                owin = true;\\n            }\\n        }\\n        if(3 == diag || 3 == adg)\\n        {\\n            xwin = true;\\n        }\\n        if(-3 == diag || -3 == adg)\\n        {\\n            owin = true;\\n        }\\n        if(xwin && owin)\\n        {\\n            return false;\\n        }\\n        if(turn != 0 && turn != 1)\\n        {\\n            return false;\\n        }\\n        if((xwin && turn != 1) || (owin && turn != 0))\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        rows, cols, diag1, diag2 = [0]*3, [0]*3, 0, 0 \\n        o, x = 0, 0\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \"O\":\\n                    o+=1\\n                    rows[i]+=1\\n                    cols[j]+=1\\n                    if i == j:\\n                        diag1+=1\\n                    if i+j == 2:\\n                        diag2+=1\\n                if board[i][j] == \"X\":\\n                    x+=1\\n                    rows[i]-=1\\n                    cols[j]-=1\\n                    if i == j:\\n                        diag1-=1\\n                    if i+j == 2:\\n                        diag2-=1\\n        \\n        player1 = 3 in rows or 3 in cols or diag1 == 3 or diag2 == 3\\n        player2 = -3 in rows or -3 in cols or diag1 == -3 or diag2 == -3\\n        \\n        if o != x and x-o != 1: return False\\n        if player1 and player2: return False\\n        if player1: return o == x\\n        if player2: return x-o == 1\\n\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }\\n\\n        int n = board.length;\\n        int diag1 = 0;\\n        int diag2 = 0;\\n        int turnsDiff = 0;\\n        boolean xWin = false;\\n        boolean oWin = false;\\n        char c;\\n\\n        for (int i = 0; i < n; i++) {\\n            int row = 0;\\n            int col = 0;\\n            for (int j = 0; j < n; j++) {\\n                c = board[i].charAt(j);\\n                if (c == \\'X\\') {\\n                    row++;\\n                    turnsDiff++;\\n                } else if (c == \\'O\\') {\\n                    row--;\\n                    turnsDiff--;\\n                }\\n                c = board[j].charAt(i);\\n                if (c == \\'X\\') {\\n                    col++;\\n                } else if (c == \\'O\\') {\\n                    col--;\\n                }\\n            }\\n            c = board[i].charAt(i);\\n            if (c == \\'X\\') {\\n                diag1++;\\n            } else if (c == \\'O\\') {\\n                diag1--;\\n            }\\n            c = board[i].charAt(n - 1 - i);\\n            if (c == \\'X\\') {\\n                diag2++;\\n            } else if (c == \\'O\\') {\\n                diag2--;\\n            }\\n            if (row == n || col == n || diag1 == n || diag2 == n) {\\n                if (oWin) {\\n                    return false;\\n                }\\n                xWin = true;\\n            }\\n            if (row == -n || col == -n || diag1 == -n || diag2 == -n) {\\n                if (xWin) {\\n                    return false;\\n                }\\n                oWin = true;\\n            }\\n        }\\n        if (turnsDiff < 0 || turnsDiff > 1) {\\n            return false;\\n        }\\n        if ((turnsDiff == 0 && xWin) || (turnsDiff == 1 && oWin)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) \\n    {\\n        int turn = 0, diag = 0, adg = 0, i, j;\\n        bool xwin = false, owin = false;\\n        vector<int> row(3), col(3);\\n        for(i = 0; i < 3; i ++)\\n        {\\n            for(j = 0; j < 3; j ++)\\n            {\\n                if(\\'X\\' == board[i][j])\\n                {\\n                    turn ++;\\n                    row[i] ++;\\n                    col[j] ++;\\n                    \\n                    if(i == j)\\n                    {\\n                        diag ++;\\n                    }\\n                    if(i + j == 2)\\n                    {\\n                        adg ++;\\n                    }\\n                }\\n                else if(\\'O\\' == board[i][j])\\n                {\\n                    turn --;\\n                    row[i] --;\\n                    col[j] --;\\n                    \\n                    if(i == j)\\n                    {\\n                        diag --;\\n                    }\\n                    if(i + j == 2)\\n                    {\\n                        adg --;\\n                    }\\n                }\\n            }\\n        }\\n        for(i = 0; i < 3; i ++)\\n        {\\n            if(3 == row[i] || 3 == col[i])\\n            {\\n                xwin = true;\\n            }\\n            if(-3 == row[i] || -3 == col[i])\\n            {\\n                owin = true;\\n            }\\n        }\\n        if(3 == diag || 3 == adg)\\n        {\\n            xwin = true;\\n        }\\n        if(-3 == diag || -3 == adg)\\n        {\\n            owin = true;\\n        }\\n        if(xwin && owin)\\n        {\\n            return false;\\n        }\\n        if(turn != 0 && turn != 1)\\n        {\\n            return false;\\n        }\\n        if((xwin && turn != 1) || (owin && turn != 0))\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        rows, cols, diag1, diag2 = [0]*3, [0]*3, 0, 0 \\n        o, x = 0, 0\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \"O\":\\n                    o+=1\\n                    rows[i]+=1\\n                    cols[j]+=1\\n                    if i == j:\\n                        diag1+=1\\n                    if i+j == 2:\\n                        diag2+=1\\n                if board[i][j] == \"X\":\\n                    x+=1\\n                    rows[i]-=1\\n                    cols[j]-=1\\n                    if i == j:\\n                        diag1-=1\\n                    if i+j == 2:\\n                        diag2-=1\\n        \\n        player1 = 3 in rows or 3 in cols or diag1 == 3 or diag2 == 3\\n        player2 = -3 in rows or -3 in cols or diag1 == -3 or diag2 == -3\\n        \\n        if o != x and x-o != 1: return False\\n        if player1 and player2: return False\\n        if player1: return o == x\\n        if player2: return x-o == 1\\n\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        if (board == null || board.length == 0) {\\n            return false;\\n        }\\n\\n        int n = board.length;\\n        int diag1 = 0;\\n        int diag2 = 0;\\n        int turnsDiff = 0;\\n        boolean xWin = false;\\n        boolean oWin = false;\\n        char c;\\n\\n        for (int i = 0; i < n; i++) {\\n            int row = 0;\\n            int col = 0;\\n            for (int j = 0; j < n; j++) {\\n                c = board[i].charAt(j);\\n                if (c == \\'X\\') {\\n                    row++;\\n                    turnsDiff++;\\n                } else if (c == \\'O\\') {\\n                    row--;\\n                    turnsDiff--;\\n                }\\n                c = board[j].charAt(i);\\n                if (c == \\'X\\') {\\n                    col++;\\n                } else if (c == \\'O\\') {\\n                    col--;\\n                }\\n            }\\n            c = board[i].charAt(i);\\n            if (c == \\'X\\') {\\n                diag1++;\\n            } else if (c == \\'O\\') {\\n                diag1--;\\n            }\\n            c = board[i].charAt(n - 1 - i);\\n            if (c == \\'X\\') {\\n                diag2++;\\n            } else if (c == \\'O\\') {\\n                diag2--;\\n            }\\n            if (row == n || col == n || diag1 == n || diag2 == n) {\\n                if (oWin) {\\n                    return false;\\n                }\\n                xWin = true;\\n            }\\n            if (row == -n || col == -n || diag1 == -n || diag2 == -n) {\\n                if (xWin) {\\n                    return false;\\n                }\\n                oWin = true;\\n            }\\n        }\\n        if (turnsDiff < 0 || turnsDiff > 1) {\\n            return false;\\n        }\\n        if ((turnsDiff == 0 && xWin) || (turnsDiff == 1 && oWin)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206891,
                "title": "bug-in-the-testcase",
                "content": "Input\\n[\"XXX\",\\n\"OOX\",\\n\"OOX\"]\\n\\nOutput\\nfalse\\n\\nExpected --> The expected value should be \"false\", since this status cannot be reached in the real game.\\ntrue",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1935237,
                "title": "industry-code-clear-and-with-comments",
                "content": "```\\nfun validTicTacToe(board: Array<String>): Boolean {\\n\\n\\tfun countChars(c: Char) = board.map{it.filter{it == c}.count()}.sum()  // counts moves per player\\n\\t\\n\\tfun countRowWins(c: Char) = board.filter{it.filter{it == c}.count() == 3}.count()\\n\\tfun countColWins(c: Char) = board[0].indices.map{index -> board.map{it[index]}}.filter{it.filter{it == c}.count() == 3}.count()\\n\\tfun countDiagWins(c: Char) = board[0].indices.zip(board.indices).filter{board[it.first][it.second] == c}.count()/3\\n\\tfun countAntiDiagWins(c: Char) = board[0].indices.zip(board.indices.reversed()).filter{board[it.first][it.second] == c}.count()/3   \\n\\tfun countWins(c: Char) = countRowWins(c)+countColWins(c).also{println(it)}+countDiagWins(c)+countAntiDiagWins(c) // counts the wins for a player\\n\\n\\tval movesX = countChars(\\'X\\')\\n\\tval movesO = countChars(\\'O\\')\\n\\tval winsX = countWins(\\'X\\')\\n\\tval winsO = countWins(\\'O\\')\\n\\treturn when {\\n\\t\\tmovesX - movesO > 1 || movesX - movesO < 0 ->  false // player X must be at most 1 move ahead\\n\\t\\twinsX == 0 && winsO == 0 ->  true // noone won, that\\'s ok\\n\\t\\twinsX > 0 && winsO == 0 ->  movesX - movesO == 1 // if player X wins, he should have one move more than player O\\n\\t\\twinsX == 0 && winsO > 0 ->  movesX - movesO == 0 // if player O wins, both have an equal amount of moves\\n\\t\\telse -> false // both won\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun validTicTacToe(board: Array<String>): Boolean {\\n\\n\\tfun countChars(c: Char) = board.map{it.filter{it == c}.count()}.sum()  // counts moves per player\\n\\t\\n\\tfun countRowWins(c: Char) = board.filter{it.filter{it == c}.count() == 3}.count()\\n\\tfun countColWins(c: Char) = board[0].indices.map{index -> board.map{it[index]}}.filter{it.filter{it == c}.count() == 3}.count()\\n\\tfun countDiagWins(c: Char) = board[0].indices.zip(board.indices).filter{board[it.first][it.second] == c}.count()/3\\n\\tfun countAntiDiagWins(c: Char) = board[0].indices.zip(board.indices.reversed()).filter{board[it.first][it.second] == c}.count()/3   \\n\\tfun countWins(c: Char) = countRowWins(c)+countColWins(c).also{println(it)}+countDiagWins(c)+countAntiDiagWins(c) // counts the wins for a player\\n\\n\\tval movesX = countChars(\\'X\\')\\n\\tval movesO = countChars(\\'O\\')\\n\\tval winsX = countWins(\\'X\\')\\n\\tval winsO = countWins(\\'O\\')\\n\\treturn when {\\n\\t\\tmovesX - movesO > 1 || movesX - movesO < 0 ->  false // player X must be at most 1 move ahead\\n\\t\\twinsX == 0 && winsO == 0 ->  true // noone won, that\\'s ok\\n\\t\\twinsX > 0 && winsO == 0 ->  movesX - movesO == 1 // if player X wins, he should have one move more than player O\\n\\t\\twinsX == 0 && winsO > 0 ->  movesX - movesO == 0 // if player O wins, both have an equal amount of moves\\n\\t\\telse -> false // both won\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1798111,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic boolean didXWin(String[] board){\\n        for(String row : board)\\n            if(row.equals(\"XXX\"))\\n                return true;\\n        \\n        for(int i = 0; i < 3; i++)\\n            if(board[0].charAt(i) == \\'X\\' && board[1].charAt(i) == \\'X\\' && board[2].charAt(i) == \\'X\\')\\n                return true;\\n        \\n        if(board[0].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\')\\n            return true;\\n        \\n        if(board[0].charAt(2) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(0) == \\'X\\')\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean didOWin(String[] board){\\n        for(String row : board)\\n            if(row.equals(\"OOO\"))\\n                return true;\\n        \\n        for(int i = 0; i < 3; i++)\\n            if(board[0].charAt(i) == \\'O\\' && board[1].charAt(i) == \\'O\\' && board[2].charAt(i) == \\'O\\')\\n                return true;\\n        \\n        if(board[0].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\')\\n            return true;\\n        \\n        if(board[0].charAt(2) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(0) == \\'O\\')\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        int countX = 0, countO = 0;\\n        \\n        boolean didXWin = didXWin(board),\\n                didOWin = didOWin(board);\\n        \\n        if(didXWin && didOWin)\\n            return false;\\n        \\n        for(String row : board){\\n            for(char ch : row.toCharArray()){\\n                if(ch == \\'O\\')\\n                    countO++;\\n                else if(ch == \\'X\\')\\n                    countX++;\\n            }\\n        }\\n        \\n        if(didXWin){\\n            return countO == countX - 1;\\n        }\\n        \\n        if(didOWin){\\n            return countO == countX;\\n        }\\n        \\n        return countO == countX || countO == countX - 1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic boolean didXWin(String[] board){\\n        for(String row : board)\\n            if(row.equals(\"XXX\"))\\n                return true;\\n        \\n        for(int i = 0; i < 3; i++)\\n            if(board[0].charAt(i) == \\'X\\' && board[1].charAt(i) == \\'X\\' && board[2].charAt(i) == \\'X\\')\\n                return true;\\n        \\n        if(board[0].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\')\\n            return true;\\n        \\n        if(board[0].charAt(2) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(0) == \\'X\\')\\n            return true;\\n        \\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1618465,
                "title": "c-794-valid-tic-tac-toe-state",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int diff = 0; \\n        vector<int> freq(8); \\n        unordered_map<char, int> mp = {{\\'O\\', -1}, {\\' \\', 0}, {\\'X\\', 1}}; \\n        for (int i = 0; i < 3; ++i) \\n            for (int j = 0; j < 3; ++j) {\\n                int x = mp[board[i][j]]; \\n                diff += x; \\n                freq[i] += x; \\n                freq[j+3] += x; \\n                if (i == j) freq[6] += x; \\n                if (i+j == 2) freq[7] += x; \\n            }\\n        bool xwin = false, owin = false; \\n        if (find(freq.begin(), freq.end(), 3) != freq.end()) xwin = true; \\n        if (find(freq.begin(), freq.end(), -3) != freq.end()) owin = true; \\n        if ((xwin && owin) || (xwin && diff != 1) || (owin && diff != 0))  return false; \\n        return 0 <= diff && diff <= 1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int diff = 0; \\n        vector<int> freq(8); \\n        unordered_map<char, int> mp = {{\\'O\\', -1}, {\\' \\', 0}, {\\'X\\', 1}}; \\n        for (int i = 0; i < 3; ++i) \\n            for (int j = 0; j < 3; ++j) {\\n                int x = mp[board[i][j]]; \\n                diff += x; \\n                freq[i] += x; \\n                freq[j+3] += x; \\n                if (i == j) freq[6] += x; \\n                if (i+j == 2) freq[7] += x; \\n            }\\n        bool xwin = false, owin = false; \\n        if (find(freq.begin(), freq.end(), 3) != freq.end()) xwin = true; \\n        if (find(freq.begin(), freq.end(), -3) != freq.end()) owin = true; \\n        if ((xwin && owin) || (xwin && diff != 1) || (owin && diff != 0))  return false; \\n        return 0 <= diff && diff <= 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119359,
                "title": "straightforward-game-rules",
                "content": "-> Count X and O in the Whole Board.\\n-> Write a Function to check Status of Winner(if present)\\n-> Use Status to Check Finally the state of the Board.\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        row, col = len(board), len(board[0])\\n        xCount, oCount = 0, 0\\n        \\n        def checkStatusWinner(board):\\n            status = \\'\\'\\n            if board[0][2] == board[1][1] == board[2][0] !=\\' \\':\\n                status = board[0][2]\\n            elif board[0][0] == board[1][1] == board[2][2] !=\\' \\':\\n                status = board[0][0]\\n            elif board[0][0] == board[0][1] == board[0][2] !=\\' \\':\\n                status = board[0][0]\\n            elif board[0][2] == board[1][2] == board[2][2] !=\\' \\':\\n                status = board[0][2]\\n            elif board[2][2] == board[2][1] == board[2][0] !=\\' \\':\\n                status = board[2][2]\\n            elif board[2][0] == board[1][0] == board[0][0] !=\\' \\':\\n                status = board[2][0]\\n            elif board[0][1] == board[1][1] == board[2][1] !=\\' \\':\\n                status = board[0][1]\\n            \\n            return status\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j] == \\'X\\':\\n                    xCount += 1\\n                elif board[i][j] == \\'O\\':\\n                    oCount += 1\\n\\n        if xCount < oCount or oCount+1 < xCount:\\n            return False\\n        \\n        status = checkStatusWinner(board)\\n\\n        if status == \\'X\\':\\n            return xCount == oCount+1\\n        if status == \\'O\\':\\n            return xCount == oCount\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        row, col = len(board), len(board[0])\\n        xCount, oCount = 0, 0\\n        \\n        def checkStatusWinner(board):\\n            status = \\'\\'\\n            if board[0][2] == board[1][1] == board[2][0] !=\\' \\':\\n                status = board[0][2]\\n            elif board[0][0] == board[1][1] == board[2][2] !=\\' \\':\\n                status = board[0][0]\\n            elif board[0][0] == board[0][1] == board[0][2] !=\\' \\':\\n                status = board[0][0]\\n            elif board[0][2] == board[1][2] == board[2][2] !=\\' \\':\\n                status = board[0][2]\\n            elif board[2][2] == board[2][1] == board[2][0] !=\\' \\':\\n                status = board[2][2]\\n            elif board[2][0] == board[1][0] == board[0][0] !=\\' \\':\\n                status = board[2][0]\\n            elif board[0][1] == board[1][1] == board[2][1] !=\\' \\':\\n                status = board[0][1]\\n            \\n            return status\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j] == \\'X\\':\\n                    xCount += 1\\n                elif board[i][j] == \\'O\\':\\n                    oCount += 1\\n\\n        if xCount < oCount or oCount+1 < xCount:\\n            return False\\n        \\n        status = checkStatusWinner(board)\\n\\n        if status == \\'X\\':\\n            return xCount == oCount+1\\n        if status == \\'O\\':\\n            return xCount == oCount\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106836,
                "title": "java-simple-and-easy-to-understand-solution-o-1-0-ms-faster-than-100-00",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] counts = getCounts(board);\\n        \\n        int xCount = counts[0];\\n        int oCount = counts[1];\\n        \\n        //X count must be equal to O count/ O count + 1\\n        if(!(xCount == oCount || xCount == oCount + 1)) return false;\\n        \\n        //when X is winner, then X count must equal to O count + 1\\n        //if not retunr false\\n        if(isWinner(board, \\'X\\') && xCount != oCount + 1) return false;\\n        \\n        //when O is winner, then X count must equal to O count\\n        if(isWinner(board, \\'O\\') && xCount != oCount) return false;\\n        \\n        return true;\\n    }\\n    \\n    private boolean isWinner(String[] board, char c){\\n        \\n        //horizonal\\n        for(int i = 0; i < 3; i++){\\n            if(board[i].charAt(0) == c && board[i].charAt(1) == c  && board[i].charAt(2) == c) \\n                return true;\\n        }\\n        \\n        //Vertical\\n        for(int i = 0; i < 3; i++){\\n            if(board[0].charAt(i) == c && board[1].charAt(i) == c  && board[2].charAt(i) == c) \\n                return true;\\n        }\\n        \\n        //doagonal\\n        if(board[0].charAt(0) == c && board[1].charAt(1) == c  && board[2].charAt(2) == c) \\n                return true;\\n         \\n        //anti diagonal\\n        if(board[0].charAt(2) == c && board[1].charAt(1) == c  && board[2].charAt(0) == c) \\n                return true;\\n        \\n        return false;\\n        \\n    }\\n    \\n    private int[] getCounts(String[] board){\\n        int x = 0; // X count\\n        int o = 0; // Y Count \\n        \\n        for(int i = 0; i < 3; i++){\\n            \\n            for(int j = 0; j < 3; j++){\\n                char c = board[i].charAt(j);\\n                if(c == \\'X\\'){\\n                    x++;\\n                }else if(c == \\'O\\'){\\n                    o++;\\n                }\\n            }\\n        }\\n        \\n        return new int[]{x, o};\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] counts = getCounts(board);\\n        \\n        int xCount = counts[0];\\n        int oCount = counts[1];\\n        \\n        //X count must be equal to O count/ O count + 1\\n        if(!(xCount == oCount || xCount == oCount + 1)) return false;\\n        \\n        //when X is winner, then X count must equal to O count + 1\\n        //if not retunr false\\n        if(isWinner(board, \\'X\\') && xCount != oCount + 1) return false;\\n        \\n        //when O is winner, then X count must equal to O count\\n        if(isWinner(board, \\'O\\') && xCount != oCount) return false;\\n        \\n        return true;\\n    }\\n    \\n    private boolean isWinner(String[] board, char c){\\n        \\n        //horizonal\\n        for(int i = 0; i < 3; i++){\\n            if(board[i].charAt(0) == c && board[i].charAt(1) == c  && board[i].charAt(2) == c) \\n                return true;\\n        }\\n        \\n        //Vertical\\n        for(int i = 0; i < 3; i++){\\n            if(board[0].charAt(i) == c && board[1].charAt(i) == c  && board[2].charAt(i) == c) \\n                return true;\\n        }\\n        \\n        //doagonal\\n        if(board[0].charAt(0) == c && board[1].charAt(1) == c  && board[2].charAt(2) == c) \\n                return true;\\n         \\n        //anti diagonal\\n        if(board[0].charAt(2) == c && board[1].charAt(1) == c  && board[2].charAt(0) == c) \\n                return true;\\n        \\n        return false;\\n        \\n    }\\n    \\n    private int[] getCounts(String[] board){\\n        int x = 0; // X count\\n        int o = 0; // Y Count \\n        \\n        for(int i = 0; i < 3; i++){\\n            \\n            for(int j = 0; j < 3; j++){\\n                char c = board[i].charAt(j);\\n                if(c == \\'X\\'){\\n                    x++;\\n                }else if(c == \\'O\\'){\\n                    o++;\\n                }\\n            }\\n        }\\n        \\n        return new int[]{x, o};\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912369,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int turns =0;\\n        int[] cols=new int[3];\\n        int[] rows=new int[3];\\n        int diag=0;\\n        int antidiag=0;\\n        boolean xwins=false;\\n        boolean owins=false;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[i].charAt(j)==\\'X\\')\\n                {\\n                    cols[j]++;\\n                    turns++;\\n                    rows[i]++;\\n                    if(i == j)\\n                        diag++;\\n                    if(i+j == 2)\\n                        antidiag++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\')\\n                {\\n                    cols[j]--;\\n                    turns--;\\n                    rows[i]--;\\n                    if(i == j)\\n                        diag--;\\n                    if(i+j == 2)\\n                        antidiag--;\\n                }\\n            }\\n        }\\n        xwins= (cols[0] == 3 || cols[1] == 3 || cols[2] == 3 ||\\n                  rows[0] == 3 || rows[1] == 3 || rows[2] == 3 || diag == 3 ||\\n                  antidiag == 3)? true:false;\\n        owins= (cols[0] == -3 || cols[1] == -3 || cols[2] == -3 ||\\n                  rows[0] == -3 || rows[1] == -3 || rows[2] == -3 || diag == -3 ||\\n                  antidiag == -3)? true:false;\\n        if(xwins && owins)\\n            return false;\\n        if(xwins && turns == 0 || owins && turns == 1)\\n            return false;\\n        return (turns == 1 || turns == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int turns =0;\\n        int[] cols=new int[3];\\n        int[] rows=new int[3];\\n        int diag=0;\\n        int antidiag=0;\\n        boolean xwins=false;\\n        boolean owins=false;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[i].charAt(j)==\\'X\\')\\n                {\\n                    cols[j]++;\\n                    turns++;\\n                    rows[i]++;\\n                    if(i == j)\\n                        diag++;\\n                    if(i+j == 2)\\n                        antidiag++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\')\\n                {\\n                    cols[j]--;\\n                    turns--;\\n                    rows[i]--;\\n                    if(i == j)\\n                        diag--;\\n                    if(i+j == 2)\\n                        antidiag--;\\n                }\\n            }\\n        }\\n        xwins= (cols[0] == 3 || cols[1] == 3 || cols[2] == 3 ||\\n                  rows[0] == 3 || rows[1] == 3 || rows[2] == 3 || diag == 3 ||\\n                  antidiag == 3)? true:false;\\n        owins= (cols[0] == -3 || cols[1] == -3 || cols[2] == -3 ||\\n                  rows[0] == -3 || rows[1] == -3 || rows[2] == -3 || diag == -3 ||\\n                  antidiag == -3)? true:false;\\n        if(xwins && owins)\\n            return false;\\n        if(xwins && turns == 0 || owins && turns == 1)\\n            return false;\\n        return (turns == 1 || turns == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731386,
                "title": "c-clean-easy-to-read-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int xCount = 0, oCount = 0;\\n        \\n        for (auto row : board)\\n            for (auto ch : row)\\n                if (ch != \\' \\')\\n                    ch == \\'X\\' ? xCount++ : oCount++;\\n        \\n        if (oCount > xCount or xCount - oCount > 1)\\n            return false;\\n        \\n        if (xCount >= 3)\\n            if (playerWins(board, \\'X\\') and xCount - 1 != oCount)\\n                return false;\\n        \\n        if (oCount >= 3)\\n            if (playerWins(board, \\'O\\') and oCount != xCount)\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    bool playerWins(vector<string>& board, char ch) {\\n        // check row wise\\n        for (int i = 0; i < 3; i++)\\n            if (board[i][0] == ch and board[i][1] == ch and board[i][2] == ch)\\n                return true;\\n        \\n        // check column wise\\n        for (int i = 0; i < 3; i++)\\n            if (board[0][i] == ch and board[1][i] == ch and board[2][i] == ch)\\n                return true;\\n        \\n        // check diagnal\\n        if (board[0][0] == ch and board[1][1] == ch and board[2][2] == ch)\\n            return true;\\n            \\n        // check anti-diagnal\\n        if (board[0][2] == ch and board[1][1] == ch and board[2][0] == ch)\\n            return true;            \\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int xCount = 0, oCount = 0;\\n        \\n        for (auto row : board)\\n            for (auto ch : row)\\n                if (ch != \\' \\')\\n                    ch == \\'X\\' ? xCount++ : oCount++;\\n        \\n        if (oCount > xCount or xCount - oCount > 1)\\n            return false;\\n        \\n        if (xCount >= 3)\\n            if (playerWins(board, \\'X\\') and xCount - 1 != oCount)\\n                return false;\\n        \\n        if (oCount >= 3)\\n            if (playerWins(board, \\'O\\') and oCount != xCount)\\n                return false;\\n        \\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 706810,
                "title": "python3-super-readable-solution-valid-tic-tac-toe-state",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def wins(c: str) -> bool:\\n            cols = map(lambda x:\\'\\'.join(x), zip(*board))\\n            diags = map(lambda x:\\'\\'.join(x),\\n                        ((board[i][i] for i in range(3)),\\n                         (board[i][-i-1] for i in range(3))))\\n            return any(row == c * 3 for row in itertools.chain.from_iterable((board, cols, diags)))\\n        \\n        Xwins = wins(\\'X\\')\\n        Owins = wins(\\'O\\')\\n        \\n        if Xwins and Owins:\\n            return False\\n        \\n        countX = sum(row.count(\\'X\\') for row in board)\\n        countO = sum(row.count(\\'O\\') for row in board)\\n        \\n        if not Xwins and not Owins:\\n            return countX == countO or countX == countO + 1\\n        if Xwins:\\n            return countX == countO + 1\\n        return countX == countO\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def wins(c: str) -> bool:\\n            cols = map(lambda x:\\'\\'.join(x), zip(*board))\\n            diags = map(lambda x:\\'\\'.join(x),\\n                        ((board[i][i] for i in range(3)),\\n                         (board[i][-i-1] for i in range(3))))\\n            return any(row == c * 3 for row in itertools.chain.from_iterable((board, cols, diags)))\\n        \\n        Xwins = wins(\\'X\\')\\n        Owins = wins(\\'O\\')\\n        \\n        if Xwins and Owins:\\n            return False\\n        \\n        countX = sum(row.count(\\'X\\') for row in board)\\n        countO = sum(row.count(\\'O\\') for row in board)\\n        \\n        if not Xwins and not Owins:\\n            return countX == countO or countX == countO + 1\\n        if Xwins:\\n            return countX == countO + 1\\n        return countX == countO\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560202,
                "title": "java-beat-100",
                "content": "```\\nclass Solution {\\n    char[][] bd;\\n    int xc, oc;\\n    public boolean validTicTacToe(String[] board) {\\n        bd = parse(board);\\n        xc = count(\\'X\\');\\n        oc = count(\\'O\\');\\n        if (xc < oc || xc > oc + 1) return false;\\n        boolean xw = win(\\'X\\'), ow = win(\\'O\\');\\n        if(xw && ow) return false;\\n        if (xw && xc == oc) return false;\\n        if (ow && xc == oc + 1) return false;\\n        return true;\\n    }\\n    \\n    private char[][] parse(String[] board) {\\n        char[][] res = new char[3][3];\\n        for (int i = 0; i < 3; i++) {\\n            String str = board[i];\\n            for (int j = 0; j < 3; j++) {\\n                res[i][j] = str.charAt(j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int count(char c) {\\n        int res = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (bd[i][j] == c) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean win(char c) {\\n        return winRow(c) || winCol(c) || winDiag(c, 1) || winDiag(c, -1);\\n    }\\n    \\n    private boolean winRow(char c) {\\n        for (int i = 0; i < 3; i++) {\\n            boolean res = true;\\n            for (int j = 0; j < 3; j++) {\\n                if (bd[i][j] != c) {\\n                    res = false;\\n                    break;\\n                }\\n            }\\n            if (res) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean winCol(char c) {\\n        for (int i = 0; i < 3; i++) {\\n            boolean res = true;\\n            for (int j = 0; j < 3; j++) {\\n                if (bd[j][i] != c) {\\n                    res = false;\\n                    break;\\n                }\\n            }\\n            if (res) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean winDiag(char c, int dir) {\\n        int j = dir == 1 ? 0 : 2;\\n        for (int i = 0; i < 3; i++, j += dir){\\n            if (bd[i][j] != c) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nRef: https://leetcode.com/problems/valid-tic-tac-toe-state/discuss/318887/Java-faster-than-100-Memory-9966",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] bd;\\n    int xc, oc;\\n    public boolean validTicTacToe(String[] board) {\\n        bd = parse(board);\\n        xc = count(\\'X\\');\\n        oc = count(\\'O\\');\\n        if (xc < oc || xc > oc + 1) return false;\\n        boolean xw = win(\\'X\\'), ow = win(\\'O\\');\\n        if(xw && ow) return false;\\n        if (xw && xc == oc) return false;\\n        if (ow && xc == oc + 1) return false;\\n        return true;\\n    }\\n    \\n    private char[][] parse(String[] board) {\\n        char[][] res = new char[3][3];\\n        for (int i = 0; i < 3; i++) {\\n            String str = board[i];\\n            for (int j = 0; j < 3; j++) {\\n                res[i][j] = str.charAt(j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int count(char c) {\\n        int res = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (bd[i][j] == c) res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean win(char c) {\\n        return winRow(c) || winCol(c) || winDiag(c, 1) || winDiag(c, -1);\\n    }\\n    \\n    private boolean winRow(char c) {\\n        for (int i = 0; i < 3; i++) {\\n            boolean res = true;\\n            for (int j = 0; j < 3; j++) {\\n                if (bd[i][j] != c) {\\n                    res = false;\\n                    break;\\n                }\\n            }\\n            if (res) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean winCol(char c) {\\n        for (int i = 0; i < 3; i++) {\\n            boolean res = true;\\n            for (int j = 0; j < 3; j++) {\\n                if (bd[j][i] != c) {\\n                    res = false;\\n                    break;\\n                }\\n            }\\n            if (res) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean winDiag(char c, int dir) {\\n        int j = dir == 1 ? 0 : 2;\\n        for (int i = 0; i < 3; i++, j += dir){\\n            if (bd[i][j] != c) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451560,
                "title": "python-compute-all-of-them",
                "content": "emulate a game starting from empty board, \\n\\n1. at each round, put an x where we can (or a o if its o\\'s turn)\\n2. avoid cycle and keep track of where we have been in a hashset **vis**\\n3. hash the board a list of string into the unique string concatenated ```[\\'oxo\\' , \\'   \\', \\' ox\\']``` is represented by ```\\'oxo\\' +\\'   \\'+ \\' ox\\'```\\n4. stop recursing (dfsing) if someone won\\n5. final answer : original board in vis\\n7. upper bound is a **3 ^ 9 == 19683** (3 options for each of the 9 cells)\\n6. compute the hashset once and do a lookup once its been computed\\n\\npseudo code\\n```\\nvis = set([])\\n\\ndfs(u, b):\\n\\tb is a bool that tells me whos turn it is\\n\\tif won(u):\\n\\t\\tif someone won return\\n\\tfor v in adj[u]:\\n\\t\\tif v not in vis:\\n\\t\\t\\tvis.add(v)\\n\\t\\t\\tdfs(v, not(b))\\n```\\ncode\\n\\nvis is global to be reused accross test cases\\n\\n```\\nvis = set([])\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        if not(vis):\\n            vis.add(\\' \\'* 9)\\n            self.dfs(\\' \\' * 9, True)\\n        return reduce(lambda x,y: x+y, board) in vis\\n    \\n    def dfs(self, u, b):\\n        if self.won(u, (\\'O\\' if b else \\'X\\')): \\n            return\\n        for v in [u[:i] + (\\'X\\' if b else \\'O\\') + u[i+1:] for i in range(len(u)) if u[i] == \\' \\']:\\n            if v not in vis:\\n                vis.add(v)\\n                self.dfs(v, not(b))\\n    \\n    def won(self, s, letter):\\n        if s[0] + s[1] + s[2] == letter * 3: return True\\n        if s[3] + s[4] + s[5] == letter * 3: return True\\n        if s[6] + s[7] + s[8] == letter * 3: return True\\n        \\n        if s[2] + s[5] + s[8] == letter * 3: return True\\n        if s[1] + s[4] + s[7] == letter * 3: return True\\n        if s[0] + s[3] + s[6] == letter * 3: return True\\n        \\n        if s[0] + s[4] + s[8] == letter * 3: return True\\n        if s[2] + s[4] + s[6] == letter * 3: return True\\n        return False\\n        \\n```\\n\\n1. 5478 different boards out of 3 ^ 9 (about 1/4)\\n1. once computed its the cost of a lookup in a (small) hashset: O(1) amortized\\n1. or even a the cost of binary searching a  sorted list if I sort the possible boards within a list: ( log(5000) wihich is about 13)\\n\\n\\nkind of a fun way (relatively fun but not as fun as the masked singer damn the last episode was so good with vic oladipo, what a singer)\\n\\n\\nother wise, count the x\\'s , count the o\\'s \\nand consider all cases \\n1. either x won \\n1. either draw\\n1. either o won \\n\\n```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        cc = collections.Counter([e for l in board for e in l])        \\n        if cc[\\'O\\'] not in set([cc[\\'X\\'],cc[\\'X\\']-1]): return False\\n        state= (self.f(board,\\'X\\'), self.f(board,\\'O\\'))\\n        if state[0] > state[1]: return cc[\\'X\\'] == cc[\\'O\\'] + 1\\n        elif state[0] == state[1]: return state == (0,0)\\n        elif state[0] < state[1]: return cc[\\'X\\'] == cc[\\'O\\']\\n            \\n    def f(self, board, letter):\\n        target = [letter] * 3\\n        count = 0\\n        for l in board:\\n            l = list(l)\\n            if l == target: count += 1\\n        for c in range(3):\\n            l = [board[i][c] for i in range(3)]\\n            if l == target: count += 1\\n                \\n        l = [board[0][0], board[1][1], board[2][2]]\\n        if l == target: count += 1\\n        l = [board[0][2], board[1][1], board[2][0]]\\n        if l == target: count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```[\\'oxo\\' , \\'   \\', \\' ox\\']```\n```\\'oxo\\' +\\'   \\'+ \\' ox\\'```\n```\\nvis = set([])\\n\\ndfs(u, b):\\n\\tb is a bool that tells me whos turn it is\\n\\tif won(u):\\n\\t\\tif someone won return\\n\\tfor v in adj[u]:\\n\\t\\tif v not in vis:\\n\\t\\t\\tvis.add(v)\\n\\t\\t\\tdfs(v, not(b))\\n```\n```\\nvis = set([])\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        if not(vis):\\n            vis.add(\\' \\'* 9)\\n            self.dfs(\\' \\' * 9, True)\\n        return reduce(lambda x,y: x+y, board) in vis\\n    \\n    def dfs(self, u, b):\\n        if self.won(u, (\\'O\\' if b else \\'X\\')): \\n            return\\n        for v in [u[:i] + (\\'X\\' if b else \\'O\\') + u[i+1:] for i in range(len(u)) if u[i] == \\' \\']:\\n            if v not in vis:\\n                vis.add(v)\\n                self.dfs(v, not(b))\\n    \\n    def won(self, s, letter):\\n        if s[0] + s[1] + s[2] == letter * 3: return True\\n        if s[3] + s[4] + s[5] == letter * 3: return True\\n        if s[6] + s[7] + s[8] == letter * 3: return True\\n        \\n        if s[2] + s[5] + s[8] == letter * 3: return True\\n        if s[1] + s[4] + s[7] == letter * 3: return True\\n        if s[0] + s[3] + s[6] == letter * 3: return True\\n        \\n        if s[0] + s[4] + s[8] == letter * 3: return True\\n        if s[2] + s[4] + s[6] == letter * 3: return True\\n        return False\\n        \\n```\n```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        cc = collections.Counter([e for l in board for e in l])        \\n        if cc[\\'O\\'] not in set([cc[\\'X\\'],cc[\\'X\\']-1]): return False\\n        state= (self.f(board,\\'X\\'), self.f(board,\\'O\\'))\\n        if state[0] > state[1]: return cc[\\'X\\'] == cc[\\'O\\'] + 1\\n        elif state[0] == state[1]: return state == (0,0)\\n        elif state[0] < state[1]: return cc[\\'X\\'] == cc[\\'O\\']\\n            \\n    def f(self, board, letter):\\n        target = [letter] * 3\\n        count = 0\\n        for l in board:\\n            l = list(l)\\n            if l == target: count += 1\\n        for c in range(3):\\n            l = [board[i][c] for i in range(3)]\\n            if l == target: count += 1\\n                \\n        l = [board[0][0], board[1][1], board[2][2]]\\n        if l == target: count += 1\\n        l = [board[0][2], board[1][1], board[2][0]]\\n        if l == target: count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417694,
                "title": "long-but-modularized-easy-to-understand-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Valid Tic-Tac-Toe State.\\nMemory Usage: 8.3 MB, less than 40.00% of C++ online submissions for Valid Tic-Tac-Toe State.\\n\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        \\n        int noOs = 0;\\n        int noXs = 0;\\n        \\n        bool flagX = false;\\n        bool flagO = false;\\n        \\n        for(int i=0; i<board.size(); i++)\\n        {\\n            if(checkRow(board[i]))\\n            {\\n                if(board[i][0] == \\'X\\')\\n                {\\n                    if(flagO) return false;\\n                    flagX = true;\\n                }\\n                \\n                if(board[i][0] == \\'O\\')\\n                {\\n                    if(flagX) return false;\\n                    flagO = true;\\n                }\\n            }\\n            \\n            if(checkCol(board,i))\\n            {\\n                if(board[0][i] == \\'X\\')\\n                {\\n                    if(flagO) return false;\\n                    flagX = true;\\n                }\\n                \\n                if(board[0][i] == \\'O\\')\\n                {\\n                    if(flagX) return false;\\n                    flagO = true;\\n                }\\n            }\\n            \\n            for(char ch : board[i])\\n            {\\n                if(ch == \\'O\\')\\n                    noOs++;\\n                else if(ch == \\'X\\')\\n                    noXs++;\\n            }\\n        }\\n        \\n        if(checkDiagPrim(board))\\n        {\\n            if(board[0][0] == \\'X\\')\\n            {\\n                if(flagO) return false;\\n                flagX = true;\\n            }\\n                \\n            if(board[0][0] == \\'O\\')\\n            {\\n                if(flagX) return false;\\n                flagO = true;\\n            }\\n        }\\n        \\n        if(checkDiagSec(board))\\n        {\\n            if(board[0][2] == \\'X\\')\\n            {\\n                if(flagO) return false;\\n                flagX = true;\\n            }\\n                \\n            if(board[0][2] == \\'O\\')\\n            {\\n                if(flagX) return false;\\n                flagO = true;\\n            }\\n        }\\n        \\n        if(noOs > noXs || (noXs-noOs > 1))\\n            return false;\\n        if(flagX && (noXs <= noOs))\\n            return false;\\n        if(flagO && (noXs != noOs))\\n            return false;\\n        \\n        if(flagX && flagO)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool checkRow(string s)\\n    {\\n        char check = s[0];\\n        for(char ch : s)\\n            if(ch == \\' \\' || ch != check)\\n                return false;\\n        return true;\\n    }\\n    \\n    bool checkCol(vector<string>& board, int i)\\n    {\\n        int r = board.size();\\n        char check = board[0][i];\\n        \\n        for(int j=0; j<r; j++)\\n            if(board[j][i] == \\' \\' || board[j][i] != check)\\n                return false;\\n        return true;\\n    }\\n    \\n    bool checkDiagPrim(vector<string>& board)\\n    {\\n        char check = board[0][0];\\n        int r = board.size();\\n        \\n        for(int i=0; i<r; i++)\\n            if(board[i][i] == \\' \\' || board[i][i] != check)\\n                return false;\\n        return true;\\n    }\\n    \\n    bool checkDiagSec(vector<string>& board)\\n    {\\n        char check = board[0][2];\\n        int r = board.size()-1;\\n        for(int i=0; i<=r; i++)\\n            if(board[i][r-i] == \\' \\' || board[i][r-i] != check)\\n                return false;\\n        \\n        return true;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        \\n        int noOs = 0;\\n        int noXs = 0;\\n        \\n        bool flagX = false;\\n        bool flagO = false;\\n        \\n        for(int i=0; i<board.size(); i++)\\n        {\\n            if(checkRow(board[i]))\\n            {\\n                if(board[i][0] == \\'X\\')\\n                {\\n                    if(flagO) return false;\\n                    flagX = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 412188,
                "title": "simple-java-solution-100",
                "content": "```\\n    public boolean validTicTacToe(String[] board) {\\n      char[][] matrix = new char[3][3];\\n      matrix[0] = board[0].toCharArray();\\n      matrix[1] = board[1].toCharArray();\\n      matrix[2] = board[2].toCharArray();\\n      \\n      int cntX = 0, cntO = 0;\\n      for (char[] row : matrix) {\\n        for (char c : row) {\\n          if (c == \\'X\\') cntX++;\\n          if (c == \\'O\\') cntO++;\\n        }\\n      }\\n      if (cntO > cntX || cntX - cntO > 1) return false;\\n      if (cntO == cntX && hasSuccess(matrix, \\'X\\')) return false;\\n      if (cntX - cntO == 1 && hasSuccess(matrix, \\'O\\')) return false;\\n      \\n      return true;\\n    }\\n  \\n    private boolean hasSuccess(char[][] matrix, char c) {\\n      for (int row = 0; row < 3; ++row) {\\n        if (matrix[row][0] == c && matrix[row][1] == c && matrix[row][2] == c) {\\n          return true;\\n        }\\n      }\\n      for (int col = 0; col < 3; ++col) {\\n        if (matrix[0][col] == c && matrix[1][col] == c && matrix[2][col] == c) {\\n          return true;\\n        }\\n      }\\n      if (matrix[0][2] == c && matrix[1][1] == c && matrix[2][0] == c) {\\n        return true;\\n      }\\n      if (matrix[0][0] == c && matrix[1][1] == c && matrix[2][2] == c) {\\n        return true;\\n      }\\n      return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean validTicTacToe(String[] board) {\\n      char[][] matrix = new char[3][3];\\n      matrix[0] = board[0].toCharArray();\\n      matrix[1] = board[1].toCharArray();\\n      matrix[2] = board[2].toCharArray();\\n      \\n      int cntX = 0, cntO = 0;\\n      for (char[] row : matrix) {\\n        for (char c : row) {\\n          if (c == \\'X\\') cntX++;\\n          if (c == \\'O\\') cntO++;\\n        }\\n      }\\n      if (cntO > cntX || cntX - cntO > 1) return false;\\n      if (cntO == cntX && hasSuccess(matrix, \\'X\\')) return false;\\n      if (cntX - cntO == 1 && hasSuccess(matrix, \\'O\\')) return false;\\n      \\n      return true;\\n    }\\n  \\n    private boolean hasSuccess(char[][] matrix, char c) {\\n      for (int row = 0; row < 3; ++row) {\\n        if (matrix[row][0] == c && matrix[row][1] == c && matrix[row][2] == c) {\\n          return true;\\n        }\\n      }\\n      for (int col = 0; col < 3; ++col) {\\n        if (matrix[0][col] == c && matrix[1][col] == c && matrix[2][col] == c) {\\n          return true;\\n        }\\n      }\\n      if (matrix[0][2] == c && matrix[1][1] == c && matrix[2][0] == c) {\\n        return true;\\n      }\\n      if (matrix[0][0] == c && matrix[1][1] == c && matrix[2][2] == c) {\\n        return true;\\n      }\\n      return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306501,
                "title": "javascript-100",
                "content": "```\\nvar validTicTacToe = function(board) {\\n\\n    let count = 0,\\n        rows = new Array(3).fill(0),\\n        cols = new Array(3).fill(0),\\n        l = 0,\\n        r = 0,\\n        curr;\\n    for(let i = 0; i < 3; i ++) {\\n        for(let j = 0; j < 3; j ++) {\\n           curr = board[i][j];\\n            if(curr === \\'X\\') {\\n                count ++;\\n                rows[i] ++;\\n                cols[j] ++;\\n                if(i === j ) l ++;\\n                if(i + j === 2) r ++;\\n            } else if (curr === \\'O\\') {\\n                count --;\\n                rows[i] --;\\n                cols[j] --;\\n                if(i === j) l --;\\n                if(i + j === 2) r --;\\n            }\\n        }\\n    }\\n    if (count < 0 || count > 1) return false;\\n    const xWin = rows.some(x => x === 3) || cols.some(x => x=== 3) || l === 3 || r === 3;\\n    const oWin = rows.some(x => x === -3) || cols.some(x => x=== -3) || l === -3 || r === -3;\\n    if(xWin && oWin) {\\n        return false;\\n    } \\n    if( xWin && count === 0) {\\n        return false;\\n    } \\n    if(oWin && count === 1) {\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar validTicTacToe = function(board) {\\n\\n    let count = 0,\\n        rows = new Array(3).fill(0),\\n        cols = new Array(3).fill(0),\\n        l = 0,\\n        r = 0,\\n        curr;\\n    for(let i = 0; i < 3; i ++) {\\n        for(let j = 0; j < 3; j ++) {\\n           curr = board[i][j];\\n            if(curr === \\'X\\') {\\n                count ++;\\n                rows[i] ++;\\n                cols[j] ++;\\n                if(i === j ) l ++;\\n                if(i + j === 2) r ++;\\n            } else if (curr === \\'O\\') {\\n                count --;\\n                rows[i] --;\\n                cols[j] --;\\n                if(i === j) l --;\\n                if(i + j === 2) r --;\\n            }\\n        }\\n    }\\n    if (count < 0 || count > 1) return false;\\n    const xWin = rows.some(x => x === 3) || cols.some(x => x=== 3) || l === 3 || r === 3;\\n    const oWin = rows.some(x => x === -3) || cols.some(x => x=== -3) || l === -3 || r === -3;\\n    if(xWin && oWin) {\\n        return false;\\n    } \\n    if( xWin && count === 0) {\\n        return false;\\n    } \\n    if(oWin && count === 1) {\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117596,
                "title": "c-intuitive-solution",
                "content": "The solution calculates the difference in number of X's and O's, and if either player has won. This is then used to check if:\n* The pieces are imbalanced (X plays first, so difference of X's - O's must be 1 or 0)\n* Both players have won (not possible)\n* X has won but O played another piece: the piece difference should be 0\n* O has won but X played another piece: the piece difference should be 1\n\nIf none of the above conditions happen, the board is valid.\n\n```\nclass Solution {\nprivate:\n    int boardCount(vector<string>& board, char piece) {\n        int count = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                count += (board[i][j] == piece);\n            }\n        }\n        return count;\n    }\n    \n    bool hasWin(vector<string>& board, char piece) {\n        // row matches\n        if (board[0][0] == piece && board[0][0] == board[0][1] && board[0][1] == board[0][2]) return true;\n        if (board[1][0] == piece && board[1][0] == board[1][1] && board[1][1] == board[1][2]) return true;\n        if (board[2][0] == piece && board[2][0] == board[2][1] && board[2][1] == board[2][2]) return true;\n        // column matches\n        if (board[0][0] == piece && board[0][0] == board[1][0] && board[1][0] == board[2][0]) return true;\n        if (board[0][1] == piece && board[0][1] == board[1][1] && board[1][1] == board[2][1]) return true;\n        if (board[0][2] == piece && board[0][2] == board[1][2] && board[1][2] == board[2][2]) return true;\n        // diagonals\n        if (board[0][0] == piece && board[0][0] == board[1][1] && board[1][1] == board[2][2]) return true;\n        if (board[0][2] == piece && board[0][2] == board[1][1] && board[1][1] == board[2][0]) return true;\n        return false;\n    }\n    \npublic:\n    bool validTicTacToe(vector<string>& board) {\n        int diff = boardCount(board, 'X') - boardCount(board, 'O');\n        bool xWins = hasWin(board, 'X'), oWins = hasWin(board, 'O');\n        if (diff != 1 && diff != 0)\n            return false;\n        if (xWins && oWins)\n            return false;\n        if (xWins && diff != 1)\n            return false;\n        if (oWins && diff != 0)\n            return false;\n        return true;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\nprivate:\n    int boardCount(vector<string>& board, char piece) {\n        int count = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                count += (board[i][j] == piece);\n            }\n        }\n        return count;\n    }\n    \n    bool hasWin(vector<string>& board, char piece) {\n        // row matches\n        if (board[0][0] == piece && board[0][0] == board[0][1] && board[0][1] == board[0][2]) return true;\n        if (board[1][0] == piece && board[1][0] == board[1][1] && board[1][1] == board[1][2]) return true;\n        if (board[2][0] == piece && board[2][0] == board[2][1] && board[2][1] == board[2][2]) return true;\n        // column matches\n        if (board[0][0] == piece && board[0][0] == board[1][0] && board[1][0] == board[2][0]) return true;\n        if (board[0][1] == piece && board[0][1] == board[1][1] && board[1][1] == board[2][1]) return true;\n        if (board[0][2] == piece && board[0][2] == board[1][2] && board[1][2] == board[2][2]) return true;\n        // diagonals\n        if (board[0][0] == piece && board[0][0] == board[1][1] && board[1][1] == board[2][2]) return true;\n        if (board[0][2] == piece && board[0][2] == board[1][1] && board[1][1] == board[2][0]) return true;\n        return false;\n    }\n    \npublic:\n    bool validTicTacToe(vector<string>& board) {\n        int diff = boardCount(board, 'X') - boardCount(board, 'O');\n        bool xWins = hasWin(board, 'X'), oWins = hasWin(board, 'O');\n        if (diff != 1 && diff != 0)\n            return false;\n        if (xWins && oWins)\n            return false;\n        if (xWins && diff != 1)\n            return false;\n        if (oWins && diff != 0)\n            return false;\n        return true;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022783,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }\\n                if(board[i].charAt(j)==\\'X\\'){\\n                    if(i==j)xdiag++;\\n                    arr[1]++;\\n                    x++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\'){\\n                    if(i==j)odiag++;\\n                    arr[0]++;\\n                    o++;\\n                }\\n            }\\n            if(o==3 && owin)return false;\\n            if(owin && xwin)return false;\\n            if(x==3)xwin=true;\\n            else if(o==3)owin=true;\\n        }\\n\\n        if(xdiag==3)xwin=true;\\n        if(odiag==3)owin=true;\\n\\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')xwin=true;\\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')owin=true;\\n\\n        if(arr[0]>=arr[1] && xwin || (arr[1]>arr[0] && owin))return false;\\n        if(arr[0]>arr[1] || Math.abs(arr[0]-arr[1])>1)return false;\\n        \\n        if(xwin&&owin) return false;\\n        else return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }\\n                if(board[i].charAt(j)==\\'X\\'){\\n                    if(i==j)xdiag++;\\n                    arr[1]++;\\n                    x++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\'){\\n                    if(i==j)odiag++;\\n                    arr[0]++;\\n                    o++;\\n                }\\n            }\\n            if(o==3 && owin)return false;\\n            if(owin && xwin)return false;\\n            if(x==3)xwin=true;\\n            else if(o==3)owin=true;\\n        }\\n\\n        if(xdiag==3)xwin=true;\\n        if(odiag==3)owin=true;\\n\\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')xwin=true;\\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')owin=true;\\n\\n        if(arr[0]>=arr[1] && xwin || (arr[1]>arr[0] && owin))return false;\\n        if(arr[0]>arr[1] || Math.abs(arr[0]-arr[1])>1)return false;\\n        \\n        if(xwin&&owin) return false;\\n        else return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432898,
                "title": "easy-java-1ms-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n            int numX = 0;\\n            int numO = 0;\\n            boolean xWins =false;\\n            boolean oWins = false;\\n            for (int i= 0; i< 3; i++){\\n                for(char c: board[i].toCharArray()) {\\n                if(c == \\'X\\') numX++;\\n                else if(c== \\'O\\')numO++;\\n            }\\n            // check horizontal at row i\\n            if(board[i].equals(\"XXX\"))xWins = true;\\n            else if(board[i].equals(\"OOO\"))oWins = true;\\n            // check vertical at column i\\n            String vertical = new StringBuilder()\\n                .append(board[0].charAt(i))\\n                .append(board[1].charAt(i))\\n                .append(board[2].charAt(i))\\n                .toString();\\n            if(vertical.equals(\"XXX\"))xWins = true;\\n            else if(vertical.equals(\"OOO\")) oWins = true;\\n            }\\n        // left diagonal\\n            String diag1= new StringBuilder() // as the matrix will always be of 3x3 so we do not need to use i in checking diagonal we can just direct use the indices 0,1,2\\n                .append(board[0].charAt(0))\\n                .append(board[1].charAt(1))\\n                .append(board[2].charAt(2))\\n                .toString();\\n            if(diag1.equals(\"XXX\")) xWins = true;\\n            else if(diag1.equals(\"OOO\")) oWins = true;\\n        // right diagonal\\n            String diag2 = new StringBuilder() \\n                .append(board[0].charAt(2))\\n                .append(board[1].charAt(1))\\n                .append(board[2].charAt(0))\\n                .toString();\\n            if(diag2.equals(\"XXX\")) xWins =true;\\n            else if(diag2.equals(\"OOO\")) oWins= true;\\n            if(xWins) {\\n                return !oWins && numX - numO == 1;\\n            }else if(oWins){\\n                return numX == numO;\\n            }\\n        return numX>=numO && numX-numO<=1; // if none of them wins then we will check the number of x should be atleast equal to number of o and number of x should be atmost 1 more than the number of o \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n            int numX = 0;\\n            int numO = 0;\\n            boolean xWins =false;\\n            boolean oWins = false;\\n            for (int i= 0; i< 3; i++){\\n                for(char c: board[i].toCharArray()) {\\n                if(c == \\'X\\') numX++;\\n                else if(c== \\'O\\')numO++;\\n            }\\n            // check horizontal at row i\\n            if(board[i].equals(\"XXX\"))xWins = true;\\n            else if(board[i].equals(\"OOO\"))oWins = true;\\n            // check vertical at column i\\n            String vertical = new StringBuilder()\\n                .append(board[0].charAt(i))\\n                .append(board[1].charAt(i))\\n                .append(board[2].charAt(i))\\n                .toString();\\n            if(vertical.equals(\"XXX\"))xWins = true;\\n            else if(vertical.equals(\"OOO\")) oWins = true;\\n            }\\n        // left diagonal\\n            String diag1= new StringBuilder() // as the matrix will always be of 3x3 so we do not need to use i in checking diagonal we can just direct use the indices 0,1,2\\n                .append(board[0].charAt(0))\\n                .append(board[1].charAt(1))\\n                .append(board[2].charAt(2))\\n                .toString();\\n            if(diag1.equals(\"XXX\")) xWins = true;\\n            else if(diag1.equals(\"OOO\")) oWins = true;\\n        // right diagonal\\n            String diag2 = new StringBuilder() \\n                .append(board[0].charAt(2))\\n                .append(board[1].charAt(1))\\n                .append(board[2].charAt(0))\\n                .toString();\\n            if(diag2.equals(\"XXX\")) xWins =true;\\n            else if(diag2.equals(\"OOO\")) oWins= true;\\n            if(xWins) {\\n                return !oWins && numX - numO == 1;\\n            }else if(oWins){\\n                return numX == numO;\\n            }\\n        return numX>=numO && numX-numO<=1; // if none of them wins then we will check the number of x should be atleast equal to number of o and number of x should be atmost 1 more than the number of o \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420348,
                "title": "python-super-easy-solution-though-process-explained",
                "content": "Thought process:\\n* Two players can\\'t win at the same time\\n* X starts first, so its count must be greater by 1, or equal to the count of O.\\n* I generate a list of all different valid position for winning (rows, col and diagonals).\\n   Then I check which of the players have won.\\n*  X_won? O_won must be false and the diff between counts must be 1.\\n*  O_won? diff must be 0\\n* else, neither have won, count must be 0 or 1\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:        \\n        main_diag = board[0][0] + board[1][1] + board[2][2]\\n        second_diag = board[0][2] + board[1][1] + board[2][0]\\n        \\n        t_board = [\\'\\'.join(s) for s in zip(*board)]\\n        items = [*board, *t_board, main_diag, second_diag]\\n        \\n        X_won = \\'XXX\\' in items\\n        O_won = \\'OOO\\' in items\\n        \\n        X_count = sum(row.count(\\'X\\') for row in board)\\n        O_count = sum(row.count(\\'O\\') for row in board)\\n        diff = X_count - O_count\\n        \\n        if X_won:\\n            return not O_won and diff == 1\\n        elif O_won:\\n            return diff == 0\\n        else:\\n            return 0 <= diff <= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:        \\n        main_diag = board[0][0] + board[1][1] + board[2][2]\\n        second_diag = board[0][2] + board[1][1] + board[2][0]\\n        \\n        t_board = [\\'\\'.join(s) for s in zip(*board)]\\n        items = [*board, *t_board, main_diag, second_diag]\\n        \\n        X_won = \\'XXX\\' in items\\n        O_won = \\'OOO\\' in items\\n        \\n        X_count = sum(row.count(\\'X\\') for row in board)\\n        O_count = sum(row.count(\\'O\\') for row in board)\\n        diff = X_count - O_count\\n        \\n        if X_won:\\n            return not O_won and diff == 1\\n        elif O_won:\\n            return diff == 0\\n        else:\\n            return 0 <= diff <= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316793,
                "title": "c-solution-0ms-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Valid Tic-Tac-Toe State.\\nMemory Usage: 8.5 MB, less than 9.16% of C++ online submissions for Valid Tic-Tac-Toe State.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    bool validTicTacToe(vector<string>& grid) \\n    {\\n        int count_x = 0;\\n        int count_o = 0;\\n        \\n        for (int i = 0; i < 3; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                if (grid[i][j] == \\'X\\')\\n                {\\n                    count_x++;\\n                }\\n                else if (grid[i][j] == \\'O\\')\\n                {\\n                    count_o++;\\n                }\\n            }\\n        }\\n        \\n        if (count_o > count_x || count_x - count_o >= 2)\\n            return false;\\n        \\n        if (count_x >= 3 && count_x == count_o && check_x_win(grid))\\n            return false;\\n        \\n        if (count_o >= 3 && count_x > count_o && check_o_win(grid))\\n            return false;\\n        \\n        return true;\\n    }\\nprivate:\\n    bool check_x_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'X\\' && grid[0][1] == \\'X\\' && grid[0][2] == \\'X\\';\\n        res |= grid[1][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[1][2] == \\'X\\';\\n        res |= grid[2][0] == \\'X\\' && grid[2][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][0] == \\'X\\' && grid[2][0] == \\'X\\';\\n        res |= grid[0][1] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][1] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][2] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][0] == \\'X\\';\\n        \\n        return res;\\n    }\\n    \\n    bool check_o_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'O\\' && grid[0][1] == \\'O\\' && grid[0][2] == \\'O\\';\\n        res |= grid[1][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[1][2] == \\'O\\';\\n        res |= grid[2][0] == \\'O\\' && grid[2][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][0] == \\'O\\' && grid[2][0] == \\'O\\';\\n        res |= grid[0][1] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][1] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][2] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][0] == \\'O\\';\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool validTicTacToe(vector<string>& grid) \\n    {\\n        int count_x = 0;\\n        int count_o = 0;\\n        \\n        for (int i = 0; i < 3; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                if (grid[i][j] == \\'X\\')\\n                {\\n                    count_x++;\\n                }\\n                else if (grid[i][j] == \\'O\\')\\n                {\\n                    count_o++;\\n                }\\n            }\\n        }\\n        \\n        if (count_o > count_x || count_x - count_o >= 2)\\n            return false;\\n        \\n        if (count_x >= 3 && count_x == count_o && check_x_win(grid))\\n            return false;\\n        \\n        if (count_o >= 3 && count_x > count_o && check_o_win(grid))\\n            return false;\\n        \\n        return true;\\n    }\\nprivate:\\n    bool check_x_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'X\\' && grid[0][1] == \\'X\\' && grid[0][2] == \\'X\\';\\n        res |= grid[1][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[1][2] == \\'X\\';\\n        res |= grid[2][0] == \\'X\\' && grid[2][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][0] == \\'X\\' && grid[2][0] == \\'X\\';\\n        res |= grid[0][1] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][1] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][2] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][0] == \\'X\\';\\n        \\n        return res;\\n    }\\n    \\n    bool check_o_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'O\\' && grid[0][1] == \\'O\\' && grid[0][2] == \\'O\\';\\n        res |= grid[1][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[1][2] == \\'O\\';\\n        res |= grid[2][0] == \\'O\\' && grid[2][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][0] == \\'O\\' && grid[2][0] == \\'O\\';\\n        res |= grid[0][1] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][1] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][2] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][0] == \\'O\\';\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260655,
                "title": "c-can-be-scaled-to-any-size",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        const int N = 3;\\n\\n        unordered_map<char, int> total;\\n        unordered_map<char,int> winner;\\n        \\n        vector<unordered_map<char, int>> rows(N);\\n        vector<unordered_map<char, int>> cols(N);\\n        \\n        unordered_map<char, int> diag;\\n        unordered_map<char, int> rdiag;\\n                \\n        for (int i=0; i<N; i++)\\n            for (int j=0; j<N; j++) {\\n                int c = board[i][j];\\n                \\n                total[c]++;\\n\\n                if (i == j)\\n                    if (++diag[c] == 3)\\n                        winner[c]++;\\n                        \\n                if (i == N-j-1)\\n                    if (++rdiag[c] == 3)\\n                        winner[c]++;\\n                \\n                if (++rows[i][c] == 3)\\n                    winner[c]++;\\n                if (++cols[j][c] == 3)\\n                    winner[c]++;\\n            }\\n        \\n        int XO = total[\\'X\\']-total[\\'O\\'];\\n\\n        if (XO < 0 || XO > 1)\\n            return false;\\n        \\n        if (winner[\\'X\\'] > 0 && winner[\\'O\\'] > 0)\\n            return false;\\n        \\n        if (winner[\\'X\\'] > 0  && XO == 0)\\n            return false;\\n\\n        if (winner[\\'O\\'] > 0  && XO > 0)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        const int N = 3;\\n\\n        unordered_map<char, int> total;\\n        unordered_map<char,int> winner;\\n        \\n        vector<unordered_map<char, int>> rows(N);\\n        vector<unordered_map<char, int>> cols(N);\\n        \\n        unordered_map<char, int> diag;\\n        unordered_map<char, int> rdiag;\\n                \\n        for (int i=0; i<N; i++)\\n            for (int j=0; j<N; j++) {\\n                int c = board[i][j];\\n                \\n                total[c]++;\\n\\n                if (i == j)\\n                    if (++diag[c] == 3)\\n                        winner[c]++;\\n                        \\n                if (i == N-j-1)\\n                    if (++rdiag[c] == 3)\\n                        winner[c]++;\\n                \\n                if (++rows[i][c] == 3)\\n                    winner[c]++;\\n                if (++cols[j][c] == 3)\\n                    winner[c]++;\\n            }\\n        \\n        int XO = total[\\'X\\']-total[\\'O\\'];\\n\\n        if (XO < 0 || XO > 1)\\n            return false;\\n        \\n        if (winner[\\'X\\'] > 0 && winner[\\'O\\'] > 0)\\n            return false;\\n        \\n        if (winner[\\'X\\'] > 0  && XO == 0)\\n            return false;\\n\\n        if (winner[\\'O\\'] > 0  && XO > 0)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217833,
                "title": "c-clean-and-concise-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/valid-tic-tac-toe-state/\\n    \\n    TC: O(N*N)\\n    \\n    Idea is simple, since X starts first, no. of X should either be equal or +1 than no. of O.\\n    We check for this scenario and few others. If a strike (continuous 3X or 3O) is completed, then\\n    based on which symbol completed, the no. of X and O is different.\\n    Check the state of Xs and Os after these scenarios:\\n    1. Horizontal Strike\\n    2. Vertical Strike \\n    3. Right Diagonal\\n    4. Left Diagonal\\n*/\\nclass Solution {\\npublic:\\n    // Checks if the strike is valid or not based on the no. of Xs and Os.\\n    // Returns true if the continuous line of 0s or Xs is valid based on the config of board\\n    bool validStrike(int nX, int nO, int n, int total_x, int total_o) {\\n        if(nX == n or nO == n) {\\n            // Since X makes the 1st move, if it completes a strike, nO should always be 1 less\\n            if(nX == n && (total_o >= total_x))\\n                return false;\\n            // Since O makes the 2nd move, if it completes a strike, it should be equal to X\\n            if(nO == n && (total_o != total_x))\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool validTicTacToe(vector<string>& board) {\\n        // n(x) == n(O) or x(X) == n(O) + 1\\n        // no moves after straight 3 Os or Xs => 3X (nX = nO + 1), 3O (nX = nO) \\n        int total_x = 0, total_o = 0;\\n        int n = board.size();\\n        // <char=[X, O], no. of chars>\\n        // Used just to make the code cleaner\\n        unordered_map<char, int> freq;\\n        \\n        // calculate total X and O\\n        for(int r = 0; r < n; r++)\\n            for(int c = 0; c < n; c++)\\n                ++freq[board[r][c]];\\n        \\n        total_x = freq[\\'X\\'], total_o = freq[\\'O\\'];\\n        // Since X starts first, no. of X should either be equal or +1 than no. of O\\n        if(total_x != total_o + 1 && total_x != total_o)\\n            return false; \\n        \\n        // check for 3 Xs or Os: Horizontally \\n        for(int r = 0; r < n; r++) {\\n            freq.clear();\\n            for(int c = 0; c < n; c++)\\n                ++freq[board[r][c]];\\n            // Found a horizontal strike\\n            if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n                return false;\\n        }\\n        \\n        // check for 3 Xs or Os: Vertically \\n        for(int c = 0; c < n; c++) {\\n            freq.clear();\\n            for(int r = 0; r < n; r++)\\n                ++freq[board[r][c]];\\n            // Found a vertical strike\\n            if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n                return false;\\n        }\\n        \\n        freq.clear();\\n        // check for a diagonal strike: Right upwards diagonal\\n        int r = 0, c = n-1;\\n        while(r < n && c >= 0) {\\n            ++freq[board[r][c]];\\n            ++r, --c;\\n        }\\n        // Found a diagonal strike\\n        if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n            return false;\\n\\n        freq.clear();\\n        // check for a diagonal strike: Left downwards diagonal\\n        r = 0, c = 0;\\n        while(r < n && c < n) {\\n            ++freq[board[r][c]];   \\n            ++r, ++c;\\n        }\\n        // Found a diagonal strike\\n        if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/valid-tic-tac-toe-state/\\n    \\n    TC: O(N*N)\\n    \\n    Idea is simple, since X starts first, no. of X should either be equal or +1 than no. of O.\\n    We check for this scenario and few others. If a strike (continuous 3X or 3O) is completed, then\\n    based on which symbol completed, the no. of X and O is different.\\n    Check the state of Xs and Os after these scenarios:\\n    1. Horizontal Strike\\n    2. Vertical Strike \\n    3. Right Diagonal\\n    4. Left Diagonal\\n*/\\nclass Solution {\\npublic:\\n    // Checks if the strike is valid or not based on the no. of Xs and Os.\\n    // Returns true if the continuous line of 0s or Xs is valid based on the config of board\\n    bool validStrike(int nX, int nO, int n, int total_x, int total_o) {\\n        if(nX == n or nO == n) {\\n            // Since X makes the 1st move, if it completes a strike, nO should always be 1 less\\n            if(nX == n && (total_o >= total_x))\\n                return false;\\n            // Since O makes the 2nd move, if it completes a strike, it should be equal to X\\n            if(nO == n && (total_o != total_x))\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool validTicTacToe(vector<string>& board) {\\n        // n(x) == n(O) or x(X) == n(O) + 1\\n        // no moves after straight 3 Os or Xs => 3X (nX = nO + 1), 3O (nX = nO) \\n        int total_x = 0, total_o = 0;\\n        int n = board.size();\\n        // <char=[X, O], no. of chars>\\n        // Used just to make the code cleaner\\n        unordered_map<char, int> freq;\\n        \\n        // calculate total X and O\\n        for(int r = 0; r < n; r++)\\n            for(int c = 0; c < n; c++)\\n                ++freq[board[r][c]];\\n        \\n        total_x = freq[\\'X\\'], total_o = freq[\\'O\\'];\\n        // Since X starts first, no. of X should either be equal or +1 than no. of O\\n        if(total_x != total_o + 1 && total_x != total_o)\\n            return false; \\n        \\n        // check for 3 Xs or Os: Horizontally \\n        for(int r = 0; r < n; r++) {\\n            freq.clear();\\n            for(int c = 0; c < n; c++)\\n                ++freq[board[r][c]];\\n            // Found a horizontal strike\\n            if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n                return false;\\n        }\\n        \\n        // check for 3 Xs or Os: Vertically \\n        for(int c = 0; c < n; c++) {\\n            freq.clear();\\n            for(int r = 0; r < n; r++)\\n                ++freq[board[r][c]];\\n            // Found a vertical strike\\n            if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n                return false;\\n        }\\n        \\n        freq.clear();\\n        // check for a diagonal strike: Right upwards diagonal\\n        int r = 0, c = n-1;\\n        while(r < n && c >= 0) {\\n            ++freq[board[r][c]];\\n            ++r, --c;\\n        }\\n        // Found a diagonal strike\\n        if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n            return false;\\n\\n        freq.clear();\\n        // check for a diagonal strike: Left downwards diagonal\\n        r = 0, c = 0;\\n        while(r < n && c < n) {\\n            ++freq[board[r][c]];   \\n            ++r, ++c;\\n        }\\n        // Found a diagonal strike\\n        if(!validStrike(freq[\\'X\\'], freq[\\'O\\'], n, total_x, total_o))\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216408,
                "title": "clean-and-fast-solution-with-a-little-extra-pre-processing-easy-to-understand",
                "content": "Instead of  counting \\'X\\' , \\'O\\', \\' \\'\\nwe represent these 3 states as 1, -1 and 0.\\n\\nWe go over board once first, as pre-processing. \\nThis sort of translate board into a 1, -1, and 0 bitmask.\\n\\nThen rules becomes simple\\n1. total sum of steps can only be 1 or 0. (As in 1 goes first, then goes -1)\\n2. any row/coln/diag sums to 3/-3 means 1 or -1 wins. (i.e. 111, -1 -1 -1)\\n3. last move player has a chance to win or not win, i.e. the other player(non-last move player) cannot win\\n\\nWe can see after the pre-processing translation, solution becomes much clean and easy to understand. (with a a little space overhead to store translated board)\\nO(size of board) runtime [up to beat 100% in C++]\\nO(size of board) space\\n\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        //M1: use 1 as X, -1 as O. \\n        //check total sum, check invalid wins from non-last move player\\n        int b[3][3] = {};\\n        int totalSum = 0;\\n        \\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                if (board[i][j] == \\'X\\') {b[i][j] = 1; totalSum += 1;}\\n                else if (board[i][j] == \\'O\\') {b[i][j] = -1; totalSum -= 1;}\\n            }            \\n        }\\n        \\n        if (totalSum == 0) {\\n            //O plays last, X cant win\\n            //check rows/colns\\n            for (int i = 0; i < 3; ++i) {\\n                if (b[i][0] + b[i][1] + b[i][2] == 3 || \\n                    b[0][i] + b[1][i] + b[2][i] == 3) return false;\\n            }\\n            \\n            //check diag\\n            int diag1 = 0, diag2 = 0;\\n            for (int i = 0; i < 3; ++i) {\\n                diag1 += b[i][i];\\n                diag2 += b[i][2 - i];\\n            }\\n            if (diag1 == 3 || diag2 == 3) return false;\\n                \\n            //valid\\n            return true;\\n        } else if (totalSum == 1) {\\n            //X plays last, O cant win. Repeat last if \\n            //check rows/colns\\n            for (int i = 0; i < 3; ++i) {\\n                if (b[i][0] + b[i][1] + b[i][2] == -3 || \\n                    b[0][i] + b[1][i] + b[2][i] == -3) return false;\\n            }\\n            \\n            //check diag\\n            int diag1 = 0, diag2 = 0;\\n            for (int i = 0; i < 3; ++i) {\\n                diag1 += b[i][i];\\n                diag2 += b[i][2 - i];\\n            }\\n            if (diag1 == -3 || diag2 == -3) return false;\\n                \\n            //valid\\n            return true; \\n        } else return false; //invalid total steps\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        //M1: use 1 as X, -1 as O. \\n        //check total sum, check invalid wins from non-last move player\\n        int b[3][3] = {};\\n        int totalSum = 0;\\n        \\n        for (int i = 0; i < 3; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                if (board[i][j] == \\'X\\') {b[i][j] = 1; totalSum += 1;}\\n                else if (board[i][j] == \\'O\\') {b[i][j] = -1; totalSum -= 1;}\\n            }            \\n        }\\n        \\n        if (totalSum == 0) {\\n            //O plays last, X cant win\\n            //check rows/colns\\n            for (int i = 0; i < 3; ++i) {\\n                if (b[i][0] + b[i][1] + b[i][2] == 3 || \\n                    b[0][i] + b[1][i] + b[2][i] == 3) return false;\\n            }\\n            \\n            //check diag\\n            int diag1 = 0, diag2 = 0;\\n            for (int i = 0; i < 3; ++i) {\\n                diag1 += b[i][i];\\n                diag2 += b[i][2 - i];\\n            }\\n            if (diag1 == 3 || diag2 == 3) return false;\\n                \\n            //valid\\n            return true;\\n        } else if (totalSum == 1) {\\n            //X plays last, O cant win. Repeat last if \\n            //check rows/colns\\n            for (int i = 0; i < 3; ++i) {\\n                if (b[i][0] + b[i][1] + b[i][2] == -3 || \\n                    b[0][i] + b[1][i] + b[2][i] == -3) return false;\\n            }\\n            \\n            //check diag\\n            int diag1 = 0, diag2 = 0;\\n            for (int i = 0; i < 3; ++i) {\\n                diag1 += b[i][i];\\n                diag2 += b[i][2 - i];\\n            }\\n            if (diag1 == -3 || diag2 == -3) return false;\\n                \\n            //valid\\n            return true; \\n        } else return false; //invalid total steps\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174405,
                "title": "python-solution-works-for-nxn-matrix",
                "content": "Got inspired from myCafeBabe\\'s solution, you can check on this link : \\nhttps://leetcode.com/problems/valid-tic-tac-toe-state/discuss/117580/Straightforward-Java-solution-with-explaination\\n\\nSmall enhancement from mine is for loop below, in case size of matrix is N, just need to replace 3 with N \\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef validTicTacToe(self, board: List[str]) -> bool:\\n\\t\\tcols, rows = [0] * len(board), [0] * len(board[0])\\n\\t\\tdiagonal, anti_diagonal = 0, 0\\n\\t\\tturn, x_win, o_win = 0, False, False\\n\\n\\t\\tfor i in range(len(board)):\\n\\t\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\t\\tif board[i][j] == \\'X\\':\\n\\t\\t\\t\\t\\tturn += 1\\n\\t\\t\\t\\t\\trows[i] += 1\\n\\t\\t\\t\\t\\tcols[j] += 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal += 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal += 1\\n\\t\\t\\t\\telif board[i][j] == \\'O\\':\\n\\t\\t\\t\\t\\tturn -= 1\\n\\t\\t\\t\\t\\trows[i] -= 1\\n\\t\\t\\t\\t\\tcols[j] -= 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal -= 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal -= 1\\n\\n\\t\\tfor idx in range(len(cols)):\\n\\t\\t\\tif cols[idx] == 3 or rows[idx] == 3 or diagonal == 3 or anti_diagonal == 3:\\n\\t\\t\\t\\tx_win = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif cols[idx] == -3 or rows[idx] == -3 or diagonal == -3 or anti_diagonal == -3:\\n\\t\\t\\t\\to_win = True\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif (turn != 1 and x_win) or (turn != 0 and o_win):\\n\\t\\t\\treturn False\\n\\n\\t\\treturn turn == 1 or turn == 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef validTicTacToe(self, board: List[str]) -> bool:\\n\\t\\tcols, rows = [0] * len(board), [0] * len(board[0])\\n\\t\\tdiagonal, anti_diagonal = 0, 0\\n\\t\\tturn, x_win, o_win = 0, False, False\\n\\n\\t\\tfor i in range(len(board)):\\n\\t\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\t\\tif board[i][j] == \\'X\\':\\n\\t\\t\\t\\t\\tturn += 1\\n\\t\\t\\t\\t\\trows[i] += 1\\n\\t\\t\\t\\t\\tcols[j] += 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal += 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal += 1\\n\\t\\t\\t\\telif board[i][j] == \\'O\\':\\n\\t\\t\\t\\t\\tturn -= 1\\n\\t\\t\\t\\t\\trows[i] -= 1\\n\\t\\t\\t\\t\\tcols[j] -= 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal -= 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal -= 1\\n\\n\\t\\tfor idx in range(len(cols)):\\n\\t\\t\\tif cols[idx] == 3 or rows[idx] == 3 or diagonal == 3 or anti_diagonal == 3:\\n\\t\\t\\t\\tx_win = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif cols[idx] == -3 or rows[idx] == -3 or diagonal == -3 or anti_diagonal == -3:\\n\\t\\t\\t\\to_win = True\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif (turn != 1 and x_win) or (turn != 0 and o_win):\\n\\t\\t\\treturn False\\n\\n\\t\\treturn turn == 1 or turn == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115599,
                "title": "java-1-ms-with-simple-and-readable-code-with-comments",
                "content": "```\\n/*\\nIMP Note: If any of the player wins, their count can not match!!  Since X starts first, it\\'s always ahead of \\'O\\'\\n*/\\nclass Solution {\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        \\n        // if board is empty it\\'s valid\\n        if(board.length == 0){\\n            return true;\\n        }\\n        \\n        int count_x = 0;\\n        int count_o = 0;\\n        int empty_count = 0;\\n        \\n        // check the count for X, O and empty cell\\n        for(String s : board){\\n            for(char c : s.toCharArray()){\\n                if(c == \\'X\\'){\\n                    count_x++;\\n                }else if(c == \\'O\\'){\\n                    count_o++;\\n                }else{\\n                    empty_count++;\\n                }\\n            }\\n        }\\n        \\n        boolean x_won = checkForWin(board,\\'X\\');\\n        boolean o_won = checkForWin(board,\\'O\\');\\n        \\n        if(empty_count == 9){ // if the board is empty  ( 3 X 3 =9)\\n            return true;\\n        }else if(count_o > count_x){ // count for O can\\'t be greater because X starts first\\n            return false;\\n        }else if(x_won && o_won){ // both can\\'t win at the same time\\n            return false;\\n        }else if(o_won && count_x > count_o){ // if O wins but X tried putting even after O won\\n            return false;\\n        }\\n        else if(x_won  && count_x-count_o == 0){    // X wins but O tried putting even after X won\\n            return false;\\n        }\\n        else if(count_x-count_o == 1){ // X is always 1 step ahead of O\\n            return true;\\n        }else if(count_x == count_o && empty_count > 0){ // if X and O have same count then there are more than one empty cells in the grid\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    /* Method to check if X won or O won */\\n    public boolean checkForWin(String[] board, char check_for){\\n        char[][] b = new char[3][3];\\n        \\n        // store this in 3 X 3 matrix called \\'b\\' for simplicity and better readability \\n        for(int r = 0; r < 3; r++){\\n            for(int c = 0; c < 3; c++){\\n                char[] arr = board[r].toCharArray();\\n                b[r][c] = arr[c];\\n            }\\n        }\\n        \\n        //check for rows\\n        for(int r = 0; r < 3; r++){\\n            if(b[r][0] == b[r][1] && b[r][0] == b[r][2] && b[r][0] == check_for){\\n                return true;\\n            }\\n        }\\n        \\n        // check for cols\\n        for(int c = 0; c < 3; c++){\\n            if(b[0][c] == b[1][c] && b[0][c] == b[2][c] && b[2][c] == check_for){\\n                return true;\\n            }\\n        }\\n        \\n        // check for diagonal\\n        if(b[0][0] == b[1][1] && b[0][0] == b[2][2] && b[0][0] == check_for){\\n            return true;\\n        }\\n        \\n        // check for anti-diagonal\\n        if(b[0][2] == b[1][1] && b[2][0] == b[1][1] && b[1][1] == check_for){\\n            return true;\\n        }\\n        \\n\\t\\t//the player didn\\'t win\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nIMP Note: If any of the player wins, their count can not match!!  Since X starts first, it\\'s always ahead of \\'O\\'\\n*/\\nclass Solution {\\n    \\n    public boolean validTicTacToe(String[] board) {\\n        \\n        // if board is empty it\\'s valid\\n        if(board.length == 0){\\n            return true;\\n        }\\n        \\n        int count_x = 0;\\n        int count_o = 0;\\n        int empty_count = 0;\\n        \\n        // check the count for X, O and empty cell\\n        for(String s : board){\\n            for(char c : s.toCharArray()){\\n                if(c == \\'X\\'){\\n                    count_x++;\\n                }else if(c == \\'O\\'){\\n                    count_o++;\\n                }else{\\n                    empty_count++;\\n                }\\n            }\\n        }\\n        \\n        boolean x_won = checkForWin(board,\\'X\\');\\n        boolean o_won = checkForWin(board,\\'O\\');\\n        \\n        if(empty_count == 9){ // if the board is empty  ( 3 X 3 =9)\\n            return true;\\n        }else if(count_o > count_x){ // count for O can\\'t be greater because X starts first\\n            return false;\\n        }else if(x_won && o_won){ // both can\\'t win at the same time\\n            return false;\\n        }else if(o_won && count_x > count_o){ // if O wins but X tried putting even after O won\\n            return false;\\n        }\\n        else if(x_won  && count_x-count_o == 0){    // X wins but O tried putting even after X won\\n            return false;\\n        }\\n        else if(count_x-count_o == 1){ // X is always 1 step ahead of O\\n            return true;\\n        }else if(count_x == count_o && empty_count > 0){ // if X and O have same count then there are more than one empty cells in the grid\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    /* Method to check if X won or O won */\\n    public boolean checkForWin(String[] board, char check_for){\\n        char[][] b = new char[3][3];\\n        \\n        // store this in 3 X 3 matrix called \\'b\\' for simplicity and better readability \\n        for(int r = 0; r < 3; r++){\\n            for(int c = 0; c < 3; c++){\\n                char[] arr = board[r].toCharArray();\\n                b[r][c] = arr[c];\\n            }\\n        }\\n        \\n        //check for rows\\n        for(int r = 0; r < 3; r++){\\n            if(b[r][0] == b[r][1] && b[r][0] == b[r][2] && b[r][0] == check_for){\\n                return true;\\n            }\\n        }\\n        \\n        // check for cols\\n        for(int c = 0; c < 3; c++){\\n            if(b[0][c] == b[1][c] && b[0][c] == b[2][c] && b[2][c] == check_for){\\n                return true;\\n            }\\n        }\\n        \\n        // check for diagonal\\n        if(b[0][0] == b[1][1] && b[0][0] == b[2][2] && b[0][0] == check_for){\\n            return true;\\n        }\\n        \\n        // check for anti-diagonal\\n        if(b[0][2] == b[1][1] && b[2][0] == b[1][1] && b[1][1] == check_for){\\n            return true;\\n        }\\n        \\n\\t\\t//the player didn\\'t win\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034005,
                "title": "my-easy-to-understand-intuitive-java-solution",
                "content": "\\tclass Solution {\\n\\t\\n    public boolean validTicTacToe(String[] board) {\\n         Character[][] arr = new Character[3][3];\\n        int countX = 0, countO = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    countX++;\\n                }\\n                if (board[i].charAt(j) == \\'O\\') {\\n                    countO++;\\n                }\\n                arr[i][j] = board[i].charAt(j);\\n            }\\n        }\\n        return isValid(arr, countX, countO);\\n    }\\n    \\n    private static boolean isValid(Character[][] arr, int countX, int countO) {\\n        return (countX == countO && !isXWinner(arr) && !isOWinner(arr)) ||\\n                (countX == countO && isOWinner(arr) && !isXWinner(arr)) ||\\n                (countX - countO == 1 && !isOWinner(arr) && !isXWinner(arr)) ||\\n                (countX - countO == 1 && !isOWinner(arr) && isXWinner(arr));\\n    }\\n\\n    private static boolean isXWinner(Character[][] arr) {\\n        return (arr[0][0] == \\'X\\' && arr[0][1] == \\'X\\' && arr[0][2] == \\'X\\') ||\\n                (arr[1][0] == \\'X\\' && arr[1][1] == \\'X\\' && arr[1][2] == \\'X\\') ||\\n                (arr[2][0] == \\'X\\' && arr[2][1] == \\'X\\' && arr[2][2] == \\'X\\') ||\\n                (arr[0][0] == \\'X\\' && arr[1][0] == \\'X\\' && arr[2][0] == \\'X\\') ||\\n                (arr[0][1] == \\'X\\' && arr[1][1] == \\'X\\' && arr[2][1] == \\'X\\') ||\\n                (arr[0][2] == \\'X\\' && arr[1][2] == \\'X\\' && arr[2][2] == \\'X\\') ||\\n                (arr[0][0] == \\'X\\' && arr[1][1] == \\'X\\' && arr[2][2] == \\'X\\') ||\\n                (arr[0][2] == \\'X\\' && arr[1][1] == \\'X\\' && arr[2][0] == \\'X\\');\\n    }\\n\\n    private static boolean isOWinner(Character[][] arr) {\\n        return (arr[0][0] == \\'O\\' && arr[0][1] == \\'O\\' && arr[0][2] == \\'O\\') ||\\n                (arr[1][0] == \\'O\\' && arr[1][1] == \\'O\\' && arr[1][2] == \\'O\\') ||\\n                (arr[2][0] == \\'O\\' && arr[2][1] == \\'O\\' && arr[2][2] == \\'O\\') ||\\n                (arr[0][0] == \\'O\\' && arr[1][0] == \\'O\\' && arr[2][0] == \\'O\\') ||\\n                (arr[0][1] == \\'O\\' && arr[1][1] == \\'O\\' && arr[2][1] == \\'O\\') ||\\n                (arr[0][2] == \\'O\\' && arr[1][2] == \\'O\\' && arr[2][2] == \\'O\\') ||\\n                (arr[0][0] == \\'O\\' && arr[1][1] == \\'O\\' && arr[2][2] == \\'O\\') ||\\n                (arr[0][2] == \\'O\\' && arr[1][1] == \\'O\\' && arr[2][0] == \\'O\\');\\n    }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\n    public boolean validTicTacToe(String[] board) {\\n         Character[][] arr = new Character[3][3];\\n        int countX = 0, countO = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    countX++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1985927,
                "title": "clean-python-solution-with-explanation",
                "content": "The following requirements define valid tic-tac-toe board:\\n* Zero or one players win, it is impossible that both players win\\n* If player \"X\" wins \"X\" must have made one more move than player \"O\" (because player \"X\" makes the first move)\\n* If player \"O\" wins both players must have made the same number of moves\\n* If neither of the players win \"X\" made either the same amount of moves as \"O\" or \"X\" made one more move than \"O\".\\n\\n```\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        cnt = Counter(\"\".join(board))\\n        wins_search_space = board + \\\\\\n            list(\"\".join(x) for x in zip(*board)) + \\\\\\n            [\\n                \"\".join(board[i][i] for i in range(3)),\\n                \"\".join(board[i][2-i] for i in range(3)),\\n            ]\\n        X_wins = \"XXX\" in wins_search_space\\n        O_wins = \"OOO\" in wins_search_space\\n\\n        if X_wins and O_wins:\\n            return False\\n        elif X_wins:\\n            return cnt[\"X\"] - cnt[\"O\"] == 1\\n        elif O_wins:\\n            return cnt[\"X\"] - cnt[\"O\"] == 0\\n        else:\\n            return 0 <= cnt[\"X\"] - cnt[\"O\"] <= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        cnt = Counter(\"\".join(board))\\n        wins_search_space = board + \\\\\\n            list(\"\".join(x) for x in zip(*board)) + \\\\\\n            [\\n                \"\".join(board[i][i] for i in range(3)),\\n                \"\".join(board[i][2-i] for i in range(3)),\\n            ]\\n        X_wins = \"XXX\" in wins_search_space\\n        O_wins = \"OOO\" in wins_search_space\\n\\n        if X_wins and O_wins:\\n            return False\\n        elif X_wins:\\n            return cnt[\"X\"] - cnt[\"O\"] == 1\\n        elif O_wins:\\n            return cnt[\"X\"] - cnt[\"O\"] == 0\\n        else:\\n            return 0 <= cnt[\"X\"] - cnt[\"O\"] <= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1934382,
                "title": "description-and-comments-on-how-to-solve-this-java-easy-solution",
                "content": "```\\n/*\\n\\nSo, basically the question is asking, we are given a tic tac toe board at some state\\nwe should check and tell whether its a valid state or not\\n\\nThought process:\\n1. We know X\\'s always starts first, so count of X will be more by just 1 if X wins, otherwise invalid\\n2. As X starts first, we cannot have count of O\\'s more on the board, if thats the case, then its invalid\\n3. When O wins the game, board must have equal no of O\\'s and X\\'s, otherwise the board is invalid\\n4. The overall state of the board countX-countO should be 0 or 1.. Anything beyond is an invalid board\\n*/\\n\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int countX=0;\\n        int countO=0;\\n        \\n        //count the no. of X and O on the board\\n        for(String s: board){\\n            \\n            for(char c:s.toCharArray()){\\n                \\n                if(c==\\'X\\')\\n                    countX++;\\n                \\n                if(c==\\'O\\')\\n                    countO++;\\n            }\\n        }\\n        \\n        //if O\\'s count is more than X - its invalid bcz X always starts first\\n        //if X\\'s count is more than O\\'s by 1+, then its a invalid board\\n        if(countO>countX || countX-countO>1)\\n            return false;\\n        \\n        \\n        //variables to see whether we find 3\\'X or 3\\'O - row wise, col wise or diagonal\\n        boolean filledWithAllX=false;\\n        boolean filledWithAllO=false;\\n        \\n        //checking row wise\\n        for(String s:board){\\n            \\n            if(s.equals(\"XXX\"))\\n                filledWithAllX=true;\\n            \\n            if(s.equals(\"OOO\"))\\n                filledWithAllO=true;\\n        }\\n        \\n        //-----------------------\\n        //column wise check for X\\'s\\n        if(board[0].charAt(0)==\\'X\\' && board[1].charAt(0)==\\'X\\' && board[2].charAt(0)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        if(board[0].charAt(1)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(1)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(2)==\\'X\\' && board[2].charAt(2)==\\'X\\')\\n            filledWithAllX=true;\\n       \\n        //-----------------------\\n        //column wise check for O\\'s       \\n        if(board[0].charAt(0)==\\'O\\' && board[1].charAt(0)==\\'O\\' && board[2].charAt(0)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(1)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(1)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(2)==\\'O\\' && board[2].charAt(2)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        //--------------------------     \\n        //check for diagonals - we have 2 diagonals on 3x3 board\\n        if(board[0].charAt(0)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(2)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(0)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(2)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        //if both are true, then its invalid board, bcz only one player can win\\n        if(filledWithAllX && filledWithAllO)\\n            return false;\\n        \\n        //when X wins, X\\'s count should be more than O, as X starts first\\n        if(filledWithAllX && (countX<=countO))\\n            return false;\\n        \\n        //when O wins, O will be equal to X\\'s count if not its invalid\\n        if(filledWithAllO && (countO!=countX))\\n            return false;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n\\nSo, basically the question is asking, we are given a tic tac toe board at some state\\nwe should check and tell whether its a valid state or not\\n\\nThought process:\\n1. We know X\\'s always starts first, so count of X will be more by just 1 if X wins, otherwise invalid\\n2. As X starts first, we cannot have count of O\\'s more on the board, if thats the case, then its invalid\\n3. When O wins the game, board must have equal no of O\\'s and X\\'s, otherwise the board is invalid\\n4. The overall state of the board countX-countO should be 0 or 1.. Anything beyond is an invalid board\\n*/\\n\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int countX=0;\\n        int countO=0;\\n        \\n        //count the no. of X and O on the board\\n        for(String s: board){\\n            \\n            for(char c:s.toCharArray()){\\n                \\n                if(c==\\'X\\')\\n                    countX++;\\n                \\n                if(c==\\'O\\')\\n                    countO++;\\n            }\\n        }\\n        \\n        //if O\\'s count is more than X - its invalid bcz X always starts first\\n        //if X\\'s count is more than O\\'s by 1+, then its a invalid board\\n        if(countO>countX || countX-countO>1)\\n            return false;\\n        \\n        \\n        //variables to see whether we find 3\\'X or 3\\'O - row wise, col wise or diagonal\\n        boolean filledWithAllX=false;\\n        boolean filledWithAllO=false;\\n        \\n        //checking row wise\\n        for(String s:board){\\n            \\n            if(s.equals(\"XXX\"))\\n                filledWithAllX=true;\\n            \\n            if(s.equals(\"OOO\"))\\n                filledWithAllO=true;\\n        }\\n        \\n        //-----------------------\\n        //column wise check for X\\'s\\n        if(board[0].charAt(0)==\\'X\\' && board[1].charAt(0)==\\'X\\' && board[2].charAt(0)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        if(board[0].charAt(1)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(1)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(2)==\\'X\\' && board[2].charAt(2)==\\'X\\')\\n            filledWithAllX=true;\\n       \\n        //-----------------------\\n        //column wise check for O\\'s       \\n        if(board[0].charAt(0)==\\'O\\' && board[1].charAt(0)==\\'O\\' && board[2].charAt(0)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(1)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(1)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(2)==\\'O\\' && board[2].charAt(2)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        //--------------------------     \\n        //check for diagonals - we have 2 diagonals on 3x3 board\\n        if(board[0].charAt(0)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(2)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(0)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(2)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')\\n            filledWithAllO=true;\\n        \\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')\\n            filledWithAllX=true;\\n        \\n        //if both are true, then its invalid board, bcz only one player can win\\n        if(filledWithAllX && filledWithAllO)\\n            return false;\\n        \\n        //when X wins, X\\'s count should be more than O, as X starts first\\n        if(filledWithAllX && (countX<=countO))\\n            return false;\\n        \\n        //when O wins, O will be equal to X\\'s count if not its invalid\\n        if(filledWithAllO && (countO!=countX))\\n            return false;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927661,
                "title": "python-logical-and-self-explanatory",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        Xs = Os = dia1 = dia2 = 0\\n        row = [0] * 3\\n        col = [0] * 3\\n        for r in range(3):\\n            for c in range(3):\\n                if board[r][c] == \\'X\\':\\n                    Xs += 1\\n                    row[r] += 1\\n                    col[c] += 1\\n                    if c == r:\\n                        dia1 += 1\\n                    if c + r == 2:\\n                        dia2 += 1\\n                elif board[r][c] == \\'O\\':\\n                    Os += 1\\n                    row[r] -= 1\\n                    col[c] -= 1\\n                    if c == r:\\n                        dia1 -= 1\\n                    if c + r == 2:\\n                        dia2 -= 1\\n           \\n        if max(max(row), dia1, dia2, max(col)) == 3: #X is winning, then O cannot win or cannot move after X wins\\n            if Xs == Os + 1 and min(min(row), dia1, dia2, min(col)) > -3:\\n                return True\\n        elif min(min(row), dia1, dia2, min(col)) == -3: #O is winning, then X cannot win or cannot move after X wins\\n            if Xs == Os and max(max(row), dia1, dia2, max(col)) < 3:\\n                return True\\n        else: #nobody is winning\\n            if ((Xs == Os) or (Xs == Os + 1)):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        Xs = Os = dia1 = dia2 = 0\\n        row = [0] * 3\\n        col = [0] * 3\\n        for r in range(3):\\n            for c in range(3):\\n                if board[r][c] == \\'X\\':\\n                    Xs += 1\\n                    row[r] += 1\\n                    col[c] += 1\\n                    if c == r:\\n                        dia1 += 1\\n                    if c + r == 2:\\n                        dia2 += 1\\n                elif board[r][c] == \\'O\\':\\n                    Os += 1\\n                    row[r] -= 1\\n                    col[c] -= 1\\n                    if c == r:\\n                        dia1 -= 1\\n                    if c + r == 2:\\n                        dia2 -= 1\\n           \\n        if max(max(row), dia1, dia2, max(col)) == 3: #X is winning, then O cannot win or cannot move after X wins\\n            if Xs == Os + 1 and min(min(row), dia1, dia2, min(col)) > -3:\\n                return True\\n        elif min(min(row), dia1, dia2, min(col)) == -3: #O is winning, then X cannot win or cannot move after X wins\\n            if Xs == Os and max(max(row), dia1, dia2, max(col)) < 3:\\n                return True\\n        else: #nobody is winning\\n            if ((Xs == Os) or (Xs == Os + 1)):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890007,
                "title": "java-simple-idea-faster-than-100",
                "content": "The idea is:\\n- Encode X = 1, O = -1, \\' \\' = 0\\n- Calculate sums of row, column, diagnal, if any sum is 3, X wins; if any sum is -3, O wins\\n- Valid if total sum of all is 0 (same Xs as Os), X cannot win; doesn\\'t matter if O wins or not, still valid\\n- Valid if total sum of all is 1 (one more Os than Xs), O cannot win; doesn\\'t matter if X wins or not, still valid\\n\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        //X=1,O=-1,\\u2019 \\u2019=0\\n        int sum=0; \\n        int[] wins_col=new int[3];\\n        int[] wins_diag=new int[2];\\n        Boolean x_win=Boolean.FALSE;Boolean o_win=Boolean.FALSE;\\n        \\n        for(int i=0;i<3;i++){\\n            String str = board[i];\\n            int row_sum=0;\\n            for(int j=0;j<3;j++){\\n                //char chr=str.toCharArray()[j];\\n                int intchr=0;\\n                if(str.toCharArray()[j]==\\'X\\')\\n                    intchr=1;\\n                if(str.toCharArray()[j]==\\'O\\')\\n                    intchr=-1;\\n                row_sum+=intchr;\\n                wins_col[j]+=intchr;\\n                if(i==2 && wins_col[j]==3)\\n                    x_win=Boolean.TRUE;\\n                if(i==2 && wins_col[j]==-3)\\n                    o_win=Boolean.TRUE;\\n\\n                if(Math.abs(i-j)!=1){\\n                    if(i==j && i == 1){\\n                        wins_diag[0]+=intchr;\\n                        wins_diag[1]+=intchr;\\n                    }\\n                    else if(i==j)\\n                        wins_diag[0]+=intchr;\\n                    else\\n                        wins_diag[1]+=intchr;\\n                }\\n                if(i==2 && Math.max(wins_diag[0],wins_diag[1])==3)\\n                    x_win=Boolean.TRUE;\\n                if(i==2 && Math.min(wins_diag[0],wins_diag[1])==-3)\\n                    o_win=Boolean.TRUE;\\n            }\\n            if(row_sum == 3)\\n                x_win=Boolean.TRUE;\\n            if(row_sum == -3)\\n                o_win=Boolean.TRUE;\\n\\n            sum+=row_sum;\\n\\n        }\\n        if(sum == 0 && !x_win)\\n\\t        return true;\\n        if(sum == 1 && !o_win)\\n            return true;\\n\\t    return false;\\n    }\\n}\\n```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Valid Tic-Tac-Toe State.\\nMemory Usage: 39.4 MB, less than 93.92% of Java online submissions for Valid Tic-Tac-Toe State.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        //X=1,O=-1,\\u2019 \\u2019=0\\n        int sum=0; \\n        int[] wins_col=new int[3];\\n        int[] wins_diag=new int[2];\\n        Boolean x_win=Boolean.FALSE;Boolean o_win=Boolean.FALSE;\\n        \\n        for(int i=0;i<3;i++){\\n            String str = board[i];\\n            int row_sum=0;\\n            for(int j=0;j<3;j++){\\n                //char chr=str.toCharArray()[j];\\n                int intchr=0;\\n                if(str.toCharArray()[j]==\\'X\\')\\n                    intchr=1;\\n                if(str.toCharArray()[j]==\\'O\\')\\n                    intchr=-1;\\n                row_sum+=intchr;\\n                wins_col[j]+=intchr;\\n                if(i==2 && wins_col[j]==3)\\n                    x_win=Boolean.TRUE;\\n                if(i==2 && wins_col[j]==-3)\\n                    o_win=Boolean.TRUE;\\n\\n                if(Math.abs(i-j)!=1){\\n                    if(i==j && i == 1){\\n                        wins_diag[0]+=intchr;\\n                        wins_diag[1]+=intchr;\\n                    }\\n                    else if(i==j)\\n                        wins_diag[0]+=intchr;\\n                    else\\n                        wins_diag[1]+=intchr;\\n                }\\n                if(i==2 && Math.max(wins_diag[0],wins_diag[1])==3)\\n                    x_win=Boolean.TRUE;\\n                if(i==2 && Math.min(wins_diag[0],wins_diag[1])==-3)\\n                    o_win=Boolean.TRUE;\\n            }\\n            if(row_sum == 3)\\n                x_win=Boolean.TRUE;\\n            if(row_sum == -3)\\n                o_win=Boolean.TRUE;\\n\\n            sum+=row_sum;\\n\\n        }\\n        if(sum == 0 && !x_win)\\n\\t        return true;\\n        if(sum == 1 && !o_win)\\n            return true;\\n\\t    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853737,
                "title": "c-0ms-easy-and-case-by-case-evaluation-a-little-long-and-fully-commented",
                "content": "```\\nclass Solution {\\npublic:\\nbool validTicTacToe(vector<string>& board) {\\n        int playerOneMoves=0,playerTwoMoves=0;\\n        for(int i=0; i<3; i++) {\\n                for(int j=0; j<3; j++) {\\n                        //check current char and increase the playerMove Count respectively\\n                        char currentChar=board[i][j];\\n                        if(currentChar==\\' \\')\\n                                continue;\\n                        currentChar==\\'X\\'?playerOneMoves++:playerTwoMoves++;\\n                }\\n        }\\n\\n        //This case can\\'t happen in a valid game as playerOne is making the first move\\n        if(playerTwoMoves>playerOneMoves)\\n                return false;\\n\\n        //playerOne can be atmost 1 move ahead of playerTwo\\n        if(playerOneMoves-1>playerTwoMoves)\\n                return false;\\n\\n        //both have make equal number of moves to reach here.\\n        //so last move would have been made by playerTwo and it would be valid only if playerOne hasn\\'t won the game till that point.\\n        if(playerOneMoves==playerTwoMoves) {\\n                //for this to happen playerOne must not have win the game in previous moves\\n                if(hasWon(\\'X\\',board)) return false;\\n                return true;\\n\\n        }\\n\\n        //playerOne is 1 move ahead of playerTwo again that would only be possible if playerTwo hadn\\'t won the game\\n        //in this previous move.\\n        if(playerOneMoves-1==playerTwoMoves) {\\n                // for playerOne to make his most recent move playerTwo must not have won in previous moves\\n                if(hasWon(\\'O\\',board)) return false;\\n                return true;\\n        }\\n        return false;\\n}\\n\\n// check is player has won the game or not.\\nbool hasWon(char player,vector<string>&board){\\n\\n        int count=0;\\n        //checking each row\\n        for(int i=0; i<3; i++) {\\n                int count=0;\\n                for(int j=0; j<3; j++) {\\n                        if(board[i][j]==player)\\n                                count++;\\n                }\\n                if(count==3)\\n                        return true;\\n        }\\n\\n        //checking in coloumn\\n        for(int i=0; i<3; i++) {\\n                int count=0;\\n                for(int j=0; j<3; j++) {\\n                        if(board[j][i]==player)\\n                                count++;\\n                }\\n                if(count==3)\\n                        return true;\\n        }\\n\\n        //check both diagnols\\n        if(board[0][0]==player&&board[1][1]==player&&board[2][2]==player)\\n                return true;\\n\\n        if(board[2][0]==player&&board[1][1]==player&&board[0][2]==player)\\n                return true;\\n\\n        return false;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool validTicTacToe(vector<string>& board) {\\n        int playerOneMoves=0,playerTwoMoves=0;\\n        for(int i=0; i<3; i++) {\\n                for(int j=0; j<3; j++) {\\n                        //check current char and increase the playerMove Count respectively\\n                        char currentChar=board[i][j];\\n                        if(currentChar==\\' \\')\\n                                continue;\\n                        currentChar==\\'X\\'?playerOneMoves++:playerTwoMoves++;\\n                }\\n        }\\n\\n        //This case can\\'t happen in a valid game as playerOne is making the first move\\n        if(playerTwoMoves>playerOneMoves)\\n                return false;\\n\\n        //playerOne can be atmost 1 move ahead of playerTwo\\n        if(playerOneMoves-1>playerTwoMoves)\\n                return false;\\n\\n        //both have make equal number of moves to reach here.\\n        //so last move would have been made by playerTwo and it would be valid only if playerOne hasn\\'t won the game till that point.\\n        if(playerOneMoves==playerTwoMoves) {\\n                //for this to happen playerOne must not have win the game in previous moves\\n                if(hasWon(\\'X\\',board)) return false;\\n                return true;\\n\\n        }\\n\\n        //playerOne is 1 move ahead of playerTwo again that would only be possible if playerTwo hadn\\'t won the game\\n        //in this previous move.\\n        if(playerOneMoves-1==playerTwoMoves) {\\n                // for playerOne to make his most recent move playerTwo must not have won in previous moves\\n                if(hasWon(\\'O\\',board)) return false;\\n                return true;\\n        }\\n        return false;\\n}\\n\\n// check is player has won the game or not.\\nbool hasWon(char player,vector<string>&board){\\n\\n        int count=0;\\n        //checking each row\\n        for(int i=0; i<3; i++) {\\n                int count=0;\\n                for(int j=0; j<3; j++) {\\n                        if(board[i][j]==player)\\n                                count++;\\n                }\\n                if(count==3)\\n                        return true;\\n        }\\n\\n        //checking in coloumn\\n        for(int i=0; i<3; i++) {\\n                int count=0;\\n                for(int j=0; j<3; j++) {\\n                        if(board[j][i]==player)\\n                                count++;\\n                }\\n                if(count==3)\\n                        return true;\\n        }\\n\\n        //check both diagnols\\n        if(board[0][0]==player&&board[1][1]==player&&board[2][2]==player)\\n                return true;\\n\\n        if(board[2][0]==player&&board[1][1]==player&&board[0][2]==player)\\n                return true;\\n\\n        return false;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739474,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # Get the number of \\'X\\' and \\'O\\' in the board\\n        nx, no = 0, 0\\n        for i in range(3):\\n            for j in range(3):\\n                if board[i][j] == \\'O\\':\\n                    no += 1\\n                elif board[i][j] == \\'X\\':\\n                    nx += 1\\n        \\n        # Check the number difference between \\'X\\' and \\'O\\'\\n        if nx != no and nx != no + 1:\\n            return False\\n        \\n        # Check which player win\\n        win_x = False\\n        win_o = False\\n        \\n        rows = [0, 0, 0] # The sum of each row\\n        cols = [0, 0, 0] # The sum of each col\\n        diags = [0, 0] # The sum of two diag\\n        \\n        # Let empty, X, O to be 0, 1, -1\\n        # Compute the sum of rows, cols, diags\\n        for i in range(3):\\n            for j in range(3):\\n                if board[i][j] == \\' \\':\\n                    continue\\n                    \\n                value = 1 if board[i][j] == \\'X\\' else -1\\n                rows[i] += value\\n                cols[j] += value\\n                \\n                if i == j:\\n                    diags[0] += value\\n                if i + j == 2:\\n                    diags[1] += value\\n        \\n        # If X occupies a row, col or diag, then the sum should be equal to 3\\n        if 3 in rows or 3 in cols or 3 in diags:\\n            win_x = True\\n        # If O occupies a row, col or diag, then the sum should be equal to -3\\n        if -3 in rows or -3 in cols or -3 in diags:\\n            win_o = True\\n        \\n        # Consider the following 4 cases.\\n        # 1) Both win, impossible\\n        # 2) 1st Player win, then X = O + 1\\n        # 3) 2nd Player win, then X = O\\n        # 4) Neither wins, X can be O or O + 1\\n        \\n        if win_x and win_o:\\n            return False\\n        elif win_x:\\n            return nx == no + 1\\n        elif win_o:\\n            return nx == no\\n        else:\\n            # We have already ensured X == O or O + 1 in the beginning\\n            return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # Get the number of \\'X\\' and \\'O\\' in the board\\n        nx, no = 0, 0\\n        for i in range(3):\\n            for j in range(3):\\n                if board[i][j] == \\'O\\':\\n                    no += 1\\n                elif board[i][j] == \\'X\\':\\n                    nx += 1\\n        \\n        # Check the number difference between \\'X\\' and \\'O\\'\\n        if nx != no and nx != no + 1:\\n            return False\\n        \\n        # Check which player win\\n        win_x = False\\n        win_o = False\\n        \\n        rows = [0, 0, 0] # The sum of each row\\n        cols = [0, 0, 0] # The sum of each col\\n        diags = [0, 0] # The sum of two diag\\n        \\n        # Let empty, X, O to be 0, 1, -1\\n        # Compute the sum of rows, cols, diags\\n        for i in range(3):\\n            for j in range(3):\\n                if board[i][j] == \\' \\':\\n                    continue\\n                    \\n                value = 1 if board[i][j] == \\'X\\' else -1\\n                rows[i] += value\\n                cols[j] += value\\n                \\n                if i == j:\\n                    diags[0] += value\\n                if i + j == 2:\\n                    diags[1] += value\\n        \\n        # If X occupies a row, col or diag, then the sum should be equal to 3\\n        if 3 in rows or 3 in cols or 3 in diags:\\n            win_x = True\\n        # If O occupies a row, col or diag, then the sum should be equal to -3\\n        if -3 in rows or -3 in cols or -3 in diags:\\n            win_o = True\\n        \\n        # Consider the following 4 cases.\\n        # 1) Both win, impossible\\n        # 2) 1st Player win, then X = O + 1\\n        # 3) 2nd Player win, then X = O\\n        # 4) Neither wins, X can be O or O + 1\\n        \\n        if win_x and win_o:\\n            return False\\n        elif win_x:\\n            return nx == no + 1\\n        elif win_o:\\n            return nx == no\\n        else:\\n            # We have already ensured X == O or O + 1 in the beginning\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703373,
                "title": "0ms-100-faster-with-simple-logic-and-explanation-also-short-than-others",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n       \\n        int cO=0, cX=0;\\n        for(int x=0; x<3; x++){\\n            for(int y=0; y<3; y++){\\n                char ch=board[x].charAt(y);\\n                if(ch == \\'O\\')\\n                    cO++;\\n                else if(ch == \\'X\\')\\n                    cX++;                \\n            }\\n        }  \\n        char a1=board[0].charAt(0);\\n        char a2=board[0].charAt(1);\\n        char a3=board[0].charAt(2);\\n        char a4=board[1].charAt(0);\\n        char a5=board[1].charAt(1);\\n        char a6=board[1].charAt(2);\\n        char a7=board[2].charAt(0);\\n        char a8=board[2].charAt(1);\\n        char a9=board[2].charAt(2);\\n        \\n        //The main thing here is we just need to check if the given sequence is possible or not.\\n        //We dont need to find any winner. *Logic is the one who has last chance can be in 1 row, column(horizontally,vertically or diagonally) not the other one.\\n        //So few cases will arise \\n        //1) Count of \\'X\\' is 1 more than count of \\'O\\'-> Only X can win and \\'O\\' cannot win (Last Chance is with X so only X can win)\\n        //2) Count of \\'X\\' is equal to count of \\'O\\'   -> Only \\'O\\' can win and \\'X\\' cannot win(Check few cases)(Last Chance is with \\'O\\' so only \\'O\\' can win)\\n        //3) return false (rest all are invalid case)\\n        \\n        \\n        // Eg - if X=4 and O=3 (ie Count of \\'O\\' is 1 less) then \\'O\\' cannot win and \\n        //if we find such a case then we need to return false else the sequence is fine(try yourself & see) \\n         if( (cX-1) == cO ){\\n             if( (a1==a2 && a2==a3 && a1==\\'O\\')||    //These are all horizaontal, vertical, diagonal \\n                (a4==a5 && a5==a6 && a4==\\'O\\')||     //positions to check\\n                (a7==a8 && a8==a9 && a7==\\'O\\')||\\n                (a1==a5 && a5==a9 && a1==\\'O\\')||\\n                (a3==a5 && a5==a7 && a3==\\'O\\')||\\n                (a1==a4 && a4==a7 && a1==\\'O\\')||\\n                (a2==a5 && a5==a8 && a2==\\'O\\')||\\n                (a3==a6 && a6==a9 && a3==\\'O\\') )\\n                return false;\\n             else\\n                 return true;\\n         }\\n        //if X=4 and O=4 (ie both r equal) then \\'X\\' cannot win amd\\n        //if we find such a case then we need to return false else the sequence is fine(try yourself & see)\\n        else if(cX==cO){            \\n            if( (a1==a2 && a2==a3 && a1==\\'X\\')||\\n                (a4==a5 && a5==a6 && a4==\\'X\\')||\\n                (a7==a8 && a8==a9 && a7==\\'X\\')||\\n                (a1==a5 && a5==a9 && a1==\\'X\\')||\\n                (a3==a5 && a5==a7 && a3==\\'X\\')||\\n                (a1==a4 && a4==a7 && a1==\\'X\\')||\\n                (a2==a5 && a5==a8 && a2==\\'X\\')||\\n                (a3==a6 && a6==a9 && a3==\\'X\\') )\\n                return false;\\n            else\\n                return true;\\n        }          \\n        return false;\\n    }\\n}\\n```\\nPlease UPVOTE",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n       \\n        int cO=0, cX=0;\\n        for(int x=0; x<3; x++){\\n            for(int y=0; y<3; y++){\\n                char ch=board[x].charAt(y);\\n                if(ch == \\'O\\')\\n                    cO++;\\n                else if(ch == \\'X\\')\\n                    cX++;                \\n            }\\n        }  \\n        char a1=board[0].charAt(0);\\n        char a2=board[0].charAt(1);\\n        char a3=board[0].charAt(2);\\n        char a4=board[1].charAt(0);\\n        char a5=board[1].charAt(1);\\n        char a6=board[1].charAt(2);\\n        char a7=board[2].charAt(0);\\n        char a8=board[2].charAt(1);\\n        char a9=board[2].charAt(2);\\n        \\n        //The main thing here is we just need to check if the given sequence is possible or not.\\n        //We dont need to find any winner. *Logic is the one who has last chance can be in 1 row, column(horizontally,vertically or diagonally) not the other one.\\n        //So few cases will arise \\n        //1) Count of \\'X\\' is 1 more than count of \\'O\\'-> Only X can win and \\'O\\' cannot win (Last Chance is with X so only X can win)\\n        //2) Count of \\'X\\' is equal to count of \\'O\\'   -> Only \\'O\\' can win and \\'X\\' cannot win(Check few cases)(Last Chance is with \\'O\\' so only \\'O\\' can win)\\n        //3) return false (rest all are invalid case)\\n        \\n        \\n        // Eg - if X=4 and O=3 (ie Count of \\'O\\' is 1 less) then \\'O\\' cannot win and \\n        //if we find such a case then we need to return false else the sequence is fine(try yourself & see) \\n         if( (cX-1) == cO ){\\n             if( (a1==a2 && a2==a3 && a1==\\'O\\')||    //These are all horizaontal, vertical, diagonal \\n                (a4==a5 && a5==a6 && a4==\\'O\\')||     //positions to check\\n                (a7==a8 && a8==a9 && a7==\\'O\\')||\\n                (a1==a5 && a5==a9 && a1==\\'O\\')||\\n                (a3==a5 && a5==a7 && a3==\\'O\\')||\\n                (a1==a4 && a4==a7 && a1==\\'O\\')||\\n                (a2==a5 && a5==a8 && a2==\\'O\\')||\\n                (a3==a6 && a6==a9 && a3==\\'O\\') )\\n                return false;\\n             else\\n                 return true;\\n         }\\n        //if X=4 and O=4 (ie both r equal) then \\'X\\' cannot win amd\\n        //if we find such a case then we need to return false else the sequence is fine(try yourself & see)\\n        else if(cX==cO){            \\n            if( (a1==a2 && a2==a3 && a1==\\'X\\')||\\n                (a4==a5 && a5==a6 && a4==\\'X\\')||\\n                (a7==a8 && a8==a9 && a7==\\'X\\')||\\n                (a1==a5 && a5==a9 && a1==\\'X\\')||\\n                (a3==a5 && a5==a7 && a3==\\'X\\')||\\n                (a1==a4 && a4==a7 && a1==\\'X\\')||\\n                (a2==a5 && a5==a8 && a2==\\'X\\')||\\n                (a3==a6 && a6==a9 && a3==\\'X\\') )\\n                return false;\\n            else\\n                return true;\\n        }          \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540228,
                "title": "0ms-simple-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool winn(vector<string> brd,char c)  // Checking all vertical lines,horizontal lines and the two dialgonals to conclude a win\\n    {\\n        if((brd[0][0 ]== c && brd[1][0] == c&& brd[2][0] == c)||(brd[0][1] == c && brd[1][1]==c && brd[2][1] == c)\\n           ||(brd[0][2] == c && brd[1][2] == c && brd[2][2] == c)||(brd[0][0] == c && brd[0][1] == c && brd[0][2] == c)\\n           ||(brd[1][0] == c && brd[1][1] == c && brd[1][2] == c)||(brd[2][0] == c && brd[2][1] == c && brd[2][2] == c)\\n           ||(brd[0][0] == c && brd[1][1] == c && brd[2][2] == c)||(brd[0][2] == c && brd[1][1] == c && brd[2][0] == c)) \\n        {\\n          return(true);\\n        }\\n        return(false);\\n    }\\n    bool validTicTacToe(vector<string>& board) \\n    {\\n        int x = 0,o = 0;          //x tracks count of \\'X\\'       and          o tracks the occurance of \\'O\\'\\n        for(string s : board)\\n        {\\n            for(char c : s)\\n            {\\n                if( c == \\'X\\')\\n                {\\n                    x++;\\n                }\\n                else if(c == \\'O\\')\\n                {\\n                    o++;\\n                }\\n            }\\n        }\\n        if(x == o || x == o+1)      // the frequency of X in a valid game is either equal to the (frequency of O) or equal to (frequency of O +1)\\n        {\\n            bool win_x = winn(board,\\'X\\'),win_o = winn(board,\\'O\\');\\n            if(win_x)        // If X wins then surely O shouldn\\'t win in a valid game\\n            {\\n                if(win_o)       //If O wins then surely board is invalid\\n                {\\n                    return false;\\n                }\\n                return (x == o + 1);         //If X wins then surely the frequency of X is = Frequency of O  (AS X played first)\\n            }\\n            if(win_o)           //If O wins then surely the frequency of O is = Frequency of X  (AS O played second, it can\\'t play more moves than X)\\n            {\\n                return (x == o);\\n            }\\n            return true;     //If nobdy wins then its a valid board, as the frequency condition is satisfied\\n        }\\n        return false;    \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool winn(vector<string> brd,char c)  // Checking all vertical lines,horizontal lines and the two dialgonals to conclude a win\\n    {\\n        if((brd[0][0 ]== c && brd[1][0] == c&& brd[2][0] == c)||(brd[0][1] == c && brd[1][1]==c && brd[2][1] == c)\\n           ||(brd[0][2] == c && brd[1][2] == c && brd[2][2] == c)||(brd[0][0] == c && brd[0][1] == c && brd[0][2] == c)\\n           ||(brd[1][0] == c && brd[1][1] == c && brd[1][2] == c)||(brd[2][0] == c && brd[2][1] == c && brd[2][2] == c)\\n           ||(brd[0][0] == c && brd[1][1] == c && brd[2][2] == c)||(brd[0][2] == c && brd[1][1] == c && brd[2][0] == c)) \\n        {\\n          return(true);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1446606,
                "title": "elegant-python-solution",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        \\n        board = \\'\\'.join(board)\\n        \\n        counter = Counter(board)\\n        \\n        def win(player, board):\\n            condition = player * 3    \\n            # horizontal\\n            for i in [0,3,6]:\\n                if condition == board[i:i+3]:\\n                    return True\\n            # vertical\\n            for i in [0,1,2]:\\n                if condition == board[i:i+7:3]:\\n                    return True\\n            # diagonal\\n            if condition in [board[::4], board[2:7:2]]:\\n                return True\\n            \\n            return False\\n        \\n        # X must not win in this case\\n        if counter[\\'X\\'] == counter[\\'O\\']:\\n            return not win(\\'X\\', board)\\n        # O must not win in this case\\n        elif counter[\\'X\\'] == counter[\\'O\\'] + 1:\\n            return not win(\\'O\\', board)\\n                \\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        \\n        board = \\'\\'.join(board)\\n        \\n        counter = Counter(board)\\n        \\n        def win(player, board):\\n            condition = player * 3    \\n            # horizontal\\n            for i in [0,3,6]:\\n                if condition == board[i:i+3]:\\n                    return True\\n            # vertical\\n            for i in [0,1,2]:\\n                if condition == board[i:i+7:3]:\\n                    return True\\n            # diagonal\\n            if condition in [board[::4], board[2:7:2]]:\\n                return True\\n            \\n            return False\\n        \\n        # X must not win in this case\\n        if counter[\\'X\\'] == counter[\\'O\\']:\\n            return not win(\\'X\\', board)\\n        # O must not win in this case\\n        elif counter[\\'X\\'] == counter[\\'O\\'] + 1:\\n            return not win(\\'O\\', board)\\n                \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363242,
                "title": "24ms-faster-than-97-python3-solution",
                "content": "This is more of an **if-else** problem. You have to think of every edge case.\\n\\n```python\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        X,O = self.countSymbols(board)\\n        if O>X:\\n\\t\\t    #Os can\\'t  be greater than Xs\\n            return False\\n        elif abs(X-O)>1:\\n\\t\\t    #Difference can only be 1 \\n            return False\\n        elif X>O:\\n\\t\\t    #X can\\'t have more moves than O if O is already won\\n            if self.checkTriads(board,\\'O\\'): return False\\n        else:\\n\\t\\t    #X and O can\\'t have equal moves if X is winning\\n            if self.checkTriads(board,\\'X\\'): return False\\n        return True\\n            \\n    \\n    def countSymbols(self, board):\\n        X = 0\\n        O = 0\\n        for row in board:\\n            for i in row:\\n                if i == \\'X\\':\\n                    X+=1\\n                elif i == \\'O\\':\\n                    O+=1\\n        return X,O\\n                    \\n    def checkTriads(self, board, sym=\\'X\\'):\\n        #Checking for Hight triads\\n        i = 0\\n        while i<3:\\n            if (board[0][i] == board[1][i] == board[2][i] == sym):\\n                return True\\n            i+=1\\n            \\n        #Checking for width\\n        i=0\\n        while i<3:\\n            if (board[i][0] == board[i][1] == board[i][2] == sym):\\n                return True\\n            i+=1\\n            \\n        #Checking for diag.\\n        if (board[0][0] == board[1][1] == board[2][2] == sym):\\n                return True\\n        if (board[0][2] == board[1][1] == board[2][0] == sym):\\n                return True\\n        return False\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "This is more of an **if-else** problem. You have to think of every edge case.\\n\\n```python\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        X,O = self.countSymbols(board)\\n        if O>X:\\n\\t\\t    #Os can\\'t  be greater than Xs\\n            return False\\n        elif abs(X-O)>1:\\n\\t\\t    #Difference can only be 1 \\n            return False\\n        elif X>O:\\n\\t\\t    #X can\\'t have more moves than O if O is already won\\n            if self.checkTriads(board,\\'O\\'): return False\\n        else:\\n\\t\\t    #X and O can\\'t have equal moves if X is winning\\n            if self.checkTriads(board,\\'X\\'): return False\\n        return True\\n            \\n    \\n    def countSymbols(self, board):\\n        X = 0\\n        O = 0\\n        for row in board:\\n            for i in row:\\n                if i == \\'X\\':\\n                    X+=1\\n                elif i == \\'O\\':\\n                    O+=1\\n        return X,O\\n                    \\n    def checkTriads(self, board, sym=\\'X\\'):\\n        #Checking for Hight triads\\n        i = 0\\n        while i<3:\\n            if (board[0][i] == board[1][i] == board[2][i] == sym):\\n                return True\\n            i+=1\\n            \\n        #Checking for width\\n        i=0\\n        while i<3:\\n            if (board[i][0] == board[i][1] == board[i][2] == sym):\\n                return True\\n            i+=1\\n            \\n        #Checking for diag.\\n        if (board[0][0] == board[1][1] == board[2][2] == sym):\\n                return True\\n        if (board[0][2] == board[1][1] == board[2][0] == sym):\\n                return True\\n        return False\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1263090,
                "title": "very-easy-solution-just-count-the-number-of-x-and-o",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        \\n        int cx=0,co=0,wonx=0,wono=0;\\n        \\n        char[][] arr = new char[3][3];\\n        \\n        for(int i =0; i<board.length; i++)\\n        {\\n            String temp = board[i];\\n            if(temp.equals(\"XXX\"))        //checking if X is winner in rows\\n                wonx = 1;\\n            if(temp.equals(\"OOO\"))      // checking if O is winner in rows\\n                wono = 1;\\n            \\n            for(int j=0; j<temp.length(); j++)\\n            {\\n                arr[i][j] = temp.charAt(j);\\n                if(temp.charAt(j)==\\'X\\')\\n                    cx++;                         // counting no. of X\\n                else if(temp.charAt(j)==\\'O\\')\\n                    co++;                        // counting no. of O\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<3; i++)\\n        {\\n            if(arr[0][i]==\\'X\\' && arr[1][i]==\\'X\\' && arr[2][i]==\\'X\\')    //checking if X is winner in columns\\n                wonx = 1;\\n            if(arr[0][i]==\\'O\\' && arr[1][i]==\\'O\\' && arr[2][i]==\\'O\\')   //checking if O is winner in columns\\n                wono = 1;\\n            \\n            \\n        }\\n        if(arr[0][0]==\\'X\\' && arr[1][1]==\\'X\\' && arr[2][2]==\\'X\\')   //checking if X is winner \\'\\\\\\' in diogonal\\n            wonx=1;\\n        \\n        if(arr[0][0]==\\'O\\' && arr[1][1]==\\'O\\' && arr[2][2]==\\'O\\')  // checking if O is winner \\'\\\\\\' in diogonal\\n            wono=1;\\n        \\n        if(arr[0][2]==\\'X\\' && arr[1][1]==\\'X\\' && arr[2][0]==\\'X\\' )    //checking if X is winner \\'/\\' in diogonal\\n            wonx=1;\\n        \\n        if(arr[0][2]==\\'O\\' && arr[1][1]==\\'O\\' && arr[2][0]==\\'O\\' )   //checking if O is winner \\'/\\' in diogonal\\n            wono=1;\\n        \\n        \\n        if((wonx==1 && wono==1))   //both X and O can\\'t win\\n            return false;\\n        \\n        if(cx - co > 1  || cx - co < 0)     //there count can\\'t cross [0,1] range coz they mark X and O one by one\\n            return false;\\n        \\n        if((wonx==1 && wono==0) && cx - co==1)  //if X won  cx - co can\\'t exceed 1 coz X goes first and and after winning game should stop\\n            return true;\\n        \\n        if((wono==1 && wonx==0)  && cx==co)    //if O won  cx - co can\\'t exceed 0 coz X goes first and and after winning game should stop\\n            return true;\\n        \\n        if((wonx==0 && wono ==0) && ((cx - co==0) || (cx - co ==1)) )  // if none of them won just take care of their moves i.e. they took their chances one by one\\n            return true;\\n        \\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        \\n        int cx=0,co=0,wonx=0,wono=0;\\n        \\n        char[][] arr = new char[3][3];\\n        \\n        for(int i =0; i<board.length; i++)\\n        {\\n            String temp = board[i];\\n            if(temp.equals(\"XXX\"))        //checking if X is winner in rows\\n                wonx = 1;\\n            if(temp.equals(\"OOO\"))      // checking if O is winner in rows\\n                wono = 1;\\n            \\n            for(int j=0; j<temp.length(); j++)\\n            {\\n                arr[i][j] = temp.charAt(j);\\n                if(temp.charAt(j)==\\'X\\')\\n                    cx++;                         // counting no. of X\\n                else if(temp.charAt(j)==\\'O\\')\\n                    co++;                        // counting no. of O\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<3; i++)\\n        {\\n            if(arr[0][i]==\\'X\\' && arr[1][i]==\\'X\\' && arr[2][i]==\\'X\\')    //checking if X is winner in columns\\n                wonx = 1;\\n            if(arr[0][i]==\\'O\\' && arr[1][i]==\\'O\\' && arr[2][i]==\\'O\\')   //checking if O is winner in columns\\n                wono = 1;\\n            \\n            \\n        }\\n        if(arr[0][0]==\\'X\\' && arr[1][1]==\\'X\\' && arr[2][2]==\\'X\\')   //checking if X is winner \\'\\\\\\' in diogonal\\n            wonx=1;\\n        \\n        if(arr[0][0]==\\'O\\' && arr[1][1]==\\'O\\' && arr[2][2]==\\'O\\')  // checking if O is winner \\'\\\\\\' in diogonal\\n            wono=1;\\n        \\n        if(arr[0][2]==\\'X\\' && arr[1][1]==\\'X\\' && arr[2][0]==\\'X\\' )    //checking if X is winner \\'/\\' in diogonal\\n            wonx=1;\\n        \\n        if(arr[0][2]==\\'O\\' && arr[1][1]==\\'O\\' && arr[2][0]==\\'O\\' )   //checking if O is winner \\'/\\' in diogonal\\n            wono=1;\\n        \\n        \\n        if((wonx==1 && wono==1))   //both X and O can\\'t win\\n            return false;\\n        \\n        if(cx - co > 1  || cx - co < 0)     //there count can\\'t cross [0,1] range coz they mark X and O one by one\\n            return false;\\n        \\n        if((wonx==1 && wono==0) && cx - co==1)  //if X won  cx - co can\\'t exceed 1 coz X goes first and and after winning game should stop\\n            return true;\\n        \\n        if((wono==1 && wonx==0)  && cx==co)    //if O won  cx - co can\\'t exceed 0 coz X goes first and and after winning game should stop\\n            return true;\\n        \\n        if((wonx==0 && wono ==0) && ((cx - co==0) || (cx - co ==1)) )  // if none of them won just take care of their moves i.e. they took their chances one by one\\n            return true;\\n        \\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237638,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool ValidTicTacToe(string[] board) \\n    {\\n        int xc = 0;\\n        int oc = 0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[i][j]==\\'X\\')\\n                    xc++;\\n                else if(board[i][j]==\\'O\\')\\n                    oc++;\\n            }\\n        }\\n        \\n        if(xc-oc > 1 || oc>xc)\\n            return false;\\n        \\n        if(WinningMove(board,\\'X\\') && WinningMove(board,\\'O\\'))\\n            return false;\\n        \\n        if(WinningMove(board,\\'X\\') && xc==oc)\\n            return false;\\n        \\n        if(WinningMove(board,\\'O\\') && xc>oc)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private bool WinningMove(string[] b, char c)\\n    {\\n        bool wm1 = b[0][0]==c && b[0][1]==c && b[0][2]==c;\\n        bool wm2 = b[0][0]==c && b[1][1]==c && b[2][2]==c;\\n        bool wm3 = b[0][0]==c && b[1][0]==c && b[2][0]==c;\\n        bool wm4 = b[1][0]==c && b[1][1]==c && b[1][2]==c;\\n        bool wm5 = b[2][0]==c && b[2][1]==c && b[2][2]==c;\\n        bool wm6 = b[2][0]==c && b[1][1]==c && b[0][2]==c;\\n        bool wm7 = b[0][2]==c && b[1][2]==c && b[2][2]==c;\\n        bool wm8 = b[0][1]==c && b[1][1]==c && b[2][1]==c;\\n        \\n        if(wm1 || wm2 || wm3 || wm4 || wm5 || wm6 || wm7 || wm8)\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool ValidTicTacToe(string[] board) \\n    {\\n        int xc = 0;\\n        int oc = 0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[i][j]==\\'X\\')\\n                    xc++;\\n                else if(board[i][j]==\\'O\\')\\n                    oc++;\\n            }\\n        }\\n        \\n        if(xc-oc > 1 || oc>xc)\\n            return false;\\n        \\n        if(WinningMove(board,\\'X\\') && WinningMove(board,\\'O\\'))\\n            return false;\\n        \\n        if(WinningMove(board,\\'X\\') && xc==oc)\\n            return false;\\n        \\n        if(WinningMove(board,\\'O\\') && xc>oc)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private bool WinningMove(string[] b, char c)\\n    {\\n        bool wm1 = b[0][0]==c && b[0][1]==c && b[0][2]==c;\\n        bool wm2 = b[0][0]==c && b[1][1]==c && b[2][2]==c;\\n        bool wm3 = b[0][0]==c && b[1][0]==c && b[2][0]==c;\\n        bool wm4 = b[1][0]==c && b[1][1]==c && b[1][2]==c;\\n        bool wm5 = b[2][0]==c && b[2][1]==c && b[2][2]==c;\\n        bool wm6 = b[2][0]==c && b[1][1]==c && b[0][2]==c;\\n        bool wm7 = b[0][2]==c && b[1][2]==c && b[2][2]==c;\\n        bool wm8 = b[0][1]==c && b[1][1]==c && b[2][1]==c;\\n        \\n        if(wm1 || wm2 || wm3 || wm4 || wm5 || wm6 || wm7 || wm8)\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222790,
                "title": "0ms-java-with-comments",
                "content": "\\tclass Solution {\\n\\n\\t//     This function will count the number of character c in board\\n\\t\\tpublic int count(char[][] board, char c) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0; i<board.length; i++) {\\n\\t\\t\\t\\tfor(char ce: board[i]) {\\n\\t\\t\\t\\t\\tif(ce == c) count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t//     Valid state is when 2 rows or 2 columns doesn\\'t have the winning state.\\n\\t\\tpublic char checkValidState(char[][] board) {\\n\\t\\t\\tchar winner = \\'!\\';\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0; i<board.length; i++) {\\n\\t\\t\\t\\tif(board[i][0]!= \\' \\' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\\n\\t\\t\\t\\t\\twinner = board[i][0];\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t//         Two rows have winning state hence wrong \\n\\t\\t\\tif(count > 1) return \\'?\\';\\n\\t\\t\\tcount = 0;\\n\\t\\t\\tfor(int j=0; j<board[0].length; j++) {\\n\\t\\t\\t\\tif(board[0][j]!= \\' \\' && board[0][j] == board[1][j] && board[1][j] == board[2][j]) {\\n\\t\\t\\t\\t\\twinner = board[0][j];\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t//         Two columns have winning state hence wrong \\n\\t\\t\\tif(count > 1) return \\'?\\';\\n\\t//         Winning states an also be present in 1 of the 2 diagnals\\n\\t\\t\\tif(board[0][0] != \\' \\' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) winner = board[0][0];\\n\\t\\t\\tif(board[0][2] != \\' \\' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) winner = board[2][0];\\n\\t\\t\\treturn winner;\\n\\t\\t}\\n\\n\\n\\n\\t\\tpublic boolean validTicTacToe(String[] b) {\\n\\n\\t\\t\\tchar[][] board = new char[3][3];\\n\\t\\t\\tfor(int i=0; i<b.length; i++) {\\n\\t\\t\\t\\tfor(int j=0; j<b[i].length(); j++) {\\n\\t\\t\\t\\t\\tboard[i][j] = b[i].charAt(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint X = count(board, \\'X\\');\\n\\t\\t\\tint O = count(board, \\'O\\');\\n\\n\\t//         X-O == 1 || X-O == 0 Eg: 1-> X=1, O=0, 2-> X=2, O=1, 3->X=2, O=1 .....\\n\\t\\t\\tif(X-O != 1 && X-O != 0) return false;\\n\\t//         \\'?\\' will be stored in result if state is not valid \\'!\\' will be stored if state is valid and\\n\\t//         no one has win the game. If X wins the game \\'X\\' will be stored similarly \\'O\\'\\n\\t\\t\\tchar result = checkValidState(board);\\n\\t//         \\'?\\' stored implies not valid state\\n\\t\\t\\tif(result == \\'?\\') return false;\\n\\t//         \\'!\\' stored implies state valid but no one has win the game.\\n\\t\\t\\tif(result == \\'!\\') return true;\\n\\t//         X can only win the game if number of X is greater than number of O\\n\\t\\t\\tif(X>O) {\\n\\t\\t\\t\\tif(result == \\'X\\') return true;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t//         O can only win the game if number of O is equal to number of X\\n\\t\\t\\tif(result == \\'O\\') return true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t//     This function will count the number of character c in board\\n\\t\\tpublic int count(char[][] board, char c) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0; i<board.length; i++) {\\n\\t\\t\\t\\tfor(char ce: board[i]) {\\n\\t\\t\\t\\t\\tif(ce == c) count++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1193390,
                "title": "c-solution-with-comment",
                "content": "\\'\\'\\'\\n\\n    bool validTicTacToe(vector<string>& board) {\\n        int X_size=0, O_size=0;\\n        \\n        vector<vector<char>> chess (3, vector<char>(3, \\' \\'));\\n        // build the chess board; \\n        for (int i=0; i<board.size(); ++i) {\\n            string cur = board[i];\\n            for (int j=0; j<cur.length(); ++j) {\\n                if (cur[j] == \\'X\\') {\\n                    chess[i][j] = \\'X\\';\\n                    X_size++;\\n                } else if (cur[j] == \\'O\\') {\\n                    chess[i][j] = \\'O\\';\\n                    O_size++;\\n                }\\n            }\\n        }\\n        \\n        if (X_size < O_size || X_size > O_size + 1) return false;\\n        \\n        bool X_win = false, O_win = false;\\n        // check the row;\\n        for (int i=0; i<chess.size(); i++) {\\n            if (chess[i][0] != \\' \\' && chess[i][0]==chess[i][1] && chess[i][0]==chess[i][2]) {\\n                if (chess[i][0] == \\'X\\') {\\n                    X_win = true;  \\n                } else {\\n                    O_win = true;\\n                }\\n            }\\n            \\n            if (X_win && O_win) return false;\\n        }\\n        \\n        // check the column\\n        for (int j=0; j<chess[0].size(); j++) {\\n            if (chess[0][j] != \\' \\' && chess[0][j]==chess[1][j] && chess[0][j]==chess[2][j]) {\\n                if (chess[0][j] == \\'X\\') {\\n                    X_win = true;  \\n                } else {\\n                    O_win = true;\\n                }\\n            }\\n            if (X_win && O_win) return false;\\n        }\\n        \\n        // check the left diag\\n        if (chess[0][0] != \\' \\' && chess[0][0]==chess[1][1] && chess[0][0]==chess[2][2]) {\\n            if (chess[1][1] == \\'X\\') {\\n                X_win = true;  \\n            } else {\\n                O_win = true;\\n            }\\n        }\\n        \\n        // check the right diag\\n        if (chess[0][2] != \\' \\' && chess[0][2]==chess[1][1] && chess[0][2]==chess[2][0]) {\\n            if (chess[1][1] == \\'X\\') {\\n                X_win = true;  \\n            } else {\\n                O_win = true;\\n            }\\n        }\\n        \\n        if (X_size == O_size && X_win) return false;\\n        if (X_size == O_size+1 && O_win) return false;\\n        \\n        return true;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    bool validTicTacToe(vector<string>& board) {\\n        int X_size=0, O_size=0;\\n        \\n        vector<vector<char>> chess (3, vector<char>(3, \\' \\'));\\n        // build the chess board; \\n        for (int i=0; i<board.size(); ++i) {\\n            string cur = board[i];\\n            for (int j=0; j<cur.length(); ++j) {\\n                if (cur[j] == \\'X\\') {\\n                    chess[i][j] = \\'X\\';\\n                    X_size++;\\n                } else if (cur[j] == \\'O\\') {\\n                    chess[i][j] = \\'O\\';\\n                    O_size++;\\n                }\\n            }\\n        }\\n        \\n        if (X_size < O_size || X_size > O_size + 1) return false;\\n        \\n        bool X_win = false, O_win = false;\\n        // check the row;\\n        for (int i=0; i<chess.size(); i++) {\\n            if (chess[i][0] != \\' \\' && chess[i][0]==chess[i][1] && chess[i][0]==chess[i][2]) {\\n                if (chess[i][0] == \\'X\\') {\\n                    X_win = true;  \\n                } else {\\n                    O_win = true;\\n                }\\n            }\\n            \\n            if (X_win && O_win) return false;\\n        }\\n        \\n        // check the column\\n        for (int j=0; j<chess[0].size(); j++) {\\n            if (chess[0][j] != \\' \\' && chess[0][j]==chess[1][j] && chess[0][j]==chess[2][j]) {\\n                if (chess[0][j] == \\'X\\') {\\n                    X_win = true;  \\n                } else {\\n                    O_win = true;\\n                }\\n            }\\n            if (X_win && O_win) return false;\\n        }\\n        \\n        // check the left diag\\n        if (chess[0][0] != \\' \\' && chess[0][0]==chess[1][1] && chess[0][0]==chess[2][2]) {\\n            if (chess[1][1] == \\'X\\') {\\n                X_win = true;  \\n            } else {\\n                O_win = true;\\n            }\\n        }\\n        \\n        // check the right diag\\n        if (chess[0][2] != \\' \\' && chess[0][2]==chess[1][1] && chess[0][2]==chess[2][0]) {\\n            if (chess[1][1] == \\'X\\') {\\n                X_win = true;  \\n            } else {\\n                O_win = true;\\n            }\\n        }\\n        \\n        if (X_size == O_size && X_win) return false;\\n        if (X_size == O_size+1 && O_win) return false;\\n        \\n        return true;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1145072,
                "title": "java-easy-to-understand-0ms-100-solution",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        char[][] c= new char[3][3];\\n        int x = 0;\\n        int o = 0;\\n        boolean xwin = false;\\n        boolean owin = false;\\n        for(int i = 0;i<3;i++){\\n            for(int j= 0;j<3;j++){\\n                c[i][j]= board[i].charAt(j);\\n                if(c[i][j]==\\'X\\')\\n                    x++;\\n                if(c[i][j]==\\'O\\')\\n                    o++;\\n            }\\n        }\\n        \\n        //row check\\n        for(int i = 0;i<3;i++){\\n            if(c[i][0]==c[i][1]&& c[i][1]==c[i][2]){\\n                if(c[i][0]==\\'X\\')\\n                    xwin = true;\\n                if(c[i][0]==\\'O\\')\\n                    owin = true;\\n            }\\n        }\\n        \\n        //column check\\n        for(int i = 0;i<3;i++){\\n            if(c[0][i]==c[1][i] && c[1][i]==c[2][i]){\\n                if(c[0][i]==\\'X\\')\\n                    xwin = true;\\n                if(c[0][i]==\\'O\\')\\n                    owin = true;\\n            }\\n        }\\n        \\n        //left diagonal check\\n        if(c[0][0]==c[1][1] && c[1][1]==c[2][2]){\\n            if(c[0][0]==\\'X\\')\\n                xwin = true;\\n            if(c[0][0]==\\'O\\')\\n                owin = true;\\n        }\\n        \\n        //right diagonal check\\n        if(c[0][2]==c[1][1] && c[1][1]==c[2][0]){\\n            if(c[0][2]==\\'X\\')\\n                xwin = true;\\n            if(c[0][2]==\\'O\\')\\n                owin = true;\\n        }\\n        \\n        if(xwin){\\n            if(x-o==1)\\n                return true;\\n            return false;\\n        }\\n        if(owin){\\n            if(x-o==0)\\n                return true;\\n            return false;\\n        }\\n        if(x==o || x-o==1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        char[][] c= new char[3][3];\\n        int x = 0;\\n        int o = 0;\\n        boolean xwin = false;\\n        boolean owin = false;\\n        for(int i = 0;i<3;i++){\\n            for(int j= 0;j<3;j++){\\n                c[i][j]= board[i].charAt(j);\\n                if(c[i][j]==\\'X\\')\\n                    x++;\\n                if(c[i][j]==\\'O\\')\\n                    o++;\\n            }\\n        }\\n        \\n        //row check\\n        for(int i = 0;i<3;i++){\\n            if(c[i][0]==c[i][1]&& c[i][1]==c[i][2]){\\n                if(c[i][0]==\\'X\\')\\n                    xwin = true;\\n                if(c[i][0]==\\'O\\')\\n                    owin = true;\\n            }\\n        }\\n        \\n        //column check\\n        for(int i = 0;i<3;i++){\\n            if(c[0][i]==c[1][i] && c[1][i]==c[2][i]){\\n                if(c[0][i]==\\'X\\')\\n                    xwin = true;\\n                if(c[0][i]==\\'O\\')\\n                    owin = true;\\n            }\\n        }\\n        \\n        //left diagonal check\\n        if(c[0][0]==c[1][1] && c[1][1]==c[2][2]){\\n            if(c[0][0]==\\'X\\')\\n                xwin = true;\\n            if(c[0][0]==\\'O\\')\\n                owin = true;\\n        }\\n        \\n        //right diagonal check\\n        if(c[0][2]==c[1][1] && c[1][1]==c[2][0]){\\n            if(c[0][2]==\\'X\\')\\n                xwin = true;\\n            if(c[0][2]==\\'O\\')\\n                owin = true;\\n        }\\n        \\n        if(xwin){\\n            if(x-o==1)\\n                return true;\\n            return false;\\n        }\\n        if(owin){\\n            if(x-o==0)\\n                return true;\\n            return false;\\n        }\\n        if(x==o || x-o==1)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137645,
                "title": "ruby-get-statistic-filter-if-win-recursion-for-rest",
                "content": "## Leetcode: 794. Valid Tic-Tac-Toe State.\\n\\n**Ruby: Get statistic, filter if win, recursion for rest.**\\n\\nFirst acquire statistic number of symbols and check wins. If both types wins it is an error. If `X` wins number of `X` is greater by 1 then number of `O`. If `O` wins number of `X` and `O` are equal. After finishing working with wins, run recursive functions that pics `X` and `O` in turns, and check if finish is correct. When there is no one type of symbols to select, there must no be unselected symbols.   \\n\\nConvert grid to a binary representation an integer, where selected bits are marks.   \\n\\n\\n![Converting grid to bites.](https://assets.leetcode.com/users/images/5a655b33-5536-4637-bfed-5bf96fac8c11_1617295222.8295074.png)\\n\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 794. Valid Tic-Tac-Toe State.\\n# https://leetcode.com/problems/valid-tic-tac-toe-state/\\n# Runtime: 52 ms, faster than 100.00% of Ruby online submissions for Valid Tic-Tac-Toe State.\\n# Memory Usage: 210.1 MB, less than 100.00% of Ruby online submissions for Valid Tic-Tac-Toe State.\\n# Thanks God!\\n# @param {String[]} board\\n# @return {Boolean}\\ndef valid_tic_tac_toe(board)\\n    @b = board.map(&:chars).flatten\\n    @xw,@yw = false, false # x win, y win;\\n    @xn, @yn = 0,0\\n    @marks_mask = 0\\n    get_stat()\\n    return false if @xw && @yw\\n    if @xw\\n        return @xn == @yn + 1\\n    end\\n    if @yw\\n        return @yn == @xn\\n    end\\n    return check(true,0, 0, 0)\\nend\\n\\n# xm - x_marks;\\n# ym - y_marks;\\n# am - all_marks;\\n\\ndef check(x_turn, xm, ym, am)\\n    char = x_turn ? ?X : ?O\\n    # p \"#{char} #{am.to_s(2)}\"\\n    nt = ! x_turn # next turn;\\n    cm = x_turn ? xm : ym # current mark;\\n     (0...9).reverse_each do |i|\\n        bit = 1 << (8 - i)\\n        # Need to select only unmarked!\\n        if @b[i] == char && (0 == bit & am)\\n            nm = cm | bit # next mark;\\n            ng = am | bit # next global;\\n            return (x_turn ? check(nt,nm,ym,ng) : check(nt,xm,nm,ng))\\n        end\\n    end\\n    check_no_unmarked(am)\\nend\\n\\ndef check_win(marks)\\n    [7, 56, 448, 292, 146, 73, 273, 84].any?{|x| 0 == ((marks & x) ^ x)}\\nend\\n\\ndef get_stat()\\n    xm, ym = 0,0\\n    (0...9).reverse_each do |i|\\n        if ?X == @b[i] || ?O == @b[i]\\n            bit = (1 << (8-i))\\n            @marks_mask = @marks_mask | bit\\n            if ?X == @b[i]\\n                xm = xm | bit \\n                @xn += 1 \\n                @xw = true if check_win(xm)\\n            end\\n            if ?O == @b[i]\\n                ym = ym | bit\\n                @yn += 1\\n                @yw = true  if check_win(ym)\\n            end\\n        end\\n    end\\nend\\ndef check_no_unmarked(mask)\\n    0 == (mask ^ @marks_mask)\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion"
                ],
                "code": "```Ruby\\n# Leetcode: 794. Valid Tic-Tac-Toe State.\\n# https://leetcode.com/problems/valid-tic-tac-toe-state/\\n# Runtime: 52 ms, faster than 100.00% of Ruby online submissions for Valid Tic-Tac-Toe State.\\n# Memory Usage: 210.1 MB, less than 100.00% of Ruby online submissions for Valid Tic-Tac-Toe State.\\n# Thanks God!\\n# @param {String[]} board\\n# @return {Boolean}\\ndef valid_tic_tac_toe(board)\\n    @b = board.map(&:chars).flatten\\n    @xw,@yw = false, false # x win, y win;\\n    @xn, @yn = 0,0\\n    @marks_mask = 0\\n    get_stat()\\n    return false if @xw && @yw\\n    if @xw\\n        return @xn == @yn + 1\\n    end\\n    if @yw\\n        return @yn == @xn\\n    end\\n    return check(true,0, 0, 0)\\nend\\n\\n# xm - x_marks;\\n# ym - y_marks;\\n# am - all_marks;\\n\\ndef check(x_turn, xm, ym, am)\\n    char = x_turn ? ?X : ?O\\n    # p \"#{char} #{am.to_s(2)}\"\\n    nt = ! x_turn # next turn;\\n    cm = x_turn ? xm : ym # current mark;\\n     (0...9).reverse_each do |i|\\n        bit = 1 << (8 - i)\\n        # Need to select only unmarked!\\n        if @b[i] == char && (0 == bit & am)\\n            nm = cm | bit # next mark;\\n            ng = am | bit # next global;\\n            return (x_turn ? check(nt,nm,ym,ng) : check(nt,xm,nm,ng))\\n        end\\n    end\\n    check_no_unmarked(am)\\nend\\n\\ndef check_win(marks)\\n    [7, 56, 448, 292, 146, 73, 273, 84].any?{|x| 0 == ((marks & x) ^ x)}\\nend\\n\\ndef get_stat()\\n    xm, ym = 0,0\\n    (0...9).reverse_each do |i|\\n        if ?X == @b[i] || ?O == @b[i]\\n            bit = (1 << (8-i))\\n            @marks_mask = @marks_mask | bit\\n            if ?X == @b[i]\\n                xm = xm | bit \\n                @xn += 1 \\n                @xw = true if check_win(xm)\\n            end\\n            if ?O == @b[i]\\n                ym = ym | bit\\n                @yn += 1\\n                @yw = true  if check_win(ym)\\n            end\\n        end\\n    end\\nend\\ndef check_no_unmarked(mask)\\n    0 == (mask ^ @marks_mask)\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1109783,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n                \\n        countX = 0\\n        countO = 0\\n        \\n        rows = [0] * 3\\n        cols = [0] * 3\\n        diag = [0] * 3\\n                \\n        for i in range(3):\\n            for j in range(3):\\n                if board[i][j] == \\'X\\':\\n                    rows[i] += 1\\n                    cols[j] += 1\\n                    countX += 1\\n                    if i == j:\\n                        diag[0] += 1\\n                    if i + j == 2:\\n                        diag[1] += 1\\n                \\n                if board[i][j] == \\'O\\':\\n                    rows[i] -= 1\\n                    cols[j] -= 1\\n                    countO += 1\\n                    if i == j:\\n                        diag[0] -= 1\\n                    if i + j == 2:\\n                        diag[1] -= 1\\n                \\n        maxVal = max(max(rows),max(cols),max(diag))\\n        minVal = min(min(rows),min(cols),min(diag))\\n\\n        ## Case 1: count not good\\n        if (countX < countO) or (countX - countO > 1):\\n            return False\\n        \\n        ## Case 2: have both winning cases\\n        if maxVal == 3 and minVal == -3:\\n            return False\\n        \\n        ## Case 3: have X win but countO == countX\\n        if maxVal == 3 and (countX == countO):\\n            return False\\n        \\n        ## Case 4: have O win but countO < countX\\n        if minVal == -3 and (countX > countO):\\n            return False\\n\\n        return True\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n                \\n        countX = 0\\n        countO = 0\\n        \\n        rows = [0] * 3\\n        cols = [0] * 3\\n        diag = [0] * 3\\n                \\n        for i in range(3):\\n            for j in range(3):\\n                if board[i][j] == \\'X\\':\\n                    rows[i] += 1\\n                    cols[j] += 1\\n                    countX += 1\\n                    if i == j:\\n                        diag[0] += 1\\n                    if i + j == 2:\\n                        diag[1] += 1\\n                \\n                if board[i][j] == \\'O\\':\\n                    rows[i] -= 1\\n                    cols[j] -= 1\\n                    countO += 1\\n                    if i == j:\\n                        diag[0] -= 1\\n                    if i + j == 2:\\n                        diag[1] -= 1\\n                \\n        maxVal = max(max(rows),max(cols),max(diag))\\n        minVal = min(min(rows),min(cols),min(diag))\\n\\n        ## Case 1: count not good\\n        if (countX < countO) or (countX - countO > 1):\\n            return False\\n        \\n        ## Case 2: have both winning cases\\n        if maxVal == 3 and minVal == -3:\\n            return False\\n        \\n        ## Case 3: have X win but countO == countX\\n        if maxVal == 3 and (countX == countO):\\n            return False\\n        \\n        ## Case 4: have O win but countO < countX\\n        if minVal == -3 and (countX > countO):\\n            return False\\n\\n        return True\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067330,
                "title": "recursion-ds",
                "content": "```\\n/**\\n * @param {string[]} board\\n * @return {boolean}\\n */\\nvar validTicTacToe = function(board) {\\n    const chance = new Array(3).fill(\\'\\').map(a => new Array(3).fill(\\' \\'));\\n    let x = 0;\\n    let y = 0;\\n    let xWinner = findWinner(\\'X\\', board);\\n    let yWinner = findWinner(\\'O\\', board);\\n    if (xWinner && yWinner) return false;\\n    function findWinner(check, board2) {\\n        let win = 0;\\n       for (let i = 0; i < board2.length; i +=1 ) {\\n            if (board2[i][0] === check && board2[i][1] === board2[i][0] && board2[i][1] === board2[i][2]) win++;\\n       }\\n        for (let j = 0; j < board2.length; j +=1 ) {\\n            if (board2[0][j] === check && board2[1][j] === board2[0][j] && board2[1][j] === board2[2][j]) win++;\\n       }\\n        if (board2[0][0] === check && board2[1][1] === board2[0][0] && board2[1][1] === board[2][2]) win++;\\n        if (board2[2][0] === check && board2[1][1] === board2[2][0] && board2[1][1] === board2[0][2]) win++;\\n        return win;\\n    }\\n    for (let i = 0; i < board.length; i +=1 ) {\\n        for (let j = 0; j < board[i].length; j += 1) {\\n            if (board[i][j] === \\'X\\') x++;\\n            if (board[i][j] === \\'O\\') y++;\\n            \\n        }\\n    }\\n    if ((x - y) > 1 || (x - y) < 0) return false;\\n    return Xcheck(chance, 0, 0);\\n    function validate(chance) {\\n        for (let i = 0; i < 3; i += 1 ) {\\n            if (chance[i].join(\\'\\') !== board[i]) return false;\\n            \\n        }\\n        return true;\\n    }\\n    function Xcheck(chance, X, Y) {\\n\\n        if (X > x || Y > y) return false;\\n                // console.log(chance);\\n        if (X === x && Y === y) {\\n            // console.log(chance);\\n           if (validate(chance)) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (X >= 3) {\\n\\t\\t// check if the player can win\\n            if (findWinner(\\'X\\', chance)) return false;\\n        }\\n        if (Y >= 3) {\\n            // check if the player can win\\n           if (findWinner(\\'O\\', chance)) return false;\\n        }\\n        \\n        for (let i = 0; i < 3; i += 1) {\\n            for (let j = 0; j < 3; j += 1) {\\n                if (chance[i][j] === \\' \\') {\\n                    if ( X === Y && board[i][j] === \\'X\\') {\\n\\t\\t\\t\\t\\t// add X only where board [i][j] has it & find if X is clever enough to win or not\\n                        chance[i][j] = \\'X\\';\\n                        if (Xcheck(chance, X + 1, Y)) return true;\\n                    } else if (X > Y && board[i][j] === \\'O\\') {\\n\\t\\t\\t\\t\\t// add O only where board [i][j] has it & find if O is clever enough to win or not\\n                       chance[i][j] = \\'O\\';\\n                       if (Xcheck(chance, X, Y + 1)) return true;\\n                    }\\n                    chance[i][j] = \\' \\';\\n                }\\n            }\\n         }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} board\\n * @return {boolean}\\n */\\nvar validTicTacToe = function(board) {\\n    const chance = new Array(3).fill(\\'\\').map(a => new Array(3).fill(\\' \\'));\\n    let x = 0;\\n    let y = 0;\\n    let xWinner = findWinner(\\'X\\', board);\\n    let yWinner = findWinner(\\'O\\', board);\\n    if (xWinner && yWinner) return false;\\n    function findWinner(check, board2) {\\n        let win = 0;\\n       for (let i = 0; i < board2.length; i +=1 ) {\\n            if (board2[i][0] === check && board2[i][1] === board2[i][0] && board2[i][1] === board2[i][2]) win++;\\n       }\\n        for (let j = 0; j < board2.length; j +=1 ) {\\n            if (board2[0][j] === check && board2[1][j] === board2[0][j] && board2[1][j] === board2[2][j]) win++;\\n       }\\n        if (board2[0][0] === check && board2[1][1] === board2[0][0] && board2[1][1] === board[2][2]) win++;\\n        if (board2[2][0] === check && board2[1][1] === board2[2][0] && board2[1][1] === board2[0][2]) win++;\\n        return win;\\n    }\\n    for (let i = 0; i < board.length; i +=1 ) {\\n        for (let j = 0; j < board[i].length; j += 1) {\\n            if (board[i][j] === \\'X\\') x++;\\n            if (board[i][j] === \\'O\\') y++;\\n            \\n        }\\n    }\\n    if ((x - y) > 1 || (x - y) < 0) return false;\\n    return Xcheck(chance, 0, 0);\\n    function validate(chance) {\\n        for (let i = 0; i < 3; i += 1 ) {\\n            if (chance[i].join(\\'\\') !== board[i]) return false;\\n            \\n        }\\n        return true;\\n    }\\n    function Xcheck(chance, X, Y) {\\n\\n        if (X > x || Y > y) return false;\\n                // console.log(chance);\\n        if (X === x && Y === y) {\\n            // console.log(chance);\\n           if (validate(chance)) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (X >= 3) {\\n\\t\\t// check if the player can win\\n            if (findWinner(\\'X\\', chance)) return false;\\n        }\\n        if (Y >= 3) {\\n            // check if the player can win\\n           if (findWinner(\\'O\\', chance)) return false;\\n        }\\n        \\n        for (let i = 0; i < 3; i += 1) {\\n            for (let j = 0; j < 3; j += 1) {\\n                if (chance[i][j] === \\' \\') {\\n                    if ( X === Y && board[i][j] === \\'X\\') {\\n\\t\\t\\t\\t\\t// add X only where board [i][j] has it & find if X is clever enough to win or not\\n                        chance[i][j] = \\'X\\';\\n                        if (Xcheck(chance, X + 1, Y)) return true;\\n                    } else if (X > Y && board[i][j] === \\'O\\') {\\n\\t\\t\\t\\t\\t// add O only where board [i][j] has it & find if O is clever enough to win or not\\n                       chance[i][j] = \\'O\\';\\n                       if (Xcheck(chance, X, Y + 1)) return true;\\n                    }\\n                    chance[i][j] = \\' \\';\\n                }\\n            }\\n         }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034387,
                "title": "100-c-simple",
                "content": "class Solution {\\n    bool DidWin(vector<string>& board, char c)\\n    {\\n        for(int i = 0 ; i < 3 ; i++)\\n        {\\n            bool all = true;\\n            for(int y = 0 ; y< 3 ; y++)\\n            {\\n                if(board[i][y] != c)\\n                {\\n                    all = false;\\n                    break;\\n                }\\n            }\\n            if(all)\\n                return all;\\n        }\\n        \\n    \\n        for(int i = 0 ; i < 3 ; i++)\\n        {\\n            bool all = true;\\n            for(int y = 0 ; y< 3 ; y++)\\n            {\\n                if(board[y][i] != c)\\n                {\\n                    all = false;\\n                    break;\\n                }\\n            }\\n            if(all)\\n                return all;\\n        }\\n        \\n        bool all = true;\\n        for(int i = 0 ; i< 3;i++)\\n        {\\n           if(board[i][i]!=c)\\n           {\\n               all =false;\\n               break;\\n           }\\n        }\\n        if(all)\\n            return all;\\n        \\n        all = true;\\n        int j= 0;\\n        for(int i = 2 ; i >= 0 ; i--)\\n        {\\n           \\n           if(board[j][i]!=c)\\n           {\\n               all =false;\\n               break;\\n           }\\n            j++;\\n        }\\n        return all;\\n    }\\n    \\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int cx=0, cy=0;\\n        for(int i =0;i< 3;i++)\\n        {\\n            for(int y= 0 ;y< 3;y++)\\n            {\\n                if(board[i][y]==\\'X\\')\\n                    cx++;\\n                else if(board[i][y]==\\'O\\')\\n                    cy ++;\\n            }\\n        }\\n        \\n        if (cy > cx|| cx > cy+1)\\n            return false;\\n        \\n        bool winX=DidWin(board, \\'X\\');\\n      \\n        bool winY=DidWin(board, \\'O\\');\\n      \\n        if((winX && winY)|| (winY && cx != cy)|| (winX && cy != cx-1))\\n            return false;\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    bool DidWin(vector<string>& board, char c)\\n    {\\n        for(int i = 0 ; i < 3 ; i++)\\n        {\\n            bool all = true;\\n            for(int y = 0 ; y< 3 ; y++)\\n            {\\n                if(board[i][y] != c)\\n                {\\n                    all = false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 983584,
                "title": "error",
                "content": "Can anyone explain me why this error is been shown \\n\\nLine 5: Char 26: warning: result of comparison against a string literal is unspecified (use an explicit string comparison function instead) [-Wstring-compare]\\n           if(board[i][0]!=\" \" && board[i][0]==board[i][1] && board[i][1]==board[i][2]",
                "solutionTags": [],
                "code": "Can anyone explain me why this error is been shown \\n\\nLine 5: Char 26: warning: result of comparison against a string literal is unspecified (use an explicit string comparison function instead) [-Wstring-compare]\\n           if(board[i][0]!=\" \" && board[i][0]==board[i][1] && board[i][1]==board[i][2]",
                "codeTag": "Unknown"
            },
            {
                "id": 951829,
                "title": "java-short-and-crisp-beats-100-with-explanation",
                "content": "**Algorithm:**\\n**1.** Turns should be played alternatively and first turn should be \\'X\\'.So at any time, it can be either \\'X\\' turn or \\'O\\' turn.\\nIf no,of_X=no.of_O , then it is \\'X\\'s turn\\nelse If no,of_X=1+no.of_O, then it is \\'O\\'s turn\\nSo if other than this two conditions , return false.\\n**2.** The game ends once, there are 3 of the same (non-empty) character filling any row, column, or diagonal.\\nSo there cannot be more than 2 patterns of X, or more than two patterns O, or pattern of X and pattern of O together.\\nThere is a special case when there can be two patterns at an instant , like\\nX ,X ,**X**\\n@,@,X\\n@,@,X\\nSo again by checking,\\nIf pattern was \\'X\\',then next should be \\'O, so check if no,of_X=1+no.of_O.\\nIf pattern was \\'O\\',then next should be \\'X, so check if no,of_X=no.of_O.\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int x=0,o=0;\\n        for(String s: board){\\n            for(char ch : s.toCharArray()){\\n                if(ch==\\'X\\') x++;\\n                else if(ch==\\'O\\') o++;\\n            }\\n        }\\n        if(!(x==o || x==o+1)) return false;\\n        int x_pattern=checkPattern(board,\\'X\\');\\n        int o_pattern=checkPattern(board,\\'O\\');\\n        if(x_pattern>2 || o_pattern>2 || (x_pattern!=0 && o_pattern!=0)) return false;\\n        if((x_pattern==2 || x_pattern==1) && x!=o+1) return false;\\n        else if((o_pattern==2 || o_pattern==1 )&& x!=o) return false;\\n        return true;\\n    }\\n    private int checkPattern(String[] board,Character ch){\\n        int res=0;\\n        //Rows\\n        for(int i=0;i<3;i++){\\n            int count=0;\\n            for(int j=0;j<3;j++){\\n                if(board[i].charAt(j)==ch) count++;\\n            }\\n            if(count==3) res++;\\n        }\\n        //Cols\\n        for(int i=0;i<3;i++){\\n            int count=0;\\n            for(int j=0;j<3;j++){\\n                if(board[j].charAt(i)==ch) count++;\\n            }\\n            if(count==3) res++;\\n        }\\n        //2 diagonals\\n        if(board[0].charAt(0)==ch && board[1].charAt(1)==ch && board[2].charAt(2)==ch) res++;\\n        if(board[0].charAt(2)==ch && board[1].charAt(1)==ch && board[2].charAt(0)==ch) res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int x=0,o=0;\\n        for(String s: board){\\n            for(char ch : s.toCharArray()){\\n                if(ch==\\'X\\') x++;\\n                else if(ch==\\'O\\') o++;\\n            }\\n        }\\n        if(!(x==o || x==o+1)) return false;\\n        int x_pattern=checkPattern(board,\\'X\\');\\n        int o_pattern=checkPattern(board,\\'O\\');\\n        if(x_pattern>2 || o_pattern>2 || (x_pattern!=0 && o_pattern!=0)) return false;\\n        if((x_pattern==2 || x_pattern==1) && x!=o+1) return false;\\n        else if((o_pattern==2 || o_pattern==1 )&& x!=o) return false;\\n        return true;\\n    }\\n    private int checkPattern(String[] board,Character ch){\\n        int res=0;\\n        //Rows\\n        for(int i=0;i<3;i++){\\n            int count=0;\\n            for(int j=0;j<3;j++){\\n                if(board[i].charAt(j)==ch) count++;\\n            }\\n            if(count==3) res++;\\n        }\\n        //Cols\\n        for(int i=0;i<3;i++){\\n            int count=0;\\n            for(int j=0;j<3;j++){\\n                if(board[j].charAt(i)==ch) count++;\\n            }\\n            if(count==3) res++;\\n        }\\n        //2 diagonals\\n        if(board[0].charAt(0)==ch && board[1].charAt(1)==ch && board[2].charAt(2)==ch) res++;\\n        if(board[0].charAt(2)==ch && board[1].charAt(1)==ch && board[2].charAt(0)==ch) res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915561,
                "title": "this-problem-should-have-tags-array-and-string-instead",
                "content": "The whole problem is about array and/or string manipulations. There is no Math or Recursion involved.\\n```python\\nclass Solution:\\n    # 20 ms, 99.25%. Time and Space: O(1)\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def winning(person, board):\\n            if person*3 in board or person*3 in (\"\".join(col) for col in zip(*board)):\\n                return True\\n            if board[0][0] == board[1][1] == board[2][2] == person: return True\\n            if board[0][2] == board[1][1] == board[2][0] == person: return True\\n        \\n        x = sum(row.count(\"X\") for row in board)\\n        o = sum(row.count(\"O\") for row in board)\\n        if winning(\"X\", board) and winning(\"O\", board): return False\\n        if winning(\"X\", board) and o + 1 != x: return False\\n        if winning(\"O\", board) and o != x: return False\\n        if not 0 <= x - o <= 1: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    # 20 ms, 99.25%. Time and Space: O(1)\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def winning(person, board):\\n            if person*3 in board or person*3 in (\"\".join(col) for col in zip(*board)):\\n                return True\\n            if board[0][0] == board[1][1] == board[2][2] == person: return True\\n            if board[0][2] == board[1][1] == board[2][0] == person: return True\\n        \\n        x = sum(row.count(\"X\") for row in board)\\n        o = sum(row.count(\"O\") for row in board)\\n        if winning(\"X\", board) and winning(\"O\", board): return False\\n        if winning(\"X\", board) and o + 1 != x: return False\\n        if winning(\"O\", board) and o != x: return False\\n        if not 0 <= x - o <= 1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911519,
                "title": "python-when-in-doubt-play-it-out",
                "content": "This solution uses a Tic-Tac-Toe game class to simulate the game play.\\nA recursive helper function is used to test all possible play scenarios for the given \\'X\\' and \\'O\\' plays.  \\n\\nIf we can play all \\'X\\' and \\'O\\' without \\'X\\' or \\'O\\' winning before the last move, then board is a valid input.  \\n\\nObviously simulation is not the most efficient approach to this problem, but it is a fun challenge.  \\nIf you also solved this using simulation, share your solution in the comments below.  \\n\\n```python\\nclass Tic_Tac_Toe(object):\\n    def __init__(self, rows = None, cols = None, diag = None, total_plays = None):\\n        \\'\\'\\'\\n        if no input is given: initiate the game as an empty board\\n        if an input is given: initiate the game according to the input\\n        \\'\\'\\'\\n        self.rows = [[] for _ in range(3)] if rows is None else rows\\n        self.cols = [[] for _ in range(3)] if cols is None else cols\\n        self.diag = [[] for _ in range(2)] if diag is None else diag\\n        self.total_plays = 0 if total_plays is None else total_plays\\n    \\n    def play(self, val, i, j):\\n        \\'\\'\\'place val (\\'X\\' or \\'O\\') at location (i, j)\\'\\'\\'\\n        self.rows[i].append(val)\\n        self.cols[j].append(val)\\n        \\n        if i == j == 1:\\n            self.diag[0].append(val)\\n            self.diag[1].append(val)\\n        elif (i,j) in [(0, 0), (2, 2)]:\\n            self.diag[0].append(val)\\n        elif (i,j) in [(2, 0), (0, 2)]:\\n            self.diag[1].append(val)\\n            \\n        self.total_plays += 1\\n    \\n    def has_won(self):\\n        \\'\\'\\'returns true if \\'X\\' or \\'O\\' has won\\'\\'\\'\\n        return any((len(line) == 3) and (len(set(line)) == 1) for line in self.rows + self.cols + self.diag)\\n    \\n    def __repr__(self):\\n        \\'\\'\\'return a dictionary of the current game-state so that a deep copy of the game can be made\\'\\'\\'\\n        return {\\'rows\\': [r.copy() for r in self.rows], \\n                \\'cols\\': [c.copy() for c in self.cols],\\n                \\'diag\\': [d.copy() for d in self.diag],\\n                \\'total_plays\\': self.total_plays}\\n    \\n    def print_game(self):\\n        for row in self.rows: print(row)\\n            \\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        \\n        x_plays = [(i,j) for i in range(3) for j in range(3) if board[i][j] == \\'X\\']\\n        o_plays = [(i,j) for i in range(3) for j in range(3) if board[i][j] == \\'O\\']\\n        \\n        # 1. Check if X or O played too many times\\n        x_count, o_count = len(x_plays), len(o_plays)\\n        if x_count > o_count + 1 or o_count > x_count:\\n            return False\\n        \\n        # 2. Simulate all possible games\\n        def helper(game, turn, x_plays, o_plays):\\n            nonlocal x_count, o_count, res\\n\\n            # All plays have been made: solution found!\\n            if game.total_plays == x_count + o_count: res = True\\n            \\n            # \\'X\\' or \\'O\\' won but not all plays were made, solution not found\\n            if game.has_won(): return None\\n            \\n            # A solution has already been found, exit the recursive function\\n            if res: return None\\n            \\n            # Try all possible remaining moves\\n            if turn == \\'X\\':\\n                for i,(row,col) in enumerate(x_plays):\\n                    g = Tic_Tac_Toe(**game.__repr__())\\n                    g.play(\\'X\\', row, col)\\n                    helper(g, \\'O\\', x_plays[:i] + x_plays[i+1:], o_plays)\\n            else:\\n                for i,(row,col) in enumerate(o_plays):\\n                    g = Tic_Tac_Toe(**game.__repr__())\\n                    g.play(\\'O\\', row, col)\\n                    helper(g, \\'X\\', x_plays, o_plays[:i] + o_plays[i+1:])\\n        \\n        res = False\\n        helper(Tic_Tac_Toe(), \\'X\\', x_plays, o_plays)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Tic_Tac_Toe(object):\\n    def __init__(self, rows = None, cols = None, diag = None, total_plays = None):\\n        \\'\\'\\'\\n        if no input is given: initiate the game as an empty board\\n        if an input is given: initiate the game according to the input\\n        \\'\\'\\'\\n        self.rows = [[] for _ in range(3)] if rows is None else rows\\n        self.cols = [[] for _ in range(3)] if cols is None else cols\\n        self.diag = [[] for _ in range(2)] if diag is None else diag\\n        self.total_plays = 0 if total_plays is None else total_plays\\n    \\n    def play(self, val, i, j):\\n        \\'\\'\\'place val (\\'X\\' or \\'O\\') at location (i, j)\\'\\'\\'\\n        self.rows[i].append(val)\\n        self.cols[j].append(val)\\n        \\n        if i == j == 1:\\n            self.diag[0].append(val)\\n            self.diag[1].append(val)\\n        elif (i,j) in [(0, 0), (2, 2)]:\\n            self.diag[0].append(val)\\n        elif (i,j) in [(2, 0), (0, 2)]:\\n            self.diag[1].append(val)\\n            \\n        self.total_plays += 1\\n    \\n    def has_won(self):\\n        \\'\\'\\'returns true if \\'X\\' or \\'O\\' has won\\'\\'\\'\\n        return any((len(line) == 3) and (len(set(line)) == 1) for line in self.rows + self.cols + self.diag)\\n    \\n    def __repr__(self):\\n        \\'\\'\\'return a dictionary of the current game-state so that a deep copy of the game can be made\\'\\'\\'\\n        return {\\'rows\\': [r.copy() for r in self.rows], \\n                \\'cols\\': [c.copy() for c in self.cols],\\n                \\'diag\\': [d.copy() for d in self.diag],\\n                \\'total_plays\\': self.total_plays}\\n    \\n    def print_game(self):\\n        for row in self.rows: print(row)\\n            \\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        \\n        x_plays = [(i,j) for i in range(3) for j in range(3) if board[i][j] == \\'X\\']\\n        o_plays = [(i,j) for i in range(3) for j in range(3) if board[i][j] == \\'O\\']\\n        \\n        # 1. Check if X or O played too many times\\n        x_count, o_count = len(x_plays), len(o_plays)\\n        if x_count > o_count + 1 or o_count > x_count:\\n            return False\\n        \\n        # 2. Simulate all possible games\\n        def helper(game, turn, x_plays, o_plays):\\n            nonlocal x_count, o_count, res\\n\\n            # All plays have been made: solution found!\\n            if game.total_plays == x_count + o_count: res = True\\n            \\n            # \\'X\\' or \\'O\\' won but not all plays were made, solution not found\\n            if game.has_won(): return None\\n            \\n            # A solution has already been found, exit the recursive function\\n            if res: return None\\n            \\n            # Try all possible remaining moves\\n            if turn == \\'X\\':\\n                for i,(row,col) in enumerate(x_plays):\\n                    g = Tic_Tac_Toe(**game.__repr__())\\n                    g.play(\\'X\\', row, col)\\n                    helper(g, \\'O\\', x_plays[:i] + x_plays[i+1:], o_plays)\\n            else:\\n                for i,(row,col) in enumerate(o_plays):\\n                    g = Tic_Tac_Toe(**game.__repr__())\\n                    g.play(\\'O\\', row, col)\\n                    helper(g, \\'X\\', x_plays, o_plays[:i] + o_plays[i+1:])\\n        \\n        res = False\\n        helper(Tic_Tac_Toe(), \\'X\\', x_plays, o_plays)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832373,
                "title": "simple-easy-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int xcount,ocount;\\n        xcount=ocount=0;\\n        int xwin,owin;\\n        xwin=owin=0;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<3;j++){\\n                if(board[i][j]==\\'X\\')    xcount++;\\n                if(board[i][j]==\\'O\\')    ocount++;\\n            }\\n            if(board[i][1]==board[i][0] and board[i][2]==board[i][1] and board[i][1]!=\\' \\'){\\n                if(board[i][1]==\\'X\\')    xwin++;\\n                if(board[i][1]==\\'O\\')    owin++;\\n            }\\n            if(board[1][i]==board[0][i] and board[2][i]==board[1][i] and board[1][i]!=\\' \\'){\\n                if(board[1][i]==\\'X\\')    xwin++;\\n                if(board[1][i]==\\'O\\')    owin++;\\n            }\\n        }\\n        if(board[1][1]==board[0][0] and board[2][2]==board[1][1] and board[1][1]!=\\' \\'){\\n                if(board[1][1]==\\'X\\')    xwin++;\\n                if(board[1][1]==\\'O\\')    owin++;\\n        }\\n        if(board[0][2]==board[2][0] and board[2][0]==board[1][1] and board[1][1]!=\\' \\'){\\n                if(board[1][1]==\\'X\\')    xwin++;\\n                if(board[1][1]==\\'O\\')    owin++;\\n        }\\n        if(abs(xcount-ocount)>1 or ocount>xcount or (xwin>0 and owin>0))\\n            return false;\\n        if(xwin>0){\\n            return(xcount>ocount);\\n        }\\n        if(owin>0){\\n            return (ocount==xcount);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int xcount,ocount;\\n        xcount=ocount=0;\\n        int xwin,owin;\\n        xwin=owin=0;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<3;j++){\\n                if(board[i][j]==\\'X\\')    xcount++;\\n                if(board[i][j]==\\'O\\')    ocount++;\\n            }\\n            if(board[i][1]==board[i][0] and board[i][2]==board[i][1] and board[i][1]!=\\' \\'){\\n                if(board[i][1]==\\'X\\')    xwin++;\\n                if(board[i][1]==\\'O\\')    owin++;\\n            }\\n            if(board[1][i]==board[0][i] and board[2][i]==board[1][i] and board[1][i]!=\\' \\'){\\n                if(board[1][i]==\\'X\\')    xwin++;\\n                if(board[1][i]==\\'O\\')    owin++;\\n            }\\n        }\\n        if(board[1][1]==board[0][0] and board[2][2]==board[1][1] and board[1][1]!=\\' \\'){\\n                if(board[1][1]==\\'X\\')    xwin++;\\n                if(board[1][1]==\\'O\\')    owin++;\\n        }\\n        if(board[0][2]==board[2][0] and board[2][0]==board[1][1] and board[1][1]!=\\' \\'){\\n                if(board[1][1]==\\'X\\')    xwin++;\\n                if(board[1][1]==\\'O\\')    owin++;\\n        }\\n        if(abs(xcount-ocount)>1 or ocount>xcount or (xwin>0 and owin>0))\\n            return false;\\n        if(xwin>0){\\n            return(xcount>ocount);\\n        }\\n        if(owin>0){\\n            return (ocount==xcount);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826611,
                "title": "100-c-easy-to-understand-d",
                "content": "```\\n#include <bits/stdc++.h>\\n#include <stdio.h>\\nusing namespace std;\\n\\nvector<vector<pair<int, int>>> possibleSolutions{\\n    {{0, 0}, {0, 1}, {0, 2}}, //first row\\n    {{1, 0}, {1, 1}, {1, 2}},\\n    {{2, 0}, {2, 1}, {2, 2}},\\n    {{0, 0}, {1, 0}, {2, 0}}, // first col\\n    {{0, 1}, {1, 1}, {2, 1}},\\n    {{0, 2}, {1, 2}, {2, 2}},\\n    {{0, 0}, {1, 1}, {2, 2}}, //first diagonal\\n    {{0, 2}, {1, 1}, {2, 0}}  // second diagonal\\n\\n};\\n// This function checks if the particular character is winning or not atleast once\\nint isValidCombination(vector<string> &board, char ch)\\n{\\n    for (auto x : possibleSolutions)\\n    {\\n        auto curr = x;\\n        auto cord1 = x[0];\\n        auto cord2 = x[1];\\n        auto cord3 = x[2];\\n\\n        if (board[cord1.first][cord1.second] == ch and board[cord2.first][cord2.second] == ch and board[cord3.first][cord3.second] == ch)\\n        {\\n            return 1;\\n        }\\n    }\\n    return 0;\\n}\\n\\nclass Solution\\n{\\npublic:\\n    bool validTicTacToe(vector<string> &board)\\n    {\\n        int countX = 0;\\n        int countO = 0;\\n\\n        for (auto x : board)\\n        {\\n            for (auto c : x)\\n            {\\n                if (c == \\'X\\')\\n                {\\n                    countX++;\\n                }\\n                else if(c == \\'O\\')\\n                {\\n                    countO++;\\n                }\\n            }\\n        }\\n        // cout<<countX<<\" \"<<countO<<endl;\\n\\n        if ((countX == countO) or (countX == countO + 1))\\n        {\\n            int isXwinning = isValidCombination(board, \\'X\\');\\n            int isOwinning = isValidCombination(board, \\'O\\');\\n\\n            if (isXwinning)\\n            {\\n                if (isOwinning)\\n                {\\n                    return 0;\\n                }\\n                return countX == countO + 1;\\n            }\\n            if (isOwinning)\\n            {\\n                if (isXwinning)\\n                {\\n                    return 0;\\n                }\\n                return countX == countO;\\n            }\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\n#include <stdio.h>\\nusing namespace std;\\n\\nvector<vector<pair<int, int>>> possibleSolutions{\\n    {{0, 0}, {0, 1}, {0, 2}}, //first row\\n    {{1, 0}, {1, 1}, {1, 2}},\\n    {{2, 0}, {2, 1}, {2, 2}},\\n    {{0, 0}, {1, 0}, {2, 0}}, // first col\\n    {{0, 1}, {1, 1}, {2, 1}},\\n    {{0, 2}, {1, 2}, {2, 2}},\\n    {{0, 0}, {1, 1}, {2, 2}}, //first diagonal\\n    {{0, 2}, {1, 1}, {2, 0}}  // second diagonal\\n\\n};\\n// This function checks if the particular character is winning or not atleast once\\nint isValidCombination(vector<string> &board, char ch)\\n{\\n    for (auto x : possibleSolutions)\\n    {\\n        auto curr = x;\\n        auto cord1 = x[0];\\n        auto cord2 = x[1];\\n        auto cord3 = x[2];\\n\\n        if (board[cord1.first][cord1.second] == ch and board[cord2.first][cord2.second] == ch and board[cord3.first][cord3.second] == ch)\\n        {\\n            return 1;\\n        }\\n    }\\n    return 0;\\n}\\n\\nclass Solution\\n{\\npublic:\\n    bool validTicTacToe(vector<string> &board)\\n    {\\n        int countX = 0;\\n        int countO = 0;\\n\\n        for (auto x : board)\\n        {\\n            for (auto c : x)\\n            {\\n                if (c == \\'X\\')\\n                {\\n                    countX++;\\n                }\\n                else if(c == \\'O\\')\\n                {\\n                    countO++;\\n                }\\n            }\\n        }\\n        // cout<<countX<<\" \"<<countO<<endl;\\n\\n        if ((countX == countO) or (countX == countO + 1))\\n        {\\n            int isXwinning = isValidCombination(board, \\'X\\');\\n            int isOwinning = isValidCombination(board, \\'O\\');\\n\\n            if (isXwinning)\\n            {\\n                if (isOwinning)\\n                {\\n                    return 0;\\n                }\\n                return countX == countO + 1;\\n            }\\n            if (isOwinning)\\n            {\\n                if (isXwinning)\\n                {\\n                    return 0;\\n                }\\n                return countX == countO;\\n            }\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 766735,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    var countX = 0\\n    var countO = 0\\n\\n    func validTicTacToe(_ board: [String]) -> Bool {\\n        guard isValidCount(board), isMeetingWinningCriteria(board) else {\\n            return false\\n        }\\n      return true        \\n    }\\n    \\n    private func isMeetingWinningCriteria(_ board: [String]) -> Bool {\\n        // the idea behind this is if \"X\" is the winner then the count of X == count of Y + 1\\n        // and if O is winner, then the count of Y == count of X\\n        // We need to check this for all rows, columns and diagonals\\n        return isValidRow(board) && isValidColumn(board) && isValidDiagonal(board)\\n    }\\n    \\n    private func isValidRow(_ board: [String]) -> Bool {\\n        for i in 0..<3 {\\n            var countX = 0\\n             var countO = 0\\n            let row = board[i]\\n            for j in 0..<3 {\\n                 let index = row.index(row.startIndex, offsetBy: j)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                }\\n                else if ch == \"O\" {\\n                    countO += 1\\n                }\\n            }\\n             if !validate(countX, countO) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    \\n    private func isValidColumn(_ board: [String]) -> Bool {\\n        for i in 0..<3 {\\n            var countX = 0\\n            var countO = 0\\n            for j in 0..<3 {\\n                let row = board[j]\\n                let index = row.index(row.startIndex, offsetBy: i)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                } else if ch == \"O\" {\\n                    countO += 1\\n                }\\n            }\\n            if !validate(countX, countO) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    \\n    private func isValidDiagonal(_ board: [String]) -> Bool {\\n         var countX = 0\\n         var countO = 0\\n        for i in 0..<3 {\\n          let row = board[i]\\n            let index = row.index(row.startIndex, offsetBy: i)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                } else if ch == \"O\" {\\n                    countO += 1\\n                }\\n        }\\n            \\n        if !validate(countX, countO) {\\n               return false\\n        }\\n        \\n        countX = 0\\n        countO = 0\\n        for i in (0..<3).reversed() {\\n               let row = board[2-i]\\n                let index = row.index(row.startIndex, offsetBy: i)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                } else if ch == \"O\" {\\n                    countO += 1\\n                }\\n        }\\n        return validate(countX, countO)\\n    }\\n    \\n    private func validate(_ countX: Int, _ countO: Int) -> Bool {\\n        if countX == 3 {\\n               return self.countX - 1 == self.countO\\n         } else if countO == 3 {\\n            return self.countX == self.countO\\n        }\\n        return true\\n    }\\n    \\n    private func isValidCount(_ board: [String]) -> Bool {\\n        board.forEach { row in\\n            row.forEach { char in\\n                if char == \"X\" {\\n                    countX += 1\\n                } else if char == \"O\" {\\n                    countO += 1\\n                }\\n            }\\n        }\\n        return countX == countO || countX - 1 == countO\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var countX = 0\\n    var countO = 0\\n\\n    func validTicTacToe(_ board: [String]) -> Bool {\\n        guard isValidCount(board), isMeetingWinningCriteria(board) else {\\n            return false\\n        }\\n      return true        \\n    }\\n    \\n    private func isMeetingWinningCriteria(_ board: [String]) -> Bool {\\n        // the idea behind this is if \"X\" is the winner then the count of X == count of Y + 1\\n        // and if O is winner, then the count of Y == count of X\\n        // We need to check this for all rows, columns and diagonals\\n        return isValidRow(board) && isValidColumn(board) && isValidDiagonal(board)\\n    }\\n    \\n    private func isValidRow(_ board: [String]) -> Bool {\\n        for i in 0..<3 {\\n            var countX = 0\\n             var countO = 0\\n            let row = board[i]\\n            for j in 0..<3 {\\n                 let index = row.index(row.startIndex, offsetBy: j)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                }\\n                else if ch == \"O\" {\\n                    countO += 1\\n                }\\n            }\\n             if !validate(countX, countO) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    \\n    private func isValidColumn(_ board: [String]) -> Bool {\\n        for i in 0..<3 {\\n            var countX = 0\\n            var countO = 0\\n            for j in 0..<3 {\\n                let row = board[j]\\n                let index = row.index(row.startIndex, offsetBy: i)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                } else if ch == \"O\" {\\n                    countO += 1\\n                }\\n            }\\n            if !validate(countX, countO) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    \\n    private func isValidDiagonal(_ board: [String]) -> Bool {\\n         var countX = 0\\n         var countO = 0\\n        for i in 0..<3 {\\n          let row = board[i]\\n            let index = row.index(row.startIndex, offsetBy: i)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                } else if ch == \"O\" {\\n                    countO += 1\\n                }\\n        }\\n            \\n        if !validate(countX, countO) {\\n               return false\\n        }\\n        \\n        countX = 0\\n        countO = 0\\n        for i in (0..<3).reversed() {\\n               let row = board[2-i]\\n                let index = row.index(row.startIndex, offsetBy: i)\\n                let ch = row[index]\\n                if ch == \"X\" {\\n                    countX += 1\\n                } else if ch == \"O\" {\\n                    countO += 1\\n                }\\n        }\\n        return validate(countX, countO)\\n    }\\n    \\n    private func validate(_ countX: Int, _ countO: Int) -> Bool {\\n        if countX == 3 {\\n               return self.countX - 1 == self.countO\\n         } else if countO == 3 {\\n            return self.countX == self.countO\\n        }\\n        return true\\n    }\\n    \\n    private func isValidCount(_ board: [String]) -> Bool {\\n        board.forEach { row in\\n            row.forEach { char in\\n                if char == \"X\" {\\n                    countX += 1\\n                } else if char == \"O\" {\\n                    countO += 1\\n                }\\n            }\\n        }\\n        return countX == countO || countX - 1 == countO\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704849,
                "title": "readable-code-with-explanation-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n     bool didWon(int x,int y,vector<string>&m,char ch)\\n   {\\n    if(m[x][0]==ch&&m[x][1]==ch&&m[x][2]==ch)return true;\\n    if(m[0][y]==ch&&m[1][y]==ch&&m[2][y]==ch)return true;\\n    if(m[0][0]==ch&&m[1][1]==ch&&m[2][2]==ch)return true;\\n    if(m[0][2]==ch&&m[1][1]==ch&&m[2][0]==ch)return true;\\n       return false;\\n   }\\n    bool validTicTacToe(vector<string>& board) {\\n        int numx = 0;\\n        int numo = 0;\\n\\t\\t//calculate number of the \\'X\\'s and \\'O\\'s\\n        for(auto c: board)\\n        {\\n            for(auto a:c)\\n            {\\n                if(a==\\'X\\')numx++;\\n                if(a==\\'O\\')numo++;\\n            }\\n        }\\n\\t\\t//if number of \\'O\\'s greater than number of \\'X\\'s that means B took more moves which is unacceptable, so return false;\\n        if(numo>numx)return false;\\n\\t\\t//If number of \\'X\\'s greater than number of \\'O\\'s by 1 that means at one point 2nd player didn\\'t get his turn So return false\\n        if(numx-numo>1)return false;\\n\\t\\t//if there are equal number of \\'X\\'s and \\'O\\'s then, if 1st player is winner then 2nd player shouldn\\'t get any chance So return false if 1st player is Winner.\\n        if(numx==numo)\\n        {\\n           bool flag1 = true;\\n           bool flag2 = true;\\n             for(int i=0;i<3;i++){\\n                for(int j=0;j<3;j++) {\\n                    if(board[i][j]==\\'X\\') {\\n                        if(didWon(i,j,board,\\'X\\')){\\n                            flag1=false;\\n                            break;\\n                        } \\n                    }\\n                }\\n            }\\n            if(!flag1)return false;\\n        }\\n\\t\\t//if difference between  moves of 1st player and 2nd player is equal to one.. Again if 2nd player is  winner then 1st player shouldn\\'t get extrachance. But here 1st player got one extra chance so return false\\n        if(numx-numo==1)\\n        {\\n            for(int i=0;i<3;i++)\\n            {\\n                for(int j=0;j<3;j++)\\n                {\\n                    if(board[i][j]==\\'O\\')\\n                    {\\n                        if(didWon(i,j,board,\\'O\\'))return false;\\n                    }\\n                }\\n            }      \\n        }\\n\\t\\t//else return true if none of the above conditions failed to prove the state as invalid. \\n        return true;\\n    }\\n};\\n\\n//Please upvote if you liked it. \\n//Thanks\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool didWon(int x,int y,vector<string>&m,char ch)\\n   {\\n    if(m[x][0]==ch&&m[x][1]==ch&&m[x][2]==ch)return true;\\n    if(m[0][y]==ch&&m[1][y]==ch&&m[2][y]==ch)return true;\\n    if(m[0][0]==ch&&m[1][1]==ch&&m[2][2]==ch)return true;\\n    if(m[0][2]==ch&&m[1][1]==ch&&m[2][0]==ch)return true;\\n       return false;\\n   }\\n    bool validTicTacToe(vector<string>& board) {\\n        int numx = 0;\\n        int numo = 0;\\n\\t\\t//calculate number of the \\'X\\'s and \\'O\\'s\\n        for(auto c: board)\\n        {\\n            for(auto a:c)\\n            {\\n                if(a==\\'X\\')numx++;\\n                if(a==\\'O\\')numo++;\\n            }\\n        }\\n\\t\\t//if number of \\'O\\'s greater than number of \\'X\\'s that means B took more moves which is unacceptable, so return false;\\n        if(numo>numx)return false;\\n\\t\\t//If number of \\'X\\'s greater than number of \\'O\\'s by 1 that means at one point 2nd player didn\\'t get his turn So return false\\n        if(numx-numo>1)return false;\\n\\t\\t//if there are equal number of \\'X\\'s and \\'O\\'s then, if 1st player is winner then 2nd player shouldn\\'t get any chance So return false if 1st player is Winner.\\n        if(numx==numo)\\n        {\\n           bool flag1 = true;\\n           bool flag2 = true;\\n             for(int i=0;i<3;i++){\\n                for(int j=0;j<3;j++) {\\n                    if(board[i][j]==\\'X\\') {\\n                        if(didWon(i,j,board,\\'X\\')){\\n                            flag1=false;\\n                            break;\\n                        } \\n                    }\\n                }\\n            }\\n            if(!flag1)return false;\\n        }\\n\\t\\t//if difference between  moves of 1st player and 2nd player is equal to one.. Again if 2nd player is  winner then 1st player shouldn\\'t get extrachance. But here 1st player got one extra chance so return false\\n        if(numx-numo==1)\\n        {\\n            for(int i=0;i<3;i++)\\n            {\\n                for(int j=0;j<3;j++)\\n                {\\n                    if(board[i][j]==\\'O\\')\\n                    {\\n                        if(didWon(i,j,board,\\'O\\'))return false;\\n                    }\\n                }\\n            }      \\n        }\\n\\t\\t//else return true if none of the above conditions failed to prove the state as invalid. \\n        return true;\\n    }\\n};\\n\\n//Please upvote if you liked it. \\n//Thanks\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673903,
                "title": "python-for-a-n-n-board-with-explanation",
                "content": "In real interviews, it is possible the interviewer will ask what if it is an `n*n` board, and what if we want to adjust our rules, etc. \\nSo it will be helpful to use a helper function, and even if we adjust our rules, we just need to refactor our helper function, as the general valid-or-not logic remains the same. \\nHere is an implemenation for a `n*n` board:\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # case 1 &2 : X.amound < O.amount or X.amount - O.amount >1\\n        if sum(row.count(\\'X\\') for row in board) < sum(row.count(\\'O\\') for row in board) \\\\\\n        or sum(row.count(\\'X\\') for row in board) - sum(row.count(\\'O\\') for row in board)>1:\\n            return False\\n        # case 3: somebody already has a winning state\\n        if self.iswin(board, \\'X\\'):\\n            if sum(row.count(\\'X\\') for row in board) - sum(row.count(\\'O\\') for row in board)!=1:\\n                return False\\n        if self.iswin(board, \\'O\\'):\\n            if sum(row.count(\\'X\\') for row in board) != sum(row.count(\\'O\\') for row in board):\\n                return False\\n        return True\\n    \\n    def iswin(self, board, target):\\n        # n*n board\\n        if any(row == target*len(board) for row in board):\\n            return True\\n        for c in range(len(board[0])):\\n            if all(board[r][c] == target for r in range(len(board))):\\n                return True\\n        # diagonal\\n        diag = [(i,i) for i in range(len(board))]\\n        reverse_diag = [(i, len(board)-1-i) for i in range(len(board))]\\n        if all(board[x][y] == target for x,y in diag) or all(board[x][y] == target for x,y in reverse_diag):\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # case 1 &2 : X.amound < O.amount or X.amount - O.amount >1\\n        if sum(row.count(\\'X\\') for row in board) < sum(row.count(\\'O\\') for row in board) \\\\\\n        or sum(row.count(\\'X\\') for row in board) - sum(row.count(\\'O\\') for row in board)>1:\\n            return False\\n        # case 3: somebody already has a winning state\\n        if self.iswin(board, \\'X\\'):\\n            if sum(row.count(\\'X\\') for row in board) - sum(row.count(\\'O\\') for row in board)!=1:\\n                return False\\n        if self.iswin(board, \\'O\\'):\\n            if sum(row.count(\\'X\\') for row in board) != sum(row.count(\\'O\\') for row in board):\\n                return False\\n        return True\\n    \\n    def iswin(self, board, target):\\n        # n*n board\\n        if any(row == target*len(board) for row in board):\\n            return True\\n        for c in range(len(board[0])):\\n            if all(board[r][c] == target for r in range(len(board))):\\n                return True\\n        # diagonal\\n        diag = [(i,i) for i in range(len(board))]\\n        reverse_diag = [(i, len(board)-1-i) for i in range(len(board))]\\n        if all(board[x][y] == target for x,y in diag) or all(board[x][y] == target for x,y in reverse_diag):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570089,
                "title": "c-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int cntX = 0;\\n        int cntO = 0;\\n        for(string s : board)\\n        {\\n            for(char c : s)\\n            {\\n                if(c == \\'X\\') cntX++;\\n                else if(c == \\'O\\') cntO++;\\n            }\\n        }\\n        bool XWin = (board[0] == \"XXX\" || board[1] == \"XXX\" || board[2] == \"XXX\"\\n                      ||(board[0][0] == \\'X\\' && board[1][0] == \\'X\\' && board[2][0] == \\'X\\')\\n                      ||(board[0][1] == \\'X\\' && board[1][1] == \\'X\\' && board[2][1] == \\'X\\')\\n                      ||(board[0][2] == \\'X\\' && board[1][2] == \\'X\\' && board[2][2] == \\'X\\')\\n                      ||(board[0][0] == \\'X\\' && board[1][1] == \\'X\\' && board[2][2] == \\'X\\')\\n                      ||(board[0][2] == \\'X\\' && board[1][1] == \\'X\\' && board[2][0] == \\'X\\'));\\n        bool OWin = (board[0] == \"OOO\" || board[1] == \"OOO\" || board[2] == \"OOO\"\\n                      ||(board[0][0] == \\'O\\' && board[1][0] == \\'O\\' && board[2][0] == \\'O\\')\\n                      ||(board[0][1] == \\'O\\' && board[1][1] == \\'O\\' && board[2][1] == \\'O\\')\\n                      ||(board[0][2] == \\'O\\' && board[1][2] == \\'O\\' && board[2][2] == \\'O\\')\\n                      ||(board[0][0] == \\'O\\' && board[1][1] == \\'O\\' && board[2][2] == \\'O\\')\\n                      ||(board[0][2] == \\'O\\' && board[1][1] == \\'O\\' && board[2][0] == \\'O\\'));\\n        if(XWin) return cntO == cntX-1;\\n        if(OWin) return cntO == cntX;\\n        return cntX == cntO || cntX-1 == cntO;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int cntX = 0;\\n        int cntO = 0;\\n        for(string s : board)\\n        {\\n            for(char c : s)\\n            {\\n                if(c == \\'X\\') cntX++;\\n                else if(c == \\'O\\') cntO++;\\n            }\\n        }\\n        bool XWin = (board[0] == \"XXX\" || board[1] == \"XXX\" || board[2] == \"XXX\"\\n                      ||(board[0][0] == \\'X\\' && board[1][0] == \\'X\\' && board[2][0] == \\'X\\')\\n                      ||(board[0][1] == \\'X\\' && board[1][1] == \\'X\\' && board[2][1] == \\'X\\')\\n                      ||(board[0][2] == \\'X\\' && board[1][2] == \\'X\\' && board[2][2] == \\'X\\')\\n                      ||(board[0][0] == \\'X\\' && board[1][1] == \\'X\\' && board[2][2] == \\'X\\')\\n                      ||(board[0][2] == \\'X\\' && board[1][1] == \\'X\\' && board[2][0] == \\'X\\'));\\n        bool OWin = (board[0] == \"OOO\" || board[1] == \"OOO\" || board[2] == \"OOO\"\\n                      ||(board[0][0] == \\'O\\' && board[1][0] == \\'O\\' && board[2][0] == \\'O\\')\\n                      ||(board[0][1] == \\'O\\' && board[1][1] == \\'O\\' && board[2][1] == \\'O\\')\\n                      ||(board[0][2] == \\'O\\' && board[1][2] == \\'O\\' && board[2][2] == \\'O\\')\\n                      ||(board[0][0] == \\'O\\' && board[1][1] == \\'O\\' && board[2][2] == \\'O\\')\\n                      ||(board[0][2] == \\'O\\' && board[1][1] == \\'O\\' && board[2][0] == \\'O\\'));\\n        if(XWin) return cntO == cntX-1;\\n        if(OWin) return cntO == cntX;\\n        return cntX == cntO || cntX-1 == cntO;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535947,
                "title": "java-clean-code-generic-board-solution",
                "content": "```java\\npublic boolean validTicTacToe(String[] board) {\\n    int n = board.length;\\n    int[] rows = new int[n];\\n    int[] cols = new int[n];\\n    int[] diagonals = new int[2];\\n    \\n    int turns = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            char ch = board[i].charAt(j);\\n            if (ch == \\'X\\') {\\n                turns++;\\n                updateScores(rows, cols, diagonals, i, j, 1);\\n            }\\n            if (ch == \\'O\\') {\\n                turns--;\\n                updateScores(rows, cols, diagonals, i, j, -1);\\n            }   \\n        }\\n    }\\n    boolean isWonByX = isWon(rows, cols, diagonals, n);\\n    boolean isWonByY = isWon(rows, cols, diagonals, -n);\\n    \\n    if (isWonByX && turns != 1 || isWonByY && turns != 0) return false;\\n    \\n    return turns == 0 || turns == 1;\\n}\\nprivate void updateScores(int[] rows, int[] cols, int[] diagonals, int r, int c, int score) {\\n    rows[r] += score;\\n    cols[c] += score;\\n    \\n    if (r == c) diagonals[0] += score;\\n    if (r + c == rows.length - 1) diagonals[1] += score;\\n}\\n\\nprivate boolean isWon(int[] rows, int[] cols, int[] diagonals, int scores) {\\n    for (int i = 0; i < rows.length; i++) {\\n        if (rows[i] == scores || cols[i] == scores)\\n            return true;\\n    }\\n    return diagonals[0] == scores || diagonals[1] == scores;\\n}\\n```\\n\\n**Credit**  @mmao3",
                "solutionTags": [],
                "code": "```java\\npublic boolean validTicTacToe(String[] board) {\\n    int n = board.length;\\n    int[] rows = new int[n];\\n    int[] cols = new int[n];\\n    int[] diagonals = new int[2];\\n    \\n    int turns = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            char ch = board[i].charAt(j);\\n            if (ch == \\'X\\') {\\n                turns++;\\n                updateScores(rows, cols, diagonals, i, j, 1);\\n            }\\n            if (ch == \\'O\\') {\\n                turns--;\\n                updateScores(rows, cols, diagonals, i, j, -1);\\n            }   \\n        }\\n    }\\n    boolean isWonByX = isWon(rows, cols, diagonals, n);\\n    boolean isWonByY = isWon(rows, cols, diagonals, -n);\\n    \\n    if (isWonByX && turns != 1 || isWonByY && turns != 0) return false;\\n    \\n    return turns == 0 || turns == 1;\\n}\\nprivate void updateScores(int[] rows, int[] cols, int[] diagonals, int r, int c, int score) {\\n    rows[r] += score;\\n    cols[c] += score;\\n    \\n    if (r == c) diagonals[0] += score;\\n    if (r + c == rows.length - 1) diagonals[1] += score;\\n}\\n\\nprivate boolean isWon(int[] rows, int[] cols, int[] diagonals, int scores) {\\n    for (int i = 0; i < rows.length; i++) {\\n        if (rows[i] == scores || cols[i] == scores)\\n            return true;\\n    }\\n    return diagonals[0] == scores || diagonals[1] == scores;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530760,
                "title": "python-c-java-17-lines-straightforward-solution-std-any-std-count",
                "content": "The code explains itself :)\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def isWin(c: chr) -> bool:\\n            return any(row.count(c) == 3 for row in board) or \\\\\\n                any(row.count(c) == 3 for row in list(zip(*board))) or \\\\\\n                all(board[i][i] == c for i in range(3)) or \\\\\\n                all(board[i][2 - i] == c for i in range(3))\\n\\n        countX = sum(row.count(\\'X\\') for row in board)\\n        countO = sum(row.count(\\'O\\') for row in board)\\n\\n        if countX < countO or countX - countO > 1:\\n            return False\\n        if isWin(\\'X\\') and countX == countO or isWin(\\'O\\') and countX != countO:\\n            return False\\n\\n        return True\\n```\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\n public:\\n  bool validTicTacToe(vector<string>& board) {\\n    int countX = sum(board, \\'X\\');\\n    int countO = sum(board, \\'O\\');\\n\\n    if (countX < countO || countX - countO > 1) return false;\\n    if (isWinned(board, \\'X\\') && countX == countO ||\\n        isWinned(board, \\'O\\') && countX != countO)\\n      return false;\\n\\n    return true;\\n  }\\n\\n private:\\n  int sum(const vector<string>& board, char c) {\\n    int ans = 0;\\n\\n    for (const string& row : board) ans += count(begin(row), end(row), c);\\n\\n    return ans;\\n  }\\n\\n  bool isWinned(const vector<string>& board, char c) {\\n    vector<string> rotated = rotate(board);\\n\\n    auto equalsToThree = [&c](const string& row) {\\n      return count(begin(row), end(row), c) == 3;\\n    };\\n\\n    return any_of(begin(board), end(board), equalsToThree) ||\\n           any_of(begin(rotated), end(rotated), equalsToThree) ||\\n           board[0][0] == c && board[1][1] == c && board[2][2] == c ||\\n           board[0][2] == c && board[1][1] == c && board[2][0] == c;\\n  }\\n\\n  vector<string> rotate(const vector<string>& board) {\\n    vector<string> rotated(3);\\n\\n    for (const string& row : board)\\n      for (int i = 0; i < 3; ++i) rotated[i].push_back(row[i]);\\n\\n    return rotated;\\n  }\\n};\\n```\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n  public boolean validTicTacToe(String[] board) {\\n    int countX = sum(board, \\'X\\');\\n    int countO = sum(board, \\'O\\');\\n\\n    if (countX < countO || countX - countO > 1)\\n      return false;\\n    if (isWinned(board, \\'X\\') && countX == countO || isWinned(board, \\'O\\') && countX != countO)\\n      return false;\\n\\n    return true;\\n  }\\n\\n  private int sum(final String[] board, char c) {\\n    int ans = 0;\\n\\n    for (final String row : board)\\n      ans += row.chars().filter(i -> i == c).count();\\n\\n    return ans;\\n  }\\n\\n  private boolean isWinned(final String[] board, char c) {\\n    String[] rotated = rotate(board);\\n\\n    return Arrays.stream(board).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\\n        || Arrays.stream(rotated).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\\n        || board[0].charAt(0) == c && board[1].charAt(1) == c && board[2].charAt(2) == c\\n        || board[0].charAt(2) == c && board[1].charAt(1) == c && board[2].charAt(0) == c;\\n  }\\n\\n  private String[] rotate(final String[] board) {\\n    String[] rotated = new String[3];\\n\\n    for (final String row : board)\\n      for (int i = 0; i < 3; ++i)\\n        rotated[i] += row.charAt(i);\\n\\n    return rotated;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        def isWin(c: chr) -> bool:\\n            return any(row.count(c) == 3 for row in board) or \\\\\\n                any(row.count(c) == 3 for row in list(zip(*board))) or \\\\\\n                all(board[i][i] == c for i in range(3)) or \\\\\\n                all(board[i][2 - i] == c for i in range(3))\\n\\n        countX = sum(row.count(\\'X\\') for row in board)\\n        countO = sum(row.count(\\'O\\') for row in board)\\n\\n        if countX < countO or countX - countO > 1:\\n            return False\\n        if isWin(\\'X\\') and countX == countO or isWin(\\'O\\') and countX != countO:\\n            return False\\n\\n        return True\\n```\n```cpp\\nclass Solution {\\n public:\\n  bool validTicTacToe(vector<string>& board) {\\n    int countX = sum(board, \\'X\\');\\n    int countO = sum(board, \\'O\\');\\n\\n    if (countX < countO || countX - countO > 1) return false;\\n    if (isWinned(board, \\'X\\') && countX == countO ||\\n        isWinned(board, \\'O\\') && countX != countO)\\n      return false;\\n\\n    return true;\\n  }\\n\\n private:\\n  int sum(const vector<string>& board, char c) {\\n    int ans = 0;\\n\\n    for (const string& row : board) ans += count(begin(row), end(row), c);\\n\\n    return ans;\\n  }\\n\\n  bool isWinned(const vector<string>& board, char c) {\\n    vector<string> rotated = rotate(board);\\n\\n    auto equalsToThree = [&c](const string& row) {\\n      return count(begin(row), end(row), c) == 3;\\n    };\\n\\n    return any_of(begin(board), end(board), equalsToThree) ||\\n           any_of(begin(rotated), end(rotated), equalsToThree) ||\\n           board[0][0] == c && board[1][1] == c && board[2][2] == c ||\\n           board[0][2] == c && board[1][1] == c && board[2][0] == c;\\n  }\\n\\n  vector<string> rotate(const vector<string>& board) {\\n    vector<string> rotated(3);\\n\\n    for (const string& row : board)\\n      for (int i = 0; i < 3; ++i) rotated[i].push_back(row[i]);\\n\\n    return rotated;\\n  }\\n};\\n```\n```java\\nclass Solution {\\n  public boolean validTicTacToe(String[] board) {\\n    int countX = sum(board, \\'X\\');\\n    int countO = sum(board, \\'O\\');\\n\\n    if (countX < countO || countX - countO > 1)\\n      return false;\\n    if (isWinned(board, \\'X\\') && countX == countO || isWinned(board, \\'O\\') && countX != countO)\\n      return false;\\n\\n    return true;\\n  }\\n\\n  private int sum(final String[] board, char c) {\\n    int ans = 0;\\n\\n    for (final String row : board)\\n      ans += row.chars().filter(i -> i == c).count();\\n\\n    return ans;\\n  }\\n\\n  private boolean isWinned(final String[] board, char c) {\\n    String[] rotated = rotate(board);\\n\\n    return Arrays.stream(board).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\\n        || Arrays.stream(rotated).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\\n        || board[0].charAt(0) == c && board[1].charAt(1) == c && board[2].charAt(2) == c\\n        || board[0].charAt(2) == c && board[1].charAt(1) == c && board[2].charAt(0) == c;\\n  }\\n\\n  private String[] rotate(final String[] board) {\\n    String[] rotated = new String[3];\\n\\n    for (final String row : board)\\n      for (int i = 0; i < 3; ++i)\\n        rotated[i] += row.charAt(i);\\n\\n    return rotated;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489869,
                "title": "java-solution-straightforward-beats-100-with-explains",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        //countX & countO\\n        int countX = 0, countO = 0;\\n        for (String s : board) {\\n            char[] arr = s.toCharArray();\\n            for (char c : arr) {\\n                if (c == \\'X\\') countX++;\\n                else if (c == \\'O\\') countO++;\\n            }\\n        }\\n        if (countX < countO || countX > countO + 1) return false;\\n        \\n        // check xWin or oWin\\n        boolean xWin = false, oWin = false;\\n        //check row & column\\n        for (int i = 0; i < 3; i++) {\\n            if (board[i].equals(\"XXX\")) xWin = true;\\n            if (board[i].equals(\"OOO\")) oWin = true;\\n            if (board[0].charAt(i) == \\'X\\' && board[1].charAt(i) == \\'X\\' && board[2].charAt(i) == \\'X\\') xWin = true;\\n            if (board[0].charAt(i) == \\'O\\' && board[1].charAt(i) == \\'O\\' && board[2].charAt(i) == \\'O\\') oWin = true;\\n        }\\n        //check diagonal\\n        if (!xWin) {\\n            if (board[0].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\') xWin = true;\\n            else if (board[0].charAt(2) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(0) == \\'X\\') xWin = true;\\n        }\\n        if (!oWin) {\\n            if (board[0].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\') oWin = true;\\n            else if (board[0].charAt(2) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(0) == \\'O\\') oWin = true;\\n        }\\n\\n        if (countX == countO && xWin) return false;\\n        else if (countX == countO + 1 && oWin) return false;\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\ncountX, countO\\nnumber of X can be equal to number of O or countX > countO 1 element\\n\\nif(countX == countO) => X cannot Win\\nif(countX == countO +1) => O cannot Win\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        //countX & countO\\n        int countX = 0, countO = 0;\\n        for (String s : board) {\\n            char[] arr = s.toCharArray();\\n            for (char c : arr) {\\n                if (c == \\'X\\') countX++;\\n                else if (c == \\'O\\') countO++;\\n            }\\n        }\\n        if (countX < countO || countX > countO + 1) return false;\\n        \\n        // check xWin or oWin\\n        boolean xWin = false, oWin = false;\\n        //check row & column\\n        for (int i = 0; i < 3; i++) {\\n            if (board[i].equals(\"XXX\")) xWin = true;\\n            if (board[i].equals(\"OOO\")) oWin = true;\\n            if (board[0].charAt(i) == \\'X\\' && board[1].charAt(i) == \\'X\\' && board[2].charAt(i) == \\'X\\') xWin = true;\\n            if (board[0].charAt(i) == \\'O\\' && board[1].charAt(i) == \\'O\\' && board[2].charAt(i) == \\'O\\') oWin = true;\\n        }\\n        //check diagonal\\n        if (!xWin) {\\n            if (board[0].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\') xWin = true;\\n            else if (board[0].charAt(2) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(0) == \\'X\\') xWin = true;\\n        }\\n        if (!oWin) {\\n            if (board[0].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\') oWin = true;\\n            else if (board[0].charAt(2) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(0) == \\'O\\') oWin = true;\\n        }\\n\\n        if (countX == countO && xWin) return false;\\n        else if (countX == countO + 1 && oWin) return false;\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\ncountX, countO\\nnumber of X can be equal to number of O or countX > countO 1 element\\n\\nif(countX == countO) => X cannot Win\\nif(countX == countO +1) => O cannot Win\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478076,
                "title": "python-sol-based-on-iterative-board-scan-with-explanation",
                "content": "Python sol.based on iterative board-scan.\\n\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        \\n        rows, cols = [0] *3, [0]*3\\n        \\n        first_diag, second_diag = 0, 0\\n        \\n        turns = 0\\n        \\n        for y in range(3):\\n            \\n            for x in range(3):\\n                \\n                if board[y][x] == \\'O\\':\\n                    # \\'O\\' on board[y][x]\\n                    # \\'O\\' is on the second order of each play\\n                    turns -= 1\\n                    \\n                    # update the existance counter of \\'O\\' of each possible line\\n                    rows[y] -= 1\\n                    cols[x] -= 1\\n                    \\n                    if y == x:\\n                        first_diag -= 1\\n                    \\n                    if y + x == 2:\\n                        second_diag -=1\\n                \\n                \\n                elif board[y][x] == \\'X\\':\\n                    # \\'X\\' on board[y][x]\\n\\n                    # \\'X\\' is on the first order of each play\\n                    turns += 1\\n                    \\n                    # update the existance counter of \\'X\\' of each possible line\\n                    rows[y] += 1\\n                    cols[x] += 1\\n                    \\n                    if y == x:\\n                        first_diag += 1\\n                        \\n                    if y + x == 2:\\n                        second_diag +=1\\n\\n\\n        # check the win state of \\'X\\'                        \\n        win_of_x =  rows[0] == 3 or rows[1] == 3 or rows[2] == 3 or \\\\\\n                    cols[0] == 3 or cols[1] == 3 or cols[2] == 3 or \\\\\\n                    first_diag == 3 or second_diag == 3\\n        \\n        # check the win state of \\'O\\'\\n        win_of_o =  rows[0] == -3 or rows[1] == -3 or rows[2] == -3 or \\\\\\n                    cols[0] == -3 or cols[1] == -3 or cols[2] == -3 or \\\\\\n                    first_diag == -3 or second_diag == -3\\n        \\n        \\n        if ( win_of_x and turns == 0 ) or  ( win_of_o and turns == 1):\\n            # \\'X\\' must win with first order, and \\'O\\' must win with second order\\n            return False\\n\\n        else:\\n            # \\'X\\' and \\'O\\' must take turns with each other.\\n            # \\'XX\\' and \\'OO\\' is not allowed.\\n            return turns == 0 or turns == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        \\n        rows, cols = [0] *3, [0]*3\\n        \\n        first_diag, second_diag = 0, 0\\n        \\n        turns = 0\\n        \\n        for y in range(3):\\n            \\n            for x in range(3):\\n                \\n                if board[y][x] == \\'O\\':\\n                    # \\'O\\' on board[y][x]\\n                    # \\'O\\' is on the second order of each play\\n                    turns -= 1\\n                    \\n                    # update the existance counter of \\'O\\' of each possible line\\n                    rows[y] -= 1\\n                    cols[x] -= 1\\n                    \\n                    if y == x:\\n                        first_diag -= 1\\n                    \\n                    if y + x == 2:\\n                        second_diag -=1\\n                \\n                \\n                elif board[y][x] == \\'X\\':\\n                    # \\'X\\' on board[y][x]\\n\\n                    # \\'X\\' is on the first order of each play\\n                    turns += 1\\n                    \\n                    # update the existance counter of \\'X\\' of each possible line\\n                    rows[y] += 1\\n                    cols[x] += 1\\n                    \\n                    if y == x:\\n                        first_diag += 1\\n                        \\n                    if y + x == 2:\\n                        second_diag +=1\\n\\n\\n        # check the win state of \\'X\\'                        \\n        win_of_x =  rows[0] == 3 or rows[1] == 3 or rows[2] == 3 or \\\\\\n                    cols[0] == 3 or cols[1] == 3 or cols[2] == 3 or \\\\\\n                    first_diag == 3 or second_diag == 3\\n        \\n        # check the win state of \\'O\\'\\n        win_of_o =  rows[0] == -3 or rows[1] == -3 or rows[2] == -3 or \\\\\\n                    cols[0] == -3 or cols[1] == -3 or cols[2] == -3 or \\\\\\n                    first_diag == -3 or second_diag == -3\\n        \\n        \\n        if ( win_of_x and turns == 0 ) or  ( win_of_o and turns == 1):\\n            # \\'X\\' must win with first order, and \\'O\\' must win with second order\\n            return False\\n\\n        else:\\n            # \\'X\\' and \\'O\\' must take turns with each other.\\n            # \\'XX\\' and \\'OO\\' is not allowed.\\n            return turns == 0 or turns == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392174,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    private static char X = \\'X\\', O = \\'O\\';        \\n    public boolean validTicTacToe(String[] board) {\\n        int c1 = 0, c2 = 0;\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length(); j++) {\\n                if (board[i].charAt(j) == X) c1++;\\n                else if (board[i].charAt(j) == O) c2++;\\n            }\\n        }\\n        if (c1 < c2) return false;   // second player played first\\n        if (c1 - c2 > 1) return false;\\n        if (c1 >= 3 || c2 >= 3) {\\n            boolean xwins = checkWin(board, X);\\n            boolean owins = checkWin(board, O);\\n            if (xwins && owins) return false;\\n            if (xwins) {\\n                return c1 == c2+1;\\n            }\\n            else if (owins) {\\n                return c1 == c2;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkWin(String[] b, char c) {\\n        return (\\n            (b[0].charAt(0) == c && b[0].charAt(1) == c && b[0].charAt(2) == c) ||\\n            (b[1].charAt(0) == c && b[1].charAt(1) == c && b[1].charAt(2) == c) ||\\n            (b[2].charAt(0) == c && b[2].charAt(1) == c && b[2].charAt(2) == c) ||\\n            (b[0].charAt(0) == c && b[1].charAt(0) == c && b[2].charAt(0) == c) ||\\n            (b[0].charAt(1) == c && b[1].charAt(1) == c && b[2].charAt(1) == c) ||\\n            (b[0].charAt(2) == c && b[1].charAt(2) == c && b[2].charAt(2) == c) ||\\n            (b[0].charAt(0) == c && b[1].charAt(1) == c && b[2].charAt(2) == c) ||\\n            (b[0].charAt(2) == c && b[1].charAt(1) == c && b[2].charAt(0) == c)\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static char X = \\'X\\', O = \\'O\\';        \\n    public boolean validTicTacToe(String[] board) {\\n        int c1 = 0, c2 = 0;\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length(); j++) {\\n                if (board[i].charAt(j) == X) c1++;\\n                else if (board[i].charAt(j) == O) c2++;\\n            }\\n        }\\n        if (c1 < c2) return false;   // second player played first\\n        if (c1 - c2 > 1) return false;\\n        if (c1 >= 3 || c2 >= 3) {\\n            boolean xwins = checkWin(board, X);\\n            boolean owins = checkWin(board, O);\\n            if (xwins && owins) return false;\\n            if (xwins) {\\n                return c1 == c2+1;\\n            }\\n            else if (owins) {\\n                return c1 == c2;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkWin(String[] b, char c) {\\n        return (\\n            (b[0].charAt(0) == c && b[0].charAt(1) == c && b[0].charAt(2) == c) ||\\n            (b[1].charAt(0) == c && b[1].charAt(1) == c && b[1].charAt(2) == c) ||\\n            (b[2].charAt(0) == c && b[2].charAt(1) == c && b[2].charAt(2) == c) ||\\n            (b[0].charAt(0) == c && b[1].charAt(0) == c && b[2].charAt(0) == c) ||\\n            (b[0].charAt(1) == c && b[1].charAt(1) == c && b[2].charAt(1) == c) ||\\n            (b[0].charAt(2) == c && b[1].charAt(2) == c && b[2].charAt(2) == c) ||\\n            (b[0].charAt(0) == c && b[1].charAt(1) == c && b[2].charAt(2) == c) ||\\n            (b[0].charAt(2) == c && b[1].charAt(1) == c && b[2].charAt(0) == c)\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316019,
                "title": "i-don-t-understand-this-testcase",
                "content": "I don\\'t understand this test case, it says the expected value should be `false` but I\\'m convinced it should be `true`\\n\\nTestcase: \\n```\\n[\"OXX\",\"XOX\",\"OXO\"]\\nExpected: false\\nOutput: true\\n```",
                "solutionTags": [],
                "code": "```\\n[\"OXX\",\"XOX\",\"OXO\"]\\nExpected: false\\nOutput: true\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294127,
                "title": "an-easy-way-to-check-whether-x-or-o-wins",
                "content": "use array of 9 primes to get score for each player. there are 8 combinations winning so 8 nums in checking part.\\n\\n\\n\\n    bool win(int score) {\\n        static vector<int> wins({30, 1001, 7429, 238, 627, 1495, 506, 935});\\n        for(int x : wins) {\\n            if(score % x == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\tbool validTicTacToe(vector<string>& board) {\\n        static vector<int> prims({2,3,5,7,11,13,17,19,23});\\n        int scorex = 1, scoreo = 1;\\n        int cofx = 0, cofo = 0;\\n        int score = 0;\\n        for(string s: board) {\\n            for(char c : s) {\\n                if(c == \\'X\\') {\\n                    scorex *= prims[score];\\n                    ++cofx;\\n                }\\n                else if(c == \\'O\\') {\\n                    scoreo *= prims[score];\\n                    ++cofo;\\n                }\\n                ++score;\\n            }\\n        }\\n        \\n        if(cofx < cofo || cofx > cofo + 1)\\n            return false;\\n        \\n        bool xwin = win(scorex);    \\n        if(xwin && cofx == cofo)\\n            return false;\\n        \\n        bool owin = win(scoreo);\\n        if(owin && cofx > cofo)\\n            return false;\\n        \\n        if(xwin && owin)\\n            return false;\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "use array of 9 primes to get score for each player. there are 8 combinations winning so 8 nums in checking part.\\n\\n\\n\\n    bool win(int score) {\\n        static vector<int> wins({30, 1001, 7429, 238, 627, 1495, 506, 935});\\n        for(int x : wins) {\\n            if(score % x == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\tbool validTicTacToe(vector<string>& board) {\\n        static vector<int> prims({2,3,5,7,11,13,17,19,23});\\n        int scorex = 1, scoreo = 1;\\n        int cofx = 0, cofo = 0;\\n        int score = 0;\\n        for(string s: board) {\\n            for(char c : s) {\\n                if(c == \\'X\\') {\\n                    scorex *= prims[score];\\n                    ++cofx;\\n                }\\n                else if(c == \\'O\\') {\\n                    scoreo *= prims[score];\\n                    ++cofo;\\n                }\\n                ++score;\\n            }\\n        }\\n        \\n        if(cofx < cofo || cofx > cofo + 1)\\n            return false;\\n        \\n        bool xwin = win(scorex);    \\n        if(xwin && cofx == cofo)\\n            return false;\\n        \\n        bool owin = win(scoreo);\\n        if(owin && cofx > cofo)\\n            return false;\\n        \\n        if(xwin && owin)\\n            return false;\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 186336,
                "title": "python-solution-20ms-beats-100",
                "content": "```\\nclass Solution(object):\\n    def get_count(self,board,char):\\n        count = 0\\n        for s in board:\\n            count += s.count(char)\\n        return count\\n    \\n    def check_win(self,board,char):\\n        for i in range(3):\\n            if(board[i][0]==board[i][1]==board[i][2]==char):\\n                return True\\n        for i in range(3):\\n            if(board[0][i]==board[1][i]==board[2][i]==char):\\n                return True\\n        if(board[0][0]==board[1][1]==board[2][2]==char):\\n            return True\\n        if(board[0][2]==board[1][1]==board[2][0]==char):\\n            return True\\n        \\n        \\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        o_count = self.get_count(board,\\'O\\')\\n        x_count = self.get_count(board,\\'X\\')\\n        if  x_count-o_count >1:\\n            return False\\n        if x_count<o_count:\\n            return False\\n        is_o_win = self.check_win(board,\\'O\\')\\n        is_x_win = self.check_win(board,\\'X\\')\\n        if is_o_win and is_x_win:\\n            return False\\n        if is_o_win:\\n            if x_count>o_count:\\n                return False\\n        if is_x_win:\\n            if o_count==x_count:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def get_count(self,board,char):\\n        count = 0\\n        for s in board:\\n            count += s.count(char)\\n        return count\\n    \\n    def check_win(self,board,char):\\n        for i in range(3):\\n            if(board[i][0]==board[i][1]==board[i][2]==char):\\n                return True\\n        for i in range(3):\\n            if(board[0][i]==board[1][i]==board[2][i]==char):\\n                return True\\n        if(board[0][0]==board[1][1]==board[2][2]==char):\\n            return True\\n        if(board[0][2]==board[1][1]==board[2][0]==char):\\n            return True\\n        \\n        \\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        o_count = self.get_count(board,\\'O\\')\\n        x_count = self.get_count(board,\\'X\\')\\n        if  x_count-o_count >1:\\n            return False\\n        if x_count<o_count:\\n            return False\\n        is_o_win = self.check_win(board,\\'O\\')\\n        is_x_win = self.check_win(board,\\'X\\')\\n        if is_o_win and is_x_win:\\n            return False\\n        if is_o_win:\\n            if x_count>o_count:\\n                return False\\n        if is_x_win:\\n            if o_count==x_count:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160773,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dic_row = [{\\'X\\':0, \\'O\\':0, \\' \\':0} for _ in range(3)]\\n        dic_col = [{\\'X\\':0, \\'O\\':0, \\' \\':0} for _ in range(3)]\\n        dic_diag = [{\\'X\\':0, \\'O\\':0, \\' \\':0} for _ in range(2)]\\n        count_X = 0\\n        count_O = 0\\n        for i in range(3):\\n            for j in range(3):\\n                char = board[i][j]\\n                dic_row[i][char] += 1\\n                dic_col[j][char] += 1\\n                if j == i:\\n                    dic_diag[0][char] += 1\\n                if j == 2-i:\\n                    dic_diag[1][char] += 1\\n                if char == \"X\":\\n                    count_X += 1\\n                elif char == \"O\":\\n                    count_O += 1\\n        if not (count_X - count_O == 0 or count_X - count_O == 1):\\n            return False\\n        win_count_1 = 0\\n        win_count_2 = 0\\n        dic_comb = dic_row + dic_col + dic_diag\\n        for dic in dic_comb:\\n            if dic[\"X\"] == 3:\\n                win_count_1 += 1\\n            elif dic[\"O\"] == 3:\\n                win_count_2 += 1\\n        if win_count_1 == 0 and win_count_2 == 0:\\n            return True\\n        elif win_count_1 - win_count_2 > 0 and count_X - count_O == 1:\\n            return True\\n        elif win_count_1 - win_count_2 < 0 and count_X == count_O:\\n            return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dic_row = [{\\'X\\':0, \\'O\\':0, \\' \\':0} for _ in range(3)]\\n        dic_col = [{\\'X\\':0, \\'O\\':0, \\' \\':0} for _ in range(3)]\\n        dic_diag = [{\\'X\\':0, \\'O\\':0, \\' \\':0} for _ in range(2)]\\n        count_X = 0\\n        count_O = 0\\n        for i in range(3):\\n            for j in range(3):\\n                char = board[i][j]\\n                dic_row[i][char] += 1\\n                dic_col[j][char] += 1\\n                if j == i:\\n                    dic_diag[0][char] += 1\\n                if j == 2-i:\\n                    dic_diag[1][char] += 1\\n                if char == \"X\":\\n                    count_X += 1\\n                elif char == \"O\":\\n                    count_O += 1\\n        if not (count_X - count_O == 0 or count_X - count_O == 1):\\n            return False\\n        win_count_1 = 0\\n        win_count_2 = 0\\n        dic_comb = dic_row + dic_col + dic_diag\\n        for dic in dic_comb:\\n            if dic[\"X\"] == 3:\\n                win_count_1 += 1\\n            elif dic[\"O\"] == 3:\\n                win_count_2 += 1\\n        if win_count_1 == 0 and win_count_2 == 0:\\n            return True\\n        elif win_count_1 - win_count_2 > 0 and count_X - count_O == 1:\\n            return True\\n        elif win_count_1 - win_count_2 < 0 and count_X == count_O:\\n            return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150559,
                "title": "python-simple-solution-beats-99-7",
                "content": "The idea is, number of Xs can only be equal to Os, or Os + 1.\\nIn the first case, it\\'s impossible for O to win.\\nIn the later case, it\\'s impossible for X to win.\\n\\n```python\\nclass Solution:\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        def check_win(board, sym):\\n            # check win\\n            for ln in board:\\n                if ln == sym*3:\\n                    return True\\n            if b[0] == sym and b[3] == sym and b[6] == sym: return True\\n            if b[1] == sym and b[4] == sym and b[7] == sym: return True\\n            if b[2] == sym and b[5] == sym and b[8] == sym: return True\\n            if b[0] == sym and b[4] == sym and b[8] == sym: return True\\n            if b[2] == sym and b[4] == sym and b[6] == sym: return True\\n            \\n            return False     \\n        \\n        b = \\'\\'.join(board)\\n        xs = b.count(\\'X\\')\\n        os = b.count(\\'O\\')\\n        \\n        if os == xs:\\n            if check_win(board, \\'X\\'): return False\\n            return True\\n        if xs == os + 1:\\n            if check_win(board,\\'O\\'): return False\\n            return True\\n            \\n        return False\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def validTicTacToe(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        def check_win(board, sym):\\n            # check win\\n            for ln in board:\\n                if ln == sym*3:\\n                    return True\\n            if b[0] == sym and b[3] == sym and b[6] == sym: return True\\n            if b[1] == sym and b[4] == sym and b[7] == sym: return True\\n            if b[2] == sym and b[5] == sym and b[8] == sym: return True\\n            if b[0] == sym and b[4] == sym and b[8] == sym: return True\\n            if b[2] == sym and b[4] == sym and b[6] == sym: return True\\n            \\n            return False     \\n        \\n        b = \\'\\'.join(board)\\n        xs = b.count(\\'X\\')\\n        os = b.count(\\'O\\')\\n        \\n        if os == xs:\\n            if check_win(board, \\'X\\'): return False\\n            return True\\n        if xs == os + 1:\\n            if check_win(board,\\'O\\'): return False\\n            return True\\n            \\n        return False\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 117706,
                "title": "java-solution",
                "content": "    public boolean validTicTacToe(String[] board) {\n        int numOfO = 0;\n        int numOfX = 0;\n        for(String str: board){\n            for(int i=0; i<str.length(); i++){\n                if(str.charAt(i) == 'O'){\n                    numOfO++;\n                }else if(str.charAt(i) == 'X'){\n                    numOfX++;\n                }\n            }\n        }\n        \n        //Rule 1-3\n        if(numOfX < numOfO || numOfX > numOfO + 1){\n            return false;\n        }\n        \n        //Rule 5\n        if(numOfX + numOfO > 9){\n            return false;\n        }\n        \n        //Check if someone won\n        int wonO = 0;\n        int wonX = 0;\n        \n        //Vertical\n        for(String str: board){\n            if(str.charAt(0) == 'O' && str.charAt(1) == 'O' && str.charAt(2) == 'O'){\n                wonO++;\n            } \n            if(str.charAt(0) == 'X' && str.charAt(1) == 'X' && str.charAt(2) == 'X'){\n                wonX++;\n            }\n        }\n        \n        //diagonical\n        if(board[0].charAt(0) == 'O' && board[1].charAt(1) == 'O' && board[2].charAt(2) == 'O'){\n            wonO++;\n        }\n        if(board[0].charAt(0) == 'X' && board[1].charAt(1) == 'X' && board[2].charAt(2) == 'X'){\n            wonX++;\n        }\n        \n        if(board[0].charAt(2) == 'O' && board[1].charAt(1) == 'O' && board[2].charAt(0) == 'O'){\n            wonO++;\n        }\n        if(board[0].charAt(2) == 'X' && board[1].charAt(1) == 'X' && board[2].charAt(0) == 'X'){\n            wonX++;\n        }\n        \n        //horizontal\n        for(int i=0; i<3; i++){\n            if(board[0].charAt(i) == 'O' && board[1].charAt(i) == 'O' &&board[2].charAt(i) == 'O'){\n                wonO++;\n            }\n            if(board[0].charAt(i) == 'X' && board[1].charAt(i) == 'X' &&board[2].charAt(i) == 'X'){\n                wonX++;\n            }\n        }\n\n\n        if(wonO == 0 && wonX == 0){\n            return true;\n        }\n        if(wonO > 2 || wonX >2){\n            return false;\n        }\n        if(wonO == 1 && wonX == 1){\n            return false;\n        }\n\n\n        if(wonO == 1){\n            if(numOfX == numOfO){\n                return true;\n            }else{\n                return false;\n            }\n        }\n\n\n        if(wonX == 1){\n            if(numOfX == numOfO + 1){\n                return true;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n\n",
                "solutionTags": [],
                "code": "    public boolean validTicTacToe(String[] board) {\n        int numOfO = 0;\n        int numOfX = 0;\n        for(String str: board){\n            for(int i=0; i<str.length(); i++){\n                if(str.charAt(i) == 'O'){\n                    numOfO++;\n                }else if(str.charAt(i) == 'X'){\n                    numOfX++;\n                }\n            }\n        }\n        if(numOfX < numOfO || numOfX > numOfO + 1){\n            return false;\n        }\n        if(numOfX + numOfO > 9){\n            return false;\n        }\n        int wonO = 0;\n        int wonX = 0;\n        for(String str: board){\n            if(str.charAt(0) == 'O' && str.charAt(1) == 'O' && str.charAt(2) == 'O'){\n                wonO++;\n            } \n            if(str.charAt(0) == 'X' && str.charAt(1) == 'X' && str.charAt(2) == 'X'){\n                wonX++;\n            }\n        }\n        if(board[0].charAt(0) == 'O' && board[1].charAt(1) == 'O' && board[2].charAt(2) == 'O'){\n            wonO++;\n        }\n        if(board[0].charAt(0) == 'X' && board[1].charAt(1) == 'X' && board[2].charAt(2) == 'X'){\n            wonX++;\n        }\n        if(board[0].charAt(2) == 'O' && board[1].charAt(1) == 'O' && board[2].charAt(0) == 'O'){\n            wonO++;\n        }\n        if(board[0].charAt(2) == 'X' && board[1].charAt(1) == 'X' && board[2].charAt(0) == 'X'){\n            wonX++;\n        }\n        for(int i=0; i<3; i++){\n            if(board[0].charAt(i) == 'O' && board[1].charAt(i) == 'O' &&board[2].charAt(i) == 'O'){\n                wonO++;\n            }\n            if(board[0].charAt(i) == 'X' && board[1].charAt(i) == 'X' &&board[2].charAt(i) == 'X'){\n                wonX++;\n            }\n        }\n        if(wonO == 0 && wonX == 0){\n            return true;\n        }\n        if(wonO > 2 || wonX >2){\n            return false;\n        }\n        if(wonO == 1 && wonX == 1){\n            return false;\n        }\n        if(wonO == 1){\n            if(numOfX == numOfO){\n                return true;\n            }else{\n                return false;\n            }\n        }\n        if(wonX == 1){\n            if(numOfX == numOfO + 1){\n                return true;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 117577,
                "title": "simple-java-solution-using-bfs",
                "content": "```\nclass Solution {\n    public boolean validTicTacToe(String[] board) {\n        int x = 0, o = 0;\n        String original = \"\";\n        for(String str:board){\n            original += str;\n            for(char c:str.toCharArray()){\n                if(c == 'X'){\n                    x++;\n                }else if(c == 'O'){\n                    o++;\n                }\n            }\n        }\n        if(x > o + 1 || o > x){\n            return false;\n        }\n        int step = 0;\n        String str = \"         \";\n        Queue<String> queue = new LinkedList<>();\n        queue.add(str);\n        \n        while(!queue.isEmpty()){\n            int sz = queue.size();\n            for(int i=0;i<sz;i++){\n                String curr = queue.poll();\n                if(curr.equals(original))\n                    return true;\n                if(helper(curr))// check if game ends here\n                    continue;\n                char c = (step % 2 == 0) ? 'X' : 'O';\n                for(int j=0;j<9;j++){\n                    char[] stc = curr.toCharArray();\n                    if(stc[j] == ' ' && original.charAt(j) == c){\n                        stc[j] = c;                       \n                        queue.add(new String(stc));\n                    }\n                }\n            }\n            step++;\n        }\n        return false;\n    }\n    \n    public boolean helper(String temp){\n        if(temp.charAt(0) != ' ' && temp.charAt(0) == temp.charAt(4) && temp.charAt(4) == temp.charAt(8))\n            return true;\n        if(temp.charAt(2) != ' ' && temp.charAt(2) == temp.charAt(4) && temp.charAt(4) == temp.charAt(6))\n            return true;\n        String s = temp.substring(0,3);\n        String t = temp.substring(3,6);\n        String r = temp.substring(6);\n        if(s.equals(\"XXX\") || s.equals(\"OOO\") || t.equals(\"XXX\") || t.equals(\"OOO\") || r.equals(\"XXX\") || r.equals(\"OOO\"))\n            return true;\n        return false;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public boolean validTicTacToe(String[] board) {\n        int x = 0, o = 0;\n        String original = \"\";\n        for(String str:board){\n            original += str;\n            for(char c:str.toCharArray()){\n                if(c == 'X'){\n                    x++;\n                }else if(c == 'O'){\n                    o++;\n                }\n            }\n        }\n        if(x > o + 1 || o > x){\n            return false;\n        }\n        int step = 0;\n        String str = \"         \";\n        Queue<String> queue = new LinkedList<>();\n        queue.add(str);\n        \n        while(!queue.isEmpty()){\n            int sz = queue.size();\n            for(int i=0;i<sz;i++){\n                String curr = queue.poll();\n                if(curr.equals(original))\n                    return true;\n                if(helper(curr))// check if game ends here\n                    continue;\n                char c = (step % 2 == 0) ? 'X' : 'O';\n                for(int j=0;j<9;j++){\n                    char[] stc = curr.toCharArray();\n                    if(stc[j] == ' ' && original.charAt(j) == c){\n                        stc[j] = c;                       \n                        queue.add(new String(stc));\n                    }\n                }\n            }\n            step++;\n        }\n        return false;\n    }\n    \n    public boolean helper(String temp){\n        if(temp.charAt(0) != ' ' && temp.charAt(0) == temp.charAt(4) && temp.charAt(4) == temp.charAt(8))\n            return true;\n        if(temp.charAt(2) != ' ' && temp.charAt(2) == temp.charAt(4) && temp.charAt(4) == temp.charAt(6))\n            return true;\n        String s = temp.substring(0,3);\n        String t = temp.substring(3,6);\n        String r = temp.substring(6);\n        if(s.equals(\"XXX\") || s.equals(\"OOO\") || t.equals(\"XXX\") || t.equals(\"OOO\") || r.equals(\"XXX\") || r.equals(\"OOO\"))\n            return true;\n        return false;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060695,
                "title": "c-tc-o-1-sc-o-1-well-explained-with-fundamentals",
                "content": "# Intuition\\nIn the game of Tic-Tac-Toe\\n\\nFundamental Concept:\\n(1)To win, a player needs to have three of their symbols (X or O) in a row, column, or diagonal.\\n\\n(2)Number of X\\'s is equal to or one greater than the number of O\\'s\\n\\n(3)Only one player (X or O) wins the game.\\n\\n# Approach\\n- Count number of X and O\\n- If number of X and O doesn\\'t fit into the criteria(Number of X\\'s is equal to or one greater than the number of O\\'s), return false\\n- Check row wise/Column wise/Diagonal wise which play has won.\\n- If both players have won or none have won, the state is invalid, return false.\\n- If X wins, Check if the number of X\\'s is equal to or one greater than the number of O\\'s.If not, the state is invalid return false.\\n- If O wins, number of X should be equal to number of O. else return false.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //For a player to win, player should have same symbols either in a row/column/diagonal.\\n    bool checkWin(const vector<string>& board, char player)\\n    {\\n        // Check rows\\n        for (int i = 0; i < 3; ++i)\\n        {\\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player)\\n                return true;\\n        }\\n\\n        // Check columns\\n        for (int i = 0; i < 3; ++i)\\n        {\\n            if (board[0][i] == player && board[1][i] == player && board[2][i] == player)\\n                return true;\\n        }\\n\\n        // Check diagonals\\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player)\\n            return true;\\n\\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool validTicTacToe(vector<string>& board)\\n    {\\n        int countX = 0, countO = 0;\\n    \\n        for (const string& row : board)\\n        {\\n            for (char cell : row)\\n            {\\n                if (cell == \\'X\\')\\n                {\\n                    countX++;\\n                }\\n                else if (cell == \\'O\\')\\n                {\\n                    countO++;\\n                }\\n            }\\n        }\\n\\n        //Fundamental Rule: \\n        //Either \"\"number of X should be euqal to number of O\" or\\n        //\"Number of X is one greater than number of O\"\\n        if (countO > countX || countX > countO + 1)\\n        {\\n            return false;\\n        }\\n\\n        bool xWins = checkWin(board, \\'X\\');\\n        bool oWins = checkWin(board, \\'O\\');\\n\\n        //If both players have won or none have won, the state is invalid.\\n        if (xWins && oWins)\\n        {\\n            return false;\\n        }\\n        //if X wins, Check if the number of X\\'s is equal to or one greater than the number of O\\'s.\\n        //If not, the state is invalid.\\n        if (xWins && countX != countO + 1)\\n        {\\n            return false;\\n        }\\n\\n        //If O wins, number of X should be equal to number of O\\n        if (oWins && countX != countO)\\n        {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //For a player to win, player should have same symbols either in a row/column/diagonal.\\n    bool checkWin(const vector<string>& board, char player)\\n    {\\n        // Check rows\\n        for (int i = 0; i < 3; ++i)\\n        {\\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player)\\n                return true;\\n        }\\n\\n        // Check columns\\n        for (int i = 0; i < 3; ++i)\\n        {\\n            if (board[0][i] == player && board[1][i] == player && board[2][i] == player)\\n                return true;\\n        }\\n\\n        // Check diagonals\\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player)\\n            return true;\\n\\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool validTicTacToe(vector<string>& board)\\n    {\\n        int countX = 0, countO = 0;\\n    \\n        for (const string& row : board)\\n        {\\n            for (char cell : row)\\n            {\\n                if (cell == \\'X\\')\\n                {\\n                    countX++;\\n                }\\n                else if (cell == \\'O\\')\\n                {\\n                    countO++;\\n                }\\n            }\\n        }\\n\\n        //Fundamental Rule: \\n        //Either \"\"number of X should be euqal to number of O\" or\\n        //\"Number of X is one greater than number of O\"\\n        if (countO > countX || countX > countO + 1)\\n        {\\n            return false;\\n        }\\n\\n        bool xWins = checkWin(board, \\'X\\');\\n        bool oWins = checkWin(board, \\'O\\');\\n\\n        //If both players have won or none have won, the state is invalid.\\n        if (xWins && oWins)\\n        {\\n            return false;\\n        }\\n        //if X wins, Check if the number of X\\'s is equal to or one greater than the number of O\\'s.\\n        //If not, the state is invalid.\\n        if (xWins && countX != countO + 1)\\n        {\\n            return false;\\n        }\\n\\n        //If O wins, number of X should be equal to number of O\\n        if (oWins && countX != countO)\\n        {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023765,
                "title": "just-check-5-conditions-easy-explanation",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n```\\nConditions to check :-\\n1. No player should take more than 5 turns.\\n2. O should not take more turns as compared to X.\\n3. Difference between no. of turns taken by X and O should not exceed 1.\\n4. If O won the game, then X should not take further turn.\\n5. If X won the game, then O should not take further turn.\\n```\\n# Code\\n```\\nclass Solution {\\n    bool wonGame(char turn, vector<string>& board)\\n    {\\n        for(int i=0; i<3; i++)\\n        {\\n            if(board[i][0] == turn && board[i][1] == turn && board[i][2] == turn) //all same row-wise\\n             return true;\\n            if(board[0][i] == turn && board[1][i] == turn && board[2][i] == turn) //all same col-wise\\n             return true;  \\n        }\\n        if(board[0][0] == turn && board[1][1] == turn && board[2][2] == turn) //all main diagonal same\\n         return true;\\n        if(board[0][2] == turn && board[1][1] == turn && board[2][0] == turn) //all secondary diagonal same\\n         return true;\\n\\n        return false;\\n    }\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int Ocount = 0, Xcount = 0;\\n        \\n        for(auto row : board)\\n        {\\n            for(auto val : row)\\n            {\\n             if(val == \\'O\\') Ocount++;\\n             if(val == \\'X\\') Xcount++;\\n            }\\n        }\\n           //condition1              condition2           condition3\\n    if(Ocount > 5 || Xcount > 5 || Ocount > Xcount || Xcount - Ocount > 1)\\n     return false;\\n\\n    //condition 4\\n    if(wonGame(\\'O\\',board) && Xcount > Ocount)\\n     return false;\\n\\n    //condition 5\\n    if(wonGame(\\'X\\',board) && Ocount >= Xcount)\\n     return false;\\n\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nConditions to check :-\\n1. No player should take more than 5 turns.\\n2. O should not take more turns as compared to X.\\n3. Difference between no. of turns taken by X and O should not exceed 1.\\n4. If O won the game, then X should not take further turn.\\n5. If X won the game, then O should not take further turn.\\n```\n```\\nclass Solution {\\n    bool wonGame(char turn, vector<string>& board)\\n    {\\n        for(int i=0; i<3; i++)\\n        {\\n            if(board[i][0] == turn && board[i][1] == turn && board[i][2] == turn) //all same row-wise\\n             return true;\\n            if(board[0][i] == turn && board[1][i] == turn && board[2][i] == turn) //all same col-wise\\n             return true;  \\n        }\\n        if(board[0][0] == turn && board[1][1] == turn && board[2][2] == turn) //all main diagonal same\\n         return true;\\n        if(board[0][2] == turn && board[1][1] == turn && board[2][0] == turn) //all secondary diagonal same\\n         return true;\\n\\n        return false;\\n    }\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int Ocount = 0, Xcount = 0;\\n        \\n        for(auto row : board)\\n        {\\n            for(auto val : row)\\n            {\\n             if(val == \\'O\\') Ocount++;\\n             if(val == \\'X\\') Xcount++;\\n            }\\n        }\\n           //condition1              condition2           condition3\\n    if(Ocount > 5 || Xcount > 5 || Ocount > Xcount || Xcount - Ocount > 1)\\n     return false;\\n\\n    //condition 4\\n    if(wonGame(\\'O\\',board) && Xcount > Ocount)\\n     return false;\\n\\n    //condition 5\\n    if(wonGame(\\'X\\',board) && Ocount >= Xcount)\\n     return false;\\n\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000748,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }\\n                if(board[i].charAt(j)==\\'X\\'){\\n                    if(i==j)xdiag++;\\n                    arr[1]++;\\n                    x++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\'){\\n                    if(i==j)odiag++;\\n                    arr[0]++;\\n                    o++;\\n                }\\n            }\\n            if(o==3 && owin)return false;\\n            if(owin && xwin)return false;\\n            if(x==3)xwin=true;\\n            else if(o==3)owin=true;\\n        }\\n        if(xdiag==3)xwin=true;\\n        if(odiag==3)owin=true;\\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')xwin=true;\\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')owin=true;\\n        if(arr[0]>=arr[1] && xwin || (arr[1]>arr[0] && owin))return false;\\n        if(arr[0]>arr[1] || Math.abs(arr[0]-arr[1])>1)return false;\\n        return xwin&&owin?false:true;\\n    }\\n}\\n```\\n```python []\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef validTicTacToe(self, board: List[str]) -> bool:\\n\\t\\tcols, rows = [0] * len(board), [0] * len(board[0])\\n\\t\\tdiagonal, anti_diagonal = 0, 0\\n\\t\\tturn, x_win, o_win = 0, False, False\\n\\n\\t\\tfor i in range(len(board)):\\n\\t\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\t\\tif board[i][j] == \\'X\\':\\n\\t\\t\\t\\t\\tturn += 1\\n\\t\\t\\t\\t\\trows[i] += 1\\n\\t\\t\\t\\t\\tcols[j] += 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal += 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal += 1\\n\\t\\t\\t\\telif board[i][j] == \\'O\\':\\n\\t\\t\\t\\t\\tturn -= 1\\n\\t\\t\\t\\t\\trows[i] -= 1\\n\\t\\t\\t\\t\\tcols[j] -= 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal -= 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal -= 1\\n\\n\\t\\tfor idx in range(len(cols)):\\n\\t\\t\\tif cols[idx] == 3 or rows[idx] == 3 or diagonal == 3 or anti_diagonal == 3:\\n\\t\\t\\t\\tx_win = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif cols[idx] == -3 or rows[idx] == -3 or diagonal == -3 or anti_diagonal == -3:\\n\\t\\t\\t\\to_win = True\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif (turn != 1 and x_win) or (turn != 0 and o_win):\\n\\t\\t\\treturn False\\n\\n\\t\\treturn turn == 1 or turn == 0\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }\\n                if(board[i].charAt(j)==\\'X\\'){\\n                    if(i==j)xdiag++;\\n                    arr[1]++;\\n                    x++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\'){\\n                    if(i==j)odiag++;\\n                    arr[0]++;\\n                    o++;\\n                }\\n            }\\n            if(o==3 && owin)return false;\\n            if(owin && xwin)return false;\\n            if(x==3)xwin=true;\\n            else if(o==3)owin=true;\\n        }\\n        if(xdiag==3)xwin=true;\\n        if(odiag==3)owin=true;\\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')xwin=true;\\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')owin=true;\\n        if(arr[0]>=arr[1] && xwin || (arr[1]>arr[0] && owin))return false;\\n        if(arr[0]>arr[1] || Math.abs(arr[0]-arr[1])>1)return false;\\n        return xwin&&owin?false:true;\\n    }\\n}\\n```\n```python []\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef validTicTacToe(self, board: List[str]) -> bool:\\n\\t\\tcols, rows = [0] * len(board), [0] * len(board[0])\\n\\t\\tdiagonal, anti_diagonal = 0, 0\\n\\t\\tturn, x_win, o_win = 0, False, False\\n\\n\\t\\tfor i in range(len(board)):\\n\\t\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\t\\tif board[i][j] == \\'X\\':\\n\\t\\t\\t\\t\\tturn += 1\\n\\t\\t\\t\\t\\trows[i] += 1\\n\\t\\t\\t\\t\\tcols[j] += 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal += 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal += 1\\n\\t\\t\\t\\telif board[i][j] == \\'O\\':\\n\\t\\t\\t\\t\\tturn -= 1\\n\\t\\t\\t\\t\\trows[i] -= 1\\n\\t\\t\\t\\t\\tcols[j] -= 1\\n\\t\\t\\t\\t\\tif i == j:\\n\\t\\t\\t\\t\\t\\tdiagonal -= 1\\n\\t\\t\\t\\t\\tif i + j == len(board) - 1:\\n\\t\\t\\t\\t\\t\\tanti_diagonal -= 1\\n\\n\\t\\tfor idx in range(len(cols)):\\n\\t\\t\\tif cols[idx] == 3 or rows[idx] == 3 or diagonal == 3 or anti_diagonal == 3:\\n\\t\\t\\t\\tx_win = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif cols[idx] == -3 or rows[idx] == -3 or diagonal == -3 or anti_diagonal == -3:\\n\\t\\t\\t\\to_win = True\\n\\t\\t\\t\\tbreak\\n\\n\\t\\tif (turn != 1 and x_win) or (turn != 0 and o_win):\\n\\t\\t\\treturn False\\n\\n\\t\\treturn turn == 1 or turn == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986117,
                "title": "go-count-and-check-for-win",
                "content": "```\\nfunc validTicTacToe(board []string) bool {\\n    x, o, xWon, oWon := 0, 0, win(board, \"X\"), win(board, \"O\")\\n\\n    for i := 0; i < 3; i++ {\\n        for j := 0; j < 3; j++ {\\n            if board[i][j] == \\'X\\' {\\n                x++\\n            } else if board[i][j] == \\'O\\' {\\n                o++\\n            }\\n        }\\n    }\\n\\n    if o > x || x > o + 1 { return false }\\n    if xWon && (oWon || x == o) { return false }\\n    if oWon && x > o { return false }\\n\\n    return true\\n}\\n\\nfunc win(board []string, char string) bool {\\n    check := char + char + char\\n\\n    for i := 0; i < 3; i++ {\\n        if board[i] == check { return true }\\n        col := string([]byte{board[0][i], board[1][i], board[2][i]})\\n        if col == check { return true }\\n    }\\n\\n    diag1 := string([]byte{board[0][0], board[1][1], board[2][2]})\\n    diag2 := string([]byte{board[0][2], board[1][1], board[2][0]})\\n\\n    if diag1 == check || diag2 == check { return true }\\n\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc validTicTacToe(board []string) bool {\\n    x, o, xWon, oWon := 0, 0, win(board, \"X\"), win(board, \"O\")\\n\\n    for i := 0; i < 3; i++ {\\n        for j := 0; j < 3; j++ {\\n            if board[i][j] == \\'X\\' {\\n                x++\\n            } else if board[i][j] == \\'O\\' {\\n                o++\\n            }\\n        }\\n    }\\n\\n    if o > x || x > o + 1 { return false }\\n    if xWon && (oWon || x == o) { return false }\\n    if oWon && x > o { return false }\\n\\n    return true\\n}\\n\\nfunc win(board []string, char string) bool {\\n    check := char + char + char\\n\\n    for i := 0; i < 3; i++ {\\n        if board[i] == check { return true }\\n        col := string([]byte{board[0][i], board[1][i], board[2][i]})\\n        if col == check { return true }\\n    }\\n\\n    diag1 := string([]byte{board[0][0], board[1][1], board[2][2]})\\n    diag2 := string([]byte{board[0][2], board[1][1], board[2][0]})\\n\\n    if diag1 == check || diag2 == check { return true }\\n\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902157,
                "title": "cpp-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int O_count {}, X_count {};\\n        for (auto& row: board)\\n            for (auto c: row) \\n                O_count += (c == \\'O\\'), X_count += (c == \\'X\\');\\n\\n        if (O_count > X_count) return false;\\n        if (X_count > O_count + 1) return false;\\n        // if no one wins yet, the state is valid\\n        // if X wins, X should have one more character\\n        // if O wins, O should have equal characters as X\\n        // if Both win, which is apparently impossible\\n        int result = checkWins(board);\\n        if (result == 0) return true;\\n        if (result == 1) return X_count == O_count + 1;\\n        if (result == 2) return X_count == O_count;\\n        return false;\\n    }\\n    int checkWins(vector<string>& board)\\n    { // 0b1, X wins , 0b10 : O wins, 0b0 : not yet\\n        int result {};\\n        for (const auto& row: board)\\n        {\\n            if (row == \"XXX\") result |= 1;\\n            if (row == \"OOO\") result |= 2;\\n        }\\n\\n        for (int j = 0; j < 3; j++)\\n        {\\n            string col{}; col.reserve(3);\\n            for (int i = 0; i < 3; i++) col.push_back(board[i][j]);\\n            if (col == \"XXX\") result |= 1;\\n            if (col == \"OOO\") result |= 2;\\n        }\\n\\n        if (board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[1][1] != \\' \\')\\n            result |= (board[0][0] == \\'X\\' ? 1 : 2);\\n\\n        if (board[0][2] == board[1][1] && board[0][2] == board[2][0] && board[1][1] != \\' \\')\\n            result |= (board[0][2] == \\'X\\' ? 1 : 2);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int O_count {}, X_count {};\\n        for (auto& row: board)\\n            for (auto c: row) \\n                O_count += (c == \\'O\\'), X_count += (c == \\'X\\');\\n\\n        if (O_count > X_count) return false;\\n        if (X_count > O_count + 1) return false;\\n        // if no one wins yet, the state is valid\\n        // if X wins, X should have one more character\\n        // if O wins, O should have equal characters as X\\n        // if Both win, which is apparently impossible\\n        int result = checkWins(board);\\n        if (result == 0) return true;\\n        if (result == 1) return X_count == O_count + 1;\\n        if (result == 2) return X_count == O_count;\\n        return false;\\n    }\\n    int checkWins(vector<string>& board)\\n    { // 0b1, X wins , 0b10 : O wins, 0b0 : not yet\\n        int result {};\\n        for (const auto& row: board)\\n        {\\n            if (row == \"XXX\") result |= 1;\\n            if (row == \"OOO\") result |= 2;\\n        }\\n\\n        for (int j = 0; j < 3; j++)\\n        {\\n            string col{}; col.reserve(3);\\n            for (int i = 0; i < 3; i++) col.push_back(board[i][j]);\\n            if (col == \"XXX\") result |= 1;\\n            if (col == \"OOO\") result |= 2;\\n        }\\n\\n        if (board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[1][1] != \\' \\')\\n            result |= (board[0][0] == \\'X\\' ? 1 : 2);\\n\\n        if (board[0][2] == board[1][1] && board[0][2] == board[2][0] && board[1][1] != \\' \\')\\n            result |= (board[0][2] == \\'X\\' ? 1 : 2);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862381,
                "title": "c-faster-than-100-generalized-for-n-x-n-o-n-2-time-o-n-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int size = board.size();\\n        vector<int> rows(size, 0);\\n        vector<int> cols(size, 0);\\n        int diag = 0;\\n        int antiDiag = 0;\\n        int totalX = 0;\\n        int totalO = 0;\\n\\n        for(int i = 0 ; i < size; i++){\\n            for(int j = 0 ; j < size; j++){\\n                if(board[i][j] != \\' \\'){\\n                    int currPlayer = (board[i][j] == \\'X\\') ? 1 : -1;\\n                    if(currPlayer == 1)\\n                        totalX++;\\n                    else\\n                        totalO++;\\n\\n                    rows[i] += currPlayer;\\n                    cols[j] += currPlayer;\\n                    if(i == j){\\n                        diag += currPlayer;\\n                    }\\n                    if(i + j == size - 1){\\n                        antiDiag += currPlayer;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(totalX - totalO > 1 || totalX - totalO < 0){\\n            return false;\\n        } \\n\\n        bool hasWonX = false;\\n        bool hasWonO = false;\\n        for(int i = 0 ; i < size; i++){\\n            if(rows[i] == size || cols[i] == size){\\n                if(hasWonO)\\n                    return false;\\n                hasWonX = true;\\n            }\\n\\n            if(rows[i] == -size || cols[i] == -size){\\n                if(hasWonX)\\n                    return false;\\n                hasWonO = true;\\n            }\\n        }\\n        if(diag == size || antiDiag == size)\\n            hasWonX = true;\\n\\n        if(diag == -size || antiDiag == -size)\\n            hasWonO = true;\\n\\n        if(hasWonX == true && totalO == totalX)\\n            return false;\\n\\n        if(hasWonO == true && totalX > totalO)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int size = board.size();\\n        vector<int> rows(size, 0);\\n        vector<int> cols(size, 0);\\n        int diag = 0;\\n        int antiDiag = 0;\\n        int totalX = 0;\\n        int totalO = 0;\\n\\n        for(int i = 0 ; i < size; i++){\\n            for(int j = 0 ; j < size; j++){\\n                if(board[i][j] != \\' \\'){\\n                    int currPlayer = (board[i][j] == \\'X\\') ? 1 : -1;\\n                    if(currPlayer == 1)\\n                        totalX++;\\n                    else\\n                        totalO++;\\n\\n                    rows[i] += currPlayer;\\n                    cols[j] += currPlayer;\\n                    if(i == j){\\n                        diag += currPlayer;\\n                    }\\n                    if(i + j == size - 1){\\n                        antiDiag += currPlayer;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(totalX - totalO > 1 || totalX - totalO < 0){\\n            return false;\\n        } \\n\\n        bool hasWonX = false;\\n        bool hasWonO = false;\\n        for(int i = 0 ; i < size; i++){\\n            if(rows[i] == size || cols[i] == size){\\n                if(hasWonO)\\n                    return false;\\n                hasWonX = true;\\n            }\\n\\n            if(rows[i] == -size || cols[i] == -size){\\n                if(hasWonX)\\n                    return false;\\n                hasWonO = true;\\n            }\\n        }\\n        if(diag == size || antiDiag == size)\\n            hasWonX = true;\\n\\n        if(diag == -size || antiDiag == -size)\\n            hasWonO = true;\\n\\n        if(hasWonX == true && totalO == totalX)\\n            return false;\\n\\n        if(hasWonO == true && totalX > totalO)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790141,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        xs = \\'\\'.join(board).count(\\'X\\')\\n        os = \\'\\'.join(board).count(\\'O\\')\\n        if xs-os not in (0,1):\\n            return False\\n        \\n        seen = {}\\n\\n        if \\'\\'.join(board[0]) in (\\'XXX\\',\\'OOO\\'): seen[\\'\\'.join(board[0])] = seen.get(\\'\\'.join(board[0]),0)+1\\n        if \\'\\'.join(board[1]) in (\\'XXX\\',\\'OOO\\'): seen[\\'\\'.join(board[1])] = seen.get(\\'\\'.join(board[1]),0)+1\\n        if \\'\\'.join(board[2]) in (\\'XXX\\',\\'OOO\\'): seen[\\'\\'.join(board[2])] = seen.get(\\'\\'.join(board[2]),0)+1\\n\\n        col = \\'\\'.join([board[0][0],board[1][0],board[2][0]])\\n        if col in (\\'XXX\\',\\'OOO\\'): seen[col] = seen.get(col,0)+1\\n        col = \\'\\'.join([board[0][1],board[1][1],board[2][1]])\\n        if col in (\\'XXX\\',\\'OOO\\'): seen[col] = seen.get(col,0)+1\\n        col = \\'\\'.join([board[0][2],board[1][2],board[2][2]])\\n        if col in (\\'XXX\\',\\'OOO\\'): seen[col] = seen.get(col,0)+1\\n\\n        diag = \\'\\'.join([board[0][0],board[1][1],board[2][2]])\\n        if diag in (\\'XXX\\',\\'OOO\\'): seen[diag] = seen.get(diag,0)+1\\n        diag = \\'\\'.join([board[0][2],board[1][1],board[2][0]])\\n        if diag in (\\'XXX\\',\\'OOO\\'): seen[diag] = seen.get(diag,0)+1\\n\\n        return not seen or (len(seen)==1 and list(seen.values())[0]<=2 and xs-(1 if \\'XXX\\' in seen else 0)==os)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        xs = \\'\\'.join(board).count(\\'X\\')\\n        os = \\'\\'.join(board).count(\\'O\\')\\n        if xs-os not in (0,1):\\n            return False\\n        \\n        seen = {}\\n\\n        if \\'\\'.join(board[0]) in (\\'XXX\\',\\'OOO\\'): seen[\\'\\'.join(board[0])] = seen.get(\\'\\'.join(board[0]),0)+1\\n        if \\'\\'.join(board[1]) in (\\'XXX\\',\\'OOO\\'): seen[\\'\\'.join(board[1])] = seen.get(\\'\\'.join(board[1]),0)+1\\n        if \\'\\'.join(board[2]) in (\\'XXX\\',\\'OOO\\'): seen[\\'\\'.join(board[2])] = seen.get(\\'\\'.join(board[2]),0)+1\\n\\n        col = \\'\\'.join([board[0][0],board[1][0],board[2][0]])\\n        if col in (\\'XXX\\',\\'OOO\\'): seen[col] = seen.get(col,0)+1\\n        col = \\'\\'.join([board[0][1],board[1][1],board[2][1]])\\n        if col in (\\'XXX\\',\\'OOO\\'): seen[col] = seen.get(col,0)+1\\n        col = \\'\\'.join([board[0][2],board[1][2],board[2][2]])\\n        if col in (\\'XXX\\',\\'OOO\\'): seen[col] = seen.get(col,0)+1\\n\\n        diag = \\'\\'.join([board[0][0],board[1][1],board[2][2]])\\n        if diag in (\\'XXX\\',\\'OOO\\'): seen[diag] = seen.get(diag,0)+1\\n        diag = \\'\\'.join([board[0][2],board[1][1],board[2][0]])\\n        if diag in (\\'XXX\\',\\'OOO\\'): seen[diag] = seen.get(diag,0)+1\\n\\n        return not seen or (len(seen)==1 and list(seen.values())[0]<=2 and xs-(1 if \\'XXX\\' in seen else 0)==os)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749984,
                "title": "dart-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  bool validTicTacToe(List<String> board) {\\n    int xCount = 0;\\n    int oCount = 0;\\n\\n    for (int i = 0; i < board.length; i++) {\\n      for (int j = 0; j < board[i].length; j++) {\\n        if (board[i][j] == \\'X\\') {\\n          xCount++;\\n        } else if (board[i][j] == \\'O\\') {\\n          oCount++;\\n        }\\n      }\\n    }\\n\\n    if (oCount > xCount || xCount - oCount > 1) {\\n      return false;\\n    }\\n\\n    bool xWins = checkWinner(board, \\'X\\');\\n    bool oWins = checkWinner(board, \\'O\\');\\n\\n    if (xWins && oWins) {\\n      return false;\\n    }\\n    if (xWins && xCount == oCount) {\\n      return false;\\n    }\\n    if (oWins && xCount > oCount) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  bool checkWinner(List<String> board, String player) {\\n    // Check rows\\n    for (String row in board) {\\n      if (row.split(\\'\\').where((cell) => cell == player).length == 3) {\\n        return true;\\n      }\\n    }\\n\\n    // Check columns\\n    for (int col = 0; col < 3; col++) {\\n      if (board.every((row) => row[col] == player)) {\\n        return true;\\n      }\\n    }\\n\\n    // Check diagonals\\n    if (board[0][0] == player &&\\n        board[0][0] == board[1][1] &&\\n        board[1][1] == board[2][2]) {\\n      return true;\\n    }\\n    if (board[0][2] == player &&\\n        board[0][2] == board[1][1] &&\\n        board[1][1] == board[2][0]) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool validTicTacToe(List<String> board) {\\n    int xCount = 0;\\n    int oCount = 0;\\n\\n    for (int i = 0; i < board.length; i++) {\\n      for (int j = 0; j < board[i].length; j++) {\\n        if (board[i][j] == \\'X\\') {\\n          xCount++;\\n        } else if (board[i][j] == \\'O\\') {\\n          oCount++;\\n        }\\n      }\\n    }\\n\\n    if (oCount > xCount || xCount - oCount > 1) {\\n      return false;\\n    }\\n\\n    bool xWins = checkWinner(board, \\'X\\');\\n    bool oWins = checkWinner(board, \\'O\\');\\n\\n    if (xWins && oWins) {\\n      return false;\\n    }\\n    if (xWins && xCount == oCount) {\\n      return false;\\n    }\\n    if (oWins && xCount > oCount) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n\\n  bool checkWinner(List<String> board, String player) {\\n    // Check rows\\n    for (String row in board) {\\n      if (row.split(\\'\\').where((cell) => cell == player).length == 3) {\\n        return true;\\n      }\\n    }\\n\\n    // Check columns\\n    for (int col = 0; col < 3; col++) {\\n      if (board.every((row) => row[col] == player)) {\\n        return true;\\n      }\\n    }\\n\\n    // Check diagonals\\n    if (board[0][0] == player &&\\n        board[0][0] == board[1][1] &&\\n        board[1][1] == board[2][2]) {\\n      return true;\\n    }\\n    if (board[0][2] == player &&\\n        board[0][2] == board[1][1] &&\\n        board[1][1] == board[2][0]) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745506,
                "title": "tictactoe-lab-intro-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is serving as a lab walkthrough for my intro to python class. If just reviewing for your own purposes, you can skip to the approach. \\n\\nIn computer science we are concerned most often with presenting something of value to a user, whether that be a graphical user interface, up to the second calculation, or a description of some status or reading. One of the key ideas for this is that of the model view and controller. This allows computer scientists to split the work of interfacing with a user into three separate but minimally connected components. \\n\\nWhy minimally connected? The reason is quite simple with an analogy. Consider a basic automobile. If I want to drive my automobile, it\\'s probably a good idea to make sure that the engine is able to start. Let\\'s call that a minimal connection.\\n\\nMinimal Connection Example : if try to drive car, car must be able to start\\n\\nOn the other hand, if I want to drive my car, it doesn\\'t ACTUALLY matter if I can\\'t use the radio (though it is nice!). Let\\'s call this a non-minimal connection. \\n\\nNon-minimal connection example : if try to drive car, radio must work\\n\\nThe second one obviously has no real bearing or implication on the first, and can be seen as a non-minimal connection. \\n\\nAs we move into the design of classes and objects as more advanced forms of data structures, it is necessary to consider what our connections are between classes and whether or not they are minimally connected. \\n\\nWith that in mind, let\\'s return to our game of tic tac toe. \\nTo play tic tac toe in an interactive manner we want to \\n- be able to see the board \\n- be able to choose a move \\n- be able to know when I have won or lost \\n- be able to know when it\\'s a tie \\n\\nTo keep things simple, we\\'ll start by playing against ourselves or a friend. Later in the course we\\'ll add a computer opponent, first for this, then checkers, then other games. \\n\\nTo be able to see the board, we need a way to view it. This is one of your first tasks is to implement a way to easily see all positions that are marked or can be marked. \\n\\nTask 1 : \\n- part a : Make a board class object that can print out a boards current view using a to string like method for the object \\n- part b : Make a view class object that takes in a board as an argument and can produce a print out of the board when requested \\n\\nOnce you can see the board and have a view object that can print out one, we need some interaction. \\n\\nTask 2 : \\n- Add a choose move option to the board. Make it player proof so they cannot choose where someone already is, and cannot go out of bounds. How you do this is up to you, but a game that won\\'t crash everytime I make a wrong move is probably one I\\'ll play more! \\n\\nAlright, by now you have a board and can make valid moves! Now we need to know who the winner is and who the winner is not! Before we get there, we\\'re going to move some functionality around though \\n\\nTask 3 : \\n- Part a : Make a controller class. It\\'ll take in a view and a model, and then pass over control to a play method inside of it. \\n- Part b : Within the play class method of the controller, have the view object of the controller display the current screen. Then, have the controller receive from the view the succesful choice of move. \\n- Part c : Have the controller send to the model object the value from the move in a method called update board, passing in the board, player, and row and col as well. \\n\\nWell, you likely have a number of red line errors at this point! To help you out, complete task 4, and it\\'ll make a bit more sense. \\n\\nTask 4 : \\n- Part a : Make a model class. It does not take in any arguments, but it has fields set up much of the code below. Feel free to take some of the ideas there, as they may prove useful. \\n- Part b : Make a update board method, where you are passed a board, a row and col within the board, and a mark to make. \\n- Part c : In your update board method, change the appropriate row and col within the board to the mark, then, check your board status. If there\\'s a winner, you\\'ll want to report out who won. If there\\'s a tie, report that too. Otherwise, report that the game continues and update who\\'s move it is. Return the updated board, status, and if there is someones turn, say whos turn it is. \\n\\nBack to the controller now! \\n\\nTask 5 : \\n- Part a : Have the controller point where we send to the model object our value from the move method receive the appropriate values from the model. Then, have the controller send these to the view by having the view call display move result using the updated board, game status, and if there is another player a new player message. Store the result of this function call in controller next step. \\n- Part b : Now that we have something coming back to the view, we can \\n    - print the updated board in the view \\n    - display game status \\n    - if the game is over \\n        - ask the player if they want to play again \\n        - if they do not want to play again, \\n        - print the game over message and send the instruction to quit back to the controller    \\n    - otherwise, get the next move and send it back to the controller \\n    - this method can run inside the view   \\n\\nTask 6 : \\n- Final part! When the controller receives a value from the view next it is either : \\n    - a new move in the current game -> continue the game by going to top of game loop current \\n    - a new game -> start a new game by recalling the play game method with a wiped board. \\n    - a desire to end play -> set status to game over and quit the play method.  \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTo determine if we are in a valid state, we should \\n- check the size of the board (for class you will need to modify for your board\\'s representation potentially!)\\n- check the board status (have we made a valid number of moves for each? How can you guard against this for class without crashing the game?)\\n- check if the game is over (currently only determines if game ended succesfully, you\\'ll need to modify to find out WHO won WHEN and WHY)\\n\\nIf we are a correctly sized board, and we have a status that is valid, and we do not have a winner and are not in an invalid state of play, then, return True. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool :\\n        if not self.check_board_sizing(board) : \\n            return False \\n        elif not self.check_board_status(board) : \\n            return False \\n        else : \\n            return self.check_winner(board)\\n        \\n    def check_board_sizing(self, board) -> bool :\\n        if len(board) == 3 : \\n            for row in board : \\n                if len(row) != 3 : \\n                    return False \\n            return True \\n        return False  \\n\\n    def check_board_status(self, board : List[str]) -> bool : \\n        self.counts = collections.defaultdict(int)\\n        for row in board : \\n            for cell in row : \\n                self.counts[cell] += 1 \\n        return (self.counts[\"O\"] <= self.counts[\"X\"]) and (self.counts[\"X\"] - self.counts[\"O\"] <= 1)\\n\\n    def check_winner(self, board : List[str]) -> bool : \\n        # statuses by row for x and o \\n        x_statuses = [False, False, False, False]\\n        o_statuses = [False, False, False, False]\\n        # sums by row, sums by col, and diagonals up and down \\n        x_sums = [[0, 0, 0], [0, 0, 0], [0, 0]]\\n        o_sums = [[0, 0, 0], [0, 0, 0], [0, 0]]\\n\\n        # get row sum for x\\'s and o\\'s and if 3 set status 0 for each \\n        for row_index, row in enumerate(board) : \\n            x_sums[0][row_index] = sum([int(r_i == \"X\") for r_i in row])\\n            o_sums[0][row_index] = sum([int(r_i == \"O\") for r_i in row])\\n            x_statuses[0] = True if x_sums[0][row_index] == 3 else x_statuses[0]\\n            o_statuses[0] = True if o_sums[0][row_index] == 3 else o_statuses[0]\\n\\n        # col major order since we can\\'t unpack strings in python \\n        # if sum of col is 3 update status at 1 otherwise remain same \\n        for col in range(3) : \\n            for row in range(3) : \\n                cell = board[row][col]\\n                x_sums[1][col] += cell == \\'X\\'\\n                o_sums[1][col] += cell == \\'O\\'\\n            x_statuses[1] = True if x_sums[1][col] == 3 else x_statuses[1]\\n            o_statuses[1] = True if o_sums[1][col] == 3 else o_statuses[1]\\n            \\n        # for board index in range 3 \\n        # 0 cell diag down 1 cell diag up \\n        for b_i in range(3) : \\n            x_sums[2][0] += board[b_i][0+b_i] == \"X\"\\n            x_sums[2][1] += board[b_i][2-b_i] == \"X\"\\n            o_sums[2][0] += board[b_i][0+b_i] == \"O\"\\n            o_sums[2][1] += board[b_i][2-b_i] == \"O\"\\n        x_statuses[2] = x_sums[2][0] == 3 \\n        x_statuses[3] = x_sums[2][1] == 3 \\n        o_statuses[2] = o_sums[2][0] == 3 \\n        o_statuses[3] = o_sums[2][1] == 3 \\n\\n        # if we have an x win and do not have one more x than o, False \\n        # similarly, if we have an o win, and have any more or less moves, False \\n        if sum(x_statuses) > 0 and (self.counts[\"X\"] - self.counts[\"O\"] != 1) : \\n            return False \\n        elif sum(o_statuses) > 0 and (self.counts[\"X\"] - self.counts[\"O\"] != 0) : \\n            return False \\n        else : \\n            # in all other cases, valid win, but we don\\'t know who! \\n            # assignment for class is to modify this and return who won in a separate function\\n            return True \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool :\\n        if not self.check_board_sizing(board) : \\n            return False \\n        elif not self.check_board_status(board) : \\n            return False \\n        else : \\n            return self.check_winner(board)\\n        \\n    def check_board_sizing(self, board) -> bool :\\n        if len(board) == 3 : \\n            for row in board : \\n                if len(row) != 3 : \\n                    return False \\n            return True \\n        return False  \\n\\n    def check_board_status(self, board : List[str]) -> bool : \\n        self.counts = collections.defaultdict(int)\\n        for row in board : \\n            for cell in row : \\n                self.counts[cell] += 1 \\n        return (self.counts[\"O\"] <= self.counts[\"X\"]) and (self.counts[\"X\"] - self.counts[\"O\"] <= 1)\\n\\n    def check_winner(self, board : List[str]) -> bool : \\n        # statuses by row for x and o \\n        x_statuses = [False, False, False, False]\\n        o_statuses = [False, False, False, False]\\n        # sums by row, sums by col, and diagonals up and down \\n        x_sums = [[0, 0, 0], [0, 0, 0], [0, 0]]\\n        o_sums = [[0, 0, 0], [0, 0, 0], [0, 0]]\\n\\n        # get row sum for x\\'s and o\\'s and if 3 set status 0 for each \\n        for row_index, row in enumerate(board) : \\n            x_sums[0][row_index] = sum([int(r_i == \"X\") for r_i in row])\\n            o_sums[0][row_index] = sum([int(r_i == \"O\") for r_i in row])\\n            x_statuses[0] = True if x_sums[0][row_index] == 3 else x_statuses[0]\\n            o_statuses[0] = True if o_sums[0][row_index] == 3 else o_statuses[0]\\n\\n        # col major order since we can\\'t unpack strings in python \\n        # if sum of col is 3 update status at 1 otherwise remain same \\n        for col in range(3) : \\n            for row in range(3) : \\n                cell = board[row][col]\\n                x_sums[1][col] += cell == \\'X\\'\\n                o_sums[1][col] += cell == \\'O\\'\\n            x_statuses[1] = True if x_sums[1][col] == 3 else x_statuses[1]\\n            o_statuses[1] = True if o_sums[1][col] == 3 else o_statuses[1]\\n            \\n        # for board index in range 3 \\n        # 0 cell diag down 1 cell diag up \\n        for b_i in range(3) : \\n            x_sums[2][0] += board[b_i][0+b_i] == \"X\"\\n            x_sums[2][1] += board[b_i][2-b_i] == \"X\"\\n            o_sums[2][0] += board[b_i][0+b_i] == \"O\"\\n            o_sums[2][1] += board[b_i][2-b_i] == \"O\"\\n        x_statuses[2] = x_sums[2][0] == 3 \\n        x_statuses[3] = x_sums[2][1] == 3 \\n        o_statuses[2] = o_sums[2][0] == 3 \\n        o_statuses[3] = o_sums[2][1] == 3 \\n\\n        # if we have an x win and do not have one more x than o, False \\n        # similarly, if we have an o win, and have any more or less moves, False \\n        if sum(x_statuses) > 0 and (self.counts[\"X\"] - self.counts[\"O\"] != 1) : \\n            return False \\n        elif sum(o_statuses) > 0 and (self.counts[\"X\"] - self.counts[\"O\"] != 0) : \\n            return False \\n        else : \\n            # in all other cases, valid win, but we don\\'t know who! \\n            # assignment for class is to modify this and return who won in a separate function\\n            return True \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713749,
                "title": "light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        c_x = 0\\n        c_o = 0\\n        row_3 = 0\\n        row_3_2 = 0\\n        row_3_X = 0\\n        row_3_O = 0\\n        row_X = 0\\n        row_O = 0\\n        if board[0][0]==\\'X\\' and board[1][1]==\\'X\\' and board[2][2]==\\'X\\' or board[0][2]==\\'X\\' and board[1][1]==\\'X\\' and board[2][0]==\\'X\\':\\n            row_X += 1 \\n        elif board[0][0]==\\'O\\' and board[1][1]==\\'O\\' and board[2][2]==\\'O\\' or board[0][2]==\\'O\\' and board[1][1]==\\'O\\' and board[2][0]==\\'O\\':\\n            row_O += 1 \\n        for k,i in enumerate(board):\\n            x = i.count(\"X\")\\n            o = i.count(\"O\")\\n            c_x += i.count(\"X\")\\n            c_o += i.count(\"O\")\\n            if x==3 or o==3:\\n                row_3 += 1\\n            if x==3:\\n                row_3_X += 1\\n            elif o==3:\\n                row_3_O += 1\\n            if board[0][k]==board[1][k] and board[1][k]==board[2][k] and board[k][k]!=\\' \\':\\n                row_3_2 += 1\\n        if c_o > c_x or abs(c_x-c_o)>1 or row_3>1 or row_3_2>1 or row_3_O!=0 and c_o>c_x or row_3_X!=0 and c_o==c_x or row_O != 0 and c_x>=c_o or row_X != 0 and c_x==c_o:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        c_x = 0\\n        c_o = 0\\n        row_3 = 0\\n        row_3_2 = 0\\n        row_3_X = 0\\n        row_3_O = 0\\n        row_X = 0\\n        row_O = 0\\n        if board[0][0]==\\'X\\' and board[1][1]==\\'X\\' and board[2][2]==\\'X\\' or board[0][2]==\\'X\\' and board[1][1]==\\'X\\' and board[2][0]==\\'X\\':\\n            row_X += 1 \\n        elif board[0][0]==\\'O\\' and board[1][1]==\\'O\\' and board[2][2]==\\'O\\' or board[0][2]==\\'O\\' and board[1][1]==\\'O\\' and board[2][0]==\\'O\\':\\n            row_O += 1 \\n        for k,i in enumerate(board):\\n            x = i.count(\"X\")\\n            o = i.count(\"O\")\\n            c_x += i.count(\"X\")\\n            c_o += i.count(\"O\")\\n            if x==3 or o==3:\\n                row_3 += 1\\n            if x==3:\\n                row_3_X += 1\\n            elif o==3:\\n                row_3_O += 1\\n            if board[0][k]==board[1][k] and board[1][k]==board[2][k] and board[k][k]!=\\' \\':\\n                row_3_2 += 1\\n        if c_o > c_x or abs(c_x-c_o)>1 or row_3>1 or row_3_2>1 or row_3_O!=0 and c_o>c_x or row_3_X!=0 and c_o==c_x or row_O != 0 and c_x>=c_o or row_X != 0 and c_x==c_o:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694715,
                "title": "sorry-for-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }\\n                if(board[i].charAt(j)==\\'X\\'){\\n                    if(i==j)xdiag++;\\n                    arr[1]++;\\n                    x++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\'){\\n                    if(i==j)odiag++;\\n                    arr[0]++;\\n                    o++;\\n                }\\n            }\\n            if(o==3 && owin)return false;\\n            if(owin && xwin)return false;\\n            if(x==3)xwin=true;\\n            else if(o==3)owin=true;\\n        }\\n        if(xdiag==3)xwin=true;\\n        if(odiag==3)owin=true;\\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')xwin=true;\\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')owin=true;\\n        if(arr[0]>=arr[1] && xwin || (arr[1]>arr[0] && owin))return false;\\n        if(arr[0]>arr[1] || Math.abs(arr[0]-arr[1])>1)return false;\\n        return xwin&&owin?false:true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] arr=new int[2];\\n        boolean xwin=false,owin=false;\\n        int xdiag=0,odiag=0;\\n        for(int i=0;i<3;i++){\\n            int x=0,o=0;\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==0){\\n                    if(board[i].charAt(j)==\\'X\\' && board[i+1].charAt(j)==\\'X\\' && board[i+2].charAt(j)==\\'X\\')xwin=true;\\n                    if(board[i].charAt(j)==\\'O\\' && board[i+1].charAt(j)==\\'O\\' && board[i+2].charAt(j)==\\'O\\')owin=true;\\n                }\\n                if(board[i].charAt(j)==\\'X\\'){\\n                    if(i==j)xdiag++;\\n                    arr[1]++;\\n                    x++;\\n                }\\n                else if(board[i].charAt(j)==\\'O\\'){\\n                    if(i==j)odiag++;\\n                    arr[0]++;\\n                    o++;\\n                }\\n            }\\n            if(o==3 && owin)return false;\\n            if(owin && xwin)return false;\\n            if(x==3)xwin=true;\\n            else if(o==3)owin=true;\\n        }\\n        if(xdiag==3)xwin=true;\\n        if(odiag==3)owin=true;\\n        if(board[0].charAt(2)==\\'X\\' && board[1].charAt(1)==\\'X\\' && board[2].charAt(0)==\\'X\\')xwin=true;\\n        if(board[0].charAt(2)==\\'O\\' && board[1].charAt(1)==\\'O\\' && board[2].charAt(0)==\\'O\\')owin=true;\\n        if(arr[0]>=arr[1] && xwin || (arr[1]>arr[0] && owin))return false;\\n        if(arr[0]>arr[1] || Math.abs(arr[0]-arr[1])>1)return false;\\n        return xwin&&owin?false:true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670955,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ValidTicTacToe(string[] board) {\\n        int xCount = 0, oCount = 0, xRowCount = 0, oRowCount = 0;\\n        for (int i = 0; i < 3; i++)\\n        {\\n            if (board[i] == \"XXX\") xRowCount++;\\n            if (board[i] == \"OOO\") oRowCount++;\\n            xCount += board[i].Count(x => x == \\'X\\');\\n            oCount += board[i].Count(x => x == \\'O\\');\\n        }\\n        for (int i = 0; i < 3; i++)\\n        {\\n            var subStr = new StringBuilder();\\n            for (int j = 0; j < 3; j++)\\n            {\\n                subStr.Append(board[j][i]);\\n                if (subStr.ToString() == \"XXX\") xRowCount++;\\n                if (subStr.ToString() == \"OOO\") oRowCount++;\\n            }\\n        }\\n        var str = new StringBuilder();\\n        str.Append(board[0][0]);str.Append(board[1][1]);str.Append(board[2][2]);\\n                if (str.ToString() == \"XXX\") xRowCount++;\\n                if (str.ToString() == \"OOO\") oRowCount++;\\n                str.Clear();\\n                \\n        str.Append(board[0][2]);str.Append(board[1][1]);str.Append(board[2][0]);\\n                if (str.ToString() == \"XXX\") xRowCount++;\\n                if (str.ToString() == \"OOO\") oRowCount++;\\n                if (xCount < oCount || xCount - oCount > 1) return false;\\n                if (xRowCount > 0) return (oRowCount == 0 && xCount - oCount == 1);\\n                if (oRowCount > 0) return (xRowCount == 0 && xCount == oCount);\\n                return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ValidTicTacToe(string[] board) {\\n        int xCount = 0, oCount = 0, xRowCount = 0, oRowCount = 0;\\n        for (int i = 0; i < 3; i++)\\n        {\\n            if (board[i] == \"XXX\") xRowCount++;\\n            if (board[i] == \"OOO\") oRowCount++;\\n            xCount += board[i].Count(x => x == \\'X\\');\\n            oCount += board[i].Count(x => x == \\'O\\');\\n        }\\n        for (int i = 0; i < 3; i++)\\n        {\\n            var subStr = new StringBuilder();\\n            for (int j = 0; j < 3; j++)\\n            {\\n                subStr.Append(board[j][i]);\\n                if (subStr.ToString() == \"XXX\") xRowCount++;\\n                if (subStr.ToString() == \"OOO\") oRowCount++;\\n            }\\n        }\\n        var str = new StringBuilder();\\n        str.Append(board[0][0]);str.Append(board[1][1]);str.Append(board[2][2]);\\n                if (str.ToString() == \"XXX\") xRowCount++;\\n                if (str.ToString() == \"OOO\") oRowCount++;\\n                str.Clear();\\n                \\n        str.Append(board[0][2]);str.Append(board[1][1]);str.Append(board[2][0]);\\n                if (str.ToString() == \"XXX\") xRowCount++;\\n                if (str.ToString() == \"OOO\") oRowCount++;\\n                if (xCount < oCount || xCount - oCount > 1) return false;\\n                if (xRowCount > 0) return (oRowCount == 0 && xCount - oCount == 1);\\n                if (oRowCount > 0) return (xRowCount == 0 && xCount == oCount);\\n                return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573360,
                "title": "hey-i-know-how-you-feel-i-was-beat-in-tic-tac-toe-by-a-chicken",
                "content": "# Intuition\\nKeep track of X/O count, whether there are winning rows.\\nMultiple winners in the 100\\'s or so range of test cases are (supposed to be) precluded by count validites.\\n\\nRealize now as i\\'m writing that I indeed need those commented out checks in Checktermination().  input = [\"XXX\", \"  X\", \"OOO\"], [\"XXX\", \"O X\", \"OOO\"] or it\\'s isomorphisms would break any solution that does not include that check.  (There\\'s 3^9; 3^9/4 unique isomorphisms; total boards so this is a bit of a pain)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N), O(9) technically.  The program rejects any larger than 3x3 boards\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#this should not be as complicated a machine as it is...\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        return (self.checkLens(board) and self.checkCounts(board) and self.checkTermination(board))\\n\\n    #checks validity of input board\\n    def checkLens(self, board) -> bool:\\n        if (len(board) != 3):\\n            return False\\n        if any(len(row) != 3 for row in board): #Don\\'t fuck with this\\n            return False\\n\\n        return True\\n\\n    #checks whether counts of x and o are valid (the easy part, narrow range)\\n    #stores counts of x and o\\'s for checking validity of termination\\n    def checkCounts(self, board) -> bool:\\n        self.x_ct = 0\\n        self.o_ct = 0\\n\\n        for row in board:\\n            for cell in row:\\n                if cell == \"X\":\\n                    self.x_ct += 1\\n                elif cell == \"O\":\\n                    self.o_ct += 1\\n\\n        return (self.o_ct <= self.x_ct) and (self.x_ct - self.o_ct <= 1)\\n\\n\\n    #the not easy part, figuring out if we\\'re truly done\\n    #dependent on calculations made in checkcount\\n    def checkTermination(self, board) -> bool:\\n        #we care only if there\\'s both an (X and O) row or (X and O) col, there\\'s a bunch of preclusion here\\n        x_row, o_row = False, False\\n        for row in board:\\n            if all(cell == \"X\" for cell in row):\\n                x_row = True\\n            if all(cell == \"O\" for cell in row):\\n                o_row = True\\n\\n        #if x_row and o_row:\\n         #   return False\\n\\n        x_col, o_col = False, False\\n        for col in range(3):\\n            if all(board[row][col] == \"X\" for row in range(3)):\\n                x_col = True\\n            if all(board[row][col] == \"O\" for row in range(3)):\\n                o_col = True\\n\\n        #if x_col and o_col:\\n         #   return False\\n\\n        x_diag = all(board[0+i][0+i] == \"X\" for i in range(3)) or all(board[0+i][2-i] == \"X\" for i in range(3))\\n        o_diag = all(board[0+i][0+i] == \"O\" for i in range(3)) or all(board[0+i][2-i] == \"O\" for i in range(3))\\n\\n        #all winning x positions must have 1 more x than o\\n        if (x_row or x_col or x_diag) and (self.x_ct - self.o_ct != 1):\\n            return False\\n        #all winning o mush have equal x and o\\n        if (o_row or o_col or o_diag) and (self.x_ct - self.o_ct != 0):\\n            return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#this should not be as complicated a machine as it is...\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        return (self.checkLens(board) and self.checkCounts(board) and self.checkTermination(board))\\n\\n    #checks validity of input board\\n    def checkLens(self, board) -> bool:\\n        if (len(board) != 3):\\n            return False\\n        if any(len(row) != 3 for row in board): #Don\\'t fuck with this\\n            return False\\n\\n        return True\\n\\n    #checks whether counts of x and o are valid (the easy part, narrow range)\\n    #stores counts of x and o\\'s for checking validity of termination\\n    def checkCounts(self, board) -> bool:\\n        self.x_ct = 0\\n        self.o_ct = 0\\n\\n        for row in board:\\n            for cell in row:\\n                if cell == \"X\":\\n                    self.x_ct += 1\\n                elif cell == \"O\":\\n                    self.o_ct += 1\\n\\n        return (self.o_ct <= self.x_ct) and (self.x_ct - self.o_ct <= 1)\\n\\n\\n    #the not easy part, figuring out if we\\'re truly done\\n    #dependent on calculations made in checkcount\\n    def checkTermination(self, board) -> bool:\\n        #we care only if there\\'s both an (X and O) row or (X and O) col, there\\'s a bunch of preclusion here\\n        x_row, o_row = False, False\\n        for row in board:\\n            if all(cell == \"X\" for cell in row):\\n                x_row = True\\n            if all(cell == \"O\" for cell in row):\\n                o_row = True\\n\\n        #if x_row and o_row:\\n         #   return False\\n\\n        x_col, o_col = False, False\\n        for col in range(3):\\n            if all(board[row][col] == \"X\" for row in range(3)):\\n                x_col = True\\n            if all(board[row][col] == \"O\" for row in range(3)):\\n                o_col = True\\n\\n        #if x_col and o_col:\\n         #   return False\\n\\n        x_diag = all(board[0+i][0+i] == \"X\" for i in range(3)) or all(board[0+i][2-i] == \"X\" for i in range(3))\\n        o_diag = all(board[0+i][0+i] == \"O\" for i in range(3)) or all(board[0+i][2-i] == \"O\" for i in range(3))\\n\\n        #all winning x positions must have 1 more x than o\\n        if (x_row or x_col or x_diag) and (self.x_ct - self.o_ct != 1):\\n            return False\\n        #all winning o mush have equal x and o\\n        if (o_row or o_col or o_diag) and (self.x_ct - self.o_ct != 0):\\n            return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563305,
                "title": "backtracking-tictactoe-grid-validity-check",
                "content": "# Intuition\\nA grid could be part of a TTT game if the last move was possible.\\n\\n# Approach\\n\\nSolution:\\n1. Ensure the number of turns is \"balanced\": n(X) = n(O) or n(X) = n(O) + 1\\n3. Determine the last player (X or O) using turn counts.\\n5. Check if any of last player\\'s ticks could\\'ve been the final turn, i.e.\\nthe game was \"incomplete\" (had no winner) before that.\\n\\nThe above works only for non-empty grids, but we\\'ll add two more checks to make it quicker:\\n1. Mark all \"quite empty\" grids valid \\u2014 so small that they are surely\\nincomplete games or trivial X wins. This takes care of the empty grid.\\n2. Check if the provided game grid is incomplete (has no winner yet) - it\\'s valid then.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $board\\n     * @return Boolean\\n     */\\n    function validTicTacToe($board) {\\n\\t\\t$board = array_map(str_split(...), $board);\\n\\n        return (new Grid($board))->isValid();\\n    }\\n}\\n\\nclass Grid\\n{\\n    // To make it more fun, let\\'s make this generalizable to NxN TTT.\\n\\tprotected const SIZE = 3;\\n\\n\\tpublic function __construct(public readonly array $grid) {}\\n\\n\\tpublic static function fromStdin(): static\\n\\t{\\n\\t\\t$grid = [];\\n\\t\\tfor ($i = 0; $i < static::SIZE; $i++)\\n\\t\\t\\t$grid[] = static::readRow();\\n\\n\\t\\treturn new static($grid);\\n\\t}\\n\\n\\tprotected static function readRow(): array\\n\\t{\\n\\t\\treturn str_split(\\n\\t\\t\\ttrim(fgets(STDIN)),\\n\\t\\t\\t1,\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * Check if the numbers of X/O turns are valid and the state of the grid makes\\n\\t * sense with such turn counts.\\n\\t */\\n\\tpublic function isValid(): bool\\n\\t{\\n\\t\\t$turns = [\\n\\t\\t\\t\\'X\\' => 0,\\n\\t\\t\\t\\'O\\' => 0,\\n\\t\\t\\t\\' \\' => 0, // . marks a \"yet untaken\" turn\\n\\t\\t];\\n\\n\\t\\tforeach ($this->grid as $row)\\n\\t\\t\\tforeach ($row as $entry)\\n\\t\\t\\t\\t$turns[$entry]++;\\n\\n\\t\\t// Turn counts must be balanced according to TTT rules\\n\\t\\tif ($turns[\\'O\\'] > $turns[\\'X\\'] || $turns[\\'X\\'] > $turns[\\'O\\'] + 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// If O hasn\\'t had enough turns to win, the grid is always valid\\n\\t\\tif ($turns[\\'O\\'] < static::SIZE)\\n\\t\\t\\treturn true;\\n\\n\\t\\t// Grid is possible if the game isn\\'t over yet\\n\\t\\tif (!$this->gameOver())\\n\\t\\t\\treturn true;\\n\\n\\t\\t// And also possible if the game wasn\\'t over before the last move\\n\\t\\treturn $this->gameIncompleteWithout(\\n\\t\\t\\t$turns[\\'X\\'] > $turns[\\'O\\'] ? \\'X\\' : \\'O\\',\\n\\t\\t);\\n\\t}\\n\\n\\tprotected function lineComplete(array $line): bool\\n\\t{\\n\\t\\t$char = $line[0];\\n\\n\\t\\tif (\\' \\' === $char)\\n\\t\\t\\treturn false;\\n\\n\\t\\tforeach (array_slice($line, 1) as $cell)\\n\\t\\t\\tif ($char !== $cell)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * The game is over if any line on the grid is complete.\\n\\t */\\n\\tpublic function gameOver(): bool\\n\\t{\\n\\t\\t$mainDiagonal = [];\\n\\t\\t$antiDiagonal = [];\\n\\n\\t\\tfor ($i = 0; $i < static::SIZE; $i++) {\\n\\t\\t\\tif ($this->lineComplete($this->grid[$i]))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif ($this->lineComplete(array_column($this->grid, $i)))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t$mainDiagonal[] = $this->grid[$i][$i];\\n\\t\\t\\t$antiDiagonal[] = $this->grid[$i][static::SIZE - $i - 1];\\n\\t\\t}\\n\\n\\t\\tif ($this->lineComplete($mainDiagonal))\\n\\t\\t\\treturn true;\\n\\n\\t\\tif ($this->lineComplete($antiDiagonal))\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t * Check if any move of $lastMove could\\'ve been the final, i.e. if the game was\\n\\t * incomplete before that move.\\n\\t */\\n\\tprotected function gameIncompleteWithout(string $lastMove): bool\\n\\t{\\n\\t\\tforeach ($this->grid as $rowIndex => $row)\\n\\t\\t\\tforeach ($row as $colIndex => $char)\\n\\t\\t\\t\\tif ($char === $lastMove) {\\n\\t\\t\\t\\t\\t$gridBeforeMove = $this->grid;\\n\\t\\t\\t\\t\\t$gridBeforeMove[$rowIndex][$colIndex] = \\' \\';\\n\\n\\t\\t\\t\\t\\tif (!(new static($gridBeforeMove))->gameOver())\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $board\\n     * @return Boolean\\n     */\\n    function validTicTacToe($board) {\\n\\t\\t$board = array_map(str_split(...), $board);\\n\\n        return (new Grid($board))->isValid();\\n    }\\n}\\n\\nclass Grid\\n{\\n    // To make it more fun, let\\'s make this generalizable to NxN TTT.\\n\\tprotected const SIZE = 3;\\n\\n\\tpublic function __construct(public readonly array $grid) {}\\n\\n\\tpublic static function fromStdin(): static\\n\\t{\\n\\t\\t$grid = [];\\n\\t\\tfor ($i = 0; $i < static::SIZE; $i++)\\n\\t\\t\\t$grid[] = static::readRow();\\n\\n\\t\\treturn new static($grid);\\n\\t}\\n\\n\\tprotected static function readRow(): array\\n\\t{\\n\\t\\treturn str_split(\\n\\t\\t\\ttrim(fgets(STDIN)),\\n\\t\\t\\t1,\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * Check if the numbers of X/O turns are valid and the state of the grid makes\\n\\t * sense with such turn counts.\\n\\t */\\n\\tpublic function isValid(): bool\\n\\t{\\n\\t\\t$turns = [\\n\\t\\t\\t\\'X\\' => 0,\\n\\t\\t\\t\\'O\\' => 0,\\n\\t\\t\\t\\' \\' => 0, // . marks a \"yet untaken\" turn\\n\\t\\t];\\n\\n\\t\\tforeach ($this->grid as $row)\\n\\t\\t\\tforeach ($row as $entry)\\n\\t\\t\\t\\t$turns[$entry]++;\\n\\n\\t\\t// Turn counts must be balanced according to TTT rules\\n\\t\\tif ($turns[\\'O\\'] > $turns[\\'X\\'] || $turns[\\'X\\'] > $turns[\\'O\\'] + 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// If O hasn\\'t had enough turns to win, the grid is always valid\\n\\t\\tif ($turns[\\'O\\'] < static::SIZE)\\n\\t\\t\\treturn true;\\n\\n\\t\\t// Grid is possible if the game isn\\'t over yet\\n\\t\\tif (!$this->gameOver())\\n\\t\\t\\treturn true;\\n\\n\\t\\t// And also possible if the game wasn\\'t over before the last move\\n\\t\\treturn $this->gameIncompleteWithout(\\n\\t\\t\\t$turns[\\'X\\'] > $turns[\\'O\\'] ? \\'X\\' : \\'O\\',\\n\\t\\t);\\n\\t}\\n\\n\\tprotected function lineComplete(array $line): bool\\n\\t{\\n\\t\\t$char = $line[0];\\n\\n\\t\\tif (\\' \\' === $char)\\n\\t\\t\\treturn false;\\n\\n\\t\\tforeach (array_slice($line, 1) as $cell)\\n\\t\\t\\tif ($char !== $cell)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * The game is over if any line on the grid is complete.\\n\\t */\\n\\tpublic function gameOver(): bool\\n\\t{\\n\\t\\t$mainDiagonal = [];\\n\\t\\t$antiDiagonal = [];\\n\\n\\t\\tfor ($i = 0; $i < static::SIZE; $i++) {\\n\\t\\t\\tif ($this->lineComplete($this->grid[$i]))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tif ($this->lineComplete(array_column($this->grid, $i)))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t$mainDiagonal[] = $this->grid[$i][$i];\\n\\t\\t\\t$antiDiagonal[] = $this->grid[$i][static::SIZE - $i - 1];\\n\\t\\t}\\n\\n\\t\\tif ($this->lineComplete($mainDiagonal))\\n\\t\\t\\treturn true;\\n\\n\\t\\tif ($this->lineComplete($antiDiagonal))\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t * Check if any move of $lastMove could\\'ve been the final, i.e. if the game was\\n\\t * incomplete before that move.\\n\\t */\\n\\tprotected function gameIncompleteWithout(string $lastMove): bool\\n\\t{\\n\\t\\tforeach ($this->grid as $rowIndex => $row)\\n\\t\\t\\tforeach ($row as $colIndex => $char)\\n\\t\\t\\t\\tif ($char === $lastMove) {\\n\\t\\t\\t\\t\\t$gridBeforeMove = $this->grid;\\n\\t\\t\\t\\t\\t$gridBeforeMove[$rowIndex][$colIndex] = \\' \\';\\n\\n\\t\\t\\t\\t\\tif (!(new static($gridBeforeMove))->gameOver())\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551385,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\nO(n) where n is the number of cells in the board\\n\\n- Space complexity:\\nO(1) as no extra space is required\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkWin(vector<string>& board, char player)\\n    {\\n        // Check rows\\n        for (int i = 0; i < 3; i++) {\\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player)\\n                return true;\\n        }\\n        \\n        // Check columns\\n        for (int j = 0; j < 3; j++) {\\n            if (board[0][j] == player && board[1][j] == player && board[2][j] == player)\\n                return true;\\n        }\\n        \\n        // Check diagonals\\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player)\\n            return true;\\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player)\\n            return true;\\n        \\n        return false;\\n    }\\n    bool validTicTacToe(vector<string>& board) {\\n        int n = (int)board.size();\\n        int xcount = 0 , ocount = 0;\\n        for(auto it : board)\\n        {\\n            for(char c : it)\\n            {\\n                if(c==\\'X\\')\\n                xcount++;\\n                else if(c==\\'O\\')\\n                ocount++;\\n            }\\n        }\\n\\n        if(ocount>xcount || xcount-ocount>1) return false;\\n        bool xWins = checkWin(board,\\'X\\');\\n        bool oWins = checkWin(board,\\'O\\');\\n\\n        if(xWins && oWins) return false;\\n        if(xWins && (xcount-ocount)!=1) return false;\\n        if(oWins && xcount!=ocount) return false;\\n\\n\\n        return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkWin(vector<string>& board, char player)\\n    {\\n        // Check rows\\n        for (int i = 0; i < 3; i++) {\\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player)\\n                return true;\\n        }\\n        \\n        // Check columns\\n        for (int j = 0; j < 3; j++) {\\n            if (board[0][j] == player && board[1][j] == player && board[2][j] == player)\\n                return true;\\n        }\\n        \\n        // Check diagonals\\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player)\\n            return true;\\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player)\\n            return true;\\n        \\n        return false;\\n    }\\n    bool validTicTacToe(vector<string>& board) {\\n        int n = (int)board.size();\\n        int xcount = 0 , ocount = 0;\\n        for(auto it : board)\\n        {\\n            for(char c : it)\\n            {\\n                if(c==\\'X\\')\\n                xcount++;\\n                else if(c==\\'O\\')\\n                ocount++;\\n            }\\n        }\\n\\n        if(ocount>xcount || xcount-ocount>1) return false;\\n        bool xWins = checkWin(board,\\'X\\');\\n        bool oWins = checkWin(board,\\'O\\');\\n\\n        if(xWins && oWins) return false;\\n        if(xWins && (xcount-ocount)!=1) return false;\\n        if(oWins && xcount!=ocount) return false;\\n\\n\\n        return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516291,
                "title": "simple-c-backtrack-solution-with-tweak-avoiding-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isComplete(vector<vector<int>> &curr){\\n\\n        for(int i = 0;i<3;i++){\\n            if(curr[i][0]==curr[i][1] and curr[i][1]==curr[i][2]){\\n                if(curr[i][0]!=-1) return true;\\n            }\\n            if(curr[0][i]==curr[1][i] and curr[1][i]==curr[2][i]){\\n                if(curr[0][i]!=-1) return true;\\n            }\\n        }        \\n        if(curr[0][0]==curr[1][1] and curr[1][1]==curr[2][2]){\\n            if(curr[0][0]!=-1) return true;\\n        }\\n        if(curr[1][1]==curr[0][2] and curr[1][1]==curr[2][0]){\\n            if(curr[1][1]!=-1) return true;\\n        }\\n        return false;\\n    }\\n\\n    bool f(vector<vector<int>> &board,vector<vector<int>> &curr,int turn){\\n        if(board==curr) return true;\\n        if(isComplete(curr)) return false;\\n        for(int i = 0;i<3;i++){\\n            for(int j = 0;j<3;j++){\\n                if(curr[i][j]==-1){\\n                    curr[i][j] = turn;\\n                    if(f(board,curr,!turn)) return true;\\n                    curr[i][j] = -1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool validTicTacToe(vector<string>& b) {\\n        vector<vector<int>> curr(3,vector<int>(3,-1));\\n        vector<vector<int>> board(3,vector<int>(3,-1));\\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n        for(int i = 0;i<3;i++){\\n            for(int j = 0;j<3;j++){\\n                if(b[i][j]==\\'X\\') {board[i][j] = 1;cnt1++;}\\n                else if(b[i][j]==\\'O\\') {board[i][j] = 0;cnt2++;}\\n            }\\n        }\\n        if((cnt1==cnt2) or (cnt1==cnt2+1)) return f(board,curr,1);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isComplete(vector<vector<int>> &curr){\\n\\n        for(int i = 0;i<3;i++){\\n            if(curr[i][0]==curr[i][1] and curr[i][1]==curr[i][2]){\\n                if(curr[i][0]!=-1) return true;\\n            }\\n            if(curr[0][i]==curr[1][i] and curr[1][i]==curr[2][i]){\\n                if(curr[0][i]!=-1) return true;\\n            }\\n        }        \\n        if(curr[0][0]==curr[1][1] and curr[1][1]==curr[2][2]){\\n            if(curr[0][0]!=-1) return true;\\n        }\\n        if(curr[1][1]==curr[0][2] and curr[1][1]==curr[2][0]){\\n            if(curr[1][1]!=-1) return true;\\n        }\\n        return false;\\n    }\\n\\n    bool f(vector<vector<int>> &board,vector<vector<int>> &curr,int turn){\\n        if(board==curr) return true;\\n        if(isComplete(curr)) return false;\\n        for(int i = 0;i<3;i++){\\n            for(int j = 0;j<3;j++){\\n                if(curr[i][j]==-1){\\n                    curr[i][j] = turn;\\n                    if(f(board,curr,!turn)) return true;\\n                    curr[i][j] = -1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool validTicTacToe(vector<string>& b) {\\n        vector<vector<int>> curr(3,vector<int>(3,-1));\\n        vector<vector<int>> board(3,vector<int>(3,-1));\\n        int cnt1 = 0;\\n        int cnt2 = 0;\\n        for(int i = 0;i<3;i++){\\n            for(int j = 0;j<3;j++){\\n                if(b[i][j]==\\'X\\') {board[i][j] = 1;cnt1++;}\\n                else if(b[i][j]==\\'O\\') {board[i][j] = 0;cnt2++;}\\n            }\\n        }\\n        if((cnt1==cnt2) or (cnt1==cnt2+1)) return f(board,curr,1);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475386,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  bool validTicTacToe(const vector<string> &board) {\\n    constexpr int players = 2;\\n    constexpr int player1 = 0;\\n    constexpr int player2 = 1;\\n    constexpr char player1_cell = \\'X\\';\\n    constexpr char empty = \\' \\';\\n    constexpr int n = 3;\\n    constexpr uint8_t all_set = (1 << n) - 1;\\n    uint8_t rows[players][n]{};\\n    uint8_t cols[players][n]{};\\n    uint8_t diagonals[players]{};\\n    uint8_t anti_diagonals[players]{};\\n    uint8_t counts[players]{};\\n    for (int r = 0; r < n; ++r) {\\n      for (int c = 0; c < n; ++c) {\\n        if (board[r][c] == empty) {\\n          continue;\\n        }\\n        \\n        const int player = board[r][c] == player1_cell ? player1 : player2;\\n        rows[player][r] |= 1 << c;\\n        cols[player][c] |= 1 << r;\\n        if (r == c) {\\n          diagonals[player] |= 1 << r;\\n        }\\n        if (r + c == n - 1) {\\n          anti_diagonals[player] |= 1 << r;\\n        }\\n        ++counts[player];\\n      }\\n    }\\n    \\n    auto win = [&rows, &cols, &diagonals, &anti_diagonals](const int player) -> bool {\\n      if (diagonals[player] == all_set || anti_diagonals[player] == all_set) {\\n        return true;\\n      }\\n      for (int i = 0; i < n; ++i) {\\n        if (rows[player][i] == all_set || cols[player][i] == all_set) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    };\\n    \\n    if ((counts[player1] != counts[player2] && counts[player1] - counts[player2] != 1) ||\\n        (counts[player1] == counts[player2] && win(player1)) ||\\n        (counts[player1] - counts[player2] == 1 && win(player2))) {\\n      return false;\\n    }\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  bool validTicTacToe(const vector<string> &board) {\\n    constexpr int players = 2;\\n    constexpr int player1 = 0;\\n    constexpr int player2 = 1;\\n    constexpr char player1_cell = \\'X\\';\\n    constexpr char empty = \\' \\';\\n    constexpr int n = 3;\\n    constexpr uint8_t all_set = (1 << n) - 1;\\n    uint8_t rows[players][n]{};\\n    uint8_t cols[players][n]{};\\n    uint8_t diagonals[players]{};\\n    uint8_t anti_diagonals[players]{};\\n    uint8_t counts[players]{};\\n    for (int r = 0; r < n; ++r) {\\n      for (int c = 0; c < n; ++c) {\\n        if (board[r][c] == empty) {\\n          continue;\\n        }\\n        \\n        const int player = board[r][c] == player1_cell ? player1 : player2;\\n        rows[player][r] |= 1 << c;\\n        cols[player][c] |= 1 << r;\\n        if (r == c) {\\n          diagonals[player] |= 1 << r;\\n        }\\n        if (r + c == n - 1) {\\n          anti_diagonals[player] |= 1 << r;\\n        }\\n        ++counts[player];\\n      }\\n    }\\n    \\n    auto win = [&rows, &cols, &diagonals, &anti_diagonals](const int player) -> bool {\\n      if (diagonals[player] == all_set || anti_diagonals[player] == all_set) {\\n        return true;\\n      }\\n      for (int i = 0; i < n; ++i) {\\n        if (rows[player][i] == all_set || cols[player][i] == all_set) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    };\\n    \\n    if ((counts[player1] != counts[player2] && counts[player1] - counts[player2] != 1) ||\\n        (counts[player1] == counts[player2] && win(player1)) ||\\n        (counts[player1] - counts[player2] == 1 && win(player2))) {\\n      return false;\\n    }\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454048,
                "title": "java-solution-explained",
                "content": "There are 3 conditions for a tic-tac-toe board being valid.\\n1. Either the number of X\\'s is equal to or one greater than the number of O\\'s.\\n2. X\\'s and O\\'s cannot both be a winner.\\n3. If X\\'s is the winner, the number of X\\'s must be **exactly** one greater than the number of O\\'s. Likewise, if O\\'s is the winner, the number of X\\'s must be **exactly** equal to the number of O\\'s.\\n\\nProgrammatically, these conditions result in this line:\\n\\n**result = (x == o || x == o + 1) && !(xWinner && oWinner) && !((xWinner && x != o + 1) || (oWinner && x != o));**\\n\\n\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        boolean xWinner = false, oWinner = false;\\n        int[][] intBoard = new int[3][3];\\n        int x = 0, o = 0;\\n        \\n        for (int i = 0; i < 3; i++)\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    intBoard[i][j] = 1;\\n                    x++;\\n                }\\n                else if (board[i].charAt(j) == \\'O\\') {\\n                    intBoard[i][j] = -1;\\n                    o++;\\n                }\\n            }\\n        \\n        for (int i = 0; i < 3; i++) {\\n            int row = intBoard[i][0] + intBoard[i][1] + intBoard[i][2];\\n            int col = intBoard[0][i] + intBoard[1][i] + intBoard[2][i];\\n            \\n            if (row == 3 || col == 3)   xWinner = true;\\n            if (row == -3 || col == -3) oWinner = true;\\n        }\\n        \\n        int leftDiag  = intBoard[0][0] + intBoard[1][1] + intBoard[2][2];\\n        int rightDiag = intBoard[0][2] + intBoard[1][1] + intBoard[2][0];\\n        \\n        if (leftDiag == 3 || rightDiag == 3)   xWinner = true;\\n        if (leftDiag == -3 || rightDiag == -3) oWinner = true;\\n        \\n        return (x == o || x == o + 1) && !(xWinner && oWinner) && !((xWinner && x != o + 1) || (oWinner && x != o));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        boolean xWinner = false, oWinner = false;\\n        int[][] intBoard = new int[3][3];\\n        int x = 0, o = 0;\\n        \\n        for (int i = 0; i < 3; i++)\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    intBoard[i][j] = 1;\\n                    x++;\\n                }\\n                else if (board[i].charAt(j) == \\'O\\') {\\n                    intBoard[i][j] = -1;\\n                    o++;\\n                }\\n            }\\n        \\n        for (int i = 0; i < 3; i++) {\\n            int row = intBoard[i][0] + intBoard[i][1] + intBoard[i][2];\\n            int col = intBoard[0][i] + intBoard[1][i] + intBoard[2][i];\\n            \\n            if (row == 3 || col == 3)   xWinner = true;\\n            if (row == -3 || col == -3) oWinner = true;\\n        }\\n        \\n        int leftDiag  = intBoard[0][0] + intBoard[1][1] + intBoard[2][2];\\n        int rightDiag = intBoard[0][2] + intBoard[1][1] + intBoard[2][0];\\n        \\n        if (leftDiag == 3 || rightDiag == 3)   xWinner = true;\\n        if (leftDiag == -3 || rightDiag == -3) oWinner = true;\\n        \\n        return (x == o || x == o + 1) && !(xWinner && oWinner) && !((xWinner && x != o + 1) || (oWinner && x != o));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441842,
                "title": "typescript-beat-90",
                "content": "# Intuition\\nDefination: The game is valid if and only if the number of \\'X\\' is equal to or larger than the number of \\'O\\' by 1.\\n\\n# Approach\\n\\n1. if both win, return false \\n2. else if \"X\" win, then the number of X should be count(O) + 1;\\n3. else if \"O\" win, then the number of O should be equal to X;\\n4. else  countX >= countO && countX  <= countO + 1;\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// it the game is valid if and only if the number of \\'X\\' is equal to or larger than the number of \\'O\\' by 1\\n// if both win, return false \\n// if \"X\" win, then the number of X should be count(O) + 1;\\n// else if \"O\" win, then the number of O should be equal to X;\\n// else  countX >= countO && countX  <= countO + 1;\\n\\nfunction isWin(board: string[], char: string): boolean{\\n    let diagonal1: boolean = true;\\n    let diagonal2: boolean = true;\\n\\n    for(let i = 0; i < board.length; i ++){\\n        if(board[i] === char.repeat(3)) return true; // check row\\n        let isValid: boolean = true;\\n        for(let j = 0; j < board[0].length; j++){ // check column\\n            if(board[j][i] !== char){\\n                isValid = false;\\n            }\\n        }\\n        if(isValid) return true;\\n\\n        if(board[i][i] !== char){ // check diagonal1\\n            diagonal1 = false;\\n        }\\n        if(board[i][board.length - 1 - i] !== char){// check diagonal2\\n            diagonal2 = false;\\n        }\\n    }\\n\\n    return diagonal1 || diagonal2;\\n}\\n\\nfunction validTicTacToe(board: string[]): boolean {\\n    let countX: number = 0, countO: number = 0;\\n\\n    for(let i = 0; i < board.length; i ++){\\n        for(let j = 0; j < board[0].length; j++){\\n            if(board[i][j] === \\'X\\'){\\n                countX++;\\n            }else if (board[i][j] === \\'O\\'){\\n                countO++;\\n            }\\n        }\\n    }\\n\\n    if(isWin(board, \\'X\\') && isWin(board, \\'O\\')){\\n        return false;\\n    }else if(isWin(board,\\'X\\')){\\n        return countX === countO + 1;\\n    }else if (isWin(board, \\'O\\')){\\n        return countX === countO;\\n    }else{\\n        return countX >= countO && countX  <= countO + 1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// it the game is valid if and only if the number of \\'X\\' is equal to or larger than the number of \\'O\\' by 1\\n// if both win, return false \\n// if \"X\" win, then the number of X should be count(O) + 1;\\n// else if \"O\" win, then the number of O should be equal to X;\\n// else  countX >= countO && countX  <= countO + 1;\\n\\nfunction isWin(board: string[], char: string): boolean{\\n    let diagonal1: boolean = true;\\n    let diagonal2: boolean = true;\\n\\n    for(let i = 0; i < board.length; i ++){\\n        if(board[i] === char.repeat(3)) return true; // check row\\n        let isValid: boolean = true;\\n        for(let j = 0; j < board[0].length; j++){ // check column\\n            if(board[j][i] !== char){\\n                isValid = false;\\n            }\\n        }\\n        if(isValid) return true;\\n\\n        if(board[i][i] !== char){ // check diagonal1\\n            diagonal1 = false;\\n        }\\n        if(board[i][board.length - 1 - i] !== char){// check diagonal2\\n            diagonal2 = false;\\n        }\\n    }\\n\\n    return diagonal1 || diagonal2;\\n}\\n\\nfunction validTicTacToe(board: string[]): boolean {\\n    let countX: number = 0, countO: number = 0;\\n\\n    for(let i = 0; i < board.length; i ++){\\n        for(let j = 0; j < board[0].length; j++){\\n            if(board[i][j] === \\'X\\'){\\n                countX++;\\n            }else if (board[i][j] === \\'O\\'){\\n                countO++;\\n            }\\n        }\\n    }\\n\\n    if(isWin(board, \\'X\\') && isWin(board, \\'O\\')){\\n        return false;\\n    }else if(isWin(board,\\'X\\')){\\n        return countX === countO + 1;\\n    }else if (isWin(board, \\'O\\')){\\n        return countX === countO;\\n    }else{\\n        return countX >= countO && countX  <= countO + 1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414613,
                "title": "typescript-easy-to-understand",
                "content": "```\\nfunction validTicTacToe(board: string[]): boolean {\\n  let Xs = 0;\\n  let Os = 0;\\n\\n  for (const row of board) {\\n    for (let col = 0; col < row.length; col++) {\\n      const sign = row.charAt(col);\\n\\n      if (sign === \"X\") {\\n        Xs++;\\n      } else if (sign === \"O\") {\\n        Os++;\\n      }\\n    }\\n  }\\n\\n  if (Xs === 0 && Os === 0) {\\n    return true;\\n  }\\n\\n  if (Xs < Os) {\\n    return false;\\n  }\\n\\n  if (Xs - Os > 1) {\\n    return false;\\n  }\\n\\n  const diagonal = board[0][0] + board[1][1] + board[2][2];\\n  const antiDiagonal = board[0][2] + board[1][1] + board[2][0];\\n  const cols = board.map((_, col) => board[0][col] + board[1][col] + board[2][col]);\\n\\n  const XWonViaDiagonal = diagonal === \"XXX\";\\n  const XWonViaAntiDiagonal = antiDiagonal === \"XXX\";\\n  const XWonViaRows = board.includes(\"XXX\");\\n  const XWonViaCols = cols.includes(\"XXX\");\\n  const XWon = XWonViaDiagonal || XWonViaAntiDiagonal || XWonViaRows || XWonViaCols;\\n\\n  const OWonViaDiagonal = diagonal === \"OOO\";\\n  const OWonViaAntiDiagonal = antiDiagonal === \"OOO\";\\n  const OWonViaRows = board.includes(\"OOO\");\\n  const OWonViaCols = cols.includes(\"OOO\");\\n  const OWon = OWonViaDiagonal || OWonViaAntiDiagonal || OWonViaRows || OWonViaCols;\\n\\n  if (XWon && OWon) {\\n    return false;\\n  }\\n\\n  if (XWon) {\\n    return Os === Xs - 1;\\n  }\\n\\n  if (OWon) {\\n    return Xs === Os;\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nfunction validTicTacToe(board: string[]): boolean {\\n  let Xs = 0;\\n  let Os = 0;\\n\\n  for (const row of board) {\\n    for (let col = 0; col < row.length; col++) {\\n      const sign = row.charAt(col);\\n\\n      if (sign === \"X\") {\\n        Xs++;\\n      } else if (sign === \"O\") {\\n        Os++;\\n      }\\n    }\\n  }\\n\\n  if (Xs === 0 && Os === 0) {\\n    return true;\\n  }\\n\\n  if (Xs < Os) {\\n    return false;\\n  }\\n\\n  if (Xs - Os > 1) {\\n    return false;\\n  }\\n\\n  const diagonal = board[0][0] + board[1][1] + board[2][2];\\n  const antiDiagonal = board[0][2] + board[1][1] + board[2][0];\\n  const cols = board.map((_, col) => board[0][col] + board[1][col] + board[2][col]);\\n\\n  const XWonViaDiagonal = diagonal === \"XXX\";\\n  const XWonViaAntiDiagonal = antiDiagonal === \"XXX\";\\n  const XWonViaRows = board.includes(\"XXX\");\\n  const XWonViaCols = cols.includes(\"XXX\");\\n  const XWon = XWonViaDiagonal || XWonViaAntiDiagonal || XWonViaRows || XWonViaCols;\\n\\n  const OWonViaDiagonal = diagonal === \"OOO\";\\n  const OWonViaAntiDiagonal = antiDiagonal === \"OOO\";\\n  const OWonViaRows = board.includes(\"OOO\");\\n  const OWonViaCols = cols.includes(\"OOO\");\\n  const OWon = OWonViaDiagonal || OWonViaAntiDiagonal || OWonViaRows || OWonViaCols;\\n\\n  if (XWon && OWon) {\\n    return false;\\n  }\\n\\n  if (XWon) {\\n    return Os === Xs - 1;\\n  }\\n\\n  if (OWon) {\\n    return Xs === Os;\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3330159,
                "title": "short-and-easy-to-follow-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun validTicTacToe(board: Array<String>): Boolean {\\n        val xCounts = board.sumBy { row -> row.count { it == \\'X\\' } }\\n        val oCounts = board.sumBy { row -> row.count { it == \\'O\\' } }\\n        val numberOfWinsInRows = (0 until 3).count { board[it][0] == board[it][1] && board[it][0] == board[it][2] && board[it][0] != \\' \\' }\\n        val numberOfWinsInCols = (0 until 3).count { board[0][it] == board[1][it] && board[0][it] == board[2][it] && board[0][it] != \\' \\'}\\n        if (numberOfWinsInRows > 1 || numberOfWinsInCols > 1) return false\\n        val center = board[1][1]\\n        val diagonalWin = center != \\' \\' && ((board[0][0] == center && board[2][2] == center) ||\\n                (board[0][2] == center && board[2][0] == center))\\n        return when {\\n            diagonalWin -> if (center == \\'X\\') xCounts == oCounts + 1 else xCounts == oCounts\\n            numberOfWinsInRows > 0 -> if (board.contains(\"XXX\")) xCounts == oCounts + 1 else xCounts == oCounts\\n            numberOfWinsInCols > 0 -> if ((0..2).any { board[0][it] == \\'X\\' && board[1][it] == \\'X\\' && board[2][it] == \\'X\\'}) \\n                xCounts == oCounts + 1 else xCounts == oCounts\\n            else -> xCounts == oCounts || xCounts == oCounts + 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun validTicTacToe(board: Array<String>): Boolean {\\n        val xCounts = board.sumBy { row -> row.count { it == \\'X\\' } }\\n        val oCounts = board.sumBy { row -> row.count { it == \\'O\\' } }\\n        val numberOfWinsInRows = (0 until 3).count { board[it][0] == board[it][1] && board[it][0] == board[it][2] && board[it][0] != \\' \\' }\\n        val numberOfWinsInCols = (0 until 3).count { board[0][it] == board[1][it] && board[0][it] == board[2][it] && board[0][it] != \\' \\'}\\n        if (numberOfWinsInRows > 1 || numberOfWinsInCols > 1) return false\\n        val center = board[1][1]\\n        val diagonalWin = center != \\' \\' && ((board[0][0] == center && board[2][2] == center) ||\\n                (board[0][2] == center && board[2][0] == center))\\n        return when {\\n            diagonalWin -> if (center == \\'X\\') xCounts == oCounts + 1 else xCounts == oCounts\\n            numberOfWinsInRows > 0 -> if (board.contains(\"XXX\")) xCounts == oCounts + 1 else xCounts == oCounts\\n            numberOfWinsInCols > 0 -> if ((0..2).any { board[0][it] == \\'X\\' && board[1][it] == \\'X\\' && board[2][it] == \\'X\\'}) \\n                xCounts == oCounts + 1 else xCounts == oCounts\\n            else -> xCounts == oCounts || xCounts == oCounts + 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264882,
                "title": "js-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} board\\n * @return {boolean}\\n */\\nvar validTicTacToe = function(board) {\\n    let countO = 0\\n    let countX = 0\\n    for (let row = 0; row < board.length; row++){\\n        for(let i = 0; i < 3; i++){\\n            if (board[row][i] === \"O\") countO++\\n            if (board[row][i] === \"X\") countX++\\n        }\\n    }\\n    if (countO > countX) return false\\n    if (countX - countO > 1) return false\\n    let winner = new Set()\\n    if (board[0][0] === board[0][1] && board[0][1] === board[0][2] && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (board[1][0] === board[1][1] && board[1][1] === board[1][2]  && board[1][2] !== \" \") winner.add(board[1][2])\\n    if (board[2][0] === board[2][1] && board[2][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][0] && board[1][0] === board[2][0]  && board[2][0] !== \" \") winner.add(board[2][0])\\n    if (board[0][1] === board[1][1] && board[1][1] === board[2][1]  && board[2][1] !== \" \") winner.add(board[2][1])\\n    if (board[0][2] === board[1][2] && board[1][2] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[2][0] === board[1][1] && board[1][1] === board[0][2]  && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (winner.size > 1) return false\\n    if (Array.from(winner)[0] === \"O\" && countO !== countX) return false\\n    if (Array.from(winner)[0] === \"X\" && countO + 1 !== countX) return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} board\\n * @return {boolean}\\n */\\nvar validTicTacToe = function(board) {\\n    let countO = 0\\n    let countX = 0\\n    for (let row = 0; row < board.length; row++){\\n        for(let i = 0; i < 3; i++){\\n            if (board[row][i] === \"O\") countO++\\n            if (board[row][i] === \"X\") countX++\\n        }\\n    }\\n    if (countO > countX) return false\\n    if (countX - countO > 1) return false\\n    let winner = new Set()\\n    if (board[0][0] === board[0][1] && board[0][1] === board[0][2] && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (board[1][0] === board[1][1] && board[1][1] === board[1][2]  && board[1][2] !== \" \") winner.add(board[1][2])\\n    if (board[2][0] === board[2][1] && board[2][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][0] && board[1][0] === board[2][0]  && board[2][0] !== \" \") winner.add(board[2][0])\\n    if (board[0][1] === board[1][1] && board[1][1] === board[2][1]  && board[2][1] !== \" \") winner.add(board[2][1])\\n    if (board[0][2] === board[1][2] && board[1][2] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]  && board[2][2] !== \" \") winner.add(board[2][2])\\n    if (board[2][0] === board[1][1] && board[1][1] === board[0][2]  && board[0][2] !== \" \") winner.add(board[0][2])\\n    if (winner.size > 1) return false\\n    if (Array.from(winner)[0] === \"O\" && countO !== countX) return false\\n    if (Array.from(winner)[0] === \"X\" && countO + 1 !== countX) return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259899,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public static boolean validTicTacToe(String[] board) {\\n        int [] charToValue = new int[89];\\n        charToValue[\\'X\\'] = 1;\\n        charToValue[\\'O\\'] = -1;\\n\\n        char [][] chars = new char[3][3];\\n        for (int i = 0; i < 3; i++)chars[i] = board[i].toCharArray();\\n\\n        boolean X_Win = false, O_Win = false;\\n\\n        int [] rows = new int[3];\\n        int [] cols = new int[3];\\n        int [] crosses = new int[2];\\n\\n        crosses[0] =  charToValue[chars[0][0]]+charToValue[chars[1][1]]+charToValue[chars[2][2]];\\n        crosses[1] =  charToValue[chars[0][2]]+charToValue[chars[1][1]]+charToValue[chars[2][0]];\\n        if(crosses[0]==3||crosses[1]==3)X_Win=true;\\n        if(crosses[0]==-3||crosses[1]==-3)O_Win=true;\\n        \\n        int value = 0;\\n        // value = 0 -> X turn\\n        // value = 1 -> O turn\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                rows[i] += charToValue[chars[i][j]];\\n                cols[i] += charToValue[chars[j][i]];\\n            }\\n            if(rows[i]==3||cols[i]==3)X_Win=true;\\n            else if(rows[i]==-3||cols[i]==-3)O_Win=true;\\n            value+=rows[i];\\n            // both of them cannot win\\n            if(X_Win && O_Win) return false;\\n        }\\n        // value must be 0 or 1\\n        if(!(value==0 || value==1))return false;\\n        // value cannot be 0 when X_Win\\n        if(value==0 && X_Win)return false;\\n        // value cannot be 1 when O_Win\\n        if(value==1 && O_Win)return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static boolean validTicTacToe(String[] board) {\\n        int [] charToValue = new int[89];\\n        charToValue[\\'X\\'] = 1;\\n        charToValue[\\'O\\'] = -1;\\n\\n        char [][] chars = new char[3][3];\\n        for (int i = 0; i < 3; i++)chars[i] = board[i].toCharArray();\\n\\n        boolean X_Win = false, O_Win = false;\\n\\n        int [] rows = new int[3];\\n        int [] cols = new int[3];\\n        int [] crosses = new int[2];\\n\\n        crosses[0] =  charToValue[chars[0][0]]+charToValue[chars[1][1]]+charToValue[chars[2][2]];\\n        crosses[1] =  charToValue[chars[0][2]]+charToValue[chars[1][1]]+charToValue[chars[2][0]];\\n        if(crosses[0]==3||crosses[1]==3)X_Win=true;\\n        if(crosses[0]==-3||crosses[1]==-3)O_Win=true;\\n        \\n        int value = 0;\\n        // value = 0 -> X turn\\n        // value = 1 -> O turn\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                rows[i] += charToValue[chars[i][j]];\\n                cols[i] += charToValue[chars[j][i]];\\n            }\\n            if(rows[i]==3||cols[i]==3)X_Win=true;\\n            else if(rows[i]==-3||cols[i]==-3)O_Win=true;\\n            value+=rows[i];\\n            // both of them cannot win\\n            if(X_Win && O_Win) return false;\\n        }\\n        // value must be 0 or 1\\n        if(!(value==0 || value==1))return false;\\n        // value cannot be 0 when X_Win\\n        if(value==0 && X_Win)return false;\\n        // value cannot be 1 when O_Win\\n        if(value==1 && O_Win)return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256365,
                "title": "java-yes-the-boundary-cases-are-frustrating",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] rows = new int[3];\\n        int[] cols = new int[3];\\n        int dia = 0, antiDia = 0;\\n        int count0 = 0, count1 = 0;\\n        for (int row = 0; row < 3; row++) {\\n            for (int col = 0; col < 3; col++) {\\n                char ch = board[row].charAt(col);\\n                if (ch == \\'X\\') {\\n                    rows[row]++;\\n                    cols[col]++;\\n                    if (row == col) dia++;\\n                    if (row + col == 2) antiDia++;\\n                    count1++;\\n                } else if (ch == \\'O\\') {\\n                    rows[row]--;\\n                    cols[col]--;\\n                    if (row == col) dia--;\\n                    if (row + col == 2) antiDia--;\\n                    count0++;\\n                }\\n            }\\n        }\\n        boolean zerosWin = false, onesWin = false;\\n        for (int i = 0; i < 3; i++) {\\n            if (rows[i] == 3 || cols[i] == 3) onesWin = true;\\n            if (rows[i] == -3 || cols[i] == -3) zerosWin = true;\\n        }\\n        if (dia == 3 || antiDia == 3) onesWin = true;\\n        if (dia == -3 || antiDia == -3) zerosWin = true;\\n        if (onesWin && zerosWin) return false;\\n        if (onesWin && (count1 - count0) == 1) return true;\\n        if (zerosWin && (count1 - count0) == 0) return true;\\n        if (!onesWin && !zerosWin && (count1 != 0 || (count1 == 0 && count0 == 0)) && ((count1 - count0) == 1 || (count1 - count0) == 0)) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int[] rows = new int[3];\\n        int[] cols = new int[3];\\n        int dia = 0, antiDia = 0;\\n        int count0 = 0, count1 = 0;\\n        for (int row = 0; row < 3; row++) {\\n            for (int col = 0; col < 3; col++) {\\n                char ch = board[row].charAt(col);\\n                if (ch == \\'X\\') {\\n                    rows[row]++;\\n                    cols[col]++;\\n                    if (row == col) dia++;\\n                    if (row + col == 2) antiDia++;\\n                    count1++;\\n                } else if (ch == \\'O\\') {\\n                    rows[row]--;\\n                    cols[col]--;\\n                    if (row == col) dia--;\\n                    if (row + col == 2) antiDia--;\\n                    count0++;\\n                }\\n            }\\n        }\\n        boolean zerosWin = false, onesWin = false;\\n        for (int i = 0; i < 3; i++) {\\n            if (rows[i] == 3 || cols[i] == 3) onesWin = true;\\n            if (rows[i] == -3 || cols[i] == -3) zerosWin = true;\\n        }\\n        if (dia == 3 || antiDia == 3) onesWin = true;\\n        if (dia == -3 || antiDia == -3) zerosWin = true;\\n        if (onesWin && zerosWin) return false;\\n        if (onesWin && (count1 - count0) == 1) return true;\\n        if (zerosWin && (count1 - count0) == 0) return true;\\n        if (!onesWin && !zerosWin && (count1 != 0 || (count1 == 0 && count0 == 0)) && ((count1 - count0) == 1 || (count1 - count0) == 0)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237176,
                "title": "without-hard-coding-and-extra-memory",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n, where $$n$$ is size of matrix\\n\\n$$O(const)$$\\n\\n, if $$n$$ is const\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(const vector<string>& board) {\\n        const int N = board.size();\\n\\n        int xcnt = 0;\\n        int ocnt = 0;\\n        \\n        int diag_sum = 0;\\n        int rdiag_sum = 0;\\n\\n        int xwins = 0;\\n        int owins = 0;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            int row_sum = 0; \\n            int col_sum = 0;\\n            for (int j = 0; j < N; ++j) {\\n                const auto& m = board[i][j];\\n                const auto& rm = board[j][i];\\n\\n                if (m == \\'X\\') {\\n                    ++xcnt;\\n                    ++row_sum;\\n                    if (i == j) ++diag_sum;\\n                    if (i == N - 1 - j) ++rdiag_sum;\\n                }\\n                else if (m == \\'O\\') {\\n                    ++ocnt;\\n                    --row_sum;\\n                    if (i == j) --diag_sum;\\n                    if (i == N - 1 - j) --rdiag_sum;\\n                }\\n\\n                if (rm == \\'X\\') {\\n                    ++col_sum;\\n                }\\n                else if (rm == \\'O\\') {\\n                    --col_sum;\\n                }\\n            }\\n\\n            if (row_sum == N) ++xwins;\\n            else if (row_sum == -N) ++owins;\\n\\n            if (col_sum == N) ++xwins;\\n            else if (col_sum == -N) ++owins;\\n        }\\n\\n        if (diag_sum == N) ++xwins;\\n        else if (diag_sum == -N) ++owins;\\n\\n        if (rdiag_sum == N) ++xwins;\\n        else if (rdiag_sum == -N) ++owins;\\n\\n        if (xwins || owins) {\\n            return (xwins && !owins && xcnt == ocnt + 1) || (!xwins && owins && xcnt == ocnt);\\n        } else {\\n            return xcnt >= ocnt && xcnt - ocnt < 2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(const vector<string>& board) {\\n        const int N = board.size();\\n\\n        int xcnt = 0;\\n        int ocnt = 0;\\n        \\n        int diag_sum = 0;\\n        int rdiag_sum = 0;\\n\\n        int xwins = 0;\\n        int owins = 0;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            int row_sum = 0; \\n            int col_sum = 0;\\n            for (int j = 0; j < N; ++j) {\\n                const auto& m = board[i][j];\\n                const auto& rm = board[j][i];\\n\\n                if (m == \\'X\\') {\\n                    ++xcnt;\\n                    ++row_sum;\\n                    if (i == j) ++diag_sum;\\n                    if (i == N - 1 - j) ++rdiag_sum;\\n                }\\n                else if (m == \\'O\\') {\\n                    ++ocnt;\\n                    --row_sum;\\n                    if (i == j) --diag_sum;\\n                    if (i == N - 1 - j) --rdiag_sum;\\n                }\\n\\n                if (rm == \\'X\\') {\\n                    ++col_sum;\\n                }\\n                else if (rm == \\'O\\') {\\n                    --col_sum;\\n                }\\n            }\\n\\n            if (row_sum == N) ++xwins;\\n            else if (row_sum == -N) ++owins;\\n\\n            if (col_sum == N) ++xwins;\\n            else if (col_sum == -N) ++owins;\\n        }\\n\\n        if (diag_sum == N) ++xwins;\\n        else if (diag_sum == -N) ++owins;\\n\\n        if (rdiag_sum == N) ++xwins;\\n        else if (rdiag_sum == -N) ++owins;\\n\\n        if (xwins || owins) {\\n            return (xwins && !owins && xcnt == ocnt + 1) || (!xwins && owins && xcnt == ocnt);\\n        } else {\\n            return xcnt >= ocnt && xcnt - ocnt < 2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220854,
                "title": "elixir-solution",
                "content": "Very interesting problem to implement.\\n# Code\\n```elixir\\ndefmodule Solution do\\n  @spec valid_tic_tac_toe(board :: [String.t]) :: boolean\\n  def valid_tic_tac_toe(board) do\\n    chars =\\n      Enum.map(board, &String.to_charlist/1)\\n      |> Enum.concat()\\n    diff = Enum.count(chars, &(&1 == ?X)) -\\n          Enum.count(chars, &(&1 == ?O))\\n    win =\\n      Enum.with_index(chars)\\n      |> Map.new(fn {ch, i} -> {i, ch} end)\\n      |> winners()\\n\\n    case {win, diff} do\\n      {[], _} -> diff in 0..1\\n      {[?X], 1} -> true\\n      {[?O], 0} -> true\\n      _ -> false\\n    end\\n  end\\n\\n  defp winners(map) do\\n    [[0,1,2],[3,4,5],[6,7,8],\\n     [0,3,6],[1,4,7],[2,5,8],\\n     [0,4,8],[2,4,6]]\\n    |> Enum.flat_map(fn line ->\\n      Enum.map(line, &(Map.get(map, &1)))\\n      |> then(fn\\n        [w, w, w] when w != ?\\\\s -> [w]\\n        _ -> []\\n      end)\\n    end)\\n    |> Enum.uniq()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec valid_tic_tac_toe(board :: [String.t]) :: boolean\\n  def valid_tic_tac_toe(board) do\\n    chars =\\n      Enum.map(board, &String.to_charlist/1)\\n      |> Enum.concat()\\n    diff = Enum.count(chars, &(&1 == ?X)) -\\n          Enum.count(chars, &(&1 == ?O))\\n    win =\\n      Enum.with_index(chars)\\n      |> Map.new(fn {ch, i} -> {i, ch} end)\\n      |> winners()\\n\\n    case {win, diff} do\\n      {[], _} -> diff in 0..1\\n      {[?X], 1} -> true\\n      {[?O], 0} -> true\\n      _ -> false\\n    end\\n  end\\n\\n  defp winners(map) do\\n    [[0,1,2],[3,4,5],[6,7,8],\\n     [0,3,6],[1,4,7],[2,5,8],\\n     [0,4,8],[2,4,6]]\\n    |> Enum.flat_map(fn line ->\\n      Enum.map(line, &(Map.get(map, &1)))\\n      |> then(fn\\n        [w, w, w] when w != ?\\\\s -> [w]\\n        _ -> []\\n      end)\\n    end)\\n    |> Enum.uniq()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3213098,
                "title": "intuitive-c-solution",
                "content": "\\n# Approach\\n        // both X and O win : impossible solution \\n        // X winning game   : x > o\\'s by 1\\n        // O winning game   : x == o\\'s\\n        // else x always less than equal to o\\'s\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n\\n        string xstr = \"XXX\";\\n        string ostr = \"OOO\";\\n        \\n        // update count of x and o\\'s\\n        int o_cnt = 0, x_cnt = 0;\\n        for(auto str:board){\\n            for(auto ch:str){\\n                if(ch==\\'X\\')\\n                    x_cnt++;\\n                if(ch==\\'O\\')\\n                    o_cnt++;\\n            }\\n        }\\n        // check winning candidate(s)\\n        bool xwin = winFunc(board, xstr);\\n        bool owin = winFunc(board, ostr);\\n\\n        // apply above selection criteria\\n        if(xwin && owin)\\n            return false;\\n        else if(xwin)\\n            return x_cnt-o_cnt==1;\\n        else if(owin)\\n            return x_cnt == o_cnt;\\n        else\\n            return x_cnt-o_cnt<=1 && x_cnt-o_cnt>-1;\\n        \\n    }\\n\\n    bool winFunc(const vector<string>& board, const string& oxstr){\\n       string temp;\\n        for(int i = 0; i<board.size(); i++){\\n            if (board[i] == oxstr){ //check horizontal\\n                return true;\\n            }\\n            temp = \"\";\\n            temp = temp + board[0][i] + board[1][i] + board[2][i];\\n            if(oxstr == temp) // check vertical\\n                return true;\\n            \\n            temp = \"\";\\n            temp = temp + board[0][0+i]+board[1][1]+board[2][2-i];\\n            if(oxstr == temp) // check diagonal\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n\\n        string xstr = \"XXX\";\\n        string ostr = \"OOO\";\\n        \\n        // update count of x and o\\'s\\n        int o_cnt = 0, x_cnt = 0;\\n        for(auto str:board){\\n            for(auto ch:str){\\n                if(ch==\\'X\\')\\n                    x_cnt++;\\n                if(ch==\\'O\\')\\n                    o_cnt++;\\n            }\\n        }\\n        // check winning candidate(s)\\n        bool xwin = winFunc(board, xstr);\\n        bool owin = winFunc(board, ostr);\\n\\n        // apply above selection criteria\\n        if(xwin && owin)\\n            return false;\\n        else if(xwin)\\n            return x_cnt-o_cnt==1;\\n        else if(owin)\\n            return x_cnt == o_cnt;\\n        else\\n            return x_cnt-o_cnt<=1 && x_cnt-o_cnt>-1;\\n        \\n    }\\n\\n    bool winFunc(const vector<string>& board, const string& oxstr){\\n       string temp;\\n        for(int i = 0; i<board.size(); i++){\\n            if (board[i] == oxstr){ //check horizontal\\n                return true;\\n            }\\n            temp = \"\";\\n            temp = temp + board[0][i] + board[1][i] + board[2][i];\\n            if(oxstr == temp) // check vertical\\n                return true;\\n            \\n            temp = \"\";\\n            temp = temp + board[0][0+i]+board[1][1]+board[2][2-i];\\n            if(oxstr == temp) // check diagonal\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208286,
                "title": "valid-tic-toc-moves-java",
                "content": "# Intuition\\n<!-- Find a pattern in valid configurations -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem.\\n\\n- When O wins, there are equal number of O and X as O always comes after X and once O wins, the game should end. Similarly when X wins, number of Xs is one more than number of Os by the same logic\\n\\n- As X comes before O, number of Os is always one less than number of Xs. \\n\\n- It\\'s possible to iterate the board both rowwise and columnwise in the same for loops by just reversing the inner and outer loop indices\\n\\n -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n^2) -->\\n\\n- Space complexity:\\n<!-- O(n^2) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int count0 = 0;\\n        int countx = 0;\\n        boolean leftD = false;\\n        boolean rightD = false;\\n        boolean win1 = false; // x wins\\n        boolean win2 = false; // o wins\\n        char[][] cboard = new char[3][3];\\n        for(int i = 0; i < board.length; i++) {\\n            cboard[i] = board[i].toCharArray();\\n        }\\n        for(int i = 0; i < 3; i++) {\\n            char lastc = Character.MIN_VALUE;\\n            char lastr = Character.MIN_VALUE;\\n            for(int j=0; j < 3; j++) {\\n                char c = cboard[i][j];\\n                char c1 = cboard[j][i];\\n                if(lastc != Character.MIN_VALUE && c != lastc || c == \\' \\') {\\n                    lastc = \\'-\\';\\n                }\\n                if(lastr != Character.MIN_VALUE && c1 != lastr || c1 == \\' \\') {\\n                    lastr = \\'-\\';\\n                }\\n                if(c == \\'O\\'){\\n                    count0++;\\n                } else if(c == \\'X\\') {\\n                    countx++;\\n                }\\n                if(lastc != \\'-\\') {\\n                    lastc = c;\\n                }\\n                if(lastr != \\'-\\'){\\n                    lastr = c1;\\n                }\\n            }\\n            if(lastc != \\'-\\' && lastc != Character.MIN_VALUE && !win1 && !win2){\\n                win1 = lastc == \\'X\\';\\n                win2 = !win1;\\n            }\\n            if(!win1 && !win2 && lastr != \\'-\\' && lastr != Character.MIN_VALUE){\\n                win1 = lastr == \\'X\\';\\n                win2 = !win1;\\n            }\\n        }\\n        if(count0 > countx || countx-count0>1) {\\n            return false;\\n        }\\n        if(!win1 && !win2) {\\n           leftD = cboard[0][0] != \\' \\' && cboard[0][0] == cboard[1][1] && cboard[1][1] == cboard[2][2];\\n           if(leftD) {\\n               win1 = cboard[0][0] == \\'X\\';\\n               win2 = !win1;\\n            } else{\\n               rightD = cboard[0][2] != \\' \\' && cboard[0][2] == cboard[1][1] && cboard[1][1] == cboard[2][0];\\n               if(rightD) {\\n                    win1 = cboard[0][2] == \\'X\\';\\n                    win2 = !win1;\\n                }\\n           }\\n        }\\n        if(win1 && countx-count0 != 1 || win2 && countx-count0 != 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int count0 = 0;\\n        int countx = 0;\\n        boolean leftD = false;\\n        boolean rightD = false;\\n        boolean win1 = false; // x wins\\n        boolean win2 = false; // o wins\\n        char[][] cboard = new char[3][3];\\n        for(int i = 0; i < board.length; i++) {\\n            cboard[i] = board[i].toCharArray();\\n        }\\n        for(int i = 0; i < 3; i++) {\\n            char lastc = Character.MIN_VALUE;\\n            char lastr = Character.MIN_VALUE;\\n            for(int j=0; j < 3; j++) {\\n                char c = cboard[i][j];\\n                char c1 = cboard[j][i];\\n                if(lastc != Character.MIN_VALUE && c != lastc || c == \\' \\') {\\n                    lastc = \\'-\\';\\n                }\\n                if(lastr != Character.MIN_VALUE && c1 != lastr || c1 == \\' \\') {\\n                    lastr = \\'-\\';\\n                }\\n                if(c == \\'O\\'){\\n                    count0++;\\n                } else if(c == \\'X\\') {\\n                    countx++;\\n                }\\n                if(lastc != \\'-\\') {\\n                    lastc = c;\\n                }\\n                if(lastr != \\'-\\'){\\n                    lastr = c1;\\n                }\\n            }\\n            if(lastc != \\'-\\' && lastc != Character.MIN_VALUE && !win1 && !win2){\\n                win1 = lastc == \\'X\\';\\n                win2 = !win1;\\n            }\\n            if(!win1 && !win2 && lastr != \\'-\\' && lastr != Character.MIN_VALUE){\\n                win1 = lastr == \\'X\\';\\n                win2 = !win1;\\n            }\\n        }\\n        if(count0 > countx || countx-count0>1) {\\n            return false;\\n        }\\n        if(!win1 && !win2) {\\n           leftD = cboard[0][0] != \\' \\' && cboard[0][0] == cboard[1][1] && cboard[1][1] == cboard[2][2];\\n           if(leftD) {\\n               win1 = cboard[0][0] == \\'X\\';\\n               win2 = !win1;\\n            } else{\\n               rightD = cboard[0][2] != \\' \\' && cboard[0][2] == cboard[1][1] && cboard[1][1] == cboard[2][0];\\n               if(rightD) {\\n                    win1 = cboard[0][2] == \\'X\\';\\n                    win2 = !win1;\\n                }\\n           }\\n        }\\n        if(win1 && countx-count0 != 1 || win2 && countx-count0 != 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200197,
                "title": "python-just-4-conditions",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # check the number of \"X\", \"O\", and \" \"\\n        cell_state = collections.defaultdict(int)\\n        \\n        for row in board:\\n            for c in row:\\n                cell_state[c] += 1\\n        \\n        if cell_state[\\'O\\'] > cell_state[\\'X\\']:\\n            return False\\n        \\n        if cell_state[\\'X\\'] - cell_state[\\'O\\'] > 1:\\n            return False\\n        \\n        # X win, but \"O\" and \"X\" has the same count\\n        if self.win(board, \"X\") and (cell_state[\\'X\\'] == cell_state[\"O\"]):\\n            return False\\n        \\n        if self.win(board, \"O\") and (cell_state[\\'X\\'] > cell_state[\"O\"]):\\n            return False\\n        \\n        return True\\n        \\n    def win(self, board, s):\\n        rc, diag1, diag2 = 0, 0, 0\\n        cc = [0, 0, 0]\\n        for r in range(3):\\n            rc = 0\\n            for c in range(3):\\n                if board[r][c] == s:\\n                    rc += 1\\n                    cc[c] += 1\\n                    if (r == 0 and c == 0) or (r == 2 and c == 2):\\n                        diag1 += 1\\n                    if r == 1 and c == 1:\\n                        diag1 += 1\\n                        diag2 += 1\\n                    if (r == 0 and c == 2) or (r == 2 and c == 0):\\n                        diag2 += 1\\n            if rc == 3:\\n                return True\\n        if diag1 == 3 or diag2 == 3:\\n            return True\\n        return max(cc) == 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # check the number of \"X\", \"O\", and \" \"\\n        cell_state = collections.defaultdict(int)\\n        \\n        for row in board:\\n            for c in row:\\n                cell_state[c] += 1\\n        \\n        if cell_state[\\'O\\'] > cell_state[\\'X\\']:\\n            return False\\n        \\n        if cell_state[\\'X\\'] - cell_state[\\'O\\'] > 1:\\n            return False\\n        \\n        # X win, but \"O\" and \"X\" has the same count\\n        if self.win(board, \"X\") and (cell_state[\\'X\\'] == cell_state[\"O\"]):\\n            return False\\n        \\n        if self.win(board, \"O\") and (cell_state[\\'X\\'] > cell_state[\"O\"]):\\n            return False\\n        \\n        return True\\n        \\n    def win(self, board, s):\\n        rc, diag1, diag2 = 0, 0, 0\\n        cc = [0, 0, 0]\\n        for r in range(3):\\n            rc = 0\\n            for c in range(3):\\n                if board[r][c] == s:\\n                    rc += 1\\n                    cc[c] += 1\\n                    if (r == 0 and c == 0) or (r == 2 and c == 2):\\n                        diag1 += 1\\n                    if r == 1 and c == 1:\\n                        diag1 += 1\\n                        diag2 += 1\\n                    if (r == 0 and c == 2) or (r == 2 and c == 0):\\n                        diag2 += 1\\n            if rc == 3:\\n                return True\\n        if diag1 == 3 or diag2 == 3:\\n            return True\\n        return max(cc) == 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200147,
                "title": "answer-from-chatgpt-it-wrong-some-times-but-give-me-the-answer-at-last",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int xCount = 0, oCount = 0;\\n        int rows[3] = {0}, cols[3] = {0};\\n        int diagonal = 0, antiDiagonal = 0;\\n\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i][j] == \\'X\\') {\\n                    xCount++;\\n                    rows[i]++;\\n                    cols[j]++;\\n                    if (i == j) diagonal++;\\n                    if (i + j == 2) antiDiagonal++;\\n                } else if (board[i][j] == \\'O\\') {\\n                    oCount++;\\n                    rows[i]--;\\n                    cols[j]--;\\n                    if (i == j) diagonal--;\\n                    if (i + j == 2) antiDiagonal--;\\n                }\\n            }\\n        }\\n\\n        bool xWins = false, oWins = false;\\n        for (int i = 0; i < 3; i++) {\\n            if (rows[i] == 3 || cols[i] == 3) xWins = true;\\n            if (rows[i] == -3 || cols[i] == -3) oWins = true;\\n        }\\n        if (diagonal == 3 || antiDiagonal == 3) xWins = true;\\n        if (diagonal == -3 || antiDiagonal == -3) oWins = true;\\n\\n        if ((xWins && oWins) || (xCount != oCount && xCount != oCount + 1)) return false;\\n        if (xWins && xCount != oCount + 1) return false;\\n        if (oWins && xCount != oCount) return false;\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        int xCount = 0, oCount = 0;\\n        int rows[3] = {0}, cols[3] = {0};\\n        int diagonal = 0, antiDiagonal = 0;\\n\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (board[i][j] == \\'X\\') {\\n                    xCount++;\\n                    rows[i]++;\\n                    cols[j]++;\\n                    if (i == j) diagonal++;\\n                    if (i + j == 2) antiDiagonal++;\\n                } else if (board[i][j] == \\'O\\') {\\n                    oCount++;\\n                    rows[i]--;\\n                    cols[j]--;\\n                    if (i == j) diagonal--;\\n                    if (i + j == 2) antiDiagonal--;\\n                }\\n            }\\n        }\\n\\n        bool xWins = false, oWins = false;\\n        for (int i = 0; i < 3; i++) {\\n            if (rows[i] == 3 || cols[i] == 3) xWins = true;\\n            if (rows[i] == -3 || cols[i] == -3) oWins = true;\\n        }\\n        if (diagonal == 3 || antiDiagonal == 3) xWins = true;\\n        if (diagonal == -3 || antiDiagonal == -3) oWins = true;\\n\\n        if ((xWins && oWins) || (xCount != oCount && xCount != oCount + 1)) return false;\\n        if (xWins && xCount != oCount + 1) return false;\\n        if (oWins && xCount != oCount) return false;\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193963,
                "title": "python-comprehensive-solution",
                "content": "```\\nclass Solution:\\n    def validTicTacToe(self, B: list[str]) -> bool:\\n        def rows(t):\\n            res = 0\\n            for i in range(n):\\n                c = 0\\n                for j in range(n):\\n                    c += B[i][j] == t\\n                res += c == n\\n            return res\\n\\n        def cols(t):\\n            res = 0\\n            for j in range(n):\\n                c = 0\\n                for i in range(n):\\n                    c += B[i][j] == t\\n                res += c == n\\n            return res\\n\\n        def diag(t):\\n            c1 = 0\\n            for i in range(n):\\n                c1 += B[i][i] == t\\n\\n            c2 = 0\\n            for i in range(n):\\n                c2 += B[i][-i - 1] == t\\n\\n            return int(c1 == n) + int(c2 == n)\\n\\n        n = 3\\n        o_cnt, x_cnt = 0, 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if B[i][j] == \"X\":\\n                    x_cnt += 1\\n                elif B[i][j] == \"O\":\\n                    o_cnt += 1\\n\\n        o_rows = rows(\"O\")\\n        o_cols = cols(\"O\")\\n        o_diag = diag(\"O\")\\n\\n        x_rows = rows(\"X\")\\n        x_cols = cols(\"X\")\\n        x_diag = diag(\"X\")\\n\\n        # multiple wins for either X or O\\n        if o_rows > 1 or o_cols > 1 or x_rows > 1 or x_cols > 1:\\n            return False\\n\\n        o_wins = o_rows + o_cols + o_diag > 0\\n        x_wins = x_rows + x_cols + x_diag > 0\\n\\n        # both X and O are winners\\n        if o_wins and x_wins:\\n            return False\\n\\n        # invalid number of X and O\\n        if o_wins and o_cnt != x_cnt or x_wins and o_cnt != x_cnt - 1 or o_cnt > x_cnt or o_cnt < x_cnt - 1:\\n            return False\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, B: list[str]) -> bool:\\n        def rows(t):\\n            res = 0\\n            for i in range(n):\\n                c = 0\\n                for j in range(n):\\n                    c += B[i][j] == t\\n                res += c == n\\n            return res\\n\\n        def cols(t):\\n            res = 0\\n            for j in range(n):\\n                c = 0\\n                for i in range(n):\\n                    c += B[i][j] == t\\n                res += c == n\\n            return res\\n\\n        def diag(t):\\n            c1 = 0\\n            for i in range(n):\\n                c1 += B[i][i] == t\\n\\n            c2 = 0\\n            for i in range(n):\\n                c2 += B[i][-i - 1] == t\\n\\n            return int(c1 == n) + int(c2 == n)\\n\\n        n = 3\\n        o_cnt, x_cnt = 0, 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if B[i][j] == \"X\":\\n                    x_cnt += 1\\n                elif B[i][j] == \"O\":\\n                    o_cnt += 1\\n\\n        o_rows = rows(\"O\")\\n        o_cols = cols(\"O\")\\n        o_diag = diag(\"O\")\\n\\n        x_rows = rows(\"X\")\\n        x_cols = cols(\"X\")\\n        x_diag = diag(\"X\")\\n\\n        # multiple wins for either X or O\\n        if o_rows > 1 or o_cols > 1 or x_rows > 1 or x_cols > 1:\\n            return False\\n\\n        o_wins = o_rows + o_cols + o_diag > 0\\n        x_wins = x_rows + x_cols + x_diag > 0\\n\\n        # both X and O are winners\\n        if o_wins and x_wins:\\n            return False\\n\\n        # invalid number of X and O\\n        if o_wins and o_cnt != x_cnt or x_wins and o_cnt != x_cnt - 1 or o_cnt > x_cnt or o_cnt < x_cnt - 1:\\n            return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186339,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// T: O(3*3) | S: O(1)\\nvar validTicTacToe = function(board) {\\n    let Os = 0;\\n    let Xs = 0;\\n    let XWon = false;\\n    let OWon = false;\\n    // loop normal and check rows while getting a count of totals\\n    for (let row of board) {\\n        if (row === \\'XXX\\') XWon = true;\\n        if (row === \\'OOO\\') OWon = true;\\n        for (let char of row) {\\n            if (char === \\'O\\') Os++;\\n            if (char === \\'X\\') Xs++;\\n        }\\n    }\\n    // check vertical lines\\n    for (let i = 0; i < 3; i++) {\\n        let str = \\'\\'\\n        for (let j = 0; j < 3; j++) {\\n            str += board[j][i];\\n        }\\n        if (str === \\'XXX\\') XWon = true;\\n        if (str === \\'OOO\\') OWon = true;\\n    }\\n    // check diagonals\\n    const diag1 = board[0][0] + board[1][1] + board[2][2];\\n    const diag2 = board[0][2] + board[1][1] + board[2][0];\\n    if (diag1 === \\'XXX\\' || diag2 === \\'XXX\\') XWon = true;\\n    if (diag1 === \\'OOO\\' || diag2 === \\'OOO\\') OWon = true;\\n\\n    if (Os > Xs) return false; // X plays first\\n    if (Xs > Os + 1) return false; // Double play by X\\n    if (XWon && Xs === Os) return false; // O played after X already won\\n    if (OWon && Xs > Os) return false; // X played after O already won\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(3*3) | S: O(1)\\nvar validTicTacToe = function(board) {\\n    let Os = 0;\\n    let Xs = 0;\\n    let XWon = false;\\n    let OWon = false;\\n    // loop normal and check rows while getting a count of totals\\n    for (let row of board) {\\n        if (row === \\'XXX\\') XWon = true;\\n        if (row === \\'OOO\\') OWon = true;\\n        for (let char of row) {\\n            if (char === \\'O\\') Os++;\\n            if (char === \\'X\\') Xs++;\\n        }\\n    }\\n    // check vertical lines\\n    for (let i = 0; i < 3; i++) {\\n        let str = \\'\\'\\n        for (let j = 0; j < 3; j++) {\\n            str += board[j][i];\\n        }\\n        if (str === \\'XXX\\') XWon = true;\\n        if (str === \\'OOO\\') OWon = true;\\n    }\\n    // check diagonals\\n    const diag1 = board[0][0] + board[1][1] + board[2][2];\\n    const diag2 = board[0][2] + board[1][1] + board[2][0];\\n    if (diag1 === \\'XXX\\' || diag2 === \\'XXX\\') XWon = true;\\n    if (diag1 === \\'OOO\\' || diag2 === \\'OOO\\') OWon = true;\\n\\n    if (Os > Xs) return false; // X plays first\\n    if (Xs > Os + 1) return false; // Double play by X\\n    if (XWon && Xs === Os) return false; // O played after X already won\\n    if (OWon && Xs > Os) return false; // X played after O already won\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3185555,
                "title": "c-solution-95-ms-the-ugliest-solution-you-ll-find",
                "content": "# Approach\\nFail. Add new if statement for failed test case.\\n*(Repeat 11 times.)*\\n\\nI hated this problem and just wanted to vent.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ValidTicTacToe(string[] board) {\\n        var countX = 0;\\n        var countO = 0;\\n        var xRowWins = 0;\\n        var oRowWins = 0;\\n        var xColWins = 0;\\n        var oColWins = 0;\\n\\n        foreach (var row in board)\\n        {\\n            if (row.Length != 3)\\n                return false;\\n\\n            if (row == \"XXX\")\\n                xRowWins++;\\n            else if (row == \"OOO\")\\n                oRowWins++;\\n\\n            foreach (var c in row)\\n            {\\n                if (c == \\'X\\')\\n                    countX++;\\n                else if (c == \\'O\\')\\n                    countO++;\\n            }\\n        }\\n\\n        if (xRowWins > 1 || oRowWins > 1)\\n            return false;\\n        if (xRowWins == 1 && oRowWins == 1)\\n            return false;\\n\\n        for (int c = 0; c < 3; c++)\\n        {\\n            if (board[0][c] == board[1][c] && board[1][c] == board[2][c])\\n            {\\n                if (board[0][c] == \\'X\\')\\n                    xColWins++;\\n                else if (board[0][c] == \\'O\\')\\n                    oColWins++;\\n            }\\n        }\\n\\n        var xDiagWins = 0;\\n        var oDiagWins = 0;\\n        if (board[0][0] == board[1][1] && board[1][1] == board[2][2])\\n        {\\n            if (board[0][0] == \\'X\\')\\n                xDiagWins++;\\n            else if (board[0][0] == \\'O\\')\\n                oDiagWins++;\\n        }\\n        if (board[0][2] == board[1][1] && board[1][1] == board[2][0])\\n        {\\n            if (board[0][2] == \\'X\\')\\n                xDiagWins++;\\n            else if (board[0][2] == \\'O\\')\\n                oDiagWins++;\\n        }\\n\\n        if (xColWins > 1 || oColWins > 1)\\n            return false;\\n        if (xColWins == 1 && oColWins == 1)\\n            return false;\\n\\n        if (countO > countX || countX - countO > 1)\\n            return false;\\n\\n        if (oColWins + oRowWins + oDiagWins > 0 && countX > countO)\\n            return false;\\n\\n        if (countX == countO && (xRowWins + xColWins + xDiagWins > 0))\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ValidTicTacToe(string[] board) {\\n        var countX = 0;\\n        var countO = 0;\\n        var xRowWins = 0;\\n        var oRowWins = 0;\\n        var xColWins = 0;\\n        var oColWins = 0;\\n\\n        foreach (var row in board)\\n        {\\n            if (row.Length != 3)\\n                return false;\\n\\n            if (row == \"XXX\")\\n                xRowWins++;\\n            else if (row == \"OOO\")\\n                oRowWins++;\\n\\n            foreach (var c in row)\\n            {\\n                if (c == \\'X\\')\\n                    countX++;\\n                else if (c == \\'O\\')\\n                    countO++;\\n            }\\n        }\\n\\n        if (xRowWins > 1 || oRowWins > 1)\\n            return false;\\n        if (xRowWins == 1 && oRowWins == 1)\\n            return false;\\n\\n        for (int c = 0; c < 3; c++)\\n        {\\n            if (board[0][c] == board[1][c] && board[1][c] == board[2][c])\\n            {\\n                if (board[0][c] == \\'X\\')\\n                    xColWins++;\\n                else if (board[0][c] == \\'O\\')\\n                    oColWins++;\\n            }\\n        }\\n\\n        var xDiagWins = 0;\\n        var oDiagWins = 0;\\n        if (board[0][0] == board[1][1] && board[1][1] == board[2][2])\\n        {\\n            if (board[0][0] == \\'X\\')\\n                xDiagWins++;\\n            else if (board[0][0] == \\'O\\')\\n                oDiagWins++;\\n        }\\n        if (board[0][2] == board[1][1] && board[1][1] == board[2][0])\\n        {\\n            if (board[0][2] == \\'X\\')\\n                xDiagWins++;\\n            else if (board[0][2] == \\'O\\')\\n                oDiagWins++;\\n        }\\n\\n        if (xColWins > 1 || oColWins > 1)\\n            return false;\\n        if (xColWins == 1 && oColWins == 1)\\n            return false;\\n\\n        if (countO > countX || countX - countO > 1)\\n            return false;\\n\\n        if (oColWins + oRowWins + oDiagWins > 0 && countX > countO)\\n            return false;\\n\\n        if (countX == countO && (xRowWins + xColWins + xDiagWins > 0))\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173058,
                "title": "100-faster-0ms-java-approach-90-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int vm = validMoves(board);\\n        //System.out.println(vm);\\n        if(vm==-5)return false;\\n        if(vm==0){\\n        int xC = getTrioX(board,\\'X\\');\\n        int oC = getTrioX(board,\\'O\\');\\n        if(xC==0&&oC==0)return true;\\n        if(xC==0&&oC>=1)return true;\\n        }\\n        else if(vm == -1 ){\\n        int xC = getTrioX(board,\\'X\\');\\n        int oC = getTrioX(board,\\'O\\');\\n        if(xC==0&&oC==0)return true;\\n        if(xC>=1&&oC==0)return true;\\n        \\n        }\\n        return false ;\\n    }\\n    int getTrioX(String[]board,char c){\\n        int ans =  0; \\n        //virticle\\n        for(int  i = 0 ; i < 3; i ++ ){\\n            if(board[0].charAt(i)==c&&board[1].charAt(i)==c&&board[2].charAt(i)==c){\\n                ans++;\\n            }\\n        }\\n        for(int  i = 0 ; i < 3; i ++ ){\\n            if(board[i].charAt(0)==c&&board[i].charAt(1)==c&&board[i].charAt(2)==c){\\n                ans++;\\n            }\\n        }\\n\\n        if(board[0].charAt(0)==c&&board[1].charAt(1)==c&&board[2].charAt(2)==c){\\n                ans++;\\n            }\\n        if(board[0].charAt(2)==c&&board[1].charAt(1)==c&&board[2].charAt(0)==c){\\n                ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    int validMoves(String[]board){\\n        int xCount = 4;\\n        int oCount = 4;\\n        for(String s : board){\\n            for(int i = 0 ; i < board.length ; i ++){\\n                if(s.charAt(i)==\\'X\\'){xCount--;}\\n                else if(s.charAt(i)==\\'O\\'){oCount--;}\\n            }\\n        }\\n        return (xCount==oCount)||(xCount+1==oCount)?xCount-oCount:-5;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int vm = validMoves(board);\\n        //System.out.println(vm);\\n        if(vm==-5)return false;\\n        if(vm==0){\\n        int xC = getTrioX(board,\\'X\\');\\n        int oC = getTrioX(board,\\'O\\');\\n        if(xC==0&&oC==0)return true;\\n        if(xC==0&&oC>=1)return true;\\n        }\\n        else if(vm == -1 ){\\n        int xC = getTrioX(board,\\'X\\');\\n        int oC = getTrioX(board,\\'O\\');\\n        if(xC==0&&oC==0)return true;\\n        if(xC>=1&&oC==0)return true;\\n        \\n        }\\n        return false ;\\n    }\\n    int getTrioX(String[]board,char c){\\n        int ans =  0; \\n        //virticle\\n        for(int  i = 0 ; i < 3; i ++ ){\\n            if(board[0].charAt(i)==c&&board[1].charAt(i)==c&&board[2].charAt(i)==c){\\n                ans++;\\n            }\\n        }\\n        for(int  i = 0 ; i < 3; i ++ ){\\n            if(board[i].charAt(0)==c&&board[i].charAt(1)==c&&board[i].charAt(2)==c){\\n                ans++;\\n            }\\n        }\\n\\n        if(board[0].charAt(0)==c&&board[1].charAt(1)==c&&board[2].charAt(2)==c){\\n                ans++;\\n            }\\n        if(board[0].charAt(2)==c&&board[1].charAt(1)==c&&board[2].charAt(0)==c){\\n                ans++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    int validMoves(String[]board){\\n        int xCount = 4;\\n        int oCount = 4;\\n        for(String s : board){\\n            for(int i = 0 ; i < board.length ; i ++){\\n                if(s.charAt(i)==\\'X\\'){xCount--;}\\n                else if(s.charAt(i)==\\'O\\'){oCount--;}\\n            }\\n        }\\n        return (xCount==oCount)||(xCount+1==oCount)?xCount-oCount:-5;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164847,
                "title": "valid-tic-tac-toe-state-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        xC,oC = 0,0\\n        for row in board:\\n            for ele in row:\\n                if ele == \\'X\\': xC += 1 \\n                if ele == \\'O\\': oC += 1\\n                    \\n        def checkCount(xC,oC):\\n            if (xC >= 0) and (oC >= 0) and  ((xC - oC == 1) or (xC - oC == 0)) and xC <= 5:\\n                return True\\n        \\n        def checkWin(board):\\n            x_list = [0]*8\\n            o_list = [0]*8\\n            for r in range(len(board)):\\n                for c in range(len(board[0])):\\n                    if board[r][c] == \\'X\\':\\n                        x_list[r] += 1\\n                        x_list[c+3] += 1\\n                        if abs(r-c) == 0:\\n                            x_list[6] += 1\\n                        if abs(r+c) == 2:\\n                            x_list[7] += 1\\n                        if 3 in x_list: return(\\'X\\')\\n\\n                    elif board[r][c] == \\'O\\':\\n                        o_list[r] += 1\\n                        o_list[c+3] += 1\\n                        if abs(r-c) == 0:\\n                            o_list[6] += 1\\n                        if abs(r+c) == 2:\\n                            o_list[7] += 1  \\n                        if 3 in o_list: return(\\'O\\')\\n\\n            print(\\'x_list: \\', x_list)\\n            print(\\'o_list: \\', o_list)\\n            return(None)\\n                    \\n        res = checkWin(board)\\n        \\n        if res == None:   # no winner\\n            pass\\n        elif res == \\'X\\':    # x won, xC must be 1 more than oC\\n            if xC <= oC:\\n                return False       \\n        elif res == \\'O\\':    # o won, xC must equal oC\\n            if xC > oC:\\n                return False\\n             \\n        if not checkCount(xC,oC):  # if number of x\\'s and o\\'s is not attainable\\n            return False\\n            \\n        return True       # board is valid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        xC,oC = 0,0\\n        for row in board:\\n            for ele in row:\\n                if ele == \\'X\\': xC += 1 \\n                if ele == \\'O\\': oC += 1\\n                    \\n        def checkCount(xC,oC):\\n            if (xC >= 0) and (oC >= 0) and  ((xC - oC == 1) or (xC - oC == 0)) and xC <= 5:\\n                return True\\n        \\n        def checkWin(board):\\n            x_list = [0]*8\\n            o_list = [0]*8\\n            for r in range(len(board)):\\n                for c in range(len(board[0])):\\n                    if board[r][c] == \\'X\\':\\n                        x_list[r] += 1\\n                        x_list[c+3] += 1\\n                        if abs(r-c) == 0:\\n                            x_list[6] += 1\\n                        if abs(r+c) == 2:\\n                            x_list[7] += 1\\n                        if 3 in x_list: return(\\'X\\')\\n\\n                    elif board[r][c] == \\'O\\':\\n                        o_list[r] += 1\\n                        o_list[c+3] += 1\\n                        if abs(r-c) == 0:\\n                            o_list[6] += 1\\n                        if abs(r+c) == 2:\\n                            o_list[7] += 1  \\n                        if 3 in o_list: return(\\'O\\')\\n\\n            print(\\'x_list: \\', x_list)\\n            print(\\'o_list: \\', o_list)\\n            return(None)\\n                    \\n        res = checkWin(board)\\n        \\n        if res == None:   # no winner\\n            pass\\n        elif res == \\'X\\':    # x won, xC must be 1 more than oC\\n            if xC <= oC:\\n                return False       \\n        elif res == \\'O\\':    # o won, xC must equal oC\\n            if xC > oC:\\n                return False\\n             \\n        if not checkCount(xC,oC):  # if number of x\\'s and o\\'s is not attainable\\n            return False\\n            \\n        return True       # board is valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162122,
                "title": "java-solution-without-explanation",
                "content": "# Intuition\\nGeneric solution without predefined board size.\\nI am not good at explaining my reasoning, please try to understand by yourself\\n\\n# Approach\\nsimilar to solution of https://leetcode.com/problems/design-tic-tac-toe/solutions/1171185/design-tic-tac-toe/\\n![image.png](https://assets.leetcode.com/users/images/9d74b8b2-6c76-4c6a-b020-99e7e95e8a75_1675894001.5433462.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        int countX = 0, countO = 0;\\n        int[] row = new int[board.length], \\n              col = new int[board.length];\\n        int diagonal = 0, antiDiagonal = 0;\\n\\n        int index = 0;\\n        for(String s : board){\\n            int colNum = 0;\\n            for(char ch : s.toCharArray()){\\n                if(ch == \\' \\') \\n                {  colNum++; continue;}\\n\\n                if(ch == \\'X\\'){\\n                    countX++;\\n                    row[index]++;\\n                    col[colNum]++;\\n                    \\n                }\\n                else {\\n                    countO++;\\n                    row[index]--;\\n                    col[colNum]--;\\n                }\\n\\n                if(index == colNum) \\n                    diagonal = ch == \\'X\\'? diagonal+1:diagonal-1;\\n                if(index + colNum == (board.length -1)) \\n                    antiDiagonal = ch == \\'X\\'? antiDiagonal+1:antiDiagonal-1;\\n\\n\\n                colNum++;\\n            }\\n            index++;\\n        }\\n\\n        if( win(1, row, col, diagonal, antiDiagonal) && countX <= countO\\n            || win(-1, row, col, diagonal, antiDiagonal) && countX != countO\\n            || countX < countO\\n            || countX > countO+1)\\n                 return false;\\n\\n        return true;\\n    }\\n\\n    boolean win(int player, int[] row, int[] col, int diagonal, int antiDiagonal ){\\n         int count = row.length;\\n         count *= player;\\n         \\n         for(int r : row)\\n            if(r == count) return true;\\n        \\n         for(int c : col)\\n            if(c == count) return true;\\n         \\n         if(diagonal == count || antiDiagonal == count) return true;\\n\\n         return false;\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        int countX = 0, countO = 0;\\n        int[] row = new int[board.length], \\n              col = new int[board.length];\\n        int diagonal = 0, antiDiagonal = 0;\\n\\n        int index = 0;\\n        for(String s : board){\\n            int colNum = 0;\\n            for(char ch : s.toCharArray()){\\n                if(ch == \\' \\') \\n                {  colNum++; continue;}\\n\\n                if(ch == \\'X\\'){\\n                    countX++;\\n                    row[index]++;\\n                    col[colNum]++;\\n                    \\n                }\\n                else {\\n                    countO++;\\n                    row[index]--;\\n                    col[colNum]--;\\n                }\\n\\n                if(index == colNum) \\n                    diagonal = ch == \\'X\\'? diagonal+1:diagonal-1;\\n                if(index + colNum == (board.length -1)) \\n                    antiDiagonal = ch == \\'X\\'? antiDiagonal+1:antiDiagonal-1;\\n\\n\\n                colNum++;\\n            }\\n            index++;\\n        }\\n\\n        if( win(1, row, col, diagonal, antiDiagonal) && countX <= countO\\n            || win(-1, row, col, diagonal, antiDiagonal) && countX != countO\\n            || countX < countO\\n            || countX > countO+1)\\n                 return false;\\n\\n        return true;\\n    }\\n\\n    boolean win(int player, int[] row, int[] col, int diagonal, int antiDiagonal ){\\n         int count = row.length;\\n         count *= player;\\n         \\n         for(int r : row)\\n            if(r == count) return true;\\n        \\n         for(int c : col)\\n            if(c == count) return true;\\n         \\n         if(diagonal == count || antiDiagonal == count) return true;\\n\\n         return false;\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140381,
                "title": "python3-solution-beats-99-66",
                "content": "![tic tac toe 99.66.PNG](https://assets.leetcode.com/users/images/8a83d0cd-6d58-4b5b-8387-157cff3af4b5_1675507643.2313235.png)\\n\\n**Python3 Solution**\\n# Code\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        a=\"\".join(board)\\n        x=0\\n        o=0\\n        for i in a:\\n            if i==\"X\":\\n                x+=1\\n            elif i==\"O\":\\n                o+=1\\n        if abs(x-o)<=1 and x>=1 and x>=o:\\n            mat=[[i for i in board[0]],[i for i in board[1]],[i for i in board[2]]]\\n\\n            def find(s):\\n                count=0\\n                if mat[0][0]+mat[0][1]+mat[0][2]==s:\\n                    count+=1\\n                if mat[0][0]+mat[1][0]+mat[2][0]==s:\\n                    count+=1\\n                if mat[2][0]+mat[2][1]+mat[2][2]==s:\\n                    count+=1\\n                if mat[2][2]+mat[1][2]+mat[0][2]==s:\\n                    count+=1\\n                if mat[0][0]+mat[1][1]+mat[2][2]==s:\\n                    count+=1\\n                if mat[1][0]+mat[1][1]+mat[1][2]==s:\\n                    count+=1\\n                if mat[0][2]+mat[1][1]+mat[2][0]==s:\\n                    count+=1\\n                \\n                return count\\n                    \\n            s1=find(\"XXX\")\\n            s2=find(\"OOO\")\\n            \\n            if s1>=1 and s2>=1:\\n                return False\\n            elif s2==0 and s1>=1 and abs(x-o)==1:\\n                return True\\n            elif s1==0 and s2>=1 and abs(x-o)==0:\\n                return True\\n            elif (abs(x-o)<=1 and x>=1 and s1==0 and s2==0 and x>=o):\\n                return True\\n            else:\\n                return False          \\n        elif x+o==0:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        a=\"\".join(board)\\n        x=0\\n        o=0\\n        for i in a:\\n            if i==\"X\":\\n                x+=1\\n            elif i==\"O\":\\n                o+=1\\n        if abs(x-o)<=1 and x>=1 and x>=o:\\n            mat=[[i for i in board[0]],[i for i in board[1]],[i for i in board[2]]]\\n\\n            def find(s):\\n                count=0\\n                if mat[0][0]+mat[0][1]+mat[0][2]==s:\\n                    count+=1\\n                if mat[0][0]+mat[1][0]+mat[2][0]==s:\\n                    count+=1\\n                if mat[2][0]+mat[2][1]+mat[2][2]==s:\\n                    count+=1\\n                if mat[2][2]+mat[1][2]+mat[0][2]==s:\\n                    count+=1\\n                if mat[0][0]+mat[1][1]+mat[2][2]==s:\\n                    count+=1\\n                if mat[1][0]+mat[1][1]+mat[1][2]==s:\\n                    count+=1\\n                if mat[0][2]+mat[1][1]+mat[2][0]==s:\\n                    count+=1\\n                \\n                return count\\n                    \\n            s1=find(\"XXX\")\\n            s2=find(\"OOO\")\\n            \\n            if s1>=1 and s2>=1:\\n                return False\\n            elif s2==0 and s1>=1 and abs(x-o)==1:\\n                return True\\n            elif s1==0 and s2>=1 and abs(x-o)==0:\\n                return True\\n            elif (abs(x-o)<=1 and x>=1 and s1==0 and s2==0 and x>=o):\\n                return True\\n            else:\\n                return False          \\n        elif x+o==0:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111143,
                "title": "explained-and-commented-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n// solved using only one iteration over board\\nbool validTicTacToe(vector<string>& board) {\\n    bool wony = false, wonx = false;\\n    int rows = board.size();\\n    int cols = rows ? board[0].size() : 0;\\n    int diax = 0, diay = 0, xdiax = 0, xdiay = 0, x_count = 0, y_count = 0;\\n    \\n    for(int i = 0; i < rows; i++) {\\n        int rowsx = 0, rowsy = 0;\\n        int colsx = 0, colsy = 0;\\n        for(int j = 0; j < cols; j++) {\\n            // see current row\\n            if(board[i][j] == \\'X\\')\\n                rowsx++,x_count++;\\n            if(board[i][j] == \\'O\\')\\n                rowsy++, y_count++;\\n            // see ith column\\n            if(board[j][i] == \\'X\\')\\n                colsx++;\\n            if (board[j][i] == \\'O\\')\\n                colsy++;\\n        }\\n        \\n        // see both the diagonals\\n        if(board[i][i] == \\'X\\')\\n            diax++;\\n        if(board[i][i] == \\'O\\')\\n            diay++;\\n        if(board[i][cols - 1 - i] == \\'X\\')\\n            xdiax++;\\n        if(board[i][cols - 1 - i] == \\'O\\')\\n            xdiay++;\\n        \\n        if(rowsx == 3 || colsx == 3 || diax == 3 || xdiax == 3)\\n            wonx = true;\\n        \\n         if(rowsy == 3 || colsy == 3 || diay == 3 || xdiay == 3)\\n            wony = true;\\n    }\\n    \\n    if(!(x_count == y_count || x_count == y_count + 1))\\n        return false;\\n    \\n    if((wonx && wony) || (wonx && x_count == y_count) || (wony && x_count != y_count))\\n        return false;\\n    \\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// solved using only one iteration over board\\nbool validTicTacToe(vector<string>& board) {\\n    bool wony = false, wonx = false;\\n    int rows = board.size();\\n    int cols = rows ? board[0].size() : 0;\\n    int diax = 0, diay = 0, xdiax = 0, xdiay = 0, x_count = 0, y_count = 0;\\n    \\n    for(int i = 0; i < rows; i++) {\\n        int rowsx = 0, rowsy = 0;\\n        int colsx = 0, colsy = 0;\\n        for(int j = 0; j < cols; j++) {\\n            // see current row\\n            if(board[i][j] == \\'X\\')\\n                rowsx++,x_count++;\\n            if(board[i][j] == \\'O\\')\\n                rowsy++, y_count++;\\n            // see ith column\\n            if(board[j][i] == \\'X\\')\\n                colsx++;\\n            if (board[j][i] == \\'O\\')\\n                colsy++;\\n        }\\n        \\n        // see both the diagonals\\n        if(board[i][i] == \\'X\\')\\n            diax++;\\n        if(board[i][i] == \\'O\\')\\n            diay++;\\n        if(board[i][cols - 1 - i] == \\'X\\')\\n            xdiax++;\\n        if(board[i][cols - 1 - i] == \\'O\\')\\n            xdiay++;\\n        \\n        if(rowsx == 3 || colsx == 3 || diax == 3 || xdiax == 3)\\n            wonx = true;\\n        \\n         if(rowsy == 3 || colsy == 3 || diay == 3 || xdiay == 3)\\n            wony = true;\\n    }\\n    \\n    if(!(x_count == y_count || x_count == y_count + 1))\\n        return false;\\n    \\n    if((wonx && wony) || (wonx && x_count == y_count) || (wony && x_count != y_count))\\n        return false;\\n    \\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089969,
                "title": "not-an-easy-or-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static boolean winForO;\\n\\n    public static boolean winForX;\\n\\n    public boolean validTicTacToe(String[] board) {\\n        winForO = false;\\n        winForX = false;\\n        int countOs = 0;\\n        int countXs = 0;\\n        for(String str : board){\\n            for(char ch : str.toCharArray()){\\n                if(ch == \\'O\\') countOs++;\\n                if(ch == \\'X\\') countXs++;\\n            }\\n        }\\n        if(countOs > countXs || countXs > countOs + 1) return false;\\n        if(!validWin(board)) return false;\\n        if(countXs > countOs && winForO) return false;\\n        if(countOs == countXs && winForX) return false;\\n        return true;\\n    }\\n\\n    public boolean validWin(String[] board){\\n        if(isWin(board[0]) && isWin(board[1]) || isWin(board[0]) && isWin(board[2]) ||\\n        isWin(board[1]) && isWin(board[2])) return false;\\n        List<String> verticals = new ArrayList<>();\\n        for(int i = 0;i < 3;i++){\\n            String vertical = \"\";\\n            for(int j = 0;j < 3;j++){\\n                vertical += board[j].charAt(i);\\n            }\\n            verticals.add(vertical);\\n        }\\n\\n        if(isWin(verticals.get(0)) && isWin(verticals.get(1)) || isWin(verticals.get(0)) && isWin(verticals.get(2)) ||\\n        isWin(verticals.get(1)) && isWin(verticals.get(2))) return false;\\n\\n        String diagonal = \"\" + board[0].charAt(0) + board[1].charAt(1) + board[2].charAt(2);\\n        isWin(diagonal);\\n        diagonal = \"\" + board[2].charAt(0) + board[1].charAt(1) + board[0].charAt(2);\\n        isWin(diagonal);\\n        return true;\\n    }\\n\\n    public boolean isWin(String str){\\n        if(str.equals(\"XXX\")){\\n            winForX = true;\\n            return true;\\n        }\\n        if(str.equals(\"OOO\")){\\n            winForO = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static boolean winForO;\\n\\n    public static boolean winForX;\\n\\n    public boolean validTicTacToe(String[] board) {\\n        winForO = false;\\n        winForX = false;\\n        int countOs = 0;\\n        int countXs = 0;\\n        for(String str : board){\\n            for(char ch : str.toCharArray()){\\n                if(ch == \\'O\\') countOs++;\\n                if(ch == \\'X\\') countXs++;\\n            }\\n        }\\n        if(countOs > countXs || countXs > countOs + 1) return false;\\n        if(!validWin(board)) return false;\\n        if(countXs > countOs && winForO) return false;\\n        if(countOs == countXs && winForX) return false;\\n        return true;\\n    }\\n\\n    public boolean validWin(String[] board){\\n        if(isWin(board[0]) && isWin(board[1]) || isWin(board[0]) && isWin(board[2]) ||\\n        isWin(board[1]) && isWin(board[2])) return false;\\n        List<String> verticals = new ArrayList<>();\\n        for(int i = 0;i < 3;i++){\\n            String vertical = \"\";\\n            for(int j = 0;j < 3;j++){\\n                vertical += board[j].charAt(i);\\n            }\\n            verticals.add(vertical);\\n        }\\n\\n        if(isWin(verticals.get(0)) && isWin(verticals.get(1)) || isWin(verticals.get(0)) && isWin(verticals.get(2)) ||\\n        isWin(verticals.get(1)) && isWin(verticals.get(2))) return false;\\n\\n        String diagonal = \"\" + board[0].charAt(0) + board[1].charAt(1) + board[2].charAt(2);\\n        isWin(diagonal);\\n        diagonal = \"\" + board[2].charAt(0) + board[1].charAt(1) + board[0].charAt(2);\\n        isWin(diagonal);\\n        return true;\\n    }\\n\\n    public boolean isWin(String str){\\n        if(str.equals(\"XXX\")){\\n            winForX = true;\\n            return true;\\n        }\\n        if(str.equals(\"OOO\")){\\n            winForO = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066450,
                "title": "java-one-pass-bitmask-easy-to-follow",
                "content": "# Intuition\\n\\nThere are two main concepts\\n* Players place symbols in rotation, but `X` goes first.\\n* There is only one winner in a game.\\n\\n# Approach\\n1. Create an additional class `PlayerState` for tracking the count and winning state of a player.\\n2. Update the state of each player through iteration over board cells.\\n    * Increment count\\n    * Mark the coverage of cells in any row, cell, or diagonal. Use bitmask for it. If all bits are set player has won.\\n3. Define depends on the states correctness of the board\\n    * Count of `X` is greater or equal to the count of `O`, but the difference can not exceed 1 \\n        > Players place symbols in rotation, but `X` goes first\\n    * There is only one winner\\n\\n# Complexity\\n- Time complexity:\\nO(`BOARD_SIZE^2`) => O(1)\\n\\n- Space complexity:\\nO(`BOARD_SIZE`) => O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int BOARD_SIZE = 3;\\n\\n    static boolean validTicTacToe(String[] board) {\\n        final PlayerState xState = new PlayerState();\\n        final PlayerState oState = new PlayerState();\\n        for (int i = 0; i < BOARD_SIZE; i++) {\\n            String row = board[i];\\n            for (int j = 0; j < BOARD_SIZE; j++) {\\n                char c = row.charAt(j);\\n                if (c == \\'X\\') {\\n                    xState.update(i, j);\\n                }\\n                if (c == \\'O\\') {\\n                    oState.update(i, j);\\n                }\\n            }\\n        }\\n        if (Math.abs(xState.count - oState.count) > 1) {\\n            return false;\\n        }\\n        boolean xWon = xState.isWon();\\n        boolean oWon = oState.isWon();\\n        if (xWon) {\\n            return xState.count > oState.count && !oWon;\\n        }\\n        if (oWon) {\\n            return xState.count == oState.count;\\n        }\\n        return xState.count >= oState.count;\\n    }\\n\\n\\n    private static class PlayerState {\\n        private static final int IS_COVERED = (1 << BOARD_SIZE) - 1;\\n        private final int[] rowCov = new int[BOARD_SIZE];\\n        private final int[] colCov = new int[BOARD_SIZE];\\n        private int mainDiagCov = 0;\\n        private int secondDiagCov = 0;\\n        private int count = 0;\\n\\n        void update(int i, int j) {\\n            count++;\\n            rowCov[j] |= (1 << i);\\n            colCov[i] |= (1 << j);\\n            if (i == j) {\\n                mainDiagCov |= (1 << i);\\n            }\\n            if (i == BOARD_SIZE - j - 1) {\\n                secondDiagCov |= (1 << i);\\n            }\\n        }\\n\\n        boolean isWon() {\\n            return isCovered(mainDiagCov) || isCovered(secondDiagCov)\\n                    || isCoveredAny(rowCov) || isCoveredAny(colCov);\\n        }\\n\\n        private static boolean isCovered(int cov) {\\n            return IS_COVERED == cov;\\n        }\\n\\n        private static boolean isCoveredAny(int[] covArr) {\\n            for (int cov : covArr) {\\n                if (isCovered(cov)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int BOARD_SIZE = 3;\\n\\n    static boolean validTicTacToe(String[] board) {\\n        final PlayerState xState = new PlayerState();\\n        final PlayerState oState = new PlayerState();\\n        for (int i = 0; i < BOARD_SIZE; i++) {\\n            String row = board[i];\\n            for (int j = 0; j < BOARD_SIZE; j++) {\\n                char c = row.charAt(j);\\n                if (c == \\'X\\') {\\n                    xState.update(i, j);\\n                }\\n                if (c == \\'O\\') {\\n                    oState.update(i, j);\\n                }\\n            }\\n        }\\n        if (Math.abs(xState.count - oState.count) > 1) {\\n            return false;\\n        }\\n        boolean xWon = xState.isWon();\\n        boolean oWon = oState.isWon();\\n        if (xWon) {\\n            return xState.count > oState.count && !oWon;\\n        }\\n        if (oWon) {\\n            return xState.count == oState.count;\\n        }\\n        return xState.count >= oState.count;\\n    }\\n\\n\\n    private static class PlayerState {\\n        private static final int IS_COVERED = (1 << BOARD_SIZE) - 1;\\n        private final int[] rowCov = new int[BOARD_SIZE];\\n        private final int[] colCov = new int[BOARD_SIZE];\\n        private int mainDiagCov = 0;\\n        private int secondDiagCov = 0;\\n        private int count = 0;\\n\\n        void update(int i, int j) {\\n            count++;\\n            rowCov[j] |= (1 << i);\\n            colCov[i] |= (1 << j);\\n            if (i == j) {\\n                mainDiagCov |= (1 << i);\\n            }\\n            if (i == BOARD_SIZE - j - 1) {\\n                secondDiagCov |= (1 << i);\\n            }\\n        }\\n\\n        boolean isWon() {\\n            return isCovered(mainDiagCov) || isCovered(secondDiagCov)\\n                    || isCoveredAny(rowCov) || isCoveredAny(colCov);\\n        }\\n\\n        private static boolean isCovered(int cov) {\\n            return IS_COVERED == cov;\\n        }\\n\\n        private static boolean isCoveredAny(int[] covArr) {\\n            for (int cov : covArr) {\\n                if (isCovered(cov)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055319,
                "title": "100-fast-code-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n    int numO = 0, numX = 0;\\n    for (String s : board) {\\n        for (int i = 0; i < 3; i++) {\\n            if (s.charAt(i) == \\'X\\') numX++;\\n            if (s.charAt(i) == \\'O\\') numO++;\\n        }\\n    }\\n    if (numO > numX || numX > numO + 1 || numO > 5 || numX > 5) return false;\\n    boolean winX = false, winO = false;\\n    int[][] wins = {{0,1,2}, {3,4,5}, {6,7,8}, {0,3,6}, {1,4,7}, {2,5,8}, {0,4,8}, {2,4,6}};\\n    for (int[] win : wins) {\\n        char c1 = board[win[0]/3].charAt(win[0]%3);\\n        char c2 = board[win[1]/3].charAt(win[1]%3);\\n        char c3 = board[win[2]/3].charAt(win[2]%3);\\n        if(c1 == \\'X\\' && c2 == \\'X\\' && c3 == \\'X\\') winX = true;\\n        if(c1 == \\'O\\' && c2 == \\'O\\' && c3 == \\'O\\') winO = true;\\n    }\\n    if (winX && numX == numO) return false;\\n    if (winO && numX > numO) return false;\\n    return !(winX && winO);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n    int numO = 0, numX = 0;\\n    for (String s : board) {\\n        for (int i = 0; i < 3; i++) {\\n            if (s.charAt(i) == \\'X\\') numX++;\\n            if (s.charAt(i) == \\'O\\') numO++;\\n        }\\n    }\\n    if (numO > numX || numX > numO + 1 || numO > 5 || numX > 5) return false;\\n    boolean winX = false, winO = false;\\n    int[][] wins = {{0,1,2}, {3,4,5}, {6,7,8}, {0,3,6}, {1,4,7}, {2,5,8}, {0,4,8}, {2,4,6}};\\n    for (int[] win : wins) {\\n        char c1 = board[win[0]/3].charAt(win[0]%3);\\n        char c2 = board[win[1]/3].charAt(win[1]%3);\\n        char c3 = board[win[2]/3].charAt(win[2]%3);\\n        if(c1 == \\'X\\' && c2 == \\'X\\' && c3 == \\'X\\') winX = true;\\n        if(c1 == \\'O\\' && c2 == \\'O\\' && c3 == \\'O\\') winO = true;\\n    }\\n    if (winX && numX == numO) return false;\\n    if (winO && numX > numO) return false;\\n    return !(winX && winO);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976693,
                "title": "",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        X = 0\\n        O = 0\\n        for r in range(3):\\n            for c in range(3):\\n                if board[r][c] == \"X\":\\n                    X += 1\\n                elif board[r][c] == \"O\":\\n                    O += 1\\n        \\n        if O > X or O < X - 1:\\n            return False\\n\\n\\n        winner_X = False\\n        winner_O = False\\n        for r in range(3):\\n            if board[r] == \"XXX\":\\n                winner_X = True\\n            elif board[r] == \"OOO\":\\n                winner_O = True\\n\\n            if board[0][r] == board[1][r] == board[2][r] == \"X\":\\n                winner_X = True\\n            \\n            elif board[0][r] == board[1][r] == board[2][r] == \"O\":\\n                winner_O = True\\n\\n        if board[0][0] == board[1][1] == board[2][2] == \"X\":\\n            winner_X = True\\n\\n        elif board[0][0] == board[1][1] == board[2][2] == \"O\":\\n            winner_O = True\\n\\n        if board[0][2] == board[1][1] == board[2][0] == \"X\":\\n            winner_X = True\\n\\n        elif board[0][2] == board[1][1] == board[2][0] == \"O\":\\n            winner_O = True\\n\\n\\n            \\n        if winner_X == True and winner_O == True:\\n            return False\\n\\n        if winner_X == True and X == O:\\n            return False\\n        \\n        if winner_O == True and O < X:\\n            return False\\n\\n     \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        X = 0\\n        O = 0\\n        for r in range(3):\\n            for c in range(3):\\n                if board[r][c] == \"X\":\\n                    X += 1\\n                elif board[r][c] == \"O\":\\n                    O += 1\\n        \\n        if O > X or O < X - 1:\\n            return False\\n\\n\\n        winner_X = False\\n        winner_O = False\\n        for r in range(3):\\n            if board[r] == \"XXX\":\\n                winner_X = True\\n            elif board[r] == \"OOO\":\\n                winner_O = True\\n\\n            if board[0][r] == board[1][r] == board[2][r] == \"X\":\\n                winner_X = True\\n            \\n            elif board[0][r] == board[1][r] == board[2][r] == \"O\":\\n                winner_O = True\\n\\n        if board[0][0] == board[1][1] == board[2][2] == \"X\":\\n            winner_X = True\\n\\n        elif board[0][0] == board[1][1] == board[2][2] == \"O\":\\n            winner_O = True\\n\\n        if board[0][2] == board[1][1] == board[2][0] == \"X\":\\n            winner_X = True\\n\\n        elif board[0][2] == board[1][1] == board[2][0] == \"O\":\\n            winner_O = True\\n\\n\\n            \\n        if winner_X == True and winner_O == True:\\n            return False\\n\\n        if winner_X == True and X == O:\\n            return False\\n        \\n        if winner_O == True and O < X:\\n            return False\\n\\n     \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918133,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn valid_tic_tac_toe(board: Vec<String>) -> bool {\\n        fn _valid_tic_tac_toe(board: Vec<String>) -> Option<bool> {\\n            let mut x_count = 0;\\n            let mut o_count = 0;\\n            let mut x_wins = false;\\n            let mut o_wins = false;\\n            for row in board.iter() {\\n                for c in row.chars() {\\n                    if c == \\'X\\' {\\n                        x_count += 1;\\n                    } else if c == \\'O\\' {\\n                        o_count += 1;\\n                    }\\n                }\\n            }\\n            if x_count < o_count || x_count > o_count + 1 {\\n                return Some(false);\\n            }\\n            for i in 0..3 {\\n                if board[i].chars().all(|c| c == \\'X\\') {\\n                    x_wins = true;\\n                }\\n                if board[i].chars().all(|c| c == \\'O\\') {\\n                    o_wins = true;\\n                }\\n                if board[0].chars().nth(i)? == board[1].chars().nth(i)?\\n                    && board[1].chars().nth(i)? == board[2].chars().nth(i)?\\n                {\\n                    if board[0].chars().nth(i)? == \\'X\\' {\\n                        x_wins = true;\\n                    } else if board[0].chars().nth(i)? == \\'O\\' {\\n                        o_wins = true;\\n                    }\\n                }\\n            }\\n            if board[0].chars().next()? == board[1].chars().nth(1)?\\n                && board[1].chars().nth(1)? == board[2].chars().nth(2)?\\n            {\\n                if board[0].starts_with(\\'X\\') {\\n                    x_wins = true;\\n                } else if board[0].starts_with(\\'O\\') {\\n                    o_wins = true;\\n                }\\n            }\\n            if board[0].chars().nth(2)? == board[1].chars().nth(1)?\\n                && board[1].chars().nth(1)? == board[2].chars().next()?\\n            {\\n                if board[0].chars().nth(2)? == \\'X\\' {\\n                    x_wins = true\\n                } else if board[0].chars().nth(2)? == \\'O\\' {\\n                    o_wins = true;\\n                }\\n            }\\n            if x_wins && o_wins {\\n                return Some(false);\\n            }\\n            if x_wins && x_count == o_count {\\n                return Some(false);\\n            }\\n            if o_wins && x_count > o_count {\\n                return Some(false);\\n            }\\n            Some(true)\\n        }\\n\\n        _valid_tic_tac_toe(board).unwrap_or(false)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn valid_tic_tac_toe(board: Vec<String>) -> bool {\\n        fn _valid_tic_tac_toe(board: Vec<String>) -> Option<bool> {\\n            let mut x_count = 0;\\n            let mut o_count = 0;\\n            let mut x_wins = false;\\n            let mut o_wins = false;\\n            for row in board.iter() {\\n                for c in row.chars() {\\n                    if c == \\'X\\' {\\n                        x_count += 1;\\n                    } else if c == \\'O\\' {\\n                        o_count += 1;\\n                    }\\n                }\\n            }\\n            if x_count < o_count || x_count > o_count + 1 {\\n                return Some(false);\\n            }\\n            for i in 0..3 {\\n                if board[i].chars().all(|c| c == \\'X\\') {\\n                    x_wins = true;\\n                }\\n                if board[i].chars().all(|c| c == \\'O\\') {\\n                    o_wins = true;\\n                }\\n                if board[0].chars().nth(i)? == board[1].chars().nth(i)?\\n                    && board[1].chars().nth(i)? == board[2].chars().nth(i)?\\n                {\\n                    if board[0].chars().nth(i)? == \\'X\\' {\\n                        x_wins = true;\\n                    } else if board[0].chars().nth(i)? == \\'O\\' {\\n                        o_wins = true;\\n                    }\\n                }\\n            }\\n            if board[0].chars().next()? == board[1].chars().nth(1)?\\n                && board[1].chars().nth(1)? == board[2].chars().nth(2)?\\n            {\\n                if board[0].starts_with(\\'X\\') {\\n                    x_wins = true;\\n                } else if board[0].starts_with(\\'O\\') {\\n                    o_wins = true;\\n                }\\n            }\\n            if board[0].chars().nth(2)? == board[1].chars().nth(1)?\\n                && board[1].chars().nth(1)? == board[2].chars().next()?\\n            {\\n                if board[0].chars().nth(2)? == \\'X\\' {\\n                    x_wins = true\\n                } else if board[0].chars().nth(2)? == \\'O\\' {\\n                    o_wins = true;\\n                }\\n            }\\n            if x_wins && o_wins {\\n                return Some(false);\\n            }\\n            if x_wins && x_count == o_count {\\n                return Some(false);\\n            }\\n            if o_wins && x_count > o_count {\\n                return Some(false);\\n            }\\n            Some(true)\\n        }\\n\\n        _valid_tic_tac_toe(board).unwrap_or(false)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842387,
                "title": "edge-case-galore",
                "content": "# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # create function to determine number of wins for a player\\n        # keep track of number of tiles for each player\\n        # validate different edge cases for how players are allowed to win\\n        # time O(m * n) space O(1)\\n\\n        def find_win(player):\\n            total = 0\\n            return diagonal(player) + horizontal(player) + vertical(player)\\n\\n        def diagonal(player):\\n            total = 0\\n            flat = \"\"\\n            # tl diagnal\\n            for i, j in zip(range(3), range(3)):\\n                flat += board[i][j]\\n            if flat == player * 3:\\n                total += 1\\n            flat = \"\"\\n            # bl diagonal\\n            for i, j in zip(reversed(range(3)), range(3)):\\n                flat += board[i][j]\\n            if flat == player * 3:\\n                total += 1\\n\\n            return total\\n            \\n        def horizontal(player):\\n            total = 0\\n            for i in range(3):\\n                if board[i] == player * 3:\\n                    total += 1\\n            return total\\n\\n        def vertical(player):\\n            total = 0\\n            flat = \"\"\\n            for j in range(3):\\n                for i in range(3):\\n                    flat += board[i][j]\\n                if flat == player * 3:\\n                    total += 1\\n                flat = \"\"\\n            return total\\n\\n        x_win, o_win = find_win(\"X\"), find_win(\"O\")\\n        x = o = 0\\n        for row in board:\\n            for space in row:\\n                if space == \"X\":\\n                    x += 1\\n                elif space == \"O\":\\n                    o += 1\\n\\n        if x_win > 2:\\n            return False\\n        if o_win > 2:\\n            return False\\n        if x_win > 0 and o_win > 0:\\n            return False\\n        if x_win and x == o or o_win and x > o:\\n            return False\\n        if x < o or abs(x - o) > 1:\\n            return False\\n\\n        return True\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validTicTacToe(self, board: List[str]) -> bool:\\n        # create function to determine number of wins for a player\\n        # keep track of number of tiles for each player\\n        # validate different edge cases for how players are allowed to win\\n        # time O(m * n) space O(1)\\n\\n        def find_win(player):\\n            total = 0\\n            return diagonal(player) + horizontal(player) + vertical(player)\\n\\n        def diagonal(player):\\n            total = 0\\n            flat = \"\"\\n            # tl diagnal\\n            for i, j in zip(range(3), range(3)):\\n                flat += board[i][j]\\n            if flat == player * 3:\\n                total += 1\\n            flat = \"\"\\n            # bl diagonal\\n            for i, j in zip(reversed(range(3)), range(3)):\\n                flat += board[i][j]\\n            if flat == player * 3:\\n                total += 1\\n\\n            return total\\n            \\n        def horizontal(player):\\n            total = 0\\n            for i in range(3):\\n                if board[i] == player * 3:\\n                    total += 1\\n            return total\\n\\n        def vertical(player):\\n            total = 0\\n            flat = \"\"\\n            for j in range(3):\\n                for i in range(3):\\n                    flat += board[i][j]\\n                if flat == player * 3:\\n                    total += 1\\n                flat = \"\"\\n            return total\\n\\n        x_win, o_win = find_win(\"X\"), find_win(\"O\")\\n        x = o = 0\\n        for row in board:\\n            for space in row:\\n                if space == \"X\":\\n                    x += 1\\n                elif space == \"O\":\\n                    o += 1\\n\\n        if x_win > 2:\\n            return False\\n        if o_win > 2:\\n            return False\\n        if x_win > 0 and o_win > 0:\\n            return False\\n        if x_win and x == o or o_win and x > o:\\n            return False\\n        if x < o or abs(x - o) > 1:\\n            return False\\n\\n        return True\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833167,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool validTicTacToe(vector<string>& grid) \\n    {\\n        int count_x = 0;\\n        int count_o = 0;\\n        \\n        for (int i = 0; i < 3; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                if (grid[i][j] == \\'X\\')\\n                {\\n                    count_x++;\\n                }\\n                else if (grid[i][j] == \\'O\\')\\n                {\\n                    count_o++;\\n                }\\n            }\\n        }\\n        \\n        if (count_o > count_x || count_x - count_o >= 2)\\n            return false;\\n        \\n        if (count_x >= 3 && count_x == count_o && check_x_win(grid))\\n            return false;\\n        \\n        if (count_o >= 3 && count_x > count_o && check_o_win(grid))\\n            return false;\\n        \\n        return true;\\n    }\\nprivate:\\n    bool check_x_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'X\\' && grid[0][1] == \\'X\\' && grid[0][2] == \\'X\\';\\n        res |= grid[1][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[1][2] == \\'X\\';\\n        res |= grid[2][0] == \\'X\\' && grid[2][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][0] == \\'X\\' && grid[2][0] == \\'X\\';\\n        res |= grid[0][1] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][1] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][2] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][0] == \\'X\\';\\n        \\n        return res;\\n    }\\n    \\n    bool check_o_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'O\\' && grid[0][1] == \\'O\\' && grid[0][2] == \\'O\\';\\n        res |= grid[1][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[1][2] == \\'O\\';\\n        res |= grid[2][0] == \\'O\\' && grid[2][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][0] == \\'O\\' && grid[2][0] == \\'O\\';\\n        res |= grid[0][1] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][1] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][2] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][0] == \\'O\\';\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool validTicTacToe(vector<string>& grid) \\n    {\\n        int count_x = 0;\\n        int count_o = 0;\\n        \\n        for (int i = 0; i < 3; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                if (grid[i][j] == \\'X\\')\\n                {\\n                    count_x++;\\n                }\\n                else if (grid[i][j] == \\'O\\')\\n                {\\n                    count_o++;\\n                }\\n            }\\n        }\\n        \\n        if (count_o > count_x || count_x - count_o >= 2)\\n            return false;\\n        \\n        if (count_x >= 3 && count_x == count_o && check_x_win(grid))\\n            return false;\\n        \\n        if (count_o >= 3 && count_x > count_o && check_o_win(grid))\\n            return false;\\n        \\n        return true;\\n    }\\nprivate:\\n    bool check_x_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'X\\' && grid[0][1] == \\'X\\' && grid[0][2] == \\'X\\';\\n        res |= grid[1][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[1][2] == \\'X\\';\\n        res |= grid[2][0] == \\'X\\' && grid[2][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][0] == \\'X\\' && grid[2][0] == \\'X\\';\\n        res |= grid[0][1] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][1] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][2] == \\'X\\' && grid[2][2] == \\'X\\';\\n        \\n        res |= grid[0][0] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][2] == \\'X\\';\\n        res |= grid[0][2] == \\'X\\' && grid[1][1] == \\'X\\' && grid[2][0] == \\'X\\';\\n        \\n        return res;\\n    }\\n    \\n    bool check_o_win(const std::vector<std::string>& grid)\\n    {\\n        bool res = false;\\n        res |= grid[0][0] == \\'O\\' && grid[0][1] == \\'O\\' && grid[0][2] == \\'O\\';\\n        res |= grid[1][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[1][2] == \\'O\\';\\n        res |= grid[2][0] == \\'O\\' && grid[2][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][0] == \\'O\\' && grid[2][0] == \\'O\\';\\n        res |= grid[0][1] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][1] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][2] == \\'O\\' && grid[2][2] == \\'O\\';\\n        \\n        res |= grid[0][0] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][2] == \\'O\\';\\n        res |= grid[0][2] == \\'O\\' && grid[1][1] == \\'O\\' && grid[2][0] == \\'O\\';\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818048,
                "title": "java-solution-simple",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int os = 0;\\n        int xs = 0;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<3;j++){\\n                if(board[i].charAt(j) == \\'O\\') {\\n                    os++;\\n                } else if(board[i].charAt(j) == \\'X\\') {\\n                    xs++;\\n                }\\n            }\\n        }\\n        if(xs == os || xs == os+1) {\\n            if(xs == os) {\\n                return isValid(board);\\n            } else {\\n                return isValidagain(board);        \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isValid(String[] board) {\\n        boolean diag = board[0].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\';\\n        boolean antidiag = board[0].charAt(2) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(0) == \\'X\\';\\n        boolean horizontal = (board[0].charAt(0) == \\'X\\' && board[0].charAt(1) == \\'X\\' && board[0].charAt(2) == \\'X\\') || (board[1].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[1].charAt(2) == \\'X\\') || (board[2].charAt(0) == \\'X\\' && board[2].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\');\\n        boolean vertical = (board[0].charAt(0) == \\'X\\' && board[1].charAt(0) == \\'X\\' && board[2].charAt(0) == \\'X\\') || (board[0].charAt(1) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(1) == \\'X\\') || (board[0].charAt(2) == \\'X\\' && board[1].charAt(2) == \\'X\\' && board[2].charAt(2) == \\'X\\');\\n        return !(diag || antidiag || horizontal || vertical);    \\n    }\\n    \\n     public boolean isValidagain(String[] board) {\\n        boolean diag = board[0].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\';\\n        boolean antidiag = board[0].charAt(2) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(0) == \\'O\\';\\n        boolean horizontal = (board[0].charAt(0) == \\'O\\' && board[0].charAt(1) == \\'O\\' && board[0].charAt(2) == \\'O\\') || (board[1].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[1].charAt(2) == \\'O\\') || (board[2].charAt(0) == \\'O\\' && board[2].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\');\\n        boolean vertical = (board[0].charAt(0) == \\'O\\' && board[1].charAt(0) == \\'O\\' && board[2].charAt(0) == \\'O\\') || (board[0].charAt(1) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(1) == \\'O\\') || (board[0].charAt(2) == \\'O\\' && board[1].charAt(2) == \\'O\\' && board[2].charAt(2) == \\'O\\');\\n        return !(diag || antidiag || horizontal || vertical);    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int os = 0;\\n        int xs = 0;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<3;j++){\\n                if(board[i].charAt(j) == \\'O\\') {\\n                    os++;\\n                } else if(board[i].charAt(j) == \\'X\\') {\\n                    xs++;\\n                }\\n            }\\n        }\\n        if(xs == os || xs == os+1) {\\n            if(xs == os) {\\n                return isValid(board);\\n            } else {\\n                return isValidagain(board);        \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isValid(String[] board) {\\n        boolean diag = board[0].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\';\\n        boolean antidiag = board[0].charAt(2) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(0) == \\'X\\';\\n        boolean horizontal = (board[0].charAt(0) == \\'X\\' && board[0].charAt(1) == \\'X\\' && board[0].charAt(2) == \\'X\\') || (board[1].charAt(0) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[1].charAt(2) == \\'X\\') || (board[2].charAt(0) == \\'X\\' && board[2].charAt(1) == \\'X\\' && board[2].charAt(2) == \\'X\\');\\n        boolean vertical = (board[0].charAt(0) == \\'X\\' && board[1].charAt(0) == \\'X\\' && board[2].charAt(0) == \\'X\\') || (board[0].charAt(1) == \\'X\\' && board[1].charAt(1) == \\'X\\' && board[2].charAt(1) == \\'X\\') || (board[0].charAt(2) == \\'X\\' && board[1].charAt(2) == \\'X\\' && board[2].charAt(2) == \\'X\\');\\n        return !(diag || antidiag || horizontal || vertical);    \\n    }\\n    \\n     public boolean isValidagain(String[] board) {\\n        boolean diag = board[0].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\';\\n        boolean antidiag = board[0].charAt(2) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(0) == \\'O\\';\\n        boolean horizontal = (board[0].charAt(0) == \\'O\\' && board[0].charAt(1) == \\'O\\' && board[0].charAt(2) == \\'O\\') || (board[1].charAt(0) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[1].charAt(2) == \\'O\\') || (board[2].charAt(0) == \\'O\\' && board[2].charAt(1) == \\'O\\' && board[2].charAt(2) == \\'O\\');\\n        boolean vertical = (board[0].charAt(0) == \\'O\\' && board[1].charAt(0) == \\'O\\' && board[2].charAt(0) == \\'O\\') || (board[0].charAt(1) == \\'O\\' && board[1].charAt(1) == \\'O\\' && board[2].charAt(1) == \\'O\\') || (board[0].charAt(2) == \\'O\\' && board[1].charAt(2) == \\'O\\' && board[2].charAt(2) == \\'O\\');\\n        return !(diag || antidiag || horizontal || vertical);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816299,
                "title": "java-easy-solution-o-1",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int countXEnds = getCountOfEnds(board, \\'X\\');\\n        int countOEnds = getCountOfEnds(board, \\'O\\');\\n        if(countXEnds == -1 || countOEnds == -1) return false;\\n        if(countXEnds > 0 && countOEnds > 0) return false;\\n        \\n        int[] count = getCount(board);\\n        int diff = count[0] - count[1];\\n        if(diff != 0 && diff != 1) return false;\\n        \\n        if(countXEnds > 0 && diff == 0) return false;\\n        if(countOEnds > 0 && diff == 1) return false;\\n        return true;\\n    }\\n    \\n    private int getCountOfEnds(String[] g, char ch){\\n        int countRows = 0;\\n        for(int r = 0; r < 3; r++) {\\n            if(g[r].charAt(0) == ch && g[r].charAt(1) == ch && g[r].charAt(2) == ch) {\\n                countRows += 1;\\n            }    \\n        }\\n        if(countRows > 1) return -1;\\n        \\n        int countCols = 0;\\n        for(int c = 0; c < 3; c++) {\\n            if(g[0].charAt(c) == ch && g[1].charAt(c) == ch && g[2].charAt(c) == ch) {\\n                countCols += 1;\\n            }\\n        }\\n        if(countCols > 1) return -1;\\n        \\n        int count = countRows + countCols;\\n        if(g[0].charAt(0) == ch && g[1].charAt(1) == ch && g[2].charAt(2) == ch) {\\n            count++;\\n        }\\n        if(g[0].charAt(2) == ch && g[1].charAt(1) == ch && g[2].charAt(0) == ch) {\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    private int[] getCount(String[] g){\\n        int[] count = new int[2];\\n        for(int r = 0; r < 3; r++) {\\n            for(int c = 0; c < 3; c++) {\\n                if(g[r].charAt(c) == \\'X\\') {\\n                    count[0]++;\\n                } else if(g[r].charAt(c) == \\'O\\') {\\n                    count[1]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int countXEnds = getCountOfEnds(board, \\'X\\');\\n        int countOEnds = getCountOfEnds(board, \\'O\\');\\n        if(countXEnds == -1 || countOEnds == -1) return false;\\n        if(countXEnds > 0 && countOEnds > 0) return false;\\n        \\n        int[] count = getCount(board);\\n        int diff = count[0] - count[1];\\n        if(diff != 0 && diff != 1) return false;\\n        \\n        if(countXEnds > 0 && diff == 0) return false;\\n        if(countOEnds > 0 && diff == 1) return false;\\n        return true;\\n    }\\n    \\n    private int getCountOfEnds(String[] g, char ch){\\n        int countRows = 0;\\n        for(int r = 0; r < 3; r++) {\\n            if(g[r].charAt(0) == ch && g[r].charAt(1) == ch && g[r].charAt(2) == ch) {\\n                countRows += 1;\\n            }    \\n        }\\n        if(countRows > 1) return -1;\\n        \\n        int countCols = 0;\\n        for(int c = 0; c < 3; c++) {\\n            if(g[0].charAt(c) == ch && g[1].charAt(c) == ch && g[2].charAt(c) == ch) {\\n                countCols += 1;\\n            }\\n        }\\n        if(countCols > 1) return -1;\\n        \\n        int count = countRows + countCols;\\n        if(g[0].charAt(0) == ch && g[1].charAt(1) == ch && g[2].charAt(2) == ch) {\\n            count++;\\n        }\\n        if(g[0].charAt(2) == ch && g[1].charAt(1) == ch && g[2].charAt(0) == ch) {\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    private int[] getCount(String[] g){\\n        int[] count = new int[2];\\n        for(int r = 0; r < 3; r++) {\\n            for(int c = 0; c < 3; c++) {\\n                if(g[r].charAt(c) == \\'X\\') {\\n                    count[0]++;\\n                } else if(g[r].charAt(c) == \\'O\\') {\\n                    count[1]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797877,
                "title": "java-not-fancy-solution-beating-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        int countX = 0;\\n        int countO = 0;\\n\\n        int[] rowX = new int[3];\\n        int[] colX = new int[3];\\n        int diagX = 0;\\n        int antiDiagX = 0;\\n\\n        int[] rowO = new int[3];\\n        int[] colO = new int[3];\\n        int diagO = 0;\\n        int antiDiagO = 0;\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length(); j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    countX += 1;\\n                    rowX[i]++;\\n                    colX[j]++;\\n                    if (i == j) diagX++;\\n                    if (i+j == 2) antiDiagX++;\\n                } else if (board[i].charAt(j) == \\'O\\') {\\n                    countO += 1;\\n                    rowO[i]++;\\n                    colO[j]++;\\n                    if (i == j) diagO++;\\n                    if (i+j == 2) antiDiagO++;\\n                }\\n            }\\n        }\\n        \\n        if (countO > countX) return false;\\n        if (countX-countO>1) return false;\\n        \\n        if (countX == countO) {\\n            for (int i = 0; i < rowX.length; i++)\\n                if (rowX[i] == 3) return false;\\n            for (int i = 0; i < colX.length; i++)\\n                if (colX[i] == 3) return false;\\n            if (diagX == 3 || antiDiagX == 3) return false;\\n            return true;\\n        } else {\\n            for (int i = 0; i < rowO.length; i++)\\n                if (rowO[i] == 3) return false;\\n            for (int i = 0; i < colO.length; i++)\\n                if (colO[i] == 3) return false;\\n            if (diagO == 3 || antiDiagO == 3) return false;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        \\n        int countX = 0;\\n        int countO = 0;\\n\\n        int[] rowX = new int[3];\\n        int[] colX = new int[3];\\n        int diagX = 0;\\n        int antiDiagX = 0;\\n\\n        int[] rowO = new int[3];\\n        int[] colO = new int[3];\\n        int diagO = 0;\\n        int antiDiagO = 0;\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length(); j++) {\\n                if (board[i].charAt(j) == \\'X\\') {\\n                    countX += 1;\\n                    rowX[i]++;\\n                    colX[j]++;\\n                    if (i == j) diagX++;\\n                    if (i+j == 2) antiDiagX++;\\n                } else if (board[i].charAt(j) == \\'O\\') {\\n                    countO += 1;\\n                    rowO[i]++;\\n                    colO[j]++;\\n                    if (i == j) diagO++;\\n                    if (i+j == 2) antiDiagO++;\\n                }\\n            }\\n        }\\n        \\n        if (countO > countX) return false;\\n        if (countX-countO>1) return false;\\n        \\n        if (countX == countO) {\\n            for (int i = 0; i < rowX.length; i++)\\n                if (rowX[i] == 3) return false;\\n            for (int i = 0; i < colX.length; i++)\\n                if (colX[i] == 3) return false;\\n            if (diagX == 3 || antiDiagX == 3) return false;\\n            return true;\\n        } else {\\n            for (int i = 0; i < rowO.length; i++)\\n                if (rowO[i] == 3) return false;\\n            for (int i = 0; i < colO.length; i++)\\n                if (colO[i] == 3) return false;\\n            if (diagO == 3 || antiDiagO == 3) return false;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793332,
                "title": "0-ms-faster-than-100-solution-easy-cpp-without-bfs-or-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<string>& board,char c){\\n       //check for row\\n       for(int i=0;i<3;i++){\\n           if(board[i][0]==c && board[i][1]==c && board[i][2]==c) return true;\\n       }\\n\\n       // check for col\\n       for(int i=0;i<3;i++){\\n           if(board[0][i]==c && board[1][i]==c && board[2][i]==c) return true;\\n       }\\n        // check for 1 diagonal\\n        if(board[0][0]==c && board[1][1]==c && board[2][2]==c) return true;\\n\\n        // check for 2 diagonal\\n        if(board[0][2]==c && board[1][1]==c && board[2][0]==c) return true;\\n\\n        return false;\\n       \\n    }\\n    bool validTicTacToe(vector<string>& board) {\\n        if(check(board,\\'X\\')==true && check(board,\\'O\\')==true ) return false;\\n        int xc=0,xo=0;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++){\\n                if(board[i][j]==\\'X\\')xc++;\\n                else if(board[i][j]==\\'O\\')xo++;\\n            }\\n        if((xc-xo)==0) \\n        {\\n            if(check(board,\\'X\\')) return false;\\n            return true;\\n        }\\n        if((xc-xo) == 1 && check(board,\\'O\\')==false) return true;\\n\\n        return false;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<string>& board,char c){\\n       //check for row\\n       for(int i=0;i<3;i++){\\n           if(board[i][0]==c && board[i][1]==c && board[i][2]==c) return true;\\n       }\\n\\n       // check for col\\n       for(int i=0;i<3;i++){\\n           if(board[0][i]==c && board[1][i]==c && board[2][i]==c) return true;\\n       }\\n        // check for 1 diagonal\\n        if(board[0][0]==c && board[1][1]==c && board[2][2]==c) return true;\\n\\n        // check for 2 diagonal\\n        if(board[0][2]==c && board[1][1]==c && board[2][0]==c) return true;\\n\\n        return false;\\n       \\n    }\\n    bool validTicTacToe(vector<string>& board) {\\n        if(check(board,\\'X\\')==true && check(board,\\'O\\')==true ) return false;\\n        int xc=0,xo=0;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++){\\n                if(board[i][j]==\\'X\\')xc++;\\n                else if(board[i][j]==\\'O\\')xo++;\\n            }\\n        if((xc-xo)==0) \\n        {\\n            if(check(board,\\'X\\')) return false;\\n            return true;\\n        }\\n        if((xc-xo) == 1 && check(board,\\'O\\')==false) return true;\\n\\n        return false;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778224,
                "title": "c-solution-faster-than-100-of-c-submissions-0-ms-easy-to-read",
                "content": "```\\nint count (char **board, char c){\\n    int counter = 0;\\n    for (int i = 0; i < 3; i++){\\n        for (int j = 0; j < 3; j++){\\n            if (board[i][j] == c) \\n                counter++;\\n        }\\n    }\\n    return counter;\\n}\\n\\nbool isWinner (char **board, char c){\\n    for (int i = 0; i < 3; i++){\\n        if (board[i][0] == c && board[i][1] == c && board[i][2] == c)\\n            return true;\\n        \\n        if (board[0][i] == c && board[1][i] == c && board[2][i] == c)\\n            return true;\\n    }\\n    if (board[0][0] == c && board[1][1] == c && board[2][2] == c)\\n        return true;\\n\\n    if (board[2][0] == c && board[1][1] == c && board[0][2] == c)\\n        return true;\\n    \\n    return false;\\n}\\n\\nbool validTicTacToe(char **board, int boardSize){\\n    int countOfX = count(board, \\'X\\');\\n    int countOfO = count(board, \\'O\\');\\n    if (countOfX != countOfO && countOfX != countOfO + 1)\\n        return false;\\n    \\n    if (isWinner(board, \\'X\\') && countOfX != countOfO + 1)\\n        return false;\\n    \\n    if (isWinner(board, \\'O\\') && countOfX != countOfO)\\n        return false;\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint count (char **board, char c){\\n    int counter = 0;\\n    for (int i = 0; i < 3; i++){\\n        for (int j = 0; j < 3; j++){\\n            if (board[i][j] == c) \\n                counter++;\\n        }\\n    }\\n    return counter;\\n}\\n\\nbool isWinner (char **board, char c){\\n    for (int i = 0; i < 3; i++){\\n        if (board[i][0] == c && board[i][1] == c && board[i][2] == c)\\n            return true;\\n        \\n        if (board[0][i] == c && board[1][i] == c && board[2][i] == c)\\n            return true;\\n    }\\n    if (board[0][0] == c && board[1][1] == c && board[2][2] == c)\\n        return true;\\n\\n    if (board[2][0] == c && board[1][1] == c && board[0][2] == c)\\n        return true;\\n    \\n    return false;\\n}\\n\\nbool validTicTacToe(char **board, int boardSize){\\n    int countOfX = count(board, \\'X\\');\\n    int countOfO = count(board, \\'O\\');\\n    if (countOfX != countOfO && countOfX != countOfO + 1)\\n        return false;\\n    \\n    if (isWinner(board, \\'X\\') && countOfX != countOfO + 1)\\n        return false;\\n    \\n    if (isWinner(board, \\'O\\') && countOfX != countOfO)\\n        return false;\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764540,
                "title": "very-straight-c-solution",
                "content": "**thought**\\n->there are only two possibilities \\n1.no of `x` must be one more than `O`\\n2.or number of both \\'X\\' and \\'O\\' must be equal\\n\\n-> if both \\'X\\' and \\'O\\' number is equal then X should not win as \"X\\' is the one started ,if \\'X\\' wins , \\'O\\' does not get any chance to play its chance.\\n\\n-> if no of \\'X\" is one more than \\'O\\' then O should not win, because if O wins then X will not have a chance to play the game.\\n\\ncheck this two conditions it is fine..\\n \\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<string>&board,char c)\\n    {\\n        //checking whether row has all c\\'s\\n        for(string s:board)\\n            if(s == string(3,c)) return false;\\n        \\n        //checking whether col has all c\\'s\\n        \\n        for(int i=0;i<3;i++)\\n            if(board[0][i]==board[1][i] && board[1][i]==board[2][i] && board[0][i] == c) return false;\\n        \\n        \\n       // checking whether left diagonal has all c\\'s\\n        \\n        if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] == c)\\n            return false;\\n        \\n        //checking whether right diagonal has all c\\'s\\n        if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] == c)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool validTicTacToe(vector<string>& board) {\\n        int one  = 0,two = 0;\\n        for(int i=0;i<board.size();i++)\\n        {\\n             \\n            for(char c:board[i])\\n            {\\n                if(c == \\'X\\')\\n                    one++;\\n                if(c == \\'O\\')\\n                    two++;\\n            }\\n                \\n        }\\n        \\n        if(one == two+1 && check(board,\\'O\\')) return true;\\n        \\n        if(one == two)\\n            return check(board,\\'X\\');\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<string>&board,char c)\\n    {\\n        //checking whether row has all c\\'s\\n        for(string s:board)\\n            if(s == string(3,c)) return false;\\n        \\n        //checking whether col has all c\\'s\\n        \\n        for(int i=0;i<3;i++)\\n            if(board[0][i]==board[1][i] && board[1][i]==board[2][i] && board[0][i] == c) return false;\\n        \\n        \\n       // checking whether left diagonal has all c\\'s\\n        \\n        if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] == c)\\n            return false;\\n        \\n        //checking whether right diagonal has all c\\'s\\n        if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] == c)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool validTicTacToe(vector<string>& board) {\\n        int one  = 0,two = 0;\\n        for(int i=0;i<board.size();i++)\\n        {\\n             \\n            for(char c:board[i])\\n            {\\n                if(c == \\'X\\')\\n                    one++;\\n                if(c == \\'O\\')\\n                    two++;\\n            }\\n                \\n        }\\n        \\n        if(one == two+1 && check(board,\\'O\\')) return true;\\n        \\n        if(one == two)\\n            return check(board,\\'X\\');\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714367,
                "title": "java-100-0ms-submission-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int xCount=count(board,\\'X\\');\\n        int oCount=count(board,\\'O\\');\\n        boolean isXWinner=isWinner(board,264);\\n        boolean isOWinner=isWinner(board,237);\\n        if((xCount>oCount+1) ||\\n          (oCount>xCount) ||\\n          (isXWinner==true && isOWinner==true)||\\n          (isXWinner==true && xCount==oCount)||\\n          (isOWinner==true && xCount>oCount)\\n          ) return false;\\n        return true;\\n    }\\n    private int count(String[] arr,char value){\\n        int count=0;\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if(arr[i].charAt(j)==value) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    private boolean isWinner(String[] arr,int s){\\n        if((s==arr[0].charAt(0)+arr[0].charAt(1)+arr[0].charAt(2))||\\n           (s==arr[1].charAt(0)+arr[1].charAt(1)+arr[1].charAt(2))||\\n           (s==arr[2].charAt(0)+arr[2].charAt(1)+arr[2].charAt(2))||\\n           (s==arr[0].charAt(0)+arr[1].charAt(0)+arr[2].charAt(0))||\\n           (s==(arr[0].charAt(1)+arr[1].charAt(1)+arr[2].charAt(1)))||\\n           (s==(arr[0].charAt(2)+arr[1].charAt(2)+arr[2].charAt(2)))||\\n           (s==(arr[0].charAt(0)+arr[1].charAt(1)+arr[2].charAt(2)))||\\n           (s==(arr[0].charAt(2)+arr[1].charAt(1)+arr[2].charAt(0)))\\n          )return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validTicTacToe(String[] board) {\\n        int xCount=count(board,\\'X\\');\\n        int oCount=count(board,\\'O\\');\\n        boolean isXWinner=isWinner(board,264);\\n        boolean isOWinner=isWinner(board,237);\\n        if((xCount>oCount+1) ||\\n          (oCount>xCount) ||\\n          (isXWinner==true && isOWinner==true)||\\n          (isXWinner==true && xCount==oCount)||\\n          (isOWinner==true && xCount>oCount)\\n          ) return false;\\n        return true;\\n    }\\n    private int count(String[] arr,char value){\\n        int count=0;\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if(arr[i].charAt(j)==value) count++;\\n            }\\n        }\\n        return count;\\n    }\\n    private boolean isWinner(String[] arr,int s){\\n        if((s==arr[0].charAt(0)+arr[0].charAt(1)+arr[0].charAt(2))||\\n           (s==arr[1].charAt(0)+arr[1].charAt(1)+arr[1].charAt(2))||\\n           (s==arr[2].charAt(0)+arr[2].charAt(1)+arr[2].charAt(2))||\\n           (s==arr[0].charAt(0)+arr[1].charAt(0)+arr[2].charAt(0))||\\n           (s==(arr[0].charAt(1)+arr[1].charAt(1)+arr[2].charAt(1)))||\\n           (s==(arr[0].charAt(2)+arr[1].charAt(2)+arr[2].charAt(2)))||\\n           (s==(arr[0].charAt(0)+arr[1].charAt(1)+arr[2].charAt(2)))||\\n           (s==(arr[0].charAt(2)+arr[1].charAt(1)+arr[2].charAt(0)))\\n          )return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697355,
                "title": "c-easy-to-understand-comments-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<string>& board,char c){\\n        string t = \"\";\\n        t+=c;t+=c;t+=c;\\n\\n        for(int j=0;j<3;j++){\\n            string tc=\"\",tr=\"\";\\n            for(int i=0;i<3;i++){\\n                tc+=board[i][j];\\n                tr+=board[j][i];\\n            }\\n            if(tr==t || tc==t)return 1;\\n        }\\n        \\n        if(board[0][0]==c && board[1][1]==c && board[2][2]==c) return 1;\\n        if(board[0][2]==c && board[1][1]==c && board[2][0]==c) return 1;\\n        return 0;\\n    }\\n\\n    bool validTicTacToe(vector<string>& board) {\\n        // z count number of \\'O\\'\\n        // k count number of \\'X\\'\\n        int z=0,k=0;\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if(board[i][j] == \\'O\\')z++;\\n                else if(board[i][j] == \\'X\\')k++;\\n            }\\n        }\\n        \\n        // cz check if \\'O\\' have won\\n        // ck check if \\'X\\' have won\\n        bool cz = check(board,\\'O\\');\\n        bool ck = check(board,\\'X\\');\\n\\n        //Both can\\'t win simultaneously\\n        if(ck==1 && cz==1)return 0;\\n        \\n       \\n        if(ck==1){\\n            if(k==z+1)return 1;  //if \\'X\\' won then number of \\'X\\' should be more on boards as he plays first\\n            return 0;\\n        }\\n        else if(cz==1){\\n            if(k==z)return 1;// if \\'O\\' won then number of \\'O\\' should be same as \\'X\\' on boards as he plays after \\'X\\'\\n            return 0;\\n        }\\n        else if(k==z || k==z+1) return 1; //if neither win then number of \\'X\\' can be either same or greater than 1 of \\'O\\'\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<string>& board,char c){\\n        string t = \"\";\\n        t+=c;t+=c;t+=c;\\n\\n        for(int j=0;j<3;j++){\\n            string tc=\"\",tr=\"\";\\n            for(int i=0;i<3;i++){\\n                tc+=board[i][j];\\n                tr+=board[j][i];\\n            }\\n            if(tr==t || tc==t)return 1;\\n        }\\n        \\n        if(board[0][0]==c && board[1][1]==c && board[2][2]==c) return 1;\\n        if(board[0][2]==c && board[1][1]==c && board[2][0]==c) return 1;\\n        return 0;\\n    }\\n\\n    bool validTicTacToe(vector<string>& board) {\\n        // z count number of \\'O\\'\\n        // k count number of \\'X\\'\\n        int z=0,k=0;\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if(board[i][j] == \\'O\\')z++;\\n                else if(board[i][j] == \\'X\\')k++;\\n            }\\n        }\\n        \\n        // cz check if \\'O\\' have won\\n        // ck check if \\'X\\' have won\\n        bool cz = check(board,\\'O\\');\\n        bool ck = check(board,\\'X\\');\\n\\n        //Both can\\'t win simultaneously\\n        if(ck==1 && cz==1)return 0;\\n        \\n       \\n        if(ck==1){\\n            if(k==z+1)return 1;  //if \\'X\\' won then number of \\'X\\' should be more on boards as he plays first\\n            return 0;\\n        }\\n        else if(cz==1){\\n            if(k==z)return 1;// if \\'O\\' won then number of \\'O\\' should be same as \\'X\\' on boards as he plays after \\'X\\'\\n            return 0;\\n        }\\n        else if(k==z || k==z+1) return 1; //if neither win then number of \\'X\\' can be either same or greater than 1 of \\'O\\'\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680501,
                "title": "python-clear-solution",
                "content": "```\\ndef validTicTacToe(self, board: List[str]) -> bool:\\n\\tc1 = sum(r.count(\\'X\\') for r in board)\\n\\tc2 = sum(r.count(\\'O\\') for r in board)\\n\\tif c1 - c2 not in (0, 1):\\n\\t\\treturn False\\n\\n\\tdef win(c):\\n\\t\\tfor i in range(3):\\n\\t\\t\\tif board[i][0]==board[i][1]==board[i][2]==c:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif board[0][i]==board[1][i]==board[2][i]==c:\\n\\t\\t\\t\\treturn True\\n\\t\\tif board[0][0]==board[1][1]==board[2][2]==c:\\n\\t\\t\\treturn True\\n\\t\\tif board[0][2]==board[1][1]==board[2][0]==c:\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\tif win(\\'X\\') and c1!=c2+1:\\n\\t\\treturn False\\n\\tif win(\\'O\\') and c1!=c2:\\n\\t\\treturn False\\n\\n\\treturn True\\n```",
                "solutionTags": [],
                "code": "```\\ndef validTicTacToe(self, board: List[str]) -> bool:\\n\\tc1 = sum(r.count(\\'X\\') for r in board)\\n\\tc2 = sum(r.count(\\'O\\') for r in board)\\n\\tif c1 - c2 not in (0, 1):\\n\\t\\treturn False\\n\\n\\tdef win(c):\\n\\t\\tfor i in range(3):\\n\\t\\t\\tif board[i][0]==board[i][1]==board[i][2]==c:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif board[0][i]==board[1][i]==board[2][i]==c:\\n\\t\\t\\t\\treturn True\\n\\t\\tif board[0][0]==board[1][1]==board[2][2]==c:\\n\\t\\t\\treturn True\\n\\t\\tif board[0][2]==board[1][1]==board[2][0]==c:\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\tif win(\\'X\\') and c1!=c2+1:\\n\\t\\treturn False\\n\\tif win(\\'O\\') and c1!=c2:\\n\\t\\treturn False\\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1569701,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 1566649,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 1567320,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 1576605,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 2049560,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 1572859,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 1572053,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 2076778,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            },
            {
                "id": 1723719,
                "content": [
                    {
                        "username": "dgrand",
                        "content": "Why this should return false?\\n[\"XXX\",\"OOX\",\"OOX\"]\\nThink of the last move being X at [0,2] yes, players played not optimally but this may happen."
                    },
                    {
                        "username": "donpablo1",
                        "content": "[@cswartzell](/cswartzell) it says true now, so its been fixed."
                    },
                    {
                        "username": "cswartzell",
                        "content": "That would be an incorrect case, and I suspect it got fixed. Clearly thats valid"
                    },
                    {
                        "username": "stackphish",
                        "content": "There is NO serious math here(Atleast NOT required here to solve)...\\nAlso, I would like to see atleast one recursive approach... I couldn\\'t find one from the discussions section. \\nI think Leetcode should seriously consider the correctness and aptness of the related topic since many leetcoders practice problems by filtering the tags. \\n"
                    },
                    {
                        "username": "klickez",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool validTicTacToe(vector<string>& board) {\\n        string board_string(9, \\' \\');\\n        unordered_set<string> valid;\\n        searchAll(board_string, /*x_to_move=*/true, valid);\\n        return valid.find(board[0] + board[1] + board[2]) != valid.end();\\n    }\\n\\nprivate:\\n    void searchAll(string& board, bool x_to_move, unordered_set<string>& seen) {\\n        if (seen.find(board) != seen.end()) {\\n            return;\\n        }\\n        seen.insert(board);\\n        if (win(board)) {\\n            return;\\n        }\\n        for (int i = 0; i < board.length(); ++i) {\\n            if (board[i] != \\' \\') {\\n                continue;\\n            }\\n            board[i] = x_to_move ? \\'X\\' : \\'O\\';\\n            searchAll(board, !x_to_move, seen);\\n            board[i] = \\' \\';\\n        }\\n    }\\n\\n    bool trioEqual(char a, char b, char c) {\\n        return a == b && b == c && c != \\' \\';\\n    }\\n\\n    bool win(string& b) {\\n        return trioEqual(b[0], b[1], b[2]) ||\\n               trioEqual(b[3], b[4], b[5]) ||\\n               trioEqual(b[6], b[7], b[8]) ||\\n               trioEqual(b[0], b[4], b[8]) ||\\n               trioEqual(b[6], b[4], b[2]) ||\\n               trioEqual(b[0], b[3], b[6]) ||\\n               trioEqual(b[1], b[4], b[7]) ||\\n               trioEqual(b[2], b[5], b[8]);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "kaihua",
                        "content": "Question above"
                    },
                    {
                        "username": "user7671HA",
                        "content": "how is the following valid state? there are 2 wins of sort from \\'X\\': left most vertical and bottom most horizontal\\n[\\n\"XOO\",\\n\"XOO\",\\n\"XXX\"]"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you can make double wins with using only 1 moves !! \\nyou just need to make the intersecting move at last (here it is [2][0] \\'s X."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "from 102 testcase i started doing test case oriented programming lol :)"
                    },
                    {
                        "username": "naveedn",
                        "content": "Input: [\"XXX\",\"XOO\",\"OO \"]\\n\\nX X X\\nX O O \\nO O \\n\\nMy understanding is that this is a valid board configuration / end-state, but the correct answer is False. Can anyone explain why?\\n\\nMoves:\\n\\tX: (0,0)\\n\\tO: (1,1)\\n\\tX:  (1,0)\\n\\tO: (2,0)\\n\\tX: (0,1)\\n\\tO: (2,1)\\n\\tX: (0,2) -> Game Over\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\n\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "whenever X wins , it has 1 more count than \\'O\\' \\nhere the \\'O\\' at (1,2) doesn\\'t come up in the moves you stated."
                    },
                    {
                        "username": "zzuniverse",
                        "content": "how come [\"XXX\",\"OOX\",\"OOX\"] returns true.  \\nthe rule clearly states that: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@user1009zf](/user1009zf) Tic Tac Toe is played in turns. You arent supposed to think about processing it in its finished state, but rather could the game have gotten to this state. In this case, how can both player have a completed row? The moment one of them completed a row, the game would have ended, implying the other did not have a completed row yet. "
                    },
                    {
                        "username": "aleph_zalgo",
                        "content": "This would be valid if the last move of the game was the \"X\" in the top right (which would fill in the win for both the row and column in a single move). Tripped me up too. \\n\\nI feel like the rules could be clearer about whether it must be a \"guaranteed valid\" board state or just a \"possibly valid\" one depending on the order of moves."
                    },
                    {
                        "username": "user1009zf",
                        "content": "I'm also little bit confused with this test case [\"XXX\",\"   \",\"OOO\"] Here expected outoput: False\n\nFirst row is marked as XXX, So game is over"
                    },
                    {
                        "username": "pradeepnaidu7034",
                        "content": "[\"XOX\",\"O X\",\"X O\"]\\nhow is it true can someone enlighten me\\n"
                    },
                    {
                        "username": "user1009zf",
                        "content": "Can anyone explain what is the state of the board [\"XXX\",\"   \",\"OOO\"]  The expected output is false for the above test case\\n\\nRule: The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal."
                    },
                    {
                        "username": "theAchiever",
                        "content": "because X and O both cannot win. Only one player can win."
                    },
                    {
                        "username": "indreshchaudhary",
                        "content": "its violating the last rule of the game, putting \\'O\\' in last even though player \\'X\\' won already."
                    }
                ]
            }
        ]
    },
    {
        "title": "Decrease Elements To Make Array Zigzag",
        "question_content": "<p>Given an array <code>nums</code> of integers, a <em>move</em>&nbsp;consists of choosing any element and <strong>decreasing it by 1</strong>.</p>\n\n<p>An array <code>A</code> is a&nbsp;<em>zigzag array</em>&nbsp;if either:</p>\n\n<ul>\n\t<li>Every even-indexed element is greater than adjacent elements, ie.&nbsp;<code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li>\n\t<li>OR, every odd-indexed element is greater than adjacent elements, ie.&nbsp;<code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li>\n</ul>\n\n<p>Return the minimum number of moves to transform the given array <code>nums</code> into a zigzag array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can decrease 2 to 0 or 3 to 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9,6,1,6,2]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 350576,
                "title": "java-c-python-easy-and-concise",
                "content": "## **Explanation**\\nTwo options, either make `A[even]` smaller or make `A[odd]` smaller.\\nLoop on the whole array `A`,\\nfind the `min(A[i - 1],A[i + 1])`,\\ncalculate that the moves need to make smaller than both side.\\nIf it\\'s negative, it means it\\'s already smaller than both side, no moved needed.\\nAdd the moves need to `res[i%i]`.\\nIn the end return the smaller option.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)` for one pass\\nSpace `O(2)` for two options\\n<br>\\n\\n**Java:**\\n```java\\n    public int movesToMakeZigzag(int[] A) {\\n        int res[] = new int[2],  n = A.length, left, right;\\n        for (int i = 0; i < n; ++i) {\\n            left = i > 0 ? A[i - 1] : 1001;\\n            right = i + 1 < n ? A[i + 1] : 1001;\\n            res[i % 2] += Math.max(0, A[i] - Math.min(left, right) + 1);\\n        }\\n        return Math.min(res[0], res[1]);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int movesToMakeZigzag(vector<int>& A) {\\n        int res[2] = {0, 0},  n = A.size(), left, right;\\n        for (int i = 0; i < n; ++i) {\\n            left = i > 0 ? A[i - 1] : 1001;\\n            right = i + 1 < n ? A[i + 1] : 1001;\\n            res[i % 2] += max(0, A[i] - min(left, right) + 1);\\n        }\\n        return min(res[0], res[1]);\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def movesToMakeZigzag(self, A):\\n        A = [float(\\'inf\\')] + A + [float(\\'inf\\')]\\n        res = [0, 0]\\n        for i in xrange(1, len(A) - 1):\\n            res[i % 2] += max(0, A[i] - min(A[i - 1], A[i + 1]) + 1)\\n        return min(res)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int movesToMakeZigzag(int[] A) {\\n        int res[] = new int[2],  n = A.length, left, right;\\n        for (int i = 0; i < n; ++i) {\\n            left = i > 0 ? A[i - 1] : 1001;\\n            right = i + 1 < n ? A[i + 1] : 1001;\\n            res[i % 2] += Math.max(0, A[i] - Math.min(left, right) + 1);\\n        }\\n        return Math.min(res[0], res[1]);\\n    }\\n```\n```cpp\\n    int movesToMakeZigzag(vector<int>& A) {\\n        int res[2] = {0, 0},  n = A.size(), left, right;\\n        for (int i = 0; i < n; ++i) {\\n            left = i > 0 ? A[i - 1] : 1001;\\n            right = i + 1 < n ? A[i + 1] : 1001;\\n            res[i % 2] += max(0, A[i] - min(left, right) + 1);\\n        }\\n        return min(res[0], res[1]);\\n    }\\n```\n```python\\n    def movesToMakeZigzag(self, A):\\n        A = [float(\\'inf\\')] + A + [float(\\'inf\\')]\\n        res = [0, 0]\\n        for i in xrange(1, len(A) - 1):\\n            res[i % 2] += max(0, A[i] - min(A[i - 1], A[i + 1]) + 1)\\n        return min(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 351306,
                "title": "c-o-n-brute-force-easy-to-understand-and-detailed-explanation",
                "content": "**Idea**\\nThere are two cases. Either the odd indices are smaller than their neighbors, or the even indices are smaller than their neighbors. \\nThus, we make two iterations (odd & even indices). Make them smaller than their neighbors.\\n\\nNow how do we make them smaller?\\n\\n\\n**Example**\\n`3 4 5`\\nif we want to make the number 4 smaller than its neighbors(3, 5) while making minimum number of decreases, we need to find the min of its neighbor and subtract 1. \\n`min(3, 4) - 1`, which now becomes `3 2 5`. and we made 2 (4 -> 2) decreases.\\n\\nso we just have to do\\n`int changes = num[i] - (min(num[i - 1], num[i + 1]) - 1) ` or simply\\n\\n`int changes = num[i] - min(num[i - 1], num[i + 1]) + 1 ` \\n\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint movesToMakeZigzag(vector<int>& nums) {\\n\\t\\t\\tint cnt1 = 0, cnt2 = 0;\\n\\n\\t\\t\\tif (nums.size() <= 1) return 0;\\n\\n\\t\\t\\t// make odd indices smaller\\n\\t\\t\\tfor (int i = 1; i < nums.size(); i += 2) {\\n\\t\\t\\t\\tif (i == nums.size() - 1) {\\n\\t\\t\\t\\t\\tif (nums[i - 1] <= nums[i]) cnt1 += nums[i] - nums[i - 1] + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (nums[i - 1] <= nums[i] || nums[i + 1] <= nums[i]) {\\n\\t\\t\\t\\t\\t\\tcnt1 += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// make even indices smaller\\n\\t\\t\\tfor (int i = 0; i < nums.size(); i+= 2) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\tif (nums[i] >= nums[i + 1]) cnt2 += nums[i] - nums[i + 1] + 1;\\n\\t\\t\\t\\t} else if (i == nums.size() - 1) {\\n\\t\\t\\t\\t\\tif (nums[i - 1] <= nums[i]) cnt2 += nums[i] - nums[i - 1] + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (nums[i - 1] <= nums[i] || nums[i + 1] <= nums[i]) {\\n\\t\\t\\t\\t\\t\\tcnt2 += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn min(cnt1, cnt2);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint movesToMakeZigzag(vector<int>& nums) {\\n\\t\\t\\tint cnt1 = 0, cnt2 = 0;\\n\\n\\t\\t\\tif (nums.size() <= 1) return 0;\\n\\n\\t\\t\\t// make odd indices smaller\\n\\t\\t\\tfor (int i = 1; i < nums.size(); i += 2) {\\n\\t\\t\\t\\tif (i == nums.size() - 1) {\\n\\t\\t\\t\\t\\tif (nums[i - 1] <= nums[i]) cnt1 += nums[i] - nums[i - 1] + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 350604,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\n`e` records how much each odd index has to be decremented and `o` the even to achieve zigzag format.\\n\\n```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int e = 0, o = 0, n = nums.length;\\n        for(int i=1; i < n; i+= 2){\\n            int min = Math.min(nums[i-1], i+1 < n ? nums[i+1] : 1000);\\n            if(min <= nums[i])\\n                e += (nums[i]-min+1);\\n        }\\n        for(int i=0; i < n; i+= 2){\\n            int min = Math.min(i > 0 ? nums[i-1] : 1000, i+1 < n ? nums[i+1] : 1000);\\n            if(min <= nums[i])\\n                o += (nums[i]-min+1);\\n        }\\n        return Math.min(e,o);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int e = 0, o = 0, n = nums.length;\\n        for(int i=1; i < n; i+= 2){\\n            int min = Math.min(nums[i-1], i+1 < n ? nums[i+1] : 1000);\\n            if(min <= nums[i])\\n                e += (nums[i]-min+1);\\n        }\\n        for(int i=0; i < n; i+= 2){\\n            int min = Math.min(i > 0 ? nums[i-1] : 1000, i+1 < n ? nums[i+1] : 1000);\\n            if(min <= nums[i])\\n                o += (nums[i]-min+1);\\n        }\\n        return Math.min(e,o);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350634,
                "title": "python-2-liner",
                "content": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, N: List[int]) -> int:\\n        moves = [max(0, N[i] - min(N[i-1:i] + N[i+1:i+2]) + 1) for i in range(len(N))]\\n        return min(sum(moves[::2]), sum(moves[1::2]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, N: List[int]) -> int:\\n        moves = [max(0, N[i] - min(N[i-1:i] + N[i+1:i+2]) + 1) for i in range(len(N))]\\n        return min(sum(moves[::2]), sum(moves[1::2]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549253,
                "title": "java-solution-from-easy-to-understand-to-concise-with-explanation",
                "content": "For example, we have input = {a, b, c, d}\\nwe have 2 options to make this array zigzag\\noption 1: a > b < c > d\\noption 2: a < b > c < d\\n\\nFor option 1: we need to reduce b & d\\nFor option 2: we need to reduce a & c\\n\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int n = nums.length;\\n        int sum1 = 0, sum2 = 0;\\n        //option 1: a > b < c > d\\n        for (int i = 1; i < n; i += 2) {\\n            int min = i < n - 1 ? Math.min(nums[i - 1], nums[i + 1]) : nums[i - 1];\\n            if (nums[i] >= min) sum1 += (nums[i] - min + 1); //reduce nums[i]\\n        }\\n        //option 2: a < b > c < d\\n        for (int i = 0; i < n; i += 2) {\\n            int min;\\n            if (i == 0) min = nums[i + 1];\\n            else if (i == n - 1) min = nums[i - 1];\\n            else min = Math.min(nums[i - 1], nums[i + 1]);\\n            if (nums[i] >= min) sum2 += (nums[i] - min + 1);\\n        }\\n        return Math.min(sum1, sum2);\\n    }\\n}\\n```\\nTime: O(n) 1 pass\\n\\nHere is the clean code from lee215:\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int res[] = new int[2], n = nums.length, left, right;\\n        for (int i = 0; i < n; ++i) {\\n            left = i > 0 ? nums[i - 1] : 1001;\\n            right = i + 1 < n ? nums[i + 1] : 1001;\\n            res[i % 2] += Math.max(0, nums[i] - Math.min(left, right) + 1);\\n        }\\n        return Math.min(res[0], res[1]);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if (nums.length < 2) return 0;\\n        int n = nums.length;\\n        int sum1 = 0, sum2 = 0;\\n        //option 1: a > b < c > d\\n        for (int i = 1; i < n; i += 2) {\\n            int min = i < n - 1 ? Math.min(nums[i - 1], nums[i + 1]) : nums[i - 1];\\n            if (nums[i] >= min) sum1 += (nums[i] - min + 1); //reduce nums[i]\\n        }\\n        //option 2: a < b > c < d\\n        for (int i = 0; i < n; i += 2) {\\n            int min;\\n            if (i == 0) min = nums[i + 1];\\n            else if (i == n - 1) min = nums[i - 1];\\n            else min = Math.min(nums[i - 1], nums[i + 1]);\\n            if (nums[i] >= min) sum2 += (nums[i] - min + 1);\\n        }\\n        return Math.min(sum1, sum2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int res[] = new int[2], n = nums.length, left, right;\\n        for (int i = 0; i < n; ++i) {\\n            left = i > 0 ? nums[i - 1] : 1001;\\n            right = i + 1 < n ? nums[i + 1] : 1001;\\n            res[i % 2] += Math.max(0, nums[i] - Math.min(left, right) + 1);\\n        }\\n        return Math.min(res[0], res[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358100,
                "title": "java-one-pass",
                "content": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int N = nums.length;\\n        int even = 0, odd = 0;\\n\\n        for (int i = 0; i < N; i++) {\\n            int next = (i + 1) < N ? nums[i + 1] : Integer.MAX_VALUE;\\n            int prev = (i - 1) >= 0 ? nums[i - 1] : Integer.MAX_VALUE;\\n            int change = Math.max(0, nums[i] - Math.min(prev, next) + 1);\\n            if (i%2 == 0) {\\n                even += change;\\n            } else {\\n                odd += change;\\n            }\\n        }\\n        return Math.min(even, odd);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int N = nums.length;\\n        int even = 0, odd = 0;\\n\\n        for (int i = 0; i < N; i++) {\\n            int next = (i + 1) < N ? nums[i + 1] : Integer.MAX_VALUE;\\n            int prev = (i - 1) >= 0 ? nums[i - 1] : Integer.MAX_VALUE;\\n            int change = Math.max(0, nums[i] - Math.min(prev, next) + 1);\\n            if (i%2 == 0) {\\n                even += change;\\n            } else {\\n                odd += change;\\n            }\\n        }\\n        return Math.min(even, odd);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368490,
                "title": "python-o-n-time-o-1-memory-with-explanation",
                "content": "There are two possible ways the array can satisfy the zigzag requirement: 1: start with a zig (increasing) 2. start with zag (decreasing). There is a loop which goes through the whole list of numbers, in each step we keep track of the number of subtractions needed to satisfy the requiremnets for both possible ways mentioned before. We also keep track of the last modified number. O(n) time and O(1) Memory.\\n```\\nclass Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        zig, zag = 0, 0\\n        prev_zig, prev_zag = nums[0], nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            if i % 2 == 0:\\n                zig += max(0, prev_zig - nums[i] + 1)\\n                prev_zig = nums[i] \\n                zag += max(0, nums[i] - prev_zag + 1)\\n                prev_zag = nums[i] - max(0, nums[i] - prev_zag + 1)\\n            else:\\n                zag += max(0, prev_zag - nums[i] + 1)\\n                prev_zag = nums[i]\\n                zig += max(0, nums[i] - prev_zig + 1)\\n                prev_zig = nums[i] - max(0, nums[i] - prev_zig + 1)\\n        \\n        return min(zig, zag)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        zig, zag = 0, 0\\n        prev_zig, prev_zag = nums[0], nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            if i % 2 == 0:\\n                zig += max(0, prev_zig - nums[i] + 1)\\n                prev_zig = nums[i] \\n                zag += max(0, nums[i] - prev_zag + 1)\\n                prev_zag = nums[i] - max(0, nums[i] - prev_zag + 1)\\n            else:\\n                zag += max(0, prev_zag - nums[i] + 1)\\n                prev_zag = nums[i]\\n                zig += max(0, nums[i] - prev_zig + 1)\\n                prev_zig = nums[i] - max(0, nums[i] - prev_zig + 1)\\n        \\n        return min(zig, zag)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443790,
                "title": "c-checking-which-one-gives-lower-ans-odd-place-or-even-place",
                "content": "checking which one gives lower final ans odd place or even place\\n\\n```\\nint movesToMakeZigzag(vector<int>& nums) {\\n        vector<int>nums2=nums;\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<nums[i-1]){\\n                \\n            }else{\\n                ans=ans+nums[i]-nums[i-1]+1;\\n                nums[i]=nums[i-1]-1;\\n            }if(i+1<nums.size()&&nums[i]<nums[i+1]){\\n                \\n            }else if(i+1<nums.size()){\\n                ans=ans+nums[i]-nums[i+1]+1;\\n            }\\n            i++;\\n        }\\n        int ans2=0;\\n        for(int i=1;i<nums2.size();i++){\\n            if(nums2[i]>nums2[i-1]){\\n                \\n            }else{\\n                ans2=ans2+nums2[i-1]-nums2[i]+1;\\n            }\\n            if(i+1<nums2.size()&&nums2[i]>nums2[i+1]){\\n                \\n            }else if(i+1<nums2.size()){\\n                ans2=ans2+nums2[i+1]-nums2[i]+1;\\n                nums2[i+1]=nums2[i]-1;\\n            }\\n            i++;\\n        }\\n        return min(ans,ans2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint movesToMakeZigzag(vector<int>& nums) {\\n        vector<int>nums2=nums;\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<nums[i-1]){\\n                \\n            }else{\\n                ans=ans+nums[i]-nums[i-1]+1;\\n                nums[i]=nums[i-1]-1;\\n            }if(i+1<nums.size()&&nums[i]<nums[i+1]){\\n                \\n            }else if(i+1<nums.size()){\\n                ans=ans+nums[i]-nums[i+1]+1;\\n            }\\n            i++;\\n        }\\n        int ans2=0;\\n        for(int i=1;i<nums2.size();i++){\\n            if(nums2[i]>nums2[i-1]){\\n                \\n            }else{\\n                ans2=ans2+nums2[i-1]-nums2[i]+1;\\n            }\\n            if(i+1<nums2.size()&&nums2[i]>nums2[i+1]){\\n                \\n            }else if(i+1<nums2.size()){\\n                ans2=ans2+nums2[i+1]-nums2[i]+1;\\n                nums2[i+1]=nums2[i]-1;\\n            }\\n            i++;\\n        }\\n        return min(ans,ans2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593467,
                "title": "c-2-pass-easy-to-understand-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int even = 0, odd = 0;\\n\\n\\t\\tif (nums.size() <= 1) return 0;\\n\\n        /* Even indices are smaller */\\n        for (int i = 0; i < nums.size(); i+= 2) {\\n\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\tif (nums[i] >= nums[i+1]) even += nums[i]-nums[i+1]+1;\\n\\t\\t\\t} else if (i == nums.size() - 1) {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i]) even += nums[i]-nums[i-1]+1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i] || nums[i+1] <= nums[i]) {\\n\\t\\t\\t\\t\\teven += nums[i] - min(nums[i-1], nums[i+1]) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        /* Odd indices are smaller */\\n\\t\\tfor (int i = 1; i < nums.size(); i += 2) {\\n\\t\\t\\tif (i == nums.size() - 1) {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i]) odd += nums[i]-nums[i-1]+1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i] || nums[i+1] <= nums[i]) {\\n\\t\\t\\t\\t\\todd += nums[i] - min(nums[i-1], nums[i+1]) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn min(even, odd);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int even = 0, odd = 0;\\n\\n\\t\\tif (nums.size() <= 1) return 0;\\n\\n        /* Even indices are smaller */\\n        for (int i = 0; i < nums.size(); i+= 2) {\\n\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\tif (nums[i] >= nums[i+1]) even += nums[i]-nums[i+1]+1;\\n\\t\\t\\t} else if (i == nums.size() - 1) {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i]) even += nums[i]-nums[i-1]+1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i] || nums[i+1] <= nums[i]) {\\n\\t\\t\\t\\t\\teven += nums[i] - min(nums[i-1], nums[i+1]) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        /* Odd indices are smaller */\\n\\t\\tfor (int i = 1; i < nums.size(); i += 2) {\\n\\t\\t\\tif (i == nums.size() - 1) {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i]) odd += nums[i]-nums[i-1]+1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (nums[i-1] <= nums[i] || nums[i+1] <= nums[i]) {\\n\\t\\t\\t\\t\\todd += nums[i] - min(nums[i-1], nums[i+1]) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn min(even, odd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570825,
                "title": "javascript-solution-100-100",
                "content": "```\\nvar movesToMakeZigzag = function(nums) {\\n   let even = zig(nums, 0, 0);\\n   let odd = zig(nums, 0, 1);\\n   return Math.min(even, odd);\\n};\\n\\nfunction zig(nums, style, start){\\n    let arr = [...nums];\\n    for(let i = start; i < nums.length; i += 2){\\n       if(arr[i] >= arr[i - 1]){\\n           style += arr[i] - arr[i - 1] + 1;\\n           arr[i] = arr[i - 1] - 1; \\n       }\\n       if(arr[i] >= arr[i + 1]){\\n           style += arr[i] - arr[i + 1] + 1;\\n           arr[i] = arr[i + 1] - 1; \\n       }\\n   }\\n   return style;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar movesToMakeZigzag = function(nums) {\\n   let even = zig(nums, 0, 0);\\n   let odd = zig(nums, 0, 1);\\n   return Math.min(even, odd);\\n};\\n\\nfunction zig(nums, style, start){\\n    let arr = [...nums];\\n    for(let i = start; i < nums.length; i += 2){\\n       if(arr[i] >= arr[i - 1]){\\n           style += arr[i] - arr[i - 1] + 1;\\n           arr[i] = arr[i - 1] - 1; \\n       }\\n       if(arr[i] >= arr[i + 1]){\\n           style += arr[i] - arr[i + 1] + 1;\\n           arr[i] = arr[i + 1] - 1; \\n       }\\n   }\\n   return style;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565384,
                "title": "python-3-line-solution",
                "content": "```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tnums = [float(\\'inf\\')]+nums+[float(\\'inf\\')]\\n\\tn1 = sum(nums[i]-min(nums[i-1], nums[i+1])+1 for i in range(1, len(nums)-1, 2) if nums[i]>=min(nums[i-1], nums[i+1]))\\n\\tn2 = sum(nums[i]-min(nums[i-1], nums[i+1])+1 for i in range(2, len(nums)-1, 2) if nums[i]>=min(nums[i-1], nums[i+1]))        \\n\\treturn min(n1, n2)\\n```\\n\\nAnother more-readable solution\\n```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tnums = [float(\\'inf\\')]+nums+[float(\\'inf\\')]\\n\\tn1 = 0\\n\\tfor i in range(1, len(nums)-1, 2):\\n\\t\\tif nums[i]>=min(nums[i-1], nums[i+1]):\\n\\t\\t\\tn1 += nums[i]-min(nums[i-1], nums[i+1])+1\\n\\tn2 = 0\\n\\tfor i in range(2, len(nums)-1, 2):\\n\\t\\tif nums[i]>=min(nums[i-1], nums[i+1]):\\n\\t\\t\\tn2 += nums[i]-min(nums[i-1], nums[i+1])+1\\n\\treturn min(n1, n2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tnums = [float(\\'inf\\')]+nums+[float(\\'inf\\')]\\n\\tn1 = sum(nums[i]-min(nums[i-1], nums[i+1])+1 for i in range(1, len(nums)-1, 2) if nums[i]>=min(nums[i-1], nums[i+1]))\\n\\tn2 = sum(nums[i]-min(nums[i-1], nums[i+1])+1 for i in range(2, len(nums)-1, 2) if nums[i]>=min(nums[i-1], nums[i+1]))        \\n\\treturn min(n1, n2)\\n```\n```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tnums = [float(\\'inf\\')]+nums+[float(\\'inf\\')]\\n\\tn1 = 0\\n\\tfor i in range(1, len(nums)-1, 2):\\n\\t\\tif nums[i]>=min(nums[i-1], nums[i+1]):\\n\\t\\t\\tn1 += nums[i]-min(nums[i-1], nums[i+1])+1\\n\\tn2 = 0\\n\\tfor i in range(2, len(nums)-1, 2):\\n\\t\\tif nums[i]>=min(nums[i-1], nums[i+1]):\\n\\t\\t\\tn2 += nums[i]-min(nums[i-1], nums[i+1])+1\\n\\treturn min(n1, n2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1734780,
                "title": "simple-java-greedy-solution-with-explaination",
                "content": "class Solution {\\n    \\n\\t//Basic idea is to minimize each index with respect to its neighbours\\n\\tpublic int movesToMakeZigzag(int[] nums) {\\n        int n = nums.length, \\n\\t\\t\\toddCost = 0,  //cost to make odd indices lower than their neighbours cost to make even indices lower than their neighbours\\n\\t\\t\\tevenCost = 0; //cost to make odd indices lower than their neighbours cost to make even indices lower than their neighbours\\n       \\n\\t   for(int i = 0; i < nums.length; i++){\\n            \\n            if((i - 1 >= 0 && nums[i - 1] <= nums[i]) || (i + 1 < n && nums[i + 1] <= nums[i])){ //if any of the neighbour is less than the curr index then reduce it \\n                int min = Integer.MAX_VALUE; //find neigbour with minimum value\\n                \\n                if(i - 1 >= 0)\\n                    min = Math.min(min, nums[i - 1]);\\n                if(i + 1 < n)\\n                    min = Math.min(min, nums[i + 1]);\\n                \\n                int cost = nums[i] - min + 1; //caluclate cost to make the value of current index lower than its neighbours\\n                \\n\\t\\t\\t\\t//add cost to corresponding index cost variable\\n                if(i % 2 == 0)\\n                    evenCost += cost;\\n                else\\n                    oddCost += cost;\\n                \\n            }\\n        }\\n        \\n        return Math.min(oddCost, evenCost);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    \\n\\t//Basic idea is to minimize each index with respect to its neighbours\\n\\tpublic int movesToMakeZigzag(int[] nums) {\\n        int n = nums.length, \\n\\t\\t\\toddCost = 0,  //cost to make odd indices lower than their neighbours cost to make even indices lower than their neighbours\\n\\t\\t\\tevenCost = 0; //cost to make odd indices lower than their neighbours cost to make even indices lower than their neighbours\\n       \\n\\t   for(int i = 0; i < nums.length; i++){\\n            \\n            if((i - 1 >= 0 && nums[i - 1] <= nums[i]) || (i + 1 < n && nums[i + 1] <= nums[i])){ //if any of the neighbour is less than the curr index then reduce it \\n                int min = Integer.MAX_VALUE; //find neigbour with minimum value\\n                \\n                if(i - 1 >= 0)\\n                    min = Math.min(min, nums[i - 1]);\\n                if(i + 1 < n)\\n                    min = Math.min(min, nums[i + 1]);\\n                \\n                int cost = nums[i] - min + 1; //caluclate cost to make the value of current index lower than its neighbours\\n                \\n\\t\\t\\t\\t//add cost to corresponding index cost variable\\n                if(i % 2 == 0)\\n                    evenCost += cost;\\n                else\\n                    oddCost += cost;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1372227,
                "title": "c-0ms-short-code-intuition",
                "content": "There are only 2 ways to make the array zigzag, either take all the odd elements and make them smaller than their neighbours or take all the even elements and make them smaller than their neighbours.\\n\\nThe smaller of these 2 potential solutions is the final ans. Can be done in 2 seperate loops (first consider just the even elements and then the odd ones) or combine for better performance.\\n\\nAt first I was considering a rather complex DP solution which considered the sub problems to the suffixes but that didn\\'t really work and had too many edge cases. This solution is really elegant.\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        const int MAX=numeric_limits<int>::max();\\n        int ans1=0,ans2=0;\\n        for(int i=0; i<n; i++){\\n            int left=(i-1>=0)?nums[i-1]:MAX;\\n            int right=(i+1<n)?nums[i+1]:MAX;\\n            int smallest = min(left, right);\\n            if(i%2 == 0)\\n                ans1 += max(0, nums[i]-smallest+1);\\n            else\\n                ans2 += max(0, nums[i]-smallest+1);    \\n            \\n        }\\n\\n        return min(ans1, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        const int MAX=numeric_limits<int>::max();\\n        int ans1=0,ans2=0;\\n        for(int i=0; i<n; i++){\\n            int left=(i-1>=0)?nums[i-1]:MAX;\\n            int right=(i+1<n)?nums[i+1]:MAX;\\n            int smallest = min(left, right);\\n            if(i%2 == 0)\\n                ans1 += max(0, nums[i]-smallest+1);\\n            else\\n                ans2 += max(0, nums[i]-smallest+1);    \\n            \\n        }\\n\\n        return min(ans1, ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246636,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        nums.push_back(1001);\\n        nums.insert(nums.begin(),1001);\\n        int count1 = 0, count2 =0;\\n        \\n        for(int i=1;i<nums.size()-1;i+=2){\\n            count1+=max(nums[i]-min(nums[i+1],nums[i-1])+1,0);\\n        }\\n        for(int i=2;i<nums.size()-1;i+=2){\\n            count2+=max(nums[i]-min(nums[i+1],nums[i-1])+1,0);\\n        }\\n        \\n        return min(count1,count2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        nums.push_back(1001);\\n        nums.insert(nums.begin(),1001);\\n        int count1 = 0, count2 =0;\\n        \\n        for(int i=1;i<nums.size()-1;i+=2){\\n            count1+=max(nums[i]-min(nums[i+1],nums[i-1])+1,0);\\n        }\\n        for(int i=2;i<nums.size()-1;i+=2){\\n            count2+=max(nums[i]-min(nums[i+1],nums[i-1])+1,0);\\n        }\\n        \\n        return min(count1,count2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205520,
                "title": "java-array-0ms-beats-100-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int movesToMakeZigzag(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint[] arr = new int[len];\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tarr[i] = nums[i];\\n\\t\\tint max1 = zigzag(nums, len, true);\\n\\t\\tint max2 = zigzag(arr, len, false);\\n\\n\\t\\treturn (max1 < max2) ? max1 : max2;\\n\\t}\\n\\n\\t// O(nums.length) O(nums.length)\\n\\tpublic int zigzag(int[] nums, int len, boolean flag) {\\n\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tint m = nums[i] - nums[i - 1];\\n\\t\\t\\tif (m >= 0 && !flag) {\\n\\t\\t\\t\\tcount += nums[i] - nums[i - 1] + 1;\\n\\t\\t\\t\\tnums[i] = nums[i - 1] - 1;\\n\\t\\t\\t} else if (m <= 0 && flag) {\\n\\t\\t\\t\\tcount += nums[i - 1] - nums[i] + 1;\\n\\t\\t\\t\\tnums[i - 1] = nums[i] - 1;\\n\\t\\t\\t}\\n\\t\\t\\tflag = !flag;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(nums.length)\\n\\tpublic int movesToMakeZigzag(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint[] arr = new int[len];\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tarr[i] = nums[i];\\n\\t\\tint max1 = zigzag(nums, len, true);\\n\\t\\tint max2 = zigzag(arr, len, false);\\n\\n\\t\\treturn (max1 < max2) ? max1 : max2;\\n\\t}\\n\\n\\t// O(nums.length) O(nums.length)\\n\\tpublic int zigzag(int[] nums, int len, boolean flag) {\\n\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tint m = nums[i] - nums[i - 1];\\n\\t\\t\\tif (m >= 0 && !flag) {\\n\\t\\t\\t\\tcount += nums[i] - nums[i - 1] + 1;\\n\\t\\t\\t\\tnums[i] = nums[i - 1] - 1;\\n\\t\\t\\t} else if (m <= 0 && flag) {\\n\\t\\t\\t\\tcount += nums[i - 1] - nums[i] + 1;\\n\\t\\t\\t\\tnums[i - 1] = nums[i] - 1;\\n\\t\\t\\t}\\n\\t\\t\\tflag = !flag;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 998380,
                "title": "c-commented-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int ans1=0,ans2=0;\\n         //case1: even idex elements are higher \\n        for(int i=1;i<nums.size();i++) {\\n            if(i%2) {\\n                if(i+1<nums.size()) {\\n                    if(min(nums[i-1],nums[i+1])<=nums[i]) //to make sure the condition is not already satisfied\\n                        ans1 += nums[i] - min(nums[i-1],nums[i+1])+1;\\n                }\\n                else \\n                    if(nums[i-1]<=nums[i]) \\n                        ans1 += nums[i]-nums[i-1] +1;\\n            }\\n        }\\n        //case 2: odd elements are higher\\n        for(int i=0;i<nums.size();i++) {\\n            if(i%2==0) {\\n                \\n                if(i==0) {\\n                    if(nums[i]>=nums[i+1]) \\n                        ans2 += nums[i]-nums[i+1]+1;\\n                }\\n                else if(i+1<nums.size()) {\\n                     if(min(nums[i-1],nums[i+1])<=nums[i]) //to make sure the condition is not already satisfied\\n                        ans2 += nums[i] - min(nums[i-1],nums[i+1])+1;\\n                }\\n                else {\\n                     if(nums[i-1]<=nums[i]) \\n                        ans2 += nums[i]-nums[i-1] +1;\\n                }\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int ans1=0,ans2=0;\\n         //case1: even idex elements are higher \\n        for(int i=1;i<nums.size();i++) {\\n            if(i%2) {\\n                if(i+1<nums.size()) {\\n                    if(min(nums[i-1],nums[i+1])<=nums[i]) //to make sure the condition is not already satisfied\\n                        ans1 += nums[i] - min(nums[i-1],nums[i+1])+1;\\n                }\\n                else \\n                    if(nums[i-1]<=nums[i]) \\n                        ans1 += nums[i]-nums[i-1] +1;\\n            }\\n        }\\n        //case 2: odd elements are higher\\n        for(int i=0;i<nums.size();i++) {\\n            if(i%2==0) {\\n                \\n                if(i==0) {\\n                    if(nums[i]>=nums[i+1]) \\n                        ans2 += nums[i]-nums[i+1]+1;\\n                }\\n                else if(i+1<nums.size()) {\\n                     if(min(nums[i-1],nums[i+1])<=nums[i]) //to make sure the condition is not already satisfied\\n                        ans2 += nums[i] - min(nums[i-1],nums[i+1])+1;\\n                }\\n                else {\\n                     if(nums[i-1]<=nums[i]) \\n                        ans2 += nums[i]-nums[i-1] +1;\\n                }\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933065,
                "title": "c-simple-and-faster-than-100-submission",
                "content": "\\nJust try simple approach:\\n\\t\\tWe can only decrease values of ```nums[i]``` by ```1```.\\nI used first for loop for ```A[0] > A[1] < A[2] > A[3] < A[4] > ...```\\nand second loop for ```A[0] < A[1] > A[2] < A[3] > A[4] < ...```\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int i,j,n=nums.size(),ans=0,temp=0;\\n        for(i=1;i<n;++i){\\n            if(i%2){\\n                if(i+1<n){\\n                    if(min(nums[i-1],nums[i+1])<=nums[i])\\n                        ans+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                }\\n                else{\\n                    if(nums[i-1]<=nums[i])ans+=nums[i]-nums[i-1]+1;\\n                }\\n            }\\n        }\\n        \\n        for(i=0;i<n;++i){\\n            if(i%2==0){\\n                if(i==0){\\n                    if(nums[i]>=nums[i+1])\\n                        temp+=nums[i]-nums[i+1]+1;\\n                }\\n                else if(i+1<n){\\n                    if(min(nums[i-1],nums[i+1])<=nums[i])\\n                        temp+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                }\\n                else{\\n                    if(nums[i-1]<=nums[i])temp+=nums[i]-nums[i-1]+1;\\n                }\\n            }\\n        }\\n        return min(temp,ans);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ee3246d0-be79-4630-ab1d-81bc97f5f369_1605185700.2807567.png)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```nums[i]```\n```1```\n```A[0] > A[1] < A[2] > A[3] < A[4] > ...```\n```A[0] < A[1] > A[2] < A[3] > A[4] < ...```\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int i,j,n=nums.size(),ans=0,temp=0;\\n        for(i=1;i<n;++i){\\n            if(i%2){\\n                if(i+1<n){\\n                    if(min(nums[i-1],nums[i+1])<=nums[i])\\n                        ans+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                }\\n                else{\\n                    if(nums[i-1]<=nums[i])ans+=nums[i]-nums[i-1]+1;\\n                }\\n            }\\n        }\\n        \\n        for(i=0;i<n;++i){\\n            if(i%2==0){\\n                if(i==0){\\n                    if(nums[i]>=nums[i+1])\\n                        temp+=nums[i]-nums[i+1]+1;\\n                }\\n                else if(i+1<n){\\n                    if(min(nums[i-1],nums[i+1])<=nums[i])\\n                        temp+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                }\\n                else{\\n                    if(nums[i-1]<=nums[i])temp+=nums[i]-nums[i-1]+1;\\n                }\\n            }\\n        }\\n        return min(temp,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769867,
                "title": "c-o-n-with-explanation",
                "content": "We will follow the below steps-\\n1. we will first make every element at even index smaller than its adjacents and count the steps to make it smaller\\n2. we will then make every elements at odd index smaller than its adjacents and count the steps to make it smaller\\n3. then we will return the minimum value of the counts obtained in step 1 and step 2\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static int get(vector<int> nums,int a,int n)\\n    {\\n        if(a<0 || a>=n)\\n            return INT_MAX;\\n        return nums[a];\\n    }\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int count[2]={0,0};\\n        int lower,higher,n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lower=get(nums,i-1,n);\\n            higher=get(nums,i+1,n);\\n            lower=min(lower,higher);\\n            if(lower<=nums[i])\\n            {\\n                count[i%2]+= nums[i]-lower+1;\\n            }\\n        }\\n        return min(count[0],count[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int get(vector<int> nums,int a,int n)\\n    {\\n        if(a<0 || a>=n)\\n            return INT_MAX;\\n        return nums[a];\\n    }\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int count[2]={0,0};\\n        int lower,higher,n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lower=get(nums,i-1,n);\\n            higher=get(nums,i+1,n);\\n            lower=min(lower,higher);\\n            if(lower<=nums[i])\\n            {\\n                count[i%2]+= nums[i]-lower+1;\\n            }\\n        }\\n        return min(count[0],count[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355802,
                "title": "java-one-pass-constant-space-beats-100",
                "content": "Iterate over the array. For every element we need to get adjusent elements - at indexes (i - 1) and (i + 1). For corner elements we take max_value, it\\'s good for comparision. Then we need to compare min of those two + 1 with our current element. If difference is greater than 0 - need to make that number of steps. Otherwise just don\\'t increment, or increment by 0. At the end return the smallest of two options. \\n\\nComplexity is O(n) for time - one pass on array. Memory is O(1) - just few state variables.\\n```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int N = nums.length;\\n        int res1 = 0, res2 = 0;\\n        int before, after;\\n\\n        for (int i = 0; i < N; i++) {\\n            //calculate adjacent neighbours - one before and one after\\n            before = (i - 1) >= 0 ? nums[i - 1] : Integer.MAX_VALUE;\\n            after = (i + 1) < N ? nums[i + 1] : Integer.MAX_VALUE;\\n            //calculate running count of steps for each option\\n            int steps = Math.max(0, nums[i] - Math.min(before, after) + 1);\\n            if (i % 2 == 0) res1 += steps;\\n            else res2 += steps;\\n        }\\n        //return min of two options\\n        return Math.min(res1, res2);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int N = nums.length;\\n        int res1 = 0, res2 = 0;\\n        int before, after;\\n\\n        for (int i = 0; i < N; i++) {\\n            //calculate adjacent neighbours - one before and one after\\n            before = (i - 1) >= 0 ? nums[i - 1] : Integer.MAX_VALUE;\\n            after = (i + 1) < N ? nums[i + 1] : Integer.MAX_VALUE;\\n            //calculate running count of steps for each option\\n            int steps = Math.max(0, nums[i] - Math.min(before, after) + 1);\\n            if (i % 2 == 0) res1 += steps;\\n            else res2 += steps;\\n        }\\n        //return min of two options\\n        return Math.min(res1, res2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350965,
                "title": "python-clean-dfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return 0\\n\\n\\t\\t# this global variable record the minimum number of changes.\\n        min_change = float(\\'inf\\')\\n\\t\\t\\n        def dfs(pos, sign, change):\\n\\t\\t\\t# \"pos: position to be checked in nums.\"\\n\\t\\t\\t# \"sign: relation of nums[pos] and nums[pos+1], either `>` or `<`\"\\n\\t\\t\\t# \"change: number of change has been made\"\\n\\n            nonlocal min_change\\n            if pos == len(nums)-1:\\n                min_change = min(min_change, change)\\n                return\\n\\n            diff = nums[pos] - nums[pos+1]\\n            if sign == \\'>\\':\\n                if diff > 0:\\n                    dfs(pos+1, \\'<\\', change)\\n                else:\\n                    nums[pos+1] += (diff-1)\\n                    dfs(pos+1, \\'<\\', change-diff+1)\\n                    nums[pos+1] -= (diff-1)\\n            else:\\n                if diff < 0:\\n                    dfs(pos+1, \\'>\\', change)\\n                else:\\n                    dfs(pos+1, \\'>\\', change+diff+1)\\n\\t\\t\\t\\t\\t\\n        # two cases to be considered\\n        dfs(0, \\'>\\', 0)\\n        dfs(0, \\'<\\', 0)\\n\\n        return int(min_change)\\n\\t```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return 0\\n\\n\\t\\t# this global variable record the minimum number of changes.\\n        min_change = float(\\'inf\\')\\n\\t\\t\\n        def dfs(pos, sign, change):\\n\\t\\t\\t# \"pos: position to be checked in nums.\"\\n\\t\\t\\t# \"sign: relation of nums[pos] and nums[pos+1], either `>` or `<`\"\\n\\t\\t\\t# \"change: number of change has been made\"\\n\\n            nonlocal min_change\\n            if pos == len(nums)-1:\\n                min_change = min(min_change, change)\\n                return\\n\\n            diff = nums[pos] - nums[pos+1]\\n            if sign == \\'>\\':\\n                if diff > 0:\\n                    dfs(pos+1, \\'<\\', change)\\n                else:\\n                    nums[pos+1] += (diff-1)\\n                    dfs(pos+1, \\'<\\', change-diff+1)\\n                    nums[pos+1] -= (diff-1)\\n            else:\\n                if diff < 0:\\n                    dfs(pos+1, \\'>\\', change)\\n                else:\\n                    dfs(pos+1, \\'>\\', change+diff+1)\\n\\t\\t\\t\\t\\t\\n        # two cases to be considered\\n        dfs(0, \\'>\\', 0)\\n        dfs(0, \\'<\\', 0)\\n\\n        return int(min_change)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 350631,
                "title": "c-straight-forward-easy-to-understand",
                "content": "Since it only allows to decrease, calculate the even and odd to make it zigzag respectively, and return the smaller one.\\n\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        int res_odd=0,res_even=0;\\n        for(int i=0;i<nums.size();i+=2){\\n            int tmp=0;\\n            if(i>0) tmp=max(nums[i]-nums[i-1]+1,tmp);\\n            if(i<nums.size()-1) tmp=max(nums[i]-nums[i+1]+1,tmp);\\n            res_even+=tmp;\\n        }\\n        for(int i=1;i<nums.size();i+=2){\\n            int tmp=0;\\n            tmp=max(nums[i]-nums[i-1]+1,tmp);\\n            if(i<nums.size()-1) tmp=max(nums[i]-nums[i+1]+1,tmp);\\n            res_odd+=tmp;\\n        }\\n        return min(res_even,res_odd);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        int res_odd=0,res_even=0;\\n        for(int i=0;i<nums.size();i+=2){\\n            int tmp=0;\\n            if(i>0) tmp=max(nums[i]-nums[i-1]+1,tmp);\\n            if(i<nums.size()-1) tmp=max(nums[i]-nums[i+1]+1,tmp);\\n            res_even+=tmp;\\n        }\\n        for(int i=1;i<nums.size();i+=2){\\n            int tmp=0;\\n            tmp=max(nums[i]-nums[i-1]+1,tmp);\\n            if(i<nums.size()-1) tmp=max(nums[i]-nums[i+1]+1,tmp);\\n            res_odd+=tmp;\\n        }\\n        return min(res_even,res_odd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163231,
                "title": "crisp-n-clear-o-n-javascript-memory-beats-100-meaningful-vars",
                "content": "# Intuition\\nFind total cost if Odd Indexed has to be greater\\nFind total cost if Odd Indexed has to be greater\\nmin cost out of both approaches gonna be the final output\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar movesToMakeZigzagEvenIndexed = function(nums) {\\n\\tlet totalCost = 0;\\n\\tlet previousValue = null;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (index === 0) {\\n\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t} else if (index % 2 === 0) {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue < currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = previousValue - currentValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue > currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = currentValue - previousValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue - tempTotalCost;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn totalCost;\\n};\\n\\nvar movesToMakeZigzagOddIndexed = function(nums) {\\n\\tlet totalCost = 0;\\n\\tlet previousValue = null;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (index === 0) {\\n\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t} else if (index % 2 === 0) {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue > currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = currentValue - previousValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue - tempTotalCost;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue < currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = previousValue - currentValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn totalCost;\\n};\\n\\nvar movesToMakeZigzag = function(nums) {\\n\\tconst fromOdd = movesToMakeZigzagOddIndexed(nums);\\n\\tconst fromEven = movesToMakeZigzagEvenIndexed(nums);\\n\\tconst finalResponse = Math.min(fromOdd, fromEven);\\n\\treturn finalResponse;\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/3d66ba03-2529-4c11-a507-4b2fce67e37e_1675926133.50146.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar movesToMakeZigzagEvenIndexed = function(nums) {\\n\\tlet totalCost = 0;\\n\\tlet previousValue = null;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (index === 0) {\\n\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t} else if (index % 2 === 0) {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue < currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = previousValue - currentValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue > currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = currentValue - previousValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue - tempTotalCost;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn totalCost;\\n};\\n\\nvar movesToMakeZigzagOddIndexed = function(nums) {\\n\\tlet totalCost = 0;\\n\\tlet previousValue = null;\\n\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\tif (index === 0) {\\n\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t} else if (index % 2 === 0) {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue > currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = currentValue - previousValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue - tempTotalCost;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tconst currentValue = nums[index];\\n\\t\\t\\tif (!(previousValue < currentValue)) {\\n\\t\\t\\t\\tconst tempTotalCost = previousValue - currentValue + 1;\\n\\t\\t\\t\\ttotalCost += tempTotalCost;\\n\\t\\t\\t\\tpreviousValue = currentValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreviousValue = nums[index];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn totalCost;\\n};\\n\\nvar movesToMakeZigzag = function(nums) {\\n\\tconst fromOdd = movesToMakeZigzagOddIndexed(nums);\\n\\tconst fromEven = movesToMakeZigzagEvenIndexed(nums);\\n\\tconst finalResponse = Math.min(fromOdd, fromEven);\\n\\treturn finalResponse;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777973,
                "title": "java-o-n-solution",
                "content": "# Intuition\\nHandle both odd and even case separately\\n\\n# Approach\\ncalculate cost if even index will be max\\nand calculate cost when odd index will be max\\nreturn the minmum cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        if(nums.length==1)return 0;\\n        if(nums.length==2 && nums[0]!=nums[1])return 0;\\n        if(nums.length==2 && nums[0]==nums[1])return 1;\\n        int even=0,odd=0;\\n\\n        int arr[]=nums.clone();\\n\\n        for(int i=0;i<nums.length;i=i+2)\\n        {   \\n           if(i+1 < nums.length)\\n            {\\n                if(nums[i]<=nums[i+1])\\n                {\\n                    even +=(nums[i+1]-nums[i])+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n                \\n            }\\n\\n            if(i-1 >= 0)\\n            {\\n                if(nums[i]<=nums[i-1])\\n                {\\n                    even +=(nums[i-1]-nums[i])+1;\\n                    nums[i-1]=nums[i]-1;\\n                }\\n\\n            }\\n            \\n\\n        }\\n\\n        for(int i=1;i<nums.length;i=i+2)\\n        {   \\n            if(i+1 < nums.length)\\n            {\\n                if(arr[i]<=arr[i+1])\\n                {\\n                    odd +=(arr[i+1]-arr[i])+1;\\n                    arr[i+1]=arr[i]-1;\\n                }\\n                \\n            }\\n\\n            if(i-1 >= 0)\\n            {\\n                if(arr[i]<=arr[i-1])\\n                {\\n                    odd +=(arr[i-1]-arr[i])+1;\\n                    arr[i-1]=arr[i]-1;\\n                }\\n\\n            }\\n\\n            // System.out.println(odd+\" \"+Arrays.toString(arr));\\n            \\n\\n        }\\n\\n\\n    return Math.min(even,odd);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        if(nums.length==1)return 0;\\n        if(nums.length==2 && nums[0]!=nums[1])return 0;\\n        if(nums.length==2 && nums[0]==nums[1])return 1;\\n        int even=0,odd=0;\\n\\n        int arr[]=nums.clone();\\n\\n        for(int i=0;i<nums.length;i=i+2)\\n        {   \\n           if(i+1 < nums.length)\\n            {\\n                if(nums[i]<=nums[i+1])\\n                {\\n                    even +=(nums[i+1]-nums[i])+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n                \\n            }\\n\\n            if(i-1 >= 0)\\n            {\\n                if(nums[i]<=nums[i-1])\\n                {\\n                    even +=(nums[i-1]-nums[i])+1;\\n                    nums[i-1]=nums[i]-1;\\n                }\\n\\n            }\\n            \\n\\n        }\\n\\n        for(int i=1;i<nums.length;i=i+2)\\n        {   \\n            if(i+1 < nums.length)\\n            {\\n                if(arr[i]<=arr[i+1])\\n                {\\n                    odd +=(arr[i+1]-arr[i])+1;\\n                    arr[i+1]=arr[i]-1;\\n                }\\n                \\n            }\\n\\n            if(i-1 >= 0)\\n            {\\n                if(arr[i]<=arr[i-1])\\n                {\\n                    odd +=(arr[i-1]-arr[i])+1;\\n                    arr[i-1]=arr[i]-1;\\n                }\\n\\n            }\\n\\n            // System.out.println(odd+\" \"+Arrays.toString(arr));\\n            \\n\\n        }\\n\\n\\n    return Math.min(even,odd);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629992,
                "title": "python-the-cleanest-and-easiest-to-understand-solution-possible",
                "content": "```python\\ndef moves_to_make_zigzag(nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\n    # Calculate how much it would cost to make the number at index i smaller than both its neighbors\\n\\tdef calc_cost(i):\\n\\t\\tleft = math.inf if i == 0 else nums[i - 1] \\n\\t\\tright = math.inf if i == n - 1 else nums[i + 1] \\n\\t\\tsmaller_neighbor = min(left, right)\\n\\t\\tif nums[i] >= smaller_neighbor:\\n\\t\\t\\treturn (nums[i] - smaller_neighbor) + 1\\n\\t\\telse:\\n\\t\\t\\treturn 0\\n\\n\\teven_cost = sum([calc_cost(i) for i in range(0, n, 2)])\\n\\todd_cost = sum([calc_cost(i) for i in range(1, n, 2)])\\n\\treturn min(even_cost, odd_cost)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef moves_to_make_zigzag(nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\n    # Calculate how much it would cost to make the number at index i smaller than both its neighbors\\n\\tdef calc_cost(i):\\n\\t\\tleft = math.inf if i == 0 else nums[i - 1] \\n\\t\\tright = math.inf if i == n - 1 else nums[i + 1] \\n\\t\\tsmaller_neighbor = min(left, right)\\n\\t\\tif nums[i] >= smaller_neighbor:\\n\\t\\t\\treturn (nums[i] - smaller_neighbor) + 1\\n\\t\\telse:\\n\\t\\t\\treturn 0\\n\\n\\teven_cost = sum([calc_cost(i) for i in range(0, n, 2)])\\n\\todd_cost = sum([calc_cost(i) for i in range(1, n, 2)])\\n\\treturn min(even_cost, odd_cost)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2599543,
                "title": "c-easy-to-understand-good-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oddSum = 0, evenSum = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(i%2 == 0){\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                evenSum += max(nums[i]-min(left,right)+1,0);\\n            }else{\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                oddSum += max(nums[i]-min(left,right)+1,0);\\n            }\\n        }\\n        return min(evenSum,oddSum);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oddSum = 0, evenSum = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(i%2 == 0){\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                evenSum += max(nums[i]-min(left,right)+1,0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2524281,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-greedy",
                "content": "```C#\\npublic class Solution {\\n    public int MovesToMakeZigzag(int[] nums) {\\n        return Math.Min(Solve(0), Solve(1));\\n        \\n        int Solve(int startIndex) {\\n            int ans = 0;\\n            for (int i = startIndex; i < nums.Length; i += 2) {\\n                int left = i != 0 ? nums[i - 1] : int.MaxValue;\\n                int right = i < nums.Length - 1 ? nums[i + 1] : int.MaxValue;\\n                ans += Math.Max(0, nums[i] - Math.Min(left, right) + 1);\\n            }\\n            \\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MovesToMakeZigzag(int[] nums) {\\n        return Math.Min(Solve(0), Solve(1));\\n        \\n        int Solve(int startIndex) {\\n            int ans = 0;\\n            for (int i = startIndex; i < nums.Length; i += 2) {\\n                int left = i != 0 ? nums[i - 1] : int.MaxValue;\\n                int right = i < nums.Length - 1 ? nums[i + 1] : int.MaxValue;\\n                ans += Math.Max(0, nums[i] - Math.Min(left, right) + 1);\\n            }\\n            \\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278191,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oddSum = 0, evenSum = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(i%2 == 0){\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                evenSum += max(nums[i]-min(left,right)+1,0);\\n            }else{\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                oddSum += max(nums[i]-min(left,right)+1,0);\\n            }\\n        }\\n        return min(evenSum,oddSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oddSum = 0, evenSum = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(i%2 == 0){\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                evenSum += max(nums[i]-min(left,right)+1,0);\\n            }else{\\n                int left = i==0?INT_MAX:nums[i-1];\\n                int right = i==n-1?INT_MAX:nums[i+1];\\n                oddSum += max(nums[i]-min(left,right)+1,0);\\n            }\\n        }\\n        return min(evenSum,oddSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278172,
                "title": "80-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tif(n == 1):\\n\\t\\treturn 0\\n\\tt1 = t2 = 0\\n\\tfor i in range(n):\\n\\t\\t# for t1\\n\\t\\tif(i % 2):\\n\\t\\t\\tif(i == n-1):\\n\\t\\t\\t\\tt1 += max(0, nums[i] - nums[i-1] + 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tt1 += max(0, nums[i] - min(nums[i+1], nums[i-1]) + 1)\\n\\n\\t\\t# for t2\\n\\t\\telse:\\n\\t\\t\\tif(i == 0):\\n\\t\\t\\t\\tt2 += max(0, nums[i] - nums[i+1] + 1)\\n\\t\\t\\telif(i == n-1):\\n\\t\\t\\t\\tt2 += max(0, nums[i] - nums[i-1] + 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tt2 += max(0, nums[i] - min(nums[i+1], nums[i-1]) + 1)\\n\\treturn min(t1, t2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tif(n == 1):\\n\\t\\treturn 0\\n\\tt1 = t2 = 0\\n\\tfor i in range(n):\\n\\t\\t# for t1\\n\\t\\tif(i % 2):\\n\\t\\t\\tif(i == n-1):\\n\\t\\t\\t\\tt1 += max(0, nums[i] - nums[i-1] + 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tt1 += max(0, nums[i] - min(nums[i+1], nums[i-1]) + 1)\\n\\n\\t\\t# for t2\\n\\t\\telse:\\n\\t\\t\\tif(i == 0):\\n\\t\\t\\t\\tt2 += max(0, nums[i] - nums[i+1] + 1)\\n\\t\\t\\telif(i == n-1):\\n\\t\\t\\t\\tt2 += max(0, nums[i] - nums[i-1] + 1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tt2 += max(0, nums[i] - min(nums[i+1], nums[i-1]) + 1)\\n\\treturn min(t1, t2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2226197,
                "title": "c-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& nums,int j){\\n        int n = 0;\\n        for(int i = j; i<nums.size();i+=2){\\n            int l = 0;\\n            if(i-1>=0 && nums[i-1]<=nums[i]) l = max(l,abs(nums[i]-nums[i-1])+1);\\n            if(i+1<nums.size() && nums[i+1]<=nums[i]) l = max(l,abs(nums[i]-nums[i+1])+1);\\n            n+=l;\\n        }\\n        return n;\\n    }\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        return min(find(nums,0),find(nums,1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& nums,int j){\\n        int n = 0;\\n        for(int i = j; i<nums.size();i+=2){\\n            int l = 0;\\n            if(i-1>=0 && nums[i-1]<=nums[i]) l = max(l,abs(nums[i]-nums[i-1])+1);\\n            if(i+1<nums.size() && nums[i+1]<=nums[i]) l = max(l,abs(nums[i]-nums[i+1])+1);\\n            n+=l;\\n        }\\n        return n;\\n    }\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        return min(find(nums,0),find(nums,1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121044,
                "title": "o-n-traversal-but-need-to-consider-every-edge-case",
                "content": "Have to evaluate odds and even moves for array to be zig zag. Found it to be a little tough for the edge cases **only**.\\n\\n``` csharp\\npublic int MovesToMakeZigzag(int[] nums) {\\n        if (nums == null) return 0;\\n        if (nums.Length <=1) return 0;\\n        \\n        if (nums.Length == 2)\\n            return nums[0] == nums[1] ? 1 : 0;\\n            \\n        var len = nums.Length;\\n        \\n        int oddMoves = 0; int evenMoves = 0;\\n        for(int i = 0; i < len; i++){\\n            if (i == 0) \\n                evenMoves+= nums[i]>=nums[i+1] ? Math.Abs(nums[1] - nums[0]) + 1 : 0;\\n            else if (i == len - 1){\\n                var lastElementIsOdd = (len - 1) % 2 == 1;\\n                var moves = nums[i]>=nums[i-1] ? Math.Abs(nums[len-1] - nums[len-2]) + 1 : 0;\\n                oddMoves+= lastElementIsOdd ? moves : 0;\\n                evenMoves+= !lastElementIsOdd ? moves: 0;\\n            }\\n            else if (i % 2 == 1) \\n                oddMoves+= (nums[i+1] <= nums[i] || nums[i-1] <= nums[i]) ? Math.Abs(Math.Min(nums[i-1], nums[i+1]) - nums[i])+1: 0;\\n            else if (i % 2 == 0) \\n                evenMoves+= (nums[i+1] <= nums[i] || nums[i-1] <= nums[i]) ? Math.Abs(Math.Min(nums[i-1], nums[i+1]) - nums[i])+1: 0;\\n        }\\n        \\n        return Math.Min(oddMoves, evenMoves);     \\n    }\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic int MovesToMakeZigzag(int[] nums) {\\n        if (nums == null) return 0;\\n        if (nums.Length <=1) return 0;\\n        \\n        if (nums.Length == 2)\\n            return nums[0] == nums[1] ? 1 : 0;\\n            \\n        var len = nums.Length;\\n        \\n        int oddMoves = 0; int evenMoves = 0;\\n        for(int i = 0; i < len; i++){\\n            if (i == 0) \\n                evenMoves+= nums[i]>=nums[i+1] ? Math.Abs(nums[1] - nums[0]) + 1 : 0;\\n            else if (i == len - 1){\\n                var lastElementIsOdd = (len - 1) % 2 == 1;\\n                var moves = nums[i]>=nums[i-1] ? Math.Abs(nums[len-1] - nums[len-2]) + 1 : 0;\\n                oddMoves+= lastElementIsOdd ? moves : 0;\\n                evenMoves+= !lastElementIsOdd ? moves: 0;\\n            }\\n            else if (i % 2 == 1) \\n                oddMoves+= (nums[i+1] <= nums[i] || nums[i-1] <= nums[i]) ? Math.Abs(Math.Min(nums[i-1], nums[i+1]) - nums[i])+1: 0;\\n            else if (i % 2 == 0) \\n                evenMoves+= (nums[i+1] <= nums[i] || nums[i-1] <= nums[i]) ? Math.Abs(Math.Min(nums[i-1], nums[i+1]) - nums[i])+1: 0;\\n        }\\n        \\n        return Math.Min(oddMoves, evenMoves);     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061597,
                "title": "0ms",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        \\n        //nothing just two patterns one of the two will surely give a result\\n        int n=nums.size();\\n        //base cases\\n        if(n==1)\\n            return 0;\\n        if(n==2 && nums[0]==nums[1])\\n            return 1;\\n        else if(n==2)\\n            return 0;\\n        \\n        \\n        \\n        vector<int>temp=nums;\\n        //making odd minimum\\n        int res=0;\\n        for(int i=1;i<temp.size()-1;i+=2){\\n            if(temp[i]<temp[i-1] && temp[i+1]>temp[i])\\n                continue;\\n            \\n            int x=min(temp[i-1],temp[i+1]);\\n            res+=temp[i]-x+1;\\n            temp[i]=x-1;\\n        }\\n        if(temp.size()%2==0){\\n            if(temp[n-2]<=temp[n-1])\\n                res+=temp[n-1]-temp[n-2]+1;\\n        }\\n      \\n        //now the second making the even minimum\\n        int ans=0;\\n        if(nums[1]<=nums[0]){\\n            ans+=nums[0]-nums[1]+1;\\n            nums[0]=nums[1]-1;\\n        }\\n       \\n            \\n        \\n        for(int i=2;i<n-1;i+=2){\\n           if(nums[i]<nums[i-1] && nums[i+1]>nums[i])\\n                continue;\\n            \\n            int x=min(nums[i-1],nums[i+1]);\\n            ans+=nums[i]-x+1;\\n            nums[i]=x-1;   \\n        }\\n        if(n%2!=0){\\n          if(nums[n-2]<=nums[n-1])\\n              ans+=nums[n-1]-nums[n-2]+1;\\n        }\\n        cout<<res<<\" \"<<ans<<\" \"<<n;\\n        return min(res,ans);\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        \\n        //nothing just two patterns one of the two will surely give a result\\n        int n=nums.size();\\n        //base cases\\n        if(n==1)\\n            return 0;\\n        if(n==2 && nums[0]==nums[1])\\n            return 1;\\n        else if(n==2)\\n            return 0;\\n        \\n        \\n        \\n        vector<int>temp=nums;\\n        //making odd minimum\\n        int res=0;\\n        for(int i=1;i<temp.size()-1;i+=2){\\n            if(temp[i]<temp[i-1] && temp[i+1]>temp[i])\\n                continue;\\n            \\n            int x=min(temp[i-1],temp[i+1]);\\n            res+=temp[i]-x+1;\\n            temp[i]=x-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1829303,
                "title": "java-easy-to-understand-time-o-n-space-o-1",
                "content": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n\\treturn Math.min(movesUtil(nums, 0), movesUtil(nums, 1));    \\n}\\n\\nprivate int movesUtil(int[] arr, int odd) {\\n\\tint moves = 0;\\n\\tfor (int i = odd; i < arr.length; i+=2) {\\n\\t\\tint left = i > 0 ? arr[i-1] : Integer.MAX_VALUE;\\n\\t\\tint right = i < arr.length-1 ? arr[i+1] : Integer.MAX_VALUE;\\n\\t\\tif (left <= arr[i] || right <= arr[i]) {\\n\\t\\t\\tmoves += arr[i] - Math.min(left, right) + 1;\\n\\t\\t}\\n\\t}\\n\\treturn moves;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n\\treturn Math.min(movesUtil(nums, 0), movesUtil(nums, 1));    \\n}\\n\\nprivate int movesUtil(int[] arr, int odd) {\\n\\tint moves = 0;\\n\\tfor (int i = odd; i < arr.length; i+=2) {\\n\\t\\tint left = i > 0 ? arr[i-1] : Integer.MAX_VALUE;\\n\\t\\tint right = i < arr.length-1 ? arr[i+1] : Integer.MAX_VALUE;\\n\\t\\tif (left <= arr[i] || right <= arr[i]) {\\n\\t\\t\\tmoves += arr[i] - Math.min(left, right) + 1;\\n\\t\\t}\\n\\t}\\n\\treturn moves;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987483,
                "title": "python3-intuitive-o-n-with-explanation",
                "content": "Since we can only decreasing number by 1, so we decrease the number till it smaller than its neighbors.\\nThen we just check every even index or every odd index\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        nums=[float(\\'inf\\')]+nums+[float(\\'inf\\')]\\n        def helper(start):\\n            tmp=0\\n            for i in range(start,len(nums)-1,2):\\n                tmp+=(min(nums[i-1],nums[i+1])<=nums[i])*(nums[i]-min(nums[i-1],nums[i+1])+1)\\n            return tmp\\n        return min(helper(1),helper(2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        nums=[float(\\'inf\\')]+nums+[float(\\'inf\\')]\\n        def helper(start):\\n            tmp=0\\n            for i in range(start,len(nums)-1,2):\\n                tmp+=(min(nums[i-1],nums[i+1])<=nums[i])*(nums[i]-min(nums[i-1],nums[i+1])+1)\\n            return tmp\\n        return min(helper(1),helper(2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891850,
                "title": "python-3-greedy-two-pass-explanation",
                "content": "### Explanation\\n- There are only 2 possbilities\\n\\t- either, the first number is smaller than the second, and zigzag going forward\\n\\t- or, the first number is larger than the second, and zigzag going forward\\n- Modify the array acoordingly for each case and take the minimum change between two scenarios\\n- Note that each move is a greedy move, because it\\'s required to have the zigzag path or you failed\\n\\t- For example `7 5 8`, if we are assuming `small_first==True`, meaning start with first num < second num\\n\\t- Based on following algorithm, you will get `7 8 7` in the end\\n\\t- And that is same move as `7 9 8`, if you are thinking to make the second number greater than both of its neighbors; this will be more difficult to manage and that\\'s why we are taking a greedy apporach\\n### Implementation\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        def greedy(nums, small_first=True):\\n            if n <= 1: return 0\\n            ans = 0\\n            for i in range(n-1):\\n                if small_first and nums[i] >= nums[i+1]:\\n                    ans += nums[i] - (nums[i+1]-1)\\n                    nums[i] = nums[i+1] - 1\\n                elif not small_first and nums[i] <= nums[i+1]:\\n                    ans += nums[i+1] - (nums[i]-1)\\n                    nums[i+1] = nums[i] - 1\\n                small_first = not small_first\\n            return ans    \\n        n = len(nums)\\n        return min(greedy(nums[:], True), greedy(nums[:], False))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        def greedy(nums, small_first=True):\\n            if n <= 1: return 0\\n            ans = 0\\n            for i in range(n-1):\\n                if small_first and nums[i] >= nums[i+1]:\\n                    ans += nums[i] - (nums[i+1]-1)\\n                    nums[i] = nums[i+1] - 1\\n                elif not small_first and nums[i] <= nums[i+1]:\\n                    ans += nums[i+1] - (nums[i]-1)\\n                    nums[i+1] = nums[i] - 1\\n                small_first = not small_first\\n            return ans    \\n        n = len(nums)\\n        return min(greedy(nums[:], True), greedy(nums[:], False))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758077,
                "title": "100-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int help1(vector<int> &A,int i){\\n    int ans = 0;\\n    if(A.size()<2) return 0;\\n    for(;i<A.size();i+=2){\\n        if(i==0) ans+=max(A[i]-A[i+1]+1,0);\\n        else if(i==A.size()-1) ans+= max(A[i]-A[i-1]+1,0);\\n        else ans+= max({A[i]-A[i+1]+1,0,A[i]-A[i-1]+1});\\n    }\\n    return ans;\\n}\\n\\n\\nint movesToMakeZigzag(vector<int>& nums) {\\n    return min(help1(nums,0),help1(nums,1));\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help1(vector<int> &A,int i){\\n    int ans = 0;\\n    if(A.size()<2) return 0;\\n    for(;i<A.size();i+=2){\\n        if(i==0) ans+=max(A[i]-A[i+1]+1,0);\\n        else if(i==A.size()-1) ans+= max(A[i]-A[i-1]+1,0);\\n        else ans+= max({A[i]-A[i+1]+1,0,A[i]-A[i-1]+1});\\n    }\\n    return ans;\\n}\\n\\n\\nint movesToMakeZigzag(vector<int>& nums) {\\n    return min(help1(nums,0),help1(nums,1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720898,
                "title": "cpp-solution-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decrease Elements To Make Array Zigzag.\\nMemory Usage: 7.4 MB, less than 26.92% of C++ online submissions for Decrease Elements To Make Array Zigzag.\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        vector<int> temp = nums;\\n        int even = 0, odd = 0, i, n = nums.size();\\n        //round 1 make 0,2,4...greater if it isnt makes its greater negihbour less than 1 than cur element\\n        for(i = 0; i < n; i += 2){\\n            int left = INT_MIN, right = INT_MIN;\\n            if(i+1 < n) right = nums[i+1];\\n            if(i-1 > 0) left = nums[i-1];\\n            if(nums[i] > left && nums[i] > right){}\\n            else{\\n                \\n                if(left >= nums[i]){ \\n                    even += (left - nums[i] + 1);\\n                    nums[i-1] = nums[i] - 1;\\n                }\\n                if(right >= nums[i]){\\n                    even += (right - nums[i] + 1);\\n                    nums[i+1] = nums[i] - 1;\\n                }    \\n            }\\n        }\\n        nums = temp;\\n        //round 2 make 1,3,5.. greater if it isnt makes its greater negihbour less than 1 than cur element\\n        for(i = 1; i < n; i += 2){\\n            int left = INT_MIN, right = INT_MIN;\\n            if(i+1 < n) right = nums[i+1];\\n            if(i-1 >= 0) left = nums[i-1];\\n            if(nums[i] > left && nums[i] > right){}\\n            else{\\n                if(left >= nums[i]){        \\n                    odd += (left - nums[i] + 1);\\n                    nums[i-1] = nums[i] - 1;\\n                }\\n                if(right >= nums[i]){\\n                    odd += (right - nums[i] + 1);\\n                    nums[i+1] = nums[i] - 1;\\n                }    \\n            }\\n        }\\n        return min(even,odd);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        vector<int> temp = nums;\\n        int even = 0, odd = 0, i, n = nums.size();\\n        //round 1 make 0,2,4...greater if it isnt makes its greater negihbour less than 1 than cur element\\n        for(i = 0; i < n; i += 2){\\n            int left = INT_MIN, right = INT_MIN;\\n            if(i+1 < n) right = nums[i+1];\\n            if(i-1 > 0) left = nums[i-1];\\n            if(nums[i] > left && nums[i] > right){}",
                "codeTag": "Java"
            },
            {
                "id": 692922,
                "title": "java-100-time",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n\\t\\t// need to copy nums because we are modifying it.\\n        return Math.min(moves(Arrays.copyOf(nums, nums.length), 1), moves(nums, 0));\\n    }\\n    \\n    int moves(int[] nums, int odd) {\\n        int moves = 0;\\n        for (int i=0;i<nums.length;i++) {\\n            if (i%2 == odd) {\\n                if (i > 0 && nums[i-1] >= nums[i]) {\\n                    int diff = nums[i-1]-nums[i]+1;\\n                    moves += diff;\\n                    nums[i-1] -= diff;\\n                }\\n                if (i < nums.length-1 && nums[i+1] >= nums[i]) {\\n                    int diff = nums[i+1]-nums[i]+1;\\n                    moves += diff;\\n                    nums[i+1] -= diff;\\n                }\\n            } \\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n\\t\\t// need to copy nums because we are modifying it.\\n        return Math.min(moves(Arrays.copyOf(nums, nums.length), 1), moves(nums, 0));\\n    }\\n    \\n    int moves(int[] nums, int odd) {\\n        int moves = 0;\\n        for (int i=0;i<nums.length;i++) {\\n            if (i%2 == odd) {\\n                if (i > 0 && nums[i-1] >= nums[i]) {\\n                    int diff = nums[i-1]-nums[i]+1;\\n                    moves += diff;\\n                    nums[i-1] -= diff;\\n                }\\n                if (i < nums.length-1 && nums[i+1] >= nums[i]) {\\n                    int diff = nums[i+1]-nums[i]+1;\\n                    moves += diff;\\n                    nums[i+1] -= diff;\\n                }\\n            } \\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596829,
                "title": "easy-to-understand-java-solution-1-pass",
                "content": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n         \\n        int oddmove = 0;\\n        int evenmove = 0;\\n        \\n        for(int i = 0; i < nums.length ; i++){\\n            int left = (i > 0)? nums[i-1]: Integer.MAX_VALUE;\\n            int right = (i < nums.length -1)? nums[i+1]: Integer.MAX_VALUE;\\n            \\n            if(i % 2 == 0){\\n                if(nums[i] < Math.min(left, right))\\n                    continue; \\n                else if(nums[i] >= Math.min(left, right))\\n                    evenmove += nums[i] - (Math.min(left, right) -1);\\n                else if (nums[i] >= Math.max(left, right))\\n                    evenmove += nums[i] - (Math.max(left, right) -1);   \\n                \\n                System.out.println(evenmove);\\n            }\\n        \\n            if(i % 2 == 1){\\n                if(nums[i] < Math.min(left, right))\\n                    continue; \\n                else if(nums[i] >= Math.min(left, right))\\n                    oddmove += nums[i] - (Math.min(left, right) -1);\\n                else if (nums[i] >= Math.max(left, right))\\n                    oddmove += nums[i] - (Math.max(left, right) -1);\\n            }\\n        }\\n        \\n        return Math.min(oddmove, evenmove);\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n         \\n        int oddmove = 0;\\n        int evenmove = 0;\\n        \\n        for(int i = 0; i < nums.length ; i++){\\n            int left = (i > 0)? nums[i-1]: Integer.MAX_VALUE;\\n            int right = (i < nums.length -1)? nums[i+1]: Integer.MAX_VALUE;\\n            \\n            if(i % 2 == 0){\\n                if(nums[i] < Math.min(left, right))\\n                    continue; \\n                else if(nums[i] >= Math.min(left, right))\\n                    evenmove += nums[i] - (Math.min(left, right) -1);\\n                else if (nums[i] >= Math.max(left, right))\\n                    evenmove += nums[i] - (Math.max(left, right) -1);   \\n                \\n                System.out.println(evenmove);\\n            }\\n        \\n            if(i % 2 == 1){\\n                if(nums[i] < Math.min(left, right))\\n                    continue; \\n                else if(nums[i] >= Math.min(left, right))\\n                    oddmove += nums[i] - (Math.min(left, right) -1);\\n                else if (nums[i] >= Math.max(left, right))\\n                    oddmove += nums[i] - (Math.max(left, right) -1);\\n            }\\n        }\\n        \\n        return Math.min(oddmove, evenmove);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488184,
                "title": "python-short-simple-solution",
                "content": "We only need to decrease a subset of the numbers with odd indices or subset of the numbers with even indices. We decrease the number so it is lower than their neighbors.\\n\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        \\n        def calc(start):\\n            moves = 0\\n            for i in range(start, len(nums), 2):\\n                to = nums[i]\\n                if i > 0:\\n\\t\\t\\t\\t     # `to` should be lower than the left neighbor\\n                    to = min(to, nums[i - 1] - 1)\\n                if i + 1 < len(nums):\\n\\t\\t\\t\\t     # `to` should be lower than the right neighbor\\n                    to = min(to, nums[i + 1] - 1)\\n\\t\\t\\t\\t# We decrease `nums[i]` to `to` \\n                moves += nums[i] - to    \\n            return moves    \\n        \\n\\t\\t# We start at index 0 or 1 based on if we handle the odd or even numbers\\n        return min(calc(0), calc(1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        \\n        def calc(start):\\n            moves = 0\\n            for i in range(start, len(nums), 2):\\n                to = nums[i]\\n                if i > 0:\\n\\t\\t\\t\\t     # `to` should be lower than the left neighbor\\n                    to = min(to, nums[i - 1] - 1)\\n                if i + 1 < len(nums):\\n\\t\\t\\t\\t     # `to` should be lower than the right neighbor\\n                    to = min(to, nums[i + 1] - 1)\\n\\t\\t\\t\\t# We decrease `nums[i]` to `to` \\n                moves += nums[i] - to    \\n            return moves    \\n        \\n\\t\\t# We start at index 0 or 1 based on if we handle the odd or even numbers\\n        return min(calc(0), calc(1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486942,
                "title": "100-100-on-c",
                "content": "```class Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int even = 0;\\n        int odd = 0;\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            int min_neighbour = 1e5;\\n            if(i-1 >=0)\\n            {\\n                min_neighbour = min(min_neighbour, nums[i-1]);\\n            }\\n            if(i+1 <nums.size())\\n            {\\n                min_neighbour = min(min_neighbour, nums[i+1]);\\n            }\\n            if(nums[i] >= min_neighbour)\\n            {\\n                int diff = nums[i] - min_neighbour + 1;\\n                odd += diff;\\n            }\\n        }\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            int min_neighbour = 1e5;\\n            if(i-1 >=0)\\n            {\\n                min_neighbour = min(min_neighbour, nums[i-1]);\\n            }\\n            if(i+1 <nums.size())\\n            {\\n                min_neighbour = min(min_neighbour, nums[i+1]);\\n            }\\n            if(nums[i] >= min_neighbour)\\n            {\\n                int diff = nums[i] - min_neighbour + 1;\\n                even += diff;\\n            }\\n        }\\n        return min(even, odd);\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int even = 0;\\n        int odd = 0;\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            int min_neighbour = 1e5;\\n            if(i-1 >=0)\\n            {\\n                min_neighbour = min(min_neighbour, nums[i-1]);\\n            }\\n            if(i+1 <nums.size())\\n            {\\n                min_neighbour = min(min_neighbour, nums[i+1]);\\n            }\\n            if(nums[i] >= min_neighbour)\\n            {\\n                int diff = nums[i] - min_neighbour + 1;\\n                odd += diff;\\n            }\\n        }\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            int min_neighbour = 1e5;\\n            if(i-1 >=0)\\n            {\\n                min_neighbour = min(min_neighbour, nums[i-1]);\\n            }\\n            if(i+1 <nums.size())\\n            {\\n                min_neighbour = min(min_neighbour, nums[i+1]);\\n            }\\n            if(nums[i] >= min_neighbour)\\n            {\\n                int diff = nums[i] - min_neighbour + 1;\\n                even += diff;\\n            }\\n        }\\n        return min(even, odd);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 421332,
                "title": "ease-c-solution-beating-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int m1=0,m2=0;\\n        int   i=1;\\n        while(i<nums.size())\\n        {\\n            if(i==nums.size()-1){\\n                if(nums[i]>=nums[i-1])\\n                {m2+=nums[i]-nums[i-1]+1;}}         //Line 10\\n            \\n            else if(nums[i]>=nums[i+1] || nums[i]>=nums[i-1])\\n                m2+=abs(min(nums[i-1],nums[i+1])-nums[i])+1; \\n        i+=2;\\n        }\\n        \\n        i=0;\\n        while(i<nums.size())\\n        {\\n            if(i==0){\\n                if(nums[i]>=nums[i+1])\\n                {m1+=abs(nums[i]-nums[i+1])+1;}}    //Line22\\n            \\n            else if(i==nums.size()-1){\\n                if(nums[i]>=nums[i-1])\\n                {m1+=nums[i]-nums[i-1]+1;}}         //Line 26\\n\\n            else if(nums[i]>=nums[i+1] || nums[i]>=nums[i-1])\\n                m1+=abs(min(nums[i-1],nums[i+1])-nums[i])+1;\\n        i+=2;\\n        }\\n        return m1<m2?m1:m2;\\n    }\\n};\\n```\\nAt first the solution was running in 4ms beating 57.70% but i noticed if i give brackets at line 10,22,26 the running time decreases to 0ms beating 100%.Is there any explanation for it because i tried several times but the result was same.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int m1=0,m2=0;\\n        int   i=1;\\n        while(i<nums.size())\\n        {\\n            if(i==nums.size()-1){\\n                if(nums[i]>=nums[i-1])\\n                {m2+=nums[i]-nums[i-1]+1;}}         //Line 10\\n            \\n            else if(nums[i]>=nums[i+1] || nums[i]>=nums[i-1])\\n                m2+=abs(min(nums[i-1],nums[i+1])-nums[i])+1; \\n        i+=2;\\n        }\\n        \\n        i=0;\\n        while(i<nums.size())\\n        {\\n            if(i==0){\\n                if(nums[i]>=nums[i+1])\\n                {m1+=abs(nums[i]-nums[i+1])+1;}}    //Line22\\n            \\n            else if(i==nums.size()-1){\\n                if(nums[i]>=nums[i-1])\\n                {m1+=nums[i]-nums[i-1]+1;}}         //Line 26\\n\\n            else if(nums[i]>=nums[i+1] || nums[i]>=nums[i-1])\\n                m1+=abs(min(nums[i-1],nums[i+1])-nums[i])+1;\\n        i+=2;\\n        }\\n        return m1<m2?m1:m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356151,
                "title": "java-0ms-faster-than-100-memory-less-than-100",
                "content": "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        \\n\\n        int [] nums1=nums.clone();\\n        int count1=0;\\n        int count2=0;\\n        \\n        for(int i=0;i<nums.length;i=i+2)\\n        {\\n            \\n            if(i>0&&i<nums.length-1&&(nums[i]>=nums[i+1]||nums[i]>=nums[i-1]))\\n            {\\n                    int max=nums[i]-nums[i+1];\\n                        \\n                    if(max<nums[i]-nums[i-1])\\n                    {\\n                        max=nums[i]-nums[i-1];\\n                    }\\n                        max++;\\n                        nums[i]-=max;\\n                        count1+=max;\\n            }\\n            else if(i==0&&nums[i+1]<=nums[i])\\n            {\\n                    int max=nums[i]-nums[i+1];\\n                    max++;\\n                    nums[i]-=max;\\n                    count1+=max;\\n            }\\n            else if(i==nums1.length-1&&nums[i-1]<=nums[i])\\n            {\\n                 int max=nums[i]-nums[i-1];\\n                    max++;\\n                    nums[i]-=max;\\n                    count1+=max;\\n            }\\n            \\n        }\\n        \\n        nums=nums1.clone();\\n         for(int i=1;i<nums.length;i=i+2)\\n        {\\n            \\n            if(i<nums.length-1&&(nums[i]>=nums[i+1]||nums[i]>=nums[i-1]))\\n            {\\n             int max=nums[i]-nums[i+1];\\n                        \\n                    if(max<nums[i]-nums[i-1])\\n                    {\\n                        max=nums[i]-nums[i-1];\\n                    }\\n                        max++;\\n                        nums[i]-=max;\\n                        count2+=max;\\n            }\\n             else if(i==nums1.length-1&&nums[i-1]<=nums[i])\\n            {\\n                 int max=nums[i]-nums[i-1];\\n                    max++;\\n                    nums[i]-=max;\\n                    count2+=max;\\n            }\\n            \\n        }\\n        \\n            if(count1<count2)\\n            {\\n                return count1;\\n            }\\n        return count2;\\n         \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        \\n\\n        int [] nums1=nums.clone();\\n        int count1=0;\\n        int count2=0;\\n        \\n        for(int i=0;i<nums.length;i=i+2)\\n        {\\n            \\n            if(i>0&&i<nums.length-1&&(nums[i]>=nums[i+1]||nums[i]>=nums[i-1]))\\n            {\\n                    int max=nums[i]-nums[i+1];\\n                        \\n                    if(max<nums[i]-nums[i-1])\\n                    {\\n                        max=nums[i]-nums[i-1];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 351310,
                "title": "backtracking-solution-beats-100",
                "content": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int i = nums.length;\\n        if(nums.length <= 2 )\\n            return 0;\\n        \\n        \\n        int soln1  = movesToMakeZigZag(nums, nums.length-1, true);\\n        int soln2  = movesToMakeZigZag(nums, nums.length-1, false);\\n        return Math.min(soln1, soln2);\\n    }\\n    \\n    public int movesToMakeZigZag(int[] nums, int n, boolean flag){\\n        if(n<=0)\\n            return 0;\\n        if(flag){\\n            int diff = 0;\\n            if(nums[n] <= nums[n-1])\\n             diff = nums[n-1] - nums[n] + 1;\\n            nums[n-1] -= diff;\\n            int result = movesToMakeZigZag(nums, n-1, !flag);\\n            nums[n-1] += diff;\\n            return result+diff;\\n        }\\n        else{\\n            int diff = 0;\\n            if(nums[n] >= nums[n-1])\\n                diff = nums[n] - nums[n-1] + 1;\\n            nums[n] -= diff;\\n            int result = movesToMakeZigZag(nums, n-1, !flag);\\n            nums[n] += diff;\\n            return result+diff;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int movesToMakeZigzag(int[] nums) {\\n        int i = nums.length;\\n        if(nums.length <= 2 )\\n            return 0;\\n        \\n        \\n        int soln1  = movesToMakeZigZag(nums, nums.length-1, true);\\n        int soln2  = movesToMakeZigZag(nums, nums.length-1, false);\\n        return Math.min(soln1, soln2);\\n    }\\n    \\n    public int movesToMakeZigZag(int[] nums, int n, boolean flag){\\n        if(n<=0)\\n            return 0;\\n        if(flag){\\n            int diff = 0;\\n            if(nums[n] <= nums[n-1])\\n             diff = nums[n-1] - nums[n] + 1;\\n            nums[n-1] -= diff;\\n            int result = movesToMakeZigZag(nums, n-1, !flag);\\n            nums[n-1] += diff;\\n            return result+diff;\\n        }\\n        else{\\n            int diff = 0;\\n            if(nums[n] >= nums[n-1])\\n                diff = nums[n] - nums[n-1] + 1;\\n            nums[n] -= diff;\\n            int result = movesToMakeZigZag(nums, n-1, !flag);\\n            nums[n] += diff;\\n            return result+diff;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350627,
                "title": "python-simple-solution",
                "content": "The basic idea is to compare the min count for either odd or even case:\\n```py\\nclass Solution:\\n    def movesToMakeZigzag(self, nums) -> int:\\n        odd_min = 0\\n        even_min = 0\\n        for i, val in enumerate(nums):\\n            if i % 2 == 1:\\n                left = nums[i-1] if i > 0 else 1001\\n                right = nums[i+1] if i < len(nums) - 1 else 1001\\n                if val >= min(left, right):\\n                    odd_min += val - min(left, right) + 1\\n            if i % 2 == 0:\\n                left = nums[i-1] if i > 0 else 1001\\n                right = nums[i+1] if i < len(nums) - 1 else 1001\\n                if val >= min(left, right):\\n                    even_min += val - min(left, right) + 1\\n        return min(odd_min, even_min)\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def movesToMakeZigzag(self, nums) -> int:\\n        odd_min = 0\\n        even_min = 0\\n        for i, val in enumerate(nums):\\n            if i % 2 == 1:\\n                left = nums[i-1] if i > 0 else 1001\\n                right = nums[i+1] if i < len(nums) - 1 else 1001\\n                if val >= min(left, right):\\n                    odd_min += val - min(left, right) + 1\\n            if i % 2 == 0:\\n                left = nums[i-1] if i > 0 else 1001\\n                right = nums[i+1] if i < len(nums) - 1 else 1001\\n                if val >= min(left, right):\\n                    even_min += val - min(left, right) + 1\\n        return min(odd_min, even_min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350622,
                "title": "java-consider-two-possibilities-o-n-runtime-100",
                "content": "```\\n    public int movesToMakeZigzag(int[] nums) {\\n        return Math.min(calc(nums,true),calc(nums,false));\\n    }\\n    \\n    public int calc(int[] nums, boolean isEvenSmall){\\n        int res = 0;\\n        for(int i = (isEvenSmall ? 0 : 1); i<nums.length; i+=2){\\n            int cur = 0;\\n            if(i+1<nums.length){\\n                if(nums[i]>=nums[i+1]){\\n                    cur=nums[i]-nums[i+1]+1;\\n                }\\n            }\\n            if(i-1>=0){\\n                if(nums[i]>=nums[i-1]){\\n                    cur=Math.max(cur,nums[i]-nums[i-1]+1);\\n                }\\n            }\\n            res+=cur;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int movesToMakeZigzag(int[] nums) {\\n        return Math.min(calc(nums,true),calc(nums,false));\\n    }\\n    \\n    public int calc(int[] nums, boolean isEvenSmall){\\n        int res = 0;\\n        for(int i = (isEvenSmall ? 0 : 1); i<nums.length; i+=2){\\n            int cur = 0;\\n            if(i+1<nums.length){\\n                if(nums[i]>=nums[i+1]){\\n                    cur=nums[i]-nums[i+1]+1;\\n                }\\n            }\\n            if(i-1>=0){\\n                if(nums[i]>=nums[i-1]){\\n                    cur=Math.max(cur,nums[i]-nums[i-1]+1);\\n                }\\n            }\\n            res+=cur;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068349,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oc=0,ec=0,ans=INT_MAX;\\n        vector<int> arr=nums;\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        int i=0;\\n        while(i<n){\\n            if(i==0 && i+1<n){\\n                if(nums[i]>=nums[i+1]){\\n                    ec=ec+(nums[i]-nums[i+1]+1);\\n                    // nums[i]=nums[i]-nums[i+1]-1;\\n                }\\n            }\\n            else if(i==n-1 && i-1>=0){\\n                if(nums[i]>=nums[i-1]){\\n                    ec=(ec+nums[i]-nums[i-1]+1);\\n                    // nums[i]=nums[i]-nums[i-1]-1;\\n                }\\n            }\\n            else{\\n                if(nums[i]>=nums[i-1] || nums[i]>=nums[i+1]){\\n                    int x=min(nums[i-1],nums[i+1]);\\n                    ec=ec+(nums[i]-x+1);\\n                    // nums[i]=nums[i]-x-1;\\n                }\\n            }\\n            // cout<<ec<<\" \";\\n            i+=2;\\n        }\\n\\n        i=1;\\n        while(i<n){\\n            if(i-1>=0 && i==n-1){\\n                if(arr[i]>=arr[i-1]){\\n                    oc=oc+(arr[i]-arr[i-1]+1);\\n                    // arr[i]=arr[i]-arr[i-1]-1;\\n                }\\n\\n            }\\n            else{\\n                if(arr[i]>=arr[i-1] || arr[i]>=arr[i+1]){\\n                    int x=min(arr[i-1],arr[i+1]);\\n                    oc=(oc+arr[i]-x+1);\\n                    // arr[i]=arr[i]-x-1;\\n                }\\n            }\\n            i+=2;\\n        }\\n        ans=min(ec,oc);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oc=0,ec=0,ans=INT_MAX;\\n        vector<int> arr=nums;\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        int i=0;\\n        while(i<n){\\n            if(i==0 && i+1<n){\\n                if(nums[i]>=nums[i+1]){\\n                    ec=ec+(nums[i]-nums[i+1]+1);\\n                    // nums[i]=nums[i]-nums[i+1]-1;\\n                }\\n            }\\n            else if(i==n-1 && i-1>=0){\\n                if(nums[i]>=nums[i-1]){\\n                    ec=(ec+nums[i]-nums[i-1]+1);\\n                    // nums[i]=nums[i]-nums[i-1]-1;\\n                }\\n            }\\n            else{\\n                if(nums[i]>=nums[i-1] || nums[i]>=nums[i+1]){\\n                    int x=min(nums[i-1],nums[i+1]);\\n                    ec=ec+(nums[i]-x+1);\\n                    // nums[i]=nums[i]-x-1;\\n                }\\n            }\\n            // cout<<ec<<\" \";\\n            i+=2;\\n        }\\n\\n        i=1;\\n        while(i<n){\\n            if(i-1>=0 && i==n-1){\\n                if(arr[i]>=arr[i-1]){\\n                    oc=oc+(arr[i]-arr[i-1]+1);\\n                    // arr[i]=arr[i]-arr[i-1]-1;\\n                }\\n\\n            }\\n            else{\\n                if(arr[i]>=arr[i-1] || arr[i]>=arr[i+1]){\\n                    int x=min(arr[i-1],arr[i+1]);\\n                    oc=(oc+arr[i]-x+1);\\n                    // arr[i]=arr[i]-x-1;\\n                }\\n            }\\n            i+=2;\\n        }\\n        ans=min(ec,oc);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3982686,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int rec(int i,vector<int>v){\\n\\n        int ans=0;\\n        for(;i<v.size();i+=2)\\n        {\\n            if(i-1>=0&&v[i-1]<=v[i])\\n            {\\n                ans+=v[i]-v[i-1]+1;\\n                v[i]=v[i-1]-1;\\n            }\\n\\n            if(i+1<v.size()&&v[i+1]<=v[i])\\n            {\\n                ans+=v[i]-v[i+1]+1;\\n                v[i]=v[i+1]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int movesToMakeZigzag(vector<int>& v) \\n    {\\n        int ans=rec(0,v);   // decreasing even indices \\n        ans=min(ans,rec(1,v));  // decreasing odd indices \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int rec(int i,vector<int>v){\\n\\n        int ans=0;\\n        for(;i<v.size();i+=2)\\n        {\\n            if(i-1>=0&&v[i-1]<=v[i])\\n            {\\n                ans+=v[i]-v[i-1]+1;\\n                v[i]=v[i-1]-1;\\n            }\\n\\n            if(i+1<v.size()&&v[i+1]<=v[i])\\n            {\\n                ans+=v[i]-v[i+1]+1;\\n                v[i]=v[i+1]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int movesToMakeZigzag(vector<int>& v) \\n    {\\n        int ans=rec(0,v);   // decreasing even indices \\n        ans=min(ans,rec(1,v));  // decreasing odd indices \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963720,
                "title": "c-faster-than-100-simple",
                "content": "***Some have to code for Work , and some have to code for Escape***\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n        int evenAns=0,oddAns=0;\\n        vector<int>even=nums,odd=nums;\\n        for(int i=1;i<even.size();i++){\\n            if(i%2){\\n                if(i==nums.size()-1&&even[i]>=even[i-1]){evenAns+=(1+even[i]-even[i-1]);even[i]=even[i-1]-1;}\\n                else if(i==nums.size()-1)continue;\\n                else if(even[i]>=even[i+1]||even[i]>=even[i-1])evenAns+=(1+even[i]-min(even[i-1],even[i+1]));\\n            }else continue;\\n        }for(int i=0;i<odd.size();i++){\\n            if(i%2==0){\\n                if(i==nums.size()-1&&odd[i]>=odd[i-1]){oddAns+=(1+odd[i]-odd[i-1]);}\\n                else if(i==0&&odd[i]>=odd[i+1]){oddAns+=(1+odd[i]-odd[i+1]);}\\n                else if(i==nums.size()-1||i==0)continue;\\n                else if(odd[i]>=odd[i+1]||odd[i]>=odd[i-1])oddAns+=(1+odd[i]-min(odd[i-1],odd[i+1]));\\n            }else continue;\\n        }return min(evenAns,oddAns);\\n    }\\n};\\n```\\n**logik**\\n1. we will consider the case when there is even zigzag seperately from when there is an odd zigzag\\n2. when considering even zigzag, note that numbers at only odd places should be decreased and vice-versa for odd zigzag\\n3. Now , question is by what amount do we decrease odd numbers when considering even zigzag? So we check left and right of it , take the minimum of it , and reduce it by 1 thus this should be our new number hence the difference between original odd number and this new calculated number should be added to even moves \\n4. similarly for odd moves(also handle corner cases such as i==0 and i==n-1th element) and then we take minimum of both moves and return it as answer.\\n![image](https://assets.leetcode.com/users/images/c0554ce1-7ae3-44a5-8bd9-8e0d966f985c_1693069678.9542348.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n        int evenAns=0,oddAns=0;\\n        vector<int>even=nums,odd=nums;\\n        for(int i=1;i<even.size();i++){\\n            if(i%2){\\n                if(i==nums.size()-1&&even[i]>=even[i-1]){evenAns+=(1+even[i]-even[i-1]);even[i]=even[i-1]-1;}\\n                else if(i==nums.size()-1)continue;\\n                else if(even[i]>=even[i+1]||even[i]>=even[i-1])evenAns+=(1+even[i]-min(even[i-1],even[i+1]));\\n            }else continue;\\n        }for(int i=0;i<odd.size();i++){\\n            if(i%2==0){\\n                if(i==nums.size()-1&&odd[i]>=odd[i-1]){oddAns+=(1+odd[i]-odd[i-1]);}\\n                else if(i==0&&odd[i]>=odd[i+1]){oddAns+=(1+odd[i]-odd[i+1]);}\\n                else if(i==nums.size()-1||i==0)continue;\\n                else if(odd[i]>=odd[i+1]||odd[i]>=odd[i-1])oddAns+=(1+odd[i]-min(odd[i-1],odd[i+1]));\\n            }else continue;\\n        }return min(evenAns,oddAns);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963404,
                "title": "java-o-n-100-faster-solution",
                "content": "# Approach\\nI run 2 loops:\\n- first loop is for numbers placed under even indices\\n- second loop is for numbers placed under odd indices\\n\\nInside these loops on each iteration:\\n- I find the minimum between two neighbors of current element\\n- I find the difference between minimum and current element\\n- If current is greater than minimum, then I just add **diff + 1** to **sum**\\n- I take into account edge cases\\n\\nFinally, I return the minimum between two sum variables.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if (nums.length == 1) return 0;\\n        if (nums.length == 2) return nums[0] == nums[1] ? 1 : 0;\\n        int sum = 0, prev = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            int diff = nums[i] - Math.min(i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1], prev);\\n            if (diff >= 0) sum += diff + 1;\\n            prev = i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1];\\n        }\\n        int sum2 = 0, prev2 = nums[0];\\n        for (int i = 1; i < nums.length; i += 2) {\\n            int diff = nums[i] - Math.min(i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1], prev2);\\n            if (diff >= 0) sum2 += diff + 1;\\n            prev2 = i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1];\\n        }\\n        return Math.min(sum, sum2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if (nums.length == 1) return 0;\\n        if (nums.length == 2) return nums[0] == nums[1] ? 1 : 0;\\n        int sum = 0, prev = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i += 2) {\\n            int diff = nums[i] - Math.min(i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1], prev);\\n            if (diff >= 0) sum += diff + 1;\\n            prev = i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1];\\n        }\\n        int sum2 = 0, prev2 = nums[0];\\n        for (int i = 1; i < nums.length; i += 2) {\\n            int diff = nums[i] - Math.min(i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1], prev2);\\n            if (diff >= 0) sum2 += diff + 1;\\n            prev2 = i + 1 >= nums.length ? Integer.MAX_VALUE : nums[i + 1];\\n        }\\n        return Math.min(sum, sum2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886376,
                "title": "intutive-beginner-friendly-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int cnt[2] = {};\\n        for (int i = 0; i < nums.size(); i++) {\\n            int left = i > 0 ? nums[i - 1] : INT_MAX;\\n            int right = i < nums.size() - 1 ? nums[i + 1] : INT_MAX;\\n            cnt[i % 2] += max(0, nums[i] - min(left, right) + 1);\\n        }\\n        return min(cnt[0], cnt[1]);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int cnt[2] = {};\\n        for (int i = 0; i < nums.size(); i++) {\\n            int left = i > 0 ? nums[i - 1] : INT_MAX;\\n            int right = i < nums.size() - 1 ? nums[i + 1] : INT_MAX;\\n            cnt[i % 2] += max(0, nums[i] - min(left, right) + 1);\\n        }\\n        return min(cnt[0], cnt[1]);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855568,
                "title": "o-n-solution-that-beats-98",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\n        def check(start):\\n            t = 0\\n            for i in range(start, n, 2):\\n                has_left = i > 0\\n                has_right = i < n - 1\\n                smallest_neighbor = 0\\n                if has_left and has_right:\\n                    smallest_neighbor = min(nums[i-1], nums[i+1])\\n                elif has_left:\\n                    smallest_neighbor = nums[i-1]\\n                elif has_right:\\n                    smallest_neighbor = nums[i+1]\\n                if smallest_neighbor <= nums[i]:\\n                    t += nums[i] - smallest_neighbor + 1\\n            return t\\n\\n        return min(check(0), check(1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\n        def check(start):\\n            t = 0\\n            for i in range(start, n, 2):\\n                has_left = i > 0\\n                has_right = i < n - 1\\n                smallest_neighbor = 0\\n                if has_left and has_right:\\n                    smallest_neighbor = min(nums[i-1], nums[i+1])\\n                elif has_left:\\n                    smallest_neighbor = nums[i-1]\\n                elif has_right:\\n                    smallest_neighbor = nums[i+1]\\n                if smallest_neighbor <= nums[i]:\\n                    t += nums[i] - smallest_neighbor + 1\\n            return t\\n\\n        return min(check(0), check(1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832156,
                "title": "readable-simple-structured-o-2n-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        //fetch all the even corrections indexs\\n        var evenCorrIdx = getCorrectionIdx(nums, true);\\n        var oddCorrIdx = getCorrectionIdx(nums, false);\\n\\n        var evenCorrCost = getCostForCorrection(evenCorrIdx, nums);\\n        var oddCorrCost = getCostForCorrection(oddCorrIdx, nums);\\n        return Math.min(evenCorrCost, oddCorrCost);\\n    }\\n\\n    private int getCostForCorrection(List<Integer> corrIdx, int[] nums){\\n        nums = Arrays.copyOf(nums, nums.length);\\n        int totalCost = 0;\\n        for(int idx : corrIdx){\\n            int currNum = nums[idx];\\n            int leftNum = idx > 0 ? nums[idx - 1] : Integer.MAX_VALUE;\\n            int rightNum = idx < nums.length - 1 ? nums[idx + 1] : Integer.MAX_VALUE;\\n            if(leftNum != Integer.MAX_VALUE && currNum <= leftNum){\\n                int diff = leftNum - currNum + 1;\\n                nums[idx - 1] -= diff;\\n                totalCost += diff;\\n            }\\n                    \\n            if(rightNum != Integer.MAX_VALUE && currNum <= rightNum){\\n                int diff = rightNum - currNum + 1;\\n                nums[idx + 1] -= diff;\\n                totalCost += diff;\\n            }\\n        }\\n        return totalCost;\\n    }\\n\\n\\n    private List<Integer> getCorrectionIdx(int[] nums, boolean isEven){\\n        var corrIdx = new ArrayList<Integer>();\\n        int i = isEven ? 0 : 1;\\n        while(i < nums.length){\\n            int currNum = nums[i];\\n            int leftNum = i > 0 ? nums[i - 1] : Integer.MIN_VALUE;\\n            int rightNum = i < nums.length - 1 ? nums[i + 1] : Integer.MIN_VALUE;   \\n            if(currNum <= leftNum || currNum <= rightNum)\\n                corrIdx.add(i);\\n            i += 2;\\n        }\\n        return corrIdx;\\n    }\\n}\\n\\n/**\\n\\n    [1,2,3]\\n     0 1.2\\n\\neven\\n    [1,0,3]\\n     0 1.2\\nodd\\n    [1,2,1]\\n     0 1.2\\n\\n\\n        6.  5 \\n     [9,6,1,6,2]\\n      0,1,2,3,4\\n\\n\\n     [19,6,1,6,2] \\n     even -> places not valid for idx 2 (1,3) for idx 4(3) = total of 2 corrections\\n     odd. -> places not valid for udx 1(0) = total 1 correction\\n\\nApproach:\\n* Iterate over the array once for:\\n    * even:\\n        * check total corrections needed\\n\\n    * odd:\\n        * check total corrections needed\\n\\n\\n\\n            [19,0,1,0,2] \\n\\n\\n            TC: O(N)\\n            SC: O(logN)\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        //fetch all the even corrections indexs\\n        var evenCorrIdx = getCorrectionIdx(nums, true);\\n        var oddCorrIdx = getCorrectionIdx(nums, false);\\n\\n        var evenCorrCost = getCostForCorrection(evenCorrIdx, nums);\\n        var oddCorrCost = getCostForCorrection(oddCorrIdx, nums);\\n        return Math.min(evenCorrCost, oddCorrCost);\\n    }\\n\\n    private int getCostForCorrection(List<Integer> corrIdx, int[] nums){\\n        nums = Arrays.copyOf(nums, nums.length);\\n        int totalCost = 0;\\n        for(int idx : corrIdx){\\n            int currNum = nums[idx];\\n            int leftNum = idx > 0 ? nums[idx - 1] : Integer.MAX_VALUE;\\n            int rightNum = idx < nums.length - 1 ? nums[idx + 1] : Integer.MAX_VALUE;\\n            if(leftNum != Integer.MAX_VALUE && currNum <= leftNum){\\n                int diff = leftNum - currNum + 1;\\n                nums[idx - 1] -= diff;\\n                totalCost += diff;\\n            }\\n                    \\n            if(rightNum != Integer.MAX_VALUE && currNum <= rightNum){\\n                int diff = rightNum - currNum + 1;\\n                nums[idx + 1] -= diff;\\n                totalCost += diff;\\n            }\\n        }\\n        return totalCost;\\n    }\\n\\n\\n    private List<Integer> getCorrectionIdx(int[] nums, boolean isEven){\\n        var corrIdx = new ArrayList<Integer>();\\n        int i = isEven ? 0 : 1;\\n        while(i < nums.length){\\n            int currNum = nums[i];\\n            int leftNum = i > 0 ? nums[i - 1] : Integer.MIN_VALUE;\\n            int rightNum = i < nums.length - 1 ? nums[i + 1] : Integer.MIN_VALUE;   \\n            if(currNum <= leftNum || currNum <= rightNum)\\n                corrIdx.add(i);\\n            i += 2;\\n        }\\n        return corrIdx;\\n    }\\n}\\n\\n/**\\n\\n    [1,2,3]\\n     0 1.2\\n\\neven\\n    [1,0,3]\\n     0 1.2\\nodd\\n    [1,2,1]\\n     0 1.2\\n\\n\\n        6.  5 \\n     [9,6,1,6,2]\\n      0,1,2,3,4\\n\\n\\n     [19,6,1,6,2] \\n     even -> places not valid for idx 2 (1,3) for idx 4(3) = total of 2 corrections\\n     odd. -> places not valid for udx 1(0) = total 1 correction\\n\\nApproach:\\n* Iterate over the array once for:\\n    * even:\\n        * check total corrections needed\\n\\n    * odd:\\n        * check total corrections needed\\n\\n\\n\\n            [19,0,1,0,2] \\n\\n\\n            TC: O(N)\\n            SC: O(logN)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813236,
                "title": "o-2n-follow-the-hint",
                "content": "# Approach\\nInstead of keeping track of the largest element in the middle, it is better to track the smallest element, this way you can always greedily decrement the middle element, no need to increment\\n\\n```\\n// e.g:     2<7>10<9>8<9\\n// replace:     6\\n// ans:     10-6=4   \\n\\n// e.g:     2>7<10>9<8<9\\n// replace    1    7    \\n// ans:     7-1+9-7 \\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(2n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar movesToMakeZigzag = function(nums) {\\n    const moves=(start)=>{\\n        let operations=0;\\n        for(let i=start;i<nums.length;i+=2){\\n            const mid=nums[i], \\n            left=i-1<0?Number.MAX_SAFE_INTEGER:nums[i-1], \\n            right=i+1===nums.length?Number.MAX_SAFE_INTEGER:nums[i+1],\\n            minBound=Math.min(left,right);\\n\\n            if(minBound<=mid) operations+=mid-minBound+1;\\n        }\\n        return operations;\\n    }\\n    return Math.min(moves(0),moves(1));    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// e.g:     2<7>10<9>8<9\\n// replace:     6\\n// ans:     10-6=4   \\n\\n// e.g:     2>7<10>9<8<9\\n// replace    1    7    \\n// ans:     7-1+9-7 \\n```\n```\\nvar movesToMakeZigzag = function(nums) {\\n    const moves=(start)=>{\\n        let operations=0;\\n        for(let i=start;i<nums.length;i+=2){\\n            const mid=nums[i], \\n            left=i-1<0?Number.MAX_SAFE_INTEGER:nums[i-1], \\n            right=i+1===nums.length?Number.MAX_SAFE_INTEGER:nums[i+1],\\n            minBound=Math.min(left,right);\\n\\n            if(minBound<=mid) operations+=mid-minBound+1;\\n        }\\n        return operations;\\n    }\\n    return Math.min(moves(0),moves(1));    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781540,
                "title": "c-beats-100-c-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int ans1 = 0, ans2 = 0, n = nums.size();\\n        // odd\\n\\n        if(n  == 1){\\n            return 0;\\n        }\\n        vector<int> temp = nums;\\n        // if(nums[0] >= nums[1]){\\n        //     ans1 += nums[0] - nums[1] + 1;\\n        //     nums[0] = nums[1] - 1;\\n        // }\\n        for(int i=1;i< n;i+=2){\\n            if(i == n-1){\\n                if(nums[i] <= nums[i-1]){\\n                    ans1 += nums[i-1] - nums[i] + 1;\\n                    nums[i-1] = nums[i] -1;\\n                }\\n            }\\n            else{\\n                if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){\\n                    continue;\\n                }\\n                \\n                if(nums[i] <= nums[i-1]){\\n                    ans1 += nums[i-1] - nums[i] + 1;\\n                    nums[i-1] = nums[i] - 1; \\n                }\\n                if(nums[i] <= nums[i+1]){\\n                    ans1 += nums[i+1] - nums[i] + 1;\\n                    nums[i+1] = nums[i] - 1; \\n                }\\n            }\\n        }\\n        cout << ans1 << endl;\\n        \\n        for(int i=0;i<n;i+=2){\\n            // cout << temp[i] << \" \" << i << \" \" << ans2 << endl;\\n            if(i == 0){\\n                if(temp[i] <= temp[i+1]){\\n                    ans2 += temp[i+1] - temp[i] + 1;\\n                    temp[i+1] = temp[i] -1;\\n                }\\n                // cout << temp[i] << \" \" << i << \" \" << ans2 << endl; \\n                // continue;\\n            }\\n            else if(i == n-1){\\n                if(temp[i] <= temp[i-1]){\\n                    ans2 += temp[i-1] - temp[i] + 1;\\n                    temp[i-1] = temp[i] -1;\\n                }\\n                // cout << temp[i] << \" \" << i << \" \" << ans2 << endl;\\n            }\\n            else{\\n                if(temp[i] > temp[i-1] && temp[i] > temp[i+1]){\\n                    continue;\\n                }\\n                \\n                if(temp[i] <= temp[i-1]){\\n                    ans2 += temp[i-1] - temp[i] + 1;\\n                    temp[i-1] = temp[i] - 1; \\n                }\\n                if(temp[i] <= temp[i+1]){\\n                    ans2 += temp[i+1] - temp[i] + 1;\\n                    temp[i+1] = temp[i] - 1; \\n                }\\n            }\\n            \\n        }\\n        cout << ans2 << endl;\\n        return min(ans1 , ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int ans1 = 0, ans2 = 0, n = nums.size();\\n        // odd\\n\\n        if(n  == 1){\\n            return 0;\\n        }\\n        vector<int> temp = nums;\\n        // if(nums[0] >= nums[1]){\\n        //     ans1 += nums[0] - nums[1] + 1;\\n        //     nums[0] = nums[1] - 1;\\n        // }\\n        for(int i=1;i< n;i+=2){\\n            if(i == n-1){\\n                if(nums[i] <= nums[i-1]){\\n                    ans1 += nums[i-1] - nums[i] + 1;\\n                    nums[i-1] = nums[i] -1;\\n                }\\n            }\\n            else{\\n                if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){\\n                    continue;\\n                }\\n                \\n                if(nums[i] <= nums[i-1]){\\n                    ans1 += nums[i-1] - nums[i] + 1;\\n                    nums[i-1] = nums[i] - 1; \\n                }\\n                if(nums[i] <= nums[i+1]){\\n                    ans1 += nums[i+1] - nums[i] + 1;\\n                    nums[i+1] = nums[i] - 1; \\n                }\\n            }\\n        }\\n        cout << ans1 << endl;\\n        \\n        for(int i=0;i<n;i+=2){\\n            // cout << temp[i] << \" \" << i << \" \" << ans2 << endl;\\n            if(i == 0){\\n                if(temp[i] <= temp[i+1]){\\n                    ans2 += temp[i+1] - temp[i] + 1;\\n                    temp[i+1] = temp[i] -1;\\n                }\\n                // cout << temp[i] << \" \" << i << \" \" << ans2 << endl; \\n                // continue;\\n            }\\n            else if(i == n-1){\\n                if(temp[i] <= temp[i-1]){\\n                    ans2 += temp[i-1] - temp[i] + 1;\\n                    temp[i-1] = temp[i] -1;\\n                }\\n                // cout << temp[i] << \" \" << i << \" \" << ans2 << endl;\\n            }\\n            else{\\n                if(temp[i] > temp[i-1] && temp[i] > temp[i+1]){\\n                    continue;\\n                }\\n                \\n                if(temp[i] <= temp[i-1]){\\n                    ans2 += temp[i-1] - temp[i] + 1;\\n                    temp[i-1] = temp[i] - 1; \\n                }\\n                if(temp[i] <= temp[i+1]){\\n                    ans2 += temp[i+1] - temp[i] + 1;\\n                    temp[i+1] = temp[i] - 1; \\n                }\\n            }\\n            \\n        }\\n        cout << ans2 << endl;\\n        return min(ans1 , ans2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3768781,
                "title": "c-easy-clean-code-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& a) {\\n    int c=0;int mx=INT_MAX;\\n    for(int i=0;i<a.size();i++)\\n    {\\n        if(i%2==0)\\n        {\\n            int m=INT_MAX,n=m;\\n            if(i-1>=0 && a[i]>=a[i-1])\\n            m=a[i-1];\\n            \\n            if(i+1<a.size() && a[i]>=a[i+1])\\n            n=a[i+1];\\n\\n            int g=min(m,n);\\n            if(g==INT_MAX) continue;\\n\\n            c+=a[i]-g+1;\\n        }\\n    }\\n    mx=min(mx,c);\\n    c=0;\\n      for(int i=0;i<a.size();i++)\\n    {\\n        if(i%2!=0)\\n        {\\n           int m=INT_MAX,n=m;\\n            if(i-1>=0 && a[i]>=a[i-1])\\n            m=a[i-1];\\n            \\n            if(i+1<a.size() && a[i]>=a[i+1])\\n            n=a[i+1];\\n\\n            int g=min(m,n);\\n            if(g==INT_MAX) continue;\\n\\n            c+=a[i]-g+1;    \\n        }\\n    }\\n mx=min(mx,c);\\n return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& a) {\\n    int c=0;int mx=INT_MAX;\\n    for(int i=0;i<a.size();i++)\\n    {\\n        if(i%2==0)\\n        {\\n            int m=INT_MAX,n=m;\\n            if(i-1>=0 && a[i]>=a[i-1])\\n            m=a[i-1];\\n            \\n            if(i+1<a.size() && a[i]>=a[i+1])\\n            n=a[i+1];\\n\\n            int g=min(m,n);\\n            if(g==INT_MAX) continue;\\n\\n            c+=a[i]-g+1;\\n        }\\n    }\\n    mx=min(mx,c);\\n    c=0;\\n      for(int i=0;i<a.size();i++)\\n    {\\n        if(i%2!=0)\\n        {\\n           int m=INT_MAX,n=m;\\n            if(i-1>=0 && a[i]>=a[i-1])\\n            m=a[i-1];\\n            \\n            if(i+1<a.size() && a[i]>=a[i+1])\\n            n=a[i+1];\\n\\n            int g=min(m,n);\\n            if(g==INT_MAX) continue;\\n\\n            c+=a[i]-g+1;    \\n        }\\n    }\\n mx=min(mx,c);\\n return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696179,
                "title": "100-faster-clean-simple-approach",
                "content": "# Intuition\\nThere an be 2 cases:\\n1) Zig-zag with (even->high , odd-> low)\\n2) Zig-Zag with (even-> low , odd->high)\\n# Approach\\nIf we want to make nums zig-zag with first case true , then we an greedily suppress the odd indices which are greater than any of its neighbor rather than inflating the even indices.\\n\\nAnalyse both cases then return min of both cases\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int M = Integer.MAX_VALUE ; \\n        int e = 0 , o = 0; \\n        int n = nums.length ; \\n        for(int i=0 ;i<n; i++ ){\\n            if((i&1)==0){\\n                int left = M , right = M ; \\n                if(i>0) left = nums[i-1] ; \\n                if(i+1<n) right = nums[i+1] ; \\n\\n                int min = Math.min(left , right) ; \\n                if(nums[i]>= min){\\n                    e+= nums[i]-min+1 ; \\n                }\\n            }\\n            else {\\n                int left = M , right = M ; \\n                if(i>0) left = nums[i-1] ; \\n                if(i+1<n) right = nums[i+1] ; \\n\\n                int min = Math.min(left , right) ; \\n                  if(nums[i]>= min){\\n                    o+= nums[i]-min+1 ; \\n                }\\n            }\\n        }\\n        return Math.min(e,o) ; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int M = Integer.MAX_VALUE ; \\n        int e = 0 , o = 0; \\n        int n = nums.length ; \\n        for(int i=0 ;i<n; i++ ){\\n            if((i&1)==0){\\n                int left = M , right = M ; \\n                if(i>0) left = nums[i-1] ; \\n                if(i+1<n) right = nums[i+1] ; \\n\\n                int min = Math.min(left , right) ; \\n                if(nums[i]>= min){\\n                    e+= nums[i]-min+1 ; \\n                }\\n            }\\n            else {\\n                int left = M , right = M ; \\n                if(i>0) left = nums[i-1] ; \\n                if(i+1<n) right = nums[i+1] ; \\n\\n                int min = Math.min(left , right) ; \\n                  if(nums[i]>= min){\\n                    o+= nums[i]-min+1 ; \\n                }\\n            }\\n        }\\n        return Math.min(e,o) ; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657347,
                "title": "best-and-easy-solution-o-n-and-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# TRY TO THINK DO WE REALLY NEED TO CHAGE THE ARRAY OR WE JUST NEED TO TAKE CARE OF PREVIOUS OR NEXT ELEMENT\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# TAKE TWO VARIABLE ONE IS NEXT AND ONE NEXT AND THEY ARE KEEPING TRACK WHAT IS THE COST OF DECRESE OF NEXT AND PREVIOUS.\\n# ONE MORE THINK DECRESE ELEMENT GREEDYLY\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(1)\\n# Code\\n```\\nclass Solution {\\n    private int f(int nums[], int i) {\\n        int n = nums.length;\\n        int prev = i == 0 ? 0 : nums[i - 1];\\n        int next = i == n - 1 ? 0 : nums[i + 1];\\n        int res = 0;\\n\\n        while(i < n) {\\n            if(nums[i] > prev && nums[i] > next) {\\n                prev = next;\\n                i += 2;\\n                next = i >= n - 1 ? 0 : nums[i + 1];\\n            }else {\\n                if(nums[i] <= prev) {\\n                    res += (prev - (nums[i] - 1));\\n                    prev = nums[i] - 1;\\n                }\\n                if(nums[i] <= next) {\\n                    res += (next - (nums[i] - 1));\\n                    next = nums[i] - 1;\\n                }\\n                prev = next;\\n                i += 2;\\n                next = i >= n - 1 ? 0 : nums[i + 1];\\n            }\\n        }\\n        return res;\\n    }\\n    public int movesToMakeZigzag(int[] nums) {\\n        if(nums.length == 1)return 0;\\n        return Math.min(f(nums, 0), f(nums, 1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int f(int nums[], int i) {\\n        int n = nums.length;\\n        int prev = i == 0 ? 0 : nums[i - 1];\\n        int next = i == n - 1 ? 0 : nums[i + 1];\\n        int res = 0;\\n\\n        while(i < n) {\\n            if(nums[i] > prev && nums[i] > next) {\\n                prev = next;\\n                i += 2;\\n                next = i >= n - 1 ? 0 : nums[i + 1];\\n            }else {\\n                if(nums[i] <= prev) {\\n                    res += (prev - (nums[i] - 1));\\n                    prev = nums[i] - 1;\\n                }\\n                if(nums[i] <= next) {\\n                    res += (next - (nums[i] - 1));\\n                    next = nums[i] - 1;\\n                }\\n                prev = next;\\n                i += 2;\\n                next = i >= n - 1 ? 0 : nums[i + 1];\\n            }\\n        }\\n        return res;\\n    }\\n    public int movesToMakeZigzag(int[] nums) {\\n        if(nums.length == 1)return 0;\\n        return Math.min(f(nums, 0), f(nums, 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647625,
                "title": "java-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this Greedy appriach, we minimize each index with respect to its adjacent elements.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int evenMoves=0,oddMoves=0;\\n        for(int i=0;i<nums.length;i++){\\n            int left = i-1 < 0? Integer.MAX_VALUE:nums[i-1];\\n            int curr = nums[i];\\n            int right= i+1>=nums.length?Integer.MAX_VALUE:nums[i+1];\\n            int min=Math.min(left,right);\\n            if(i%2==0)\\n                evenMoves+= curr-min>=0? curr-min+1:0;\\n            else\\n                oddMoves+=  curr-min>=0? curr-min+1:0;\\n        }\\n        return Math.min(evenMoves,oddMoves);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int evenMoves=0,oddMoves=0;\\n        for(int i=0;i<nums.length;i++){\\n            int left = i-1 < 0? Integer.MAX_VALUE:nums[i-1];\\n            int curr = nums[i];\\n            int right= i+1>=nums.length?Integer.MAX_VALUE:nums[i+1];\\n            int min=Math.min(left,right);\\n            if(i%2==0)\\n                evenMoves+= curr-min>=0? curr-min+1:0;\\n            else\\n                oddMoves+=  curr-min>=0? curr-min+1:0;\\n        }\\n        return Math.min(evenMoves,oddMoves);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569228,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] a) {\\n        int movesOdd = 0;\\n        int movesEven = 0;\\n        if(a.length == 1){\\n            return 0;\\n        }\\n        int nums[] = new int[a.length];\\n        for(int i = 0; i < a.length; i++){\\n            nums[i] = a[i];\\n        }\\n        for(int i = 1 ; i < a.length ; i=i+2){\\n            if(i+1 < a.length){\\n                if(a[i-1] <= a[i] && a[i] >= a[i+1]){\\n                    movesOdd +=(a[i] - Math.min(a[i-1],a[i+1]) + 1 );\\n                    a[i] = a[i] - Math.min(a[i-1],a[i+1]) - 1 ;\\n                }\\n                else if(a[i-1] <= a[i]){\\n                    movesOdd +=(a[i] - a[i-1] + 1 );\\n                    a[i] = a[i] - a[i-1] - 1 ;\\n                }\\n                else if(a[i+1] <= a[i]){\\n                    movesOdd +=(a[i] - a[i+1] + 1 );\\n                    a[i] = a[i] - a[i+1] - 1 ;\\n                }\\n            }\\n            else{\\n                if(a[i-1] <= a[i]){\\n                    movesOdd += a[i] - a[i - 1] + 1;\\n                    a[i] = a[i] - a[i - 1] - 1;\\n\\n                }\\n            }\\n            \\n        }\\n        for(int i = 0; i < a.length; i++){\\n            a[i] = nums[i];\\n        }\\n        for(int i = 0 ; i < a.length ; i=i+2){\\n            if(i-1 >= 0 && i+1 < a.length){\\n                if(a[i-1] <= a[i] && a[i] >= a[i+1]){\\n                    movesEven += a[i] - Math.min(a[i-1],a[i+1]) + 1;\\n                    a[i] = a[i] - Math.min(a[i-1],a[i+1]) - 1 ;\\n                }\\n                else if(a[i-1] <= a[i]){\\n                    movesEven +=(a[i] - a[i-1] + 1 );\\n                    a[i] = a[i] - a[i-1] - 1 ;\\n                }\\n                else if(a[i+1] <= a[i]){\\n                    movesEven +=(a[i] - a[i+1] + 1 );\\n                    a[i] = a[i] - a[i+1] - 1 ;\\n                }\\n            }\\n            else{\\n                if(i-1 >=0 ){\\n                    if(a[i-1] <= a[i]){\\n                        movesEven += a[i] - a[i-1] + 1 ;\\n                        a[i] = a[i] - a[i-1] - 1;\\n                    }\\n                }\\n                else{\\n                    if(a[i+1] <= a[i]){\\n                        movesEven += a[i] - a[i+1] + 1;\\n                        a[i] = a[i] - a[i+1] - 1;\\n\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        return Math.min(movesOdd, movesEven);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] a) {\\n        int movesOdd = 0;\\n        int movesEven = 0;\\n        if(a.length == 1){\\n            return 0;\\n        }\\n        int nums[] = new int[a.length];\\n        for(int i = 0; i < a.length; i++){\\n            nums[i] = a[i];\\n        }\\n        for(int i = 1 ; i < a.length ; i=i+2){\\n            if(i+1 < a.length){\\n                if(a[i-1] <= a[i] && a[i] >= a[i+1]){\\n                    movesOdd +=(a[i] - Math.min(a[i-1],a[i+1]) + 1 );\\n                    a[i] = a[i] - Math.min(a[i-1],a[i+1]) - 1 ;\\n                }\\n                else if(a[i-1] <= a[i]){\\n                    movesOdd +=(a[i] - a[i-1] + 1 );\\n                    a[i] = a[i] - a[i-1] - 1 ;\\n                }\\n                else if(a[i+1] <= a[i]){\\n                    movesOdd +=(a[i] - a[i+1] + 1 );\\n                    a[i] = a[i] - a[i+1] - 1 ;\\n                }\\n            }\\n            else{\\n                if(a[i-1] <= a[i]){\\n                    movesOdd += a[i] - a[i - 1] + 1;\\n                    a[i] = a[i] - a[i - 1] - 1;\\n\\n                }\\n            }\\n            \\n        }\\n        for(int i = 0; i < a.length; i++){\\n            a[i] = nums[i];\\n        }\\n        for(int i = 0 ; i < a.length ; i=i+2){\\n            if(i-1 >= 0 && i+1 < a.length){\\n                if(a[i-1] <= a[i] && a[i] >= a[i+1]){\\n                    movesEven += a[i] - Math.min(a[i-1],a[i+1]) + 1;\\n                    a[i] = a[i] - Math.min(a[i-1],a[i+1]) - 1 ;\\n                }\\n                else if(a[i-1] <= a[i]){\\n                    movesEven +=(a[i] - a[i-1] + 1 );\\n                    a[i] = a[i] - a[i-1] - 1 ;\\n                }\\n                else if(a[i+1] <= a[i]){\\n                    movesEven +=(a[i] - a[i+1] + 1 );\\n                    a[i] = a[i] - a[i+1] - 1 ;\\n                }\\n            }\\n            else{\\n                if(i-1 >=0 ){\\n                    if(a[i-1] <= a[i]){\\n                        movesEven += a[i] - a[i-1] + 1 ;\\n                        a[i] = a[i] - a[i-1] - 1;\\n                    }\\n                }\\n                else{\\n                    if(a[i+1] <= a[i]){\\n                        movesEven += a[i] - a[i+1] + 1;\\n                        a[i] = a[i] - a[i+1] - 1;\\n\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        return Math.min(movesOdd, movesEven);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496096,
                "title": "easy-c-single-iteration-constant-space-o-1",
                "content": "# Approach\\nGreedy algorithm somewhat with touch of dynamic programming is used here to minimize the number of moves. Computation is done at each step.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        vector<int> arr  = nums;\\n        int n = nums.size();\\n        int movesi  = 0;\\n        int movesj = 0;\\n        bool g=1;\\n        int previ = nums[0];\\n        int prevj = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(g)\\n            {\\n                if(arr[i]>=previ){\\n                    movesi += arr[i]-previ+1;\\n                    previ = arr[i-1] - 1;\\n                }\\n                else{\\n                    previ= arr[i];\\n                }\\n\\n                if(arr[i]<=prevj)\\n                    movesj += prevj - arr[i] +1;\\n                prevj = arr[i];\\n            }\\n            if(!g)\\n            {\\n                if(arr[i]<=previ)\\n                    movesi += previ - arr[i] +1;\\n                previ= arr[i];\\n\\n                if(arr[i]>=prevj){\\n                    movesj += arr[i]-prevj+1;\\n                    prevj = arr[i-1] - 1;\\n                }\\n                else{\\n                    prevj= arr[i];\\n                }\\n            }\\n            g^=1;\\n        }\\n        \\n\\n        return min(movesi,movesj);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        vector<int> arr  = nums;\\n        int n = nums.size();\\n        int movesi  = 0;\\n        int movesj = 0;\\n        bool g=1;\\n        int previ = nums[0];\\n        int prevj = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(g)\\n            {\\n                if(arr[i]>=previ){\\n                    movesi += arr[i]-previ+1;\\n                    previ = arr[i-1] - 1;\\n                }\\n                else{\\n                    previ= arr[i];\\n                }\\n\\n                if(arr[i]<=prevj)\\n                    movesj += prevj - arr[i] +1;\\n                prevj = arr[i];\\n            }\\n            if(!g)\\n            {\\n                if(arr[i]<=previ)\\n                    movesi += previ - arr[i] +1;\\n                previ= arr[i];\\n\\n                if(arr[i]>=prevj){\\n                    movesj += arr[i]-prevj+1;\\n                    prevj = arr[i-1] - 1;\\n                }\\n                else{\\n                    prevj= arr[i];\\n                }\\n            }\\n            g^=1;\\n        }\\n        \\n\\n        return min(movesi,movesj);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364695,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar movesToMakeZigzag = function(nums) {\\n    const MAX_NUM = 1001;\\n    const decrease = [0, 0];\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        const left = nums[index - 1] ?? MAX_NUM;\\n        const right = nums[index + 1] ?? MAX_NUM;\\n        const moves = nums[index] - Math.min(left, right) + 1;\\n\\n        decrease[index & 1] += Math.max(0, moves);\\n    }\\n    return Math.min(...decrease);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar movesToMakeZigzag = function(nums) {\\n    const MAX_NUM = 1001;\\n    const decrease = [0, 0];\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        const left = nums[index - 1] ?? MAX_NUM;\\n        const right = nums[index + 1] ?? MAX_NUM;\\n        const moves = nums[index] - Math.min(left, right) + 1;\\n\\n        decrease[index & 1] += Math.max(0, moves);\\n    }\\n    return Math.min(...decrease);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359051,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n\\n    // A[0] > A[1] < A[2] > A[3] < A[4] >    \\n    let mut p1 = 0;\\n    let mut lv = nums[0];\\n    for i in 1..n {\\n      let cv = nums[i];\\n      if i % 2 == 1 {\\n        if lv <= cv {\\n          let diff = cv - lv + 1;\\n          p1 += diff;\\n          lv = cv - diff;\\n        } else {\\n          lv = cv;\\n        }\\n      } else {\\n        if lv >= cv {\\n          let diff = lv - cv + 1;\\n          p1 += diff;\\n        }\\n        lv = cv;\\n      }\\n    }\\n\\n    // A[0] < A[1] > A[2] < A[3] > A[4] <\\n    let mut p2 = 0;\\n    let mut lv = nums[0];\\n    for i in 1..n {\\n      let cv = nums[i];\\n      if i % 2 == 1 {\\n        if lv >= cv {\\n          let diff = lv - cv + 1;\\n          p2 += diff;\\n        }\\n        lv = cv;\\n      } else {\\n        if lv <= cv {\\n          let diff = cv - lv + 1;\\n          p2 += diff;\\n          lv = cv - diff;\\n        } else {\\n          lv = cv;\\n        }\\n      }\\n    }\\n\\n    p1.min(p2)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n\\n    // A[0] > A[1] < A[2] > A[3] < A[4] >    \\n    let mut p1 = 0;\\n    let mut lv = nums[0];\\n    for i in 1..n {\\n      let cv = nums[i];\\n      if i % 2 == 1 {\\n        if lv <= cv {\\n          let diff = cv - lv + 1;\\n          p1 += diff;\\n          lv = cv - diff;\\n        } else {\\n          lv = cv;\\n        }\\n      } else {\\n        if lv >= cv {\\n          let diff = lv - cv + 1;\\n          p1 += diff;\\n        }\\n        lv = cv;\\n      }\\n    }\\n\\n    // A[0] < A[1] > A[2] < A[3] > A[4] <\\n    let mut p2 = 0;\\n    let mut lv = nums[0];\\n    for i in 1..n {\\n      let cv = nums[i];\\n      if i % 2 == 1 {\\n        if lv >= cv {\\n          let diff = lv - cv + 1;\\n          p2 += diff;\\n        }\\n        lv = cv;\\n      } else {\\n        if lv <= cv {\\n          let diff = cv - lv + 1;\\n          p2 += diff;\\n          lv = cv - diff;\\n        } else {\\n          lv = cv;\\n        }\\n      }\\n    }\\n\\n    p1.min(p2)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293936,
                "title": "intutive-beginner-friendly-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int cnt=0;\\n        int n=nums.size();\\n        if(n==1 ) return 0;\\n        // make even smalller\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           \\n                if(i%2==0)\\n                {\\n                    if(i==0)\\n                    {\\n                        if(nums[i]>=nums[i+1])\\n                        {\\n                            cnt+=nums[i]-nums[i+1]+1;\\n                        }\\n                    }\\n                    else if(i==n-1)\\n                    {\\n                        if(nums[i]>=nums[i-1])\\n                        {\\n                            cnt+=nums[i]-nums[i-1]+1;\\n                        }\\n                    }\\n                    else \\n                    {\\n                        if(min(nums[i-1],nums[i+1])<=nums[i])\\n                        {\\n                            cnt+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                        }   \\n                    }\\n\\n                }\\n               \\n            \\n        }\\n        int cnt2=0;\\n        //make odd smaller\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i%2==1)\\n            {\\n                if(i==n-1)\\n                {\\n                    if(nums[i]>=nums[i-1])\\n                    {\\n                        cnt2+=nums[i]-nums[i-1]+1;\\n                    }\\n                }\\n                else \\n                {\\n                    if(min(nums[i-1],nums[i+1])<=nums[i])\\n                    {\\n                        cnt2+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return min(cnt,cnt2);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int cnt=0;\\n        int n=nums.size();\\n        if(n==1 ) return 0;\\n        // make even smalller\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           \\n                if(i%2==0)\\n                {\\n                    if(i==0)\\n                    {\\n                        if(nums[i]>=nums[i+1])\\n                        {\\n                            cnt+=nums[i]-nums[i+1]+1;\\n                        }\\n                    }\\n                    else if(i==n-1)\\n                    {\\n                        if(nums[i]>=nums[i-1])\\n                        {\\n                            cnt+=nums[i]-nums[i-1]+1;\\n                        }\\n                    }\\n                    else \\n                    {\\n                        if(min(nums[i-1],nums[i+1])<=nums[i])\\n                        {\\n                            cnt+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                        }   \\n                    }\\n\\n                }\\n               \\n            \\n        }\\n        int cnt2=0;\\n        //make odd smaller\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i%2==1)\\n            {\\n                if(i==n-1)\\n                {\\n                    if(nums[i]>=nums[i-1])\\n                    {\\n                        cnt2+=nums[i]-nums[i-1]+1;\\n                    }\\n                }\\n                else \\n                {\\n                    if(min(nums[i-1],nums[i+1])<=nums[i])\\n                    {\\n                        cnt2+=nums[i]-min(nums[i-1],nums[i+1])+1;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return min(cnt,cnt2);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275793,
                "title": "ok",
                "content": "**greedy / odd-even indices decomposition**\\n\\n![image](https://assets.leetcode.com/users/images/7237ec4a-82be-41b7-97ce-798ab1a07610_1678388408.6628237.png)\\n\\n**time: `O(N)`; space: `O(1)`**\\n```\\nint movesToMakeZigzag(vector<int>& n)\\n{\\n\\tint out1{}, out2{};\\n\\tfor(int i{}; i<size(n); i+=2)\\n\\t\\tout1 += max(max(0, i+1<size(n) ? 1+n[i+1]-n[i]   : 0), max(0, i+2<size(n) ? 1+n[i+1]-n[i+2] : 0)),\\n\\t\\tout2 += max(max(0, i           ? 1+n[i]  -n[i-1] : 0), max(0, i+1<size(n) ? 1+n[i  ]-n[i+1] : 0));\\n\\treturn min(out1, out2);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint movesToMakeZigzag(vector<int>& n)\\n{\\n\\tint out1{}, out2{};\\n\\tfor(int i{}; i<size(n); i+=2)\\n\\t\\tout1 += max(max(0, i+1<size(n) ? 1+n[i+1]-n[i]   : 0), max(0, i+2<size(n) ? 1+n[i+1]-n[i+2] : 0)),\\n\\t\\tout2 += max(max(0, i           ? 1+n[i]  -n[i-1] : 0), max(0, i+1<size(n) ? 1+n[i  ]-n[i+1] : 0));\\n\\treturn min(out1, out2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261154,
                "title": "java-single-pass-easy-read",
                "content": "# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int oddMoves = 0, evenMoves = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0? nums[i - 1] : Integer.MAX_VALUE;\\n            int right = i + 1 < n? nums[i + 1] : Integer.MAX_VALUE;\\n            int min = Math.min(left, right);\\n            if (i % 2 == 0) {\\n                evenMoves += nums[i] - min >= 0? (nums[i] - min + 1) : 0;\\n            } else {\\n                oddMoves += nums[i] - min >= 0? (nums[i] - min + 1) : 0;\\n            }\\n        }\\n        return Math.min(evenMoves, oddMoves);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int oddMoves = 0, evenMoves = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int left = i - 1 >= 0? nums[i - 1] : Integer.MAX_VALUE;\\n            int right = i + 1 < n? nums[i + 1] : Integer.MAX_VALUE;\\n            int min = Math.min(left, right);\\n            if (i % 2 == 0) {\\n                evenMoves += nums[i] - min >= 0? (nums[i] - min + 1) : 0;\\n            } else {\\n                oddMoves += nums[i] - min >= 0? (nums[i] - min + 1) : 0;\\n            }\\n        }\\n        return Math.min(evenMoves, oddMoves);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234192,
                "title": "rust-0ms-2023-02-26-2-pass-clean-code-and-easy-to-understand",
                "content": "# Intuition\\nSelect either odd or even index and find the difference between their minimum of their neighbor minus 1 since we want that number to be 1 lower than their neighbor.  \\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n\\n    pub fn cost(nums: &Vec<i32>, evenGreater: bool) -> i32 {\\n        if nums.len() <= 1 {\\n            return 0;\\n        }\\n        let mut res = 0;\\n        for (ind, num) in nums.iter().enumerate() {\\n            if (evenGreater && ind % 2 == 1) || (!evenGreater && ind % 2 == 0) {\\n                let mut newVal : i32 = *num;\\n                if ind < nums.len() - 1 {\\n                    newVal = std::cmp::min(newVal, nums[ind+1] - 1); \\n                }\\n                if ind > 0 {\\n                    newVal = std::cmp::min(newVal, nums[ind - 1] - 1);\\n                }\\n                res += num - newVal;\\n            } \\n        }\\n        return res;\\n    }\\n\\n    pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\\n        let cost1 = Self::cost(&nums, true);\\n        let cost2 =  Self::cost(&nums, false);\\n        // println!(\"{:?}\", nums);\\n        return std::cmp::min(cost1,cost2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n\\n    pub fn cost(nums: &Vec<i32>, evenGreater: bool) -> i32 {\\n        if nums.len() <= 1 {\\n            return 0;\\n        }\\n        let mut res = 0;\\n        for (ind, num) in nums.iter().enumerate() {\\n            if (evenGreater && ind % 2 == 1) || (!evenGreater && ind % 2 == 0) {\\n                let mut newVal : i32 = *num;\\n                if ind < nums.len() - 1 {\\n                    newVal = std::cmp::min(newVal, nums[ind+1] - 1); \\n                }\\n                if ind > 0 {\\n                    newVal = std::cmp::min(newVal, nums[ind - 1] - 1);\\n                }\\n                res += num - newVal;\\n            } \\n        }\\n        return res;\\n    }\\n\\n    pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\\n        let cost1 = Self::cost(&nums, true);\\n        let cost2 =  Self::cost(&nums, false);\\n        // println!(\"{:?}\", nums);\\n        return std::cmp::min(cost1,cost2);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222925,
                "title": "java-0ms-beats-100-and-simple-traversal",
                "content": "# Approach\\n1. Edge cases: length is 1 - return 0, length is 2, return 1 if they are equal, 0 otherwise\\n2. Traverse the array and check the two conditions.\\n    - if index is even, check how much you need to reduce nums[i] to be less than left or right (cond2)\\n    - if index is odd, check how much you need to reduce nums[i] to be less than left/right. (cond1)\\n3. For each step #2, keep track of minCond1, minCond2 and return their min.  \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int moves = 0;\\n        if (nums.length > 2) {\\n            moves = getMinNumberOfMoves(nums);\\n        } else if (nums.length == 2) {\\n            moves = nums[0] != nums[1] ? 0 : 1;\\n        }\\n        return moves;\\n    }\\n\\n    private int getMinNumberOfMoves(int[] nums) {\\n        int minCondTwo = 0, minCondOne = 0;\\n        int onLeft, onRight;\\n        for (int i = 0; i < nums.length; i++) {\\n            // condition 2\\n            if (i % 2 == 0) {\\n                onLeft = i == 0 ? 0 : nums[i-1] <= nums[i] ? nums[i] +1 - nums[i-1] : 0;\\n                onRight = i == nums.length -1 ? 0 : nums[i] >= nums[i+1] ? nums[i] +1 - nums[i+1] : 0;\\n                minCondTwo += Math.max(onLeft, onRight);\\n            } else { // condition 1\\n                onLeft = nums[i-1] > nums[i] ? 0 : nums[i] + 1 - nums[i-1];\\n                onRight = i == nums.length -1 ? 0 : nums[i+1] > nums[i] ? 0 : nums[i] + 1 - nums[i+1];\\n                minCondOne += Math.max(onLeft, onRight);\\n            }\\n        }\\n        return Math.min(minCondOne, minCondTwo);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int moves = 0;\\n        if (nums.length > 2) {\\n            moves = getMinNumberOfMoves(nums);\\n        } else if (nums.length == 2) {\\n            moves = nums[0] != nums[1] ? 0 : 1;\\n        }\\n        return moves;\\n    }\\n\\n    private int getMinNumberOfMoves(int[] nums) {\\n        int minCondTwo = 0, minCondOne = 0;\\n        int onLeft, onRight;\\n        for (int i = 0; i < nums.length; i++) {\\n            // condition 2\\n            if (i % 2 == 0) {\\n                onLeft = i == 0 ? 0 : nums[i-1] <= nums[i] ? nums[i] +1 - nums[i-1] : 0;\\n                onRight = i == nums.length -1 ? 0 : nums[i] >= nums[i+1] ? nums[i] +1 - nums[i+1] : 0;\\n                minCondTwo += Math.max(onLeft, onRight);\\n            } else { // condition 1\\n                onLeft = nums[i-1] > nums[i] ? 0 : nums[i] + 1 - nums[i-1];\\n                onRight = i == nums.length -1 ? 0 : nums[i+1] > nums[i] ? 0 : nums[i] + 1 - nums[i+1];\\n                minCondOne += Math.max(onLeft, onRight);\\n            }\\n        }\\n        return Math.min(minCondOne, minCondTwo);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213409,
                "title": "clean-python-high-speed-o-n-time-o-1-space-beats-98-9",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, A):\\n        A = [float(\\'inf\\')] + A + [float(\\'inf\\')]\\n        res = [0, 0]\\n        for i in range(1, len(A) - 1):\\n            res[i % 2] += max(0, A[i] - min(A[i - 1], A[i + 1]) + 1)\\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, A):\\n        A = [float(\\'inf\\')] + A + [float(\\'inf\\')]\\n        res = [0, 0]\\n        for i in range(1, len(A) - 1):\\n            res[i % 2] += max(0, A[i] - min(A[i - 1], A[i + 1]) + 1)\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212053,
                "title": "python-greedy",
                "content": "simply check two cases, even postions are larger and odd positions are larger.\\nfor example, when even postions are larger, to achieve this goal, we are allowed to only decrease values, no way of increasing values. so let\\'s greedily increase its neighbors to make nbs 1 less than the even values if the neigh odd values are  larger. check the left and right.\\n\\n```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        odd=0\\n        ## odd idxs are greater than neibs, to reduce even positions necessary steps\\n        i=0\\n        while i<n:\\n            left=0\\n            right=0\\n            if 0<=i-1 and nums[i-1]<=nums[i]:\\n                left=nums[i]-nums[i-1]+1\\n            if i+1<n and nums[i]-left>=nums[i+1]:\\n                right=nums[i]-left-nums[i+1]+1\\n            odd+=left+right\\n            i+=2\\n        ## even are greater than nbs\\n        even=0\\n        i=1\\n        while i<n:\\n            left=0\\n            right=0\\n            if 0<=i-1 and nums[i-1]<=nums[i]:\\n                left=nums[i]-nums[i-1]+1\\n            if i+1<n and nums[i]-left>=nums[i+1]:\\n                right=nums[i]-left-nums[i+1]+1\\n            even+=left+right\\n            i+=2\\n        return min(odd,even)\\n\\t\\t\\n## alternatively\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        odd=even=0\\n        for i in range(n):\\n            nbs=[]\\n            if i-1>=0:\\n                nbs.append(nums[i-1])\\n            if i+1<n:\\n                nbs.append(nums[i+1])\\n            if not nbs:continue\\n            if i%2:\\n                even+=max(nums[i]-min(nbs)+1,0)\\n            else:\\n                odd+=max(nums[i]-min(nbs)+1,0)\\n        return min(odd,even)",
                "solutionTags": [],
                "code": "simply check two cases, even postions are larger and odd positions are larger.\\nfor example, when even postions are larger, to achieve this goal, we are allowed to only decrease values, no way of increasing values. so let\\'s greedily increase its neighbors to make nbs 1 less than the even values if the neigh odd values are  larger. check the left and right.\\n\\n```\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        odd=0\\n        ## odd idxs are greater than neibs, to reduce even positions necessary steps\\n        i=0\\n        while i<n:\\n            left=0\\n            right=0\\n            if 0<=i-1 and nums[i-1]<=nums[i]:\\n                left=nums[i]-nums[i-1]+1\\n            if i+1<n and nums[i]-left>=nums[i+1]:\\n                right=nums[i]-left-nums[i+1]+1\\n            odd+=left+right\\n            i+=2\\n        ## even are greater than nbs\\n        even=0\\n        i=1\\n        while i<n:\\n            left=0\\n            right=0\\n            if 0<=i-1 and nums[i-1]<=nums[i]:\\n                left=nums[i]-nums[i-1]+1\\n            if i+1<n and nums[i]-left>=nums[i+1]:\\n                right=nums[i]-left-nums[i+1]+1\\n            even+=left+right\\n            i+=2\\n        return min(odd,even)\\n\\t\\t\\n## alternatively\\ndef movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        odd=even=0\\n        for i in range(n):\\n            nbs=[]\\n            if i-1>=0:\\n                nbs.append(nums[i-1])\\n            if i+1<n:\\n                nbs.append(nums[i+1])\\n            if not nbs:continue\\n            if i%2:\\n                even+=max(nums[i]-min(nbs)+1,0)\\n            else:\\n                odd+=max(nums[i]-min(nbs)+1,0)\\n        return min(odd,even)",
                "codeTag": "Python3"
            },
            {
                "id": 3165502,
                "title": "easiest-solution-with-small-code-with-100-faster",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int output = Integer.MAX_VALUE;\\n        int temp[] = nums.clone();;\\n        int sum = 0,tot=0;\\n        for(int i=1;i<temp.length;i+=2){\\n            if(i+1<temp.length&&temp[i]<=temp[i+1]){\\n                int op = temp[i+1]-temp[i]+1;temp[i+1]-=op; sum+=op;}\\n            if(temp[i]<=temp[i-1]){\\n                int op = temp[i-1]-temp[i]+1;temp[i-1]-=op; sum+=op;}\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            if(i+1<nums.length&&nums[i]<=nums[i+1]){\\n                int op = nums[i+1]-nums[i]+1;nums[i+1]-=op; tot+=op;}\\n            if(i-1>=0&&nums[i]<=nums[i-1]){\\n                int op = nums[i-1]-nums[i]+1;nums[i-1]-=op; tot+=op;}\\n        }\\n        output = Math.min(sum,tot);\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int output = Integer.MAX_VALUE;\\n        int temp[] = nums.clone();;\\n        int sum = 0,tot=0;\\n        for(int i=1;i<temp.length;i+=2){\\n            if(i+1<temp.length&&temp[i]<=temp[i+1]){\\n                int op = temp[i+1]-temp[i]+1;temp[i+1]-=op; sum+=op;}",
                "codeTag": "Java"
            },
            {
                "id": 3115362,
                "title": "oms-c-solution-with-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by iterating through each element in the array and comparing it to its neighboring elements. If an element is greater than or equal to one of its neighboring elements, steps are taken to decrease its value so that it becomes strictly less than/greater than its neighboring elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to iterate through each element in the array and comparing it to its neighboring elements. If an element is greater than or equal to one of its neighboring elements, steps are taken to decrease its value so that it becomes strictly less than/greater than its neighboring elements. The steps are taken for both even and odd indexed elements are counted separately and the minimum of the two is returned as the final answer.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas the solution doesn\\'t use any additional data structures, it only uses two variables to keep track of steps taken for even and odd indexed elements.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas the solution doesn\\'t use any additional data structures, it only uses two variables to keep track of steps taken for even and odd indexed elements.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = 0, b = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int l = i > 0 ? nums[i - 1] : 1001;\\n            int r = i + 1 < n ? nums[i + 1] : 1001;\\n            int m = min(l, r);\\n            if (nums[i] >= m) {\\n                if (i & 1) {\\n                    a += nums[i] - m + 1;\\n                } else {\\n                    b += nums[i] - m + 1;\\n                }\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = 0, b = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int l = i > 0 ? nums[i - 1] : 1001;\\n            int r = i + 1 < n ? nums[i + 1] : 1001;\\n            int m = min(l, r);\\n            if (nums[i] >= m) {\\n                if (i & 1) {\\n                    a += nums[i] - m + 1;\\n                } else {\\n                    b += nums[i] - m + 1;\\n                }\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048311,
                "title": "c",
                "content": "```\\nint movesToMakeZigzag(int* nums, int numsSize){\\n    int n = numsSize;    \\n    if(n == 1)\\n        return 0;\\n    // case 1: /\\\\/\\\\/\\\\/\\\\.... \\n    \\n    int case1 = 0;\\n    if( nums[0] >= nums[1] )\\n        case1 += nums[0] - nums[1] + 1 ;\\n    \\n    for( int i = 2; i < n; i = i+2 ){\\n        if( i == (n-1) ){\\n            if( nums[i] >= nums[i-1] )\\n                case1 += nums[i] - nums[i-1] + 1 ; \\n            continue;\\n        }\\n        if( nums[i] < nums[i-1] && nums[i] < nums[i+1] )\\n            continue;\\n        else \\n            case1 += nums[i] - fmin( nums[i-1] , nums[i+1] ) + 1;\\n    }\\n    //case 2:  \\\\/\\\\/\\\\/\\\\.....\\n    int case2 = 0;\\n\\n    for( int i = 1; i < n; i = i+2 ){\\n        if( i == (n-1) ){\\n            if( nums[i] >= nums[i-1] )\\n                case2 += nums[i] - nums[i-1] + 1  ; \\n            continue;\\n        }\\n        if( nums[i] < nums[i-1] && nums[i] < nums[i+1] )\\n            continue;\\n        else \\n            case2 += nums[i] - fmin( nums[i-1] , nums[i+1] ) + 1;\\n    }\\n    \\n    return fmin(case1, case2) ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint movesToMakeZigzag(int* nums, int numsSize){\\n    int n = numsSize;    \\n    if(n == 1)\\n        return 0;\\n    // case 1: /\\\\/\\\\/\\\\/\\\\.... \\n    \\n    int case1 = 0;\\n    if( nums[0] >= nums[1] )\\n        case1 += nums[0] - nums[1] + 1 ;\\n    \\n    for( int i = 2; i < n; i = i+2 ){\\n        if( i == (n-1) ){\\n            if( nums[i] >= nums[i-1] )\\n                case1 += nums[i] - nums[i-1] + 1 ; \\n            continue;\\n        }\\n        if( nums[i] < nums[i-1] && nums[i] < nums[i+1] )\\n            continue;\\n        else \\n            case1 += nums[i] - fmin( nums[i-1] , nums[i+1] ) + 1;\\n    }\\n    //case 2:  \\\\/\\\\/\\\\/\\\\.....\\n    int case2 = 0;\\n\\n    for( int i = 1; i < n; i = i+2 ){\\n        if( i == (n-1) ){\\n            if( nums[i] >= nums[i-1] )\\n                case2 += nums[i] - nums[i-1] + 1  ; \\n            continue;\\n        }\\n        if( nums[i] < nums[i-1] && nums[i] < nums[i+1] )\\n            continue;\\n        else \\n            case2 += nums[i] - fmin( nums[i-1] , nums[i+1] ) + 1;\\n    }\\n    \\n    return fmin(case1, case2) ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3038998,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\\n        let mut res = [0, 0];\\n        let n = nums.len();\\n        for i in 0..n {\\n            let left = if i > 0 { nums[i - 1] } else { 1001 };\\n            let right = if i + 1 < n { nums[i + 1] } else { 1001 };\\n            res[i % 2] += std::cmp::max(0, nums[i] - std::cmp::min(left, right) + 1);\\n        }\\n        std::cmp::min(res[0], res[1])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\\n        let mut res = [0, 0];\\n        let n = nums.len();\\n        for i in 0..n {\\n            let left = if i > 0 { nums[i - 1] } else { 1001 };\\n            let right = if i + 1 < n { nums[i + 1] } else { 1001 };\\n            res[i % 2] += std::cmp::max(0, nums[i] - std::cmp::min(left, right) + 1);\\n        }\\n        std::cmp::min(res[0], res[1])\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2935643,
                "title": "python-simple-o-n-solution-faster-than-80",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust calculate moves if we fix elements at odd indices and moves if we fix elements at even indices and return the minimum of both\\n\\n# Code\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        oddMoves = evenMoves = 0\\n        for idx in range(1, len(nums), 2):\\n            minimum = 0\\n            if idx + 1 < len(nums):\\n                minimum = min(nums[idx - 1], nums[idx + 1])\\n            else:\\n                minimum = nums[idx - 1]            \\n            if minimum <= nums[idx]:\\n                oddMoves += nums[idx] - minimum + 1\\n        if nums[0] >= nums[1]:\\n            evenMoves += (nums[0] - nums[1] + 1)\\n        for idx in range(2, len(nums), 2):\\n            minimum = 0\\n            if idx + 1 < len(nums):\\n                minimum = min(nums[idx - 1], nums[idx + 1])\\n            else:\\n                minimum = nums[idx - 1]            \\n            if minimum <= nums[idx]:\\n                evenMoves += nums[idx] - minimum + 1\\n        return min(oddMoves, evenMoves)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        oddMoves = evenMoves = 0\\n        for idx in range(1, len(nums), 2):\\n            minimum = 0\\n            if idx + 1 < len(nums):\\n                minimum = min(nums[idx - 1], nums[idx + 1])\\n            else:\\n                minimum = nums[idx - 1]            \\n            if minimum <= nums[idx]:\\n                oddMoves += nums[idx] - minimum + 1\\n        if nums[0] >= nums[1]:\\n            evenMoves += (nums[0] - nums[1] + 1)\\n        for idx in range(2, len(nums), 2):\\n            minimum = 0\\n            if idx + 1 < len(nums):\\n                minimum = min(nums[idx - 1], nums[idx + 1])\\n            else:\\n                minimum = nums[idx - 1]            \\n            if minimum <= nums[idx]:\\n                evenMoves += nums[idx] - minimum + 1\\n        return min(oddMoves, evenMoves)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914704,
                "title": "java-accepted-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        // even\\n        int cnt1 = 0;\\n        int[] temp1 = nums.clone();\\n        for (int i = 0; i < temp1.length; i += 2) {\\n            if (i == 0) {\\n                if (i + 1 < temp1.length && temp1[i] <= temp1[i + 1]) {\\n                    cnt1 += temp1[i + 1] - temp1[i] + 1;\\n                    temp1[i + 1] = temp1[i] - 1;\\n                }   \\n            } else if (i + 1 < temp1.length) {\\n                if (temp1[i] <= temp1[i + 1]) {\\n                    cnt1 += temp1[i + 1] - temp1[i] + 1;\\n                    temp1[i + 1] = temp1[i] - 1;\\n                }\\n                if (temp1[i - 1] >= temp1[i]) {\\n                    cnt1 += temp1[i - 1] - temp1[i] + 1;\\n                    temp1[i - 1] = temp1[i] - 1;\\n                }\\n            } else if (i == temp1.length - 1) {\\n                if (temp1[i - 1] >= temp1[i]) {\\n                    cnt1 += temp1[i - 1] - temp1[i] + 1;\\n                    temp1[i - 1] = temp1[i] - 1;\\n                }\\n            }\\n        }\\n        int cnt2 = 0;\\n        int[] temp2 = nums.clone();\\n        for (int i = 1; i < temp2.length; i += 2) {\\n             if (i + 1 < temp2.length) {\\n                if (temp2[i] <= nums[i + 1]) {\\n                    cnt2 += temp2[i + 1] - temp2[i] + 1;\\n                    temp2[i + 1] = temp2[i] - 1;\\n                }\\n                if (temp2[i - 1] >= temp2[i]) {\\n                    cnt2 += temp2[i - 1] - temp2[i] + 1;\\n                    temp2[i - 1] = temp2[i] - 1;\\n                }\\n            } else if (i == temp2.length - 1) {\\n                if (temp2[i - 1] >= temp2[i]) {\\n                    cnt2 += temp2[i - 1] - temp2[i] + 1;\\n                    temp2[i - 1] = temp2[i] - 1;\\n                }\\n            }\\n        }\\n        return Math.min(cnt1, cnt2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        // even\\n        int cnt1 = 0;\\n        int[] temp1 = nums.clone();\\n        for (int i = 0; i < temp1.length; i += 2) {\\n            if (i == 0) {\\n                if (i + 1 < temp1.length && temp1[i] <= temp1[i + 1]) {\\n                    cnt1 += temp1[i + 1] - temp1[i] + 1;\\n                    temp1[i + 1] = temp1[i] - 1;\\n                }   \\n            } else if (i + 1 < temp1.length) {\\n                if (temp1[i] <= temp1[i + 1]) {\\n                    cnt1 += temp1[i + 1] - temp1[i] + 1;\\n                    temp1[i + 1] = temp1[i] - 1;\\n                }\\n                if (temp1[i - 1] >= temp1[i]) {\\n                    cnt1 += temp1[i - 1] - temp1[i] + 1;\\n                    temp1[i - 1] = temp1[i] - 1;\\n                }\\n            } else if (i == temp1.length - 1) {\\n                if (temp1[i - 1] >= temp1[i]) {\\n                    cnt1 += temp1[i - 1] - temp1[i] + 1;\\n                    temp1[i - 1] = temp1[i] - 1;\\n                }\\n            }\\n        }\\n        int cnt2 = 0;\\n        int[] temp2 = nums.clone();\\n        for (int i = 1; i < temp2.length; i += 2) {\\n             if (i + 1 < temp2.length) {\\n                if (temp2[i] <= nums[i + 1]) {\\n                    cnt2 += temp2[i + 1] - temp2[i] + 1;\\n                    temp2[i + 1] = temp2[i] - 1;\\n                }\\n                if (temp2[i - 1] >= temp2[i]) {\\n                    cnt2 += temp2[i - 1] - temp2[i] + 1;\\n                    temp2[i - 1] = temp2[i] - 1;\\n                }\\n            } else if (i == temp2.length - 1) {\\n                if (temp2[i - 1] >= temp2[i]) {\\n                    cnt2 += temp2[i - 1] - temp2[i] + 1;\\n                    temp2[i - 1] = temp2[i] - 1;\\n                }\\n            }\\n        }\\n        return Math.min(cnt1, cnt2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837791,
                "title": "can-t-get-easier-than-this-easy-to-understand-java-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        //   if length is 1 then return 0\\n        if(nums.length == 1)\\n            return 0;\\n        \\n        int odd = 0;\\n        for(int i=1; i<nums.length; i += 2){\\n            int min = 0;\\n            \\n            if(i+1 < nums.length) // make sure its not out of bound\\n                min = Math.min( nums[i-1], nums[i+1] ); // pick minimum one\\n            else\\n                min = nums[i-1];            \\n            \\n            if(min <= nums[i]) {\\n                odd += nums[i] - min + 1;\\n            }\\n        }\\n        \\n        int even = 0;\\n        if(nums[0] >= nums[1]){ // handle first case because there is no left element of 0\\n            even += nums[0] - nums[1] + 1;\\n        }\\n        for(int i=2; i<nums.length; i += 2){\\n            int min = 0;\\n            \\n            if(i+1 < nums.length) // make sure its not out of bound\\n                min = Math.min( nums[i-1], nums[i+1] ); // pick minimum one\\n            else\\n                min = nums[i-1];            \\n            \\n            if(min <= nums[i]) {\\n                even += nums[i] - min + 1;\\n            }\\n        }\\n        \\n        return Math.min(odd, even);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        //   if length is 1 then return 0\\n        if(nums.length == 1)\\n            return 0;\\n        \\n        int odd = 0;\\n        for(int i=1; i<nums.length; i += 2){\\n            int min = 0;\\n            \\n            if(i+1 < nums.length) // make sure its not out of bound\\n                min = Math.min( nums[i-1], nums[i+1] ); // pick minimum one\\n            else\\n                min = nums[i-1];            \\n            \\n            if(min <= nums[i]) {\\n                odd += nums[i] - min + 1;\\n            }\\n        }\\n        \\n        int even = 0;\\n        if(nums[0] >= nums[1]){ // handle first case because there is no left element of 0\\n            even += nums[0] - nums[1] + 1;\\n        }\\n        for(int i=2; i<nums.length; i += 2){\\n            int min = 0;\\n            \\n            if(i+1 < nums.length) // make sure its not out of bound\\n                min = Math.min( nums[i-1], nums[i+1] ); // pick minimum one\\n            else\\n                min = nums[i-1];            \\n            \\n            if(min <= nums[i]) {\\n                even += nums[i] - min + 1;\\n            }\\n        }\\n        \\n        return Math.min(odd, even);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693720,
                "title": "c-solution-100-in-both-memory-and-speed",
                "content": "```\\nint movesToMakeZigzag(int* nums, int n){\\n    if(n<3) return 0;\\n    int e = 0;\\n    int o = 0;\\n    if(nums[0] >= nums[1]) {\\n        e += nums[0] - nums[1] + 1;\\n    }\\n    if(nums[n-1] >= nums[n-2]) {\\n        if((n-1)%2) o += nums[n-1] - nums[n-2] + 1;\\n        else e += nums[n-1] - nums[n-2] + 1;\\n    }\\n    for(int i = 1; i < n - 1; i++) {\\n        int min= fmin(nums[i-1], nums[i+1]);\\n        if(nums[i] >= min) {\\n            if(i%2) o += nums[i] - min + 1;\\n            else e += nums[i] - min + 1;\\n        }\\n    }\\n    return fmin(e, o);\\n}\\n```\\n\\nBest way to solve this question is to find the total moves it takes to make all odd position or all even position at min. And then return the min moves b/w odd and even.",
                "solutionTags": [],
                "code": "```\\nint movesToMakeZigzag(int* nums, int n){\\n    if(n<3) return 0;\\n    int e = 0;\\n    int o = 0;\\n    if(nums[0] >= nums[1]) {\\n        e += nums[0] - nums[1] + 1;\\n    }\\n    if(nums[n-1] >= nums[n-2]) {\\n        if((n-1)%2) o += nums[n-1] - nums[n-2] + 1;\\n        else e += nums[n-1] - nums[n-2] + 1;\\n    }\\n    for(int i = 1; i < n - 1; i++) {\\n        int min= fmin(nums[i-1], nums[i+1]);\\n        if(nums[i] >= min) {\\n            if(i%2) o += nums[i] - min + 1;\\n            else e += nums[i] - min + 1;\\n        }\\n    }\\n    return fmin(e, o);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2645498,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        temp_nums = list(nums)\\n        temp = 0\\n        for i in range(1,len(nums),2):\\n            min_val = nums[i-1]\\n\\n            if i < len(temp_nums)-1:\\n                min_val = min(nums[i+1],nums[i-1])\\n\\n            if nums[i] >=  min_val:\\n                diff = (nums[i] - min_val)+1\\n                temp += diff\\n                nums[i] -= diff\\n\\n        temp2 = 0\\n        for i in range(1,len(temp_nums),2):\\n            if i < len(temp_nums)-1 and temp_nums[i] <= temp_nums[i+1]:\\n                diff = (temp_nums[i+1] - temp_nums[i]) + 1\\n                temp2 += diff\\n                temp_nums[i+1] -= diff\\n\\n            if temp_nums[i] <= temp_nums[i-1]:\\n                diff = (temp_nums[i-1] - temp_nums[i]) + 1\\n                temp2 += diff\\n                temp_nums[i-1] -= diff\\n\\n            \\n        return min(temp,temp2)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        temp_nums = list(nums)\\n        temp = 0\\n        for i in range(1,len(nums),2):\\n            min_val = nums[i-1]\\n\\n            if i < len(temp_nums)-1:\\n                min_val = min(nums[i+1],nums[i-1])\\n\\n            if nums[i] >=  min_val:\\n                diff = (nums[i] - min_val)+1\\n                temp += diff\\n                nums[i] -= diff\\n\\n        temp2 = 0\\n        for i in range(1,len(temp_nums),2):\\n            if i < len(temp_nums)-1 and temp_nums[i] <= temp_nums[i+1]:\\n                diff = (temp_nums[i+1] - temp_nums[i]) + 1\\n                temp2 += diff\\n                temp_nums[i+1] -= diff\\n\\n            if temp_nums[i] <= temp_nums[i-1]:\\n                diff = (temp_nums[i-1] - temp_nums[i]) + 1\\n                temp2 += diff\\n                temp_nums[i-1] -= diff\\n\\n            \\n        return min(temp,temp2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641902,
                "title": "simple-c-solution",
                "content": "**Approch :**\\nYou can either form an array of type A[0] > A[1] < A[2] > A[3] < A[4] > ...   or A[0] < A[1] > A[2] < A[3] > A[4] < ...\\nJust take be both cases and the case which require less numbers if move return that.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> v ,bool flag){\\n         \\n        int cnt = 0;\\n        for(int i = 0;i<v.size()-1;i++) {\\n             if(flag) {\\n                 if(v[i] >= v[i+1]) {\\n                    cnt += (v[i] - v[i+1]+1);\\n                    v[i] -= (v[i]-v[i+1] + 1);\\n                 }\\n             }\\n            else{\\n                if(v[i] <= v[i+1]){\\n                    cnt += (v[i+1] - v[i]+1);\\n                    v[i+1] -= (v[i+1] - v[i]+1);\\n                }\\n            }\\n            flag = !flag;\\n        }   \\n        return cnt;    \\n    } \\n    int movesToMakeZigzag(vector<int>& nums) {\\n        return min(solve(nums , 1) , solve(nums,0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> v ,bool flag){\\n         \\n        int cnt = 0;\\n        for(int i = 0;i<v.size()-1;i++) {\\n             if(flag) {\\n                 if(v[i] >= v[i+1]) {\\n                    cnt += (v[i] - v[i+1]+1);\\n                    v[i] -= (v[i]-v[i+1] + 1);\\n                 }\\n             }\\n            else{\\n                if(v[i] <= v[i+1]){\\n                    cnt += (v[i+1] - v[i]+1);\\n                    v[i+1] -= (v[i+1] - v[i]+1);\\n                }\\n            }\\n            flag = !flag;\\n        }   \\n        return cnt;    \\n    } \\n    int movesToMakeZigzag(vector<int>& nums) {\\n        return min(solve(nums , 1) , solve(nums,0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600018,
                "title": "java-intuitive-approach",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int count1 = 0, count2 = 0;\\n        int nums1[] = nums.clone();\\n        int nums2[] = nums.clone();\\n        //Checking the condition that all even placed numbers are greater than their adjacent position numbers..\\n        for(int i = 1;i<nums1.length;i++){\\n            if(i%2 == 1){\\n                if(nums1[i] >= nums1[i-1]){\\n                    int moves = nums1[i] - nums1[i-1] + 1;\\n                    count1 += moves;\\n                    nums1[i] = nums[i-1] - 1;\\n                }\\n            }\\n            else{\\n                if(nums1[i] <= nums1[i-1]){\\n                    int moves = nums1[i-1] - nums1[i] + 1;\\n                    count1 += moves;\\n                    nums1[i-1] = nums[i] - 1;\\n                }\\n            }\\n        }\\n        \\n        //Checking for the condition that all odd placed numbers are greater than their adjacent position numbers-->\\n        for(int i = 1;i<nums2.length;i++){\\n            if(i%2 == 0){\\n                if(nums2[i] >= nums2[i-1]){\\n                    int moves = nums2[i] - nums2[i-1] + 1;\\n                    count2 += moves;\\n                    nums2[i] = nums2[i-1] - 1;\\n                }\\n            }\\n            else{\\n                if(nums2[i] <= nums2[i-1]){\\n                    int moves = nums2[i-1] - nums2[i] + 1;\\n                    count2 += moves;\\n                    nums2[i-1] = nums2[i] - 1;\\n                }\\n            }\\n        }\\n        return Math.min(count1, count2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int count1 = 0, count2 = 0;\\n        int nums1[] = nums.clone();\\n        int nums2[] = nums.clone();\\n        //Checking the condition that all even placed numbers are greater than their adjacent position numbers..\\n        for(int i = 1;i<nums1.length;i++){\\n            if(i%2 == 1){\\n                if(nums1[i] >= nums1[i-1]){\\n                    int moves = nums1[i] - nums1[i-1] + 1;\\n                    count1 += moves;\\n                    nums1[i] = nums[i-1] - 1;\\n                }\\n            }\\n            else{\\n                if(nums1[i] <= nums1[i-1]){\\n                    int moves = nums1[i-1] - nums1[i] + 1;\\n                    count1 += moves;\\n                    nums1[i-1] = nums[i] - 1;\\n                }\\n            }\\n        }\\n        \\n        //Checking for the condition that all odd placed numbers are greater than their adjacent position numbers-->\\n        for(int i = 1;i<nums2.length;i++){\\n            if(i%2 == 0){\\n                if(nums2[i] >= nums2[i-1]){\\n                    int moves = nums2[i] - nums2[i-1] + 1;\\n                    count2 += moves;\\n                    nums2[i] = nums2[i-1] - 1;\\n                }\\n            }\\n            else{\\n                if(nums2[i] <= nums2[i-1]){\\n                    int moves = nums2[i-1] - nums2[i] + 1;\\n                    count2 += moves;\\n                    nums2[i-1] = nums2[i] - 1;\\n                }\\n            }\\n        }\\n        return Math.min(count1, count2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539079,
                "title": "c-easy-to-understand",
                "content": "Runtime: 70 ms, faster than 100.00% of C# online submissions for Decrease Elements To Make Array Zigzag.\\nMemory Usage: 36.4 MB, less than 92.86% of C# online submissions for Decrease Elements To Make Array Zigzag.\\n\\n```\\npublic class Solution {\\n    public int MovesToMakeZigzag(int[] nums) {\\n\\n        int even = 0, odd = 0, l = nums.Length;\\n        int[] tmp = (int[])nums.Clone();\\n        \\n        if(l > 1){\\n\\n            //1.decrease odd\\n            for(int i = 1; i <= l-1; i+=2){\\n                //left\\n                while(tmp[i] >= tmp[i-1]){\\n                    tmp[i]--;\\n                    odd++;\\n                }\\n                //right\\n                if(i < l-1){\\n                    while(tmp[i] >= tmp[i+1]){\\n                        tmp[i]--;\\n                        odd++;\\n                    }\\n                }\\n                if(tmp[i] < 0){\\n                    odd = -1;\\n                }\\n            }\\n\\n            //2.decrease even\\n            for(int i = 0; i <= l-1; i+=2){\\n                //left\\n                if(i > 0){\\n                    while(nums[i] >= nums[i-1]){\\n                        nums[i]--;\\n                        even++;\\n                    }\\n                }\\n                //right\\n                if(i == 0 || i <= l-2){\\n                    while(nums[i] >= nums[i+1]){\\n                        nums[i]--;\\n                        even++;\\n                    }\\n                }\\n                if(even < 0){\\n                    even = -1;\\n                }\\n            }\\n\\n            //check which counter to return\\n            if(odd == -1){\\n                return even;\\n            }\\n            else if (even == -1){\\n                return odd;\\n            }\\n            else{\\n                return Math.Min(even, odd);\\n            }\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n}\\n\\xB4\\xB4\\xB4",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MovesToMakeZigzag(int[] nums) {\\n\\n        int even = 0, odd = 0, l = nums.Length;\\n        int[] tmp = (int[])nums.Clone();\\n        \\n        if(l > 1){\\n\\n            //1.decrease odd\\n            for(int i = 1; i <= l-1; i+=2){\\n                //left\\n                while(tmp[i] >= tmp[i-1]){\\n                    tmp[i]--;\\n                    odd++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2535212,
                "title": "simple-with-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n\\t\\n        return min(min_res(nums,0),min_res(nums,1));\\n    }\\n    int min_res(vector<int>nums,int rem)\\n    {\\n        int res=0,inc;\\n\\t\\t\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i%2==rem)\\n            {\\n               if(i-1>=0 and nums[i-1]>=nums[i])\\n               {\\n                   inc=(nums[i-1]-nums[i])+1;\\n\\t\\t\\t\\t   \\n                   res+=inc,nums[i-1]-=inc;\\n               }\\n                if(i+1<nums.size() and nums[i+1]>=nums[i])\\n                {\\n                    inc=(nums[i+1]-nums[i])+1;\\n\\t\\t\\t\\t\\t\\n                    res+=inc,nums[i+1]-=inc;\\n                }\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n\\t\\n        return min(min_res(nums,0),min_res(nums,1));\\n    }\\n    int min_res(vector<int>nums,int rem)\\n    {\\n        int res=0,inc;\\n\\t\\t\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i%2==rem)\\n            {\\n               if(i-1>=0 and nums[i-1]>=nums[i])\\n               {\\n                   inc=(nums[i-1]-nums[i])+1;\\n\\t\\t\\t\\t   \\n                   res+=inc,nums[i-1]-=inc;\\n               }\\n                if(i+1<nums.size() and nums[i+1]>=nums[i])\\n                {\\n                    inc=(nums[i+1]-nums[i])+1;\\n\\t\\t\\t\\t\\t\\n                    res+=inc,nums[i+1]-=inc;\\n                }\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415104,
                "title": "easy-faster-100-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int n = nums.length;\\n        int [] b = nums.clone();\\n        int even = 0;\\n        int odd = 0;\\n        for(int i = 0; i < n - 1; i++){\\n//             if even indexes elements are considered to bigger \\n            if(i % 2 == 0){\\n                if(nums[i] <= nums[i + 1]){\\n                    int diff = nums[i + 1] - nums[i];\\n                    even += (diff + 1);\\n                    nums[i + 1] = nums[i + 1] - (diff + 1);\\n                }\\n            } else {\\n                if(nums[i] >= nums[i + 1]){\\n                    int diff = nums[i] - nums[i + 1];\\n                    even += (diff + 1);\\n                    nums[i] = nums[i] - (diff + 1);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n//             if odd indexes elements are considered to bigger\\n            if(i % 2 == 0){\\n                if(b[i] >= b[i + 1]){\\n                    int diff = b[i] - b[i + 1];\\n                    odd += (diff + 1);\\n                    b[i] = b[i] - (diff + 1);\\n                }\\n            } else {\\n                if(b[i] <= b[i + 1]){\\n                    int diff = b[i + 1] - b[i];\\n                    odd += (diff + 1);\\n                    b[i + 1] = b[i + 1] - (diff + 1);\\n                }\\n            }\\n        }\\n        return Math.min(odd, even);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int n = nums.length;\\n        int [] b = nums.clone();\\n        int even = 0;\\n        int odd = 0;\\n        for(int i = 0; i < n - 1; i++){\\n//             if even indexes elements are considered to bigger \\n            if(i % 2 == 0){\\n                if(nums[i] <= nums[i + 1]){\\n                    int diff = nums[i + 1] - nums[i];\\n                    even += (diff + 1);\\n                    nums[i + 1] = nums[i + 1] - (diff + 1);\\n                }\\n            } else {\\n                if(nums[i] >= nums[i + 1]){\\n                    int diff = nums[i] - nums[i + 1];\\n                    even += (diff + 1);\\n                    nums[i] = nums[i] - (diff + 1);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n//             if odd indexes elements are considered to bigger\\n            if(i % 2 == 0){\\n                if(b[i] >= b[i + 1]){\\n                    int diff = b[i] - b[i + 1];\\n                    odd += (diff + 1);\\n                    b[i] = b[i] - (diff + 1);\\n                }\\n            } else {\\n                if(b[i] <= b[i + 1]){\\n                    int diff = b[i + 1] - b[i];\\n                    odd += (diff + 1);\\n                    b[i + 1] = b[i + 1] - (diff + 1);\\n                }\\n            }\\n        }\\n        return Math.min(odd, even);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409776,
                "title": "python-easy-solution-o-n",
                "content": "1. Establish an array to store for every node that needs how many moves if decrease the node less than the other adjacent node.\\n2. Compare the even node and odd node in the array,choose the group with fewer moves.\\n\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        \\n        if length == 1: return 0\\n        if length == 2: return 0 if nums[0] != nums[1] else 1\\n        \\n        res = [nums[0] - nums[1] + 1 if nums[0] >= nums[1] else 0]\\n        for i in range(1, length - 1):\\n            value = min(nums[i - 1], nums[i + 1])\\n            res.append(nums[i] - value + 1 if nums[i] >= value else 0)\\n        res.append(nums[-1] - nums[-2] + 1 if nums[-1] >= nums[-2] else 0)\\n        \\n        return min(sum(res[0::2]), sum(res[1::2]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        \\n        if length == 1: return 0\\n        if length == 2: return 0 if nums[0] != nums[1] else 1\\n        \\n        res = [nums[0] - nums[1] + 1 if nums[0] >= nums[1] else 0]\\n        for i in range(1, length - 1):\\n            value = min(nums[i - 1], nums[i + 1])\\n            res.append(nums[i] - value + 1 if nums[i] >= value else 0)\\n        res.append(nums[-1] - nums[-2] + 1 if nums[-1] >= nums[-2] else 0)\\n        \\n        return min(sum(res[0::2]), sum(res[1::2]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402645,
                "title": "java-solution-with-easy-intuition",
                "content": "You can find an intuition of O(N) by starting with a brute force approach. Brute force approach would require to test every possible value in range [0, nums[i]] for all positions i. If we take k = max(nums[i]) then brute force would be O(k^n). This is testing every possible profile.\\n\\nHowever, from the problem description we can see that there are only 2 profiles: either up, down, up, down,..... or down, up, down, up,......\\n\\nso we test one profile at a time and return the smallest cost of the two, when we find that a position in the array does not fit the profile (for example it should go \"up\" but it goes \"down\") we fix it optimally by either reducing position i or position i - 1. In both cases we already know the all positions before i - 1 are in a zig zag pattern thanks to loop invariant, so reducing i or i - 1 should not require to change any previous positions and thus this is the optimal zig zag pattern until i.\\n```\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean up = false;\\n        for (int c = 0; c < 2; ++c, up = true) {\\n            int currAns = 0;\\n            for (int i = 1, prev = nums[0]; i < nums.length; ++i, up = !up) {\\n                if (up) {\\n                    currAns += Integer.max(0, prev - nums[i] + 1);\\n                    prev = nums[i];\\n                } else {\\n                    if (prev > nums[i]) {\\n                        prev = nums[i];\\n                        continue;\\n                    }\\n                    currAns += nums[i] - prev + 1;\\n                    --prev;\\n                }\\n            }\\n            ans = Integer.min(ans, currAns);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean up = false;\\n        for (int c = 0; c < 2; ++c, up = true) {\\n            int currAns = 0;\\n            for (int i = 1, prev = nums[0]; i < nums.length; ++i, up = !up) {\\n                if (up) {\\n                    currAns += Integer.max(0, prev - nums[i] + 1);\\n                    prev = nums[i];\\n                } else {\\n                    if (prev > nums[i]) {\\n                        prev = nums[i];\\n                        continue;\\n                    }\\n                    currAns += nums[i] - prev + 1;\\n                    --prev;\\n                }\\n            }\\n            ans = Integer.min(ans, currAns);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367455,
                "title": "python-solution-explanation-on-why-moving-evens-or-odds-works",
                "content": "```\\nclass Solution:\\n    # Consider the example [1,-1,4]\\n    # To construct odd larger array, we can move the odd only \\n    # [1, 5, 4]: 6 moves\\n    # [1, 2, 1]: 6 moves\\n    # A[2] -> A[0]\\n    # A[1] -> A[0] + 1\\n    # A[2] - A[0] + A[0] + 1 - A[1] = A[2] - A[1] + 1\\n    # The minimal move can be achieved with moving odds or evens only\\n    # Two possibilities: either even is greater or odd is greater\\n    # We don\\'t really know which one is minimal moves, so try both\\n    # To get the min for one of them:\\n    # Example: [9,6,1,6,2]\\n    # Odd is greater: 9 -> 5 \\n    # Even is greater: 1 -> 7, 2 -> 7\\n    # We modify the even indices if odd is greater and modify the odd indices if even is greater\\n    \\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 0\\n        result_even, result_odd, n = 0, 0, len(nums)\\n        for i, num in enumerate(nums):\\n            if i == 0:\\n                result_odd += max(0, nums[i] - nums[i+1] + 1)\\n            elif i == n-1:\\n                if i % 2 == 0:\\n                    result_odd += max(0, nums[i] - nums[i-1] + 1)\\n                else:\\n                    result_even += max(0, nums[i] - nums[i-1] + 1)\\n            else:\\n                if i % 2 == 0:\\n                    result_odd += max(0, nums[i] - nums[i-1] + 1, nums[i] - nums[i+1] + 1)\\n                else:\\n                    result_even += max(0, nums[i] - nums[i-1]+ 1, nums[i] - nums[i+1] + 1)\\n        return min(result_odd, result_even)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Consider the example [1,-1,4]\\n    # To construct odd larger array, we can move the odd only \\n    # [1, 5, 4]: 6 moves\\n    # [1, 2, 1]: 6 moves\\n    # A[2] -> A[0]\\n    # A[1] -> A[0] + 1\\n    # A[2] - A[0] + A[0] + 1 - A[1] = A[2] - A[1] + 1\\n    # The minimal move can be achieved with moving odds or evens only\\n    # Two possibilities: either even is greater or odd is greater\\n    # We don\\'t really know which one is minimal moves, so try both\\n    # To get the min for one of them:\\n    # Example: [9,6,1,6,2]\\n    # Odd is greater: 9 -> 5 \\n    # Even is greater: 1 -> 7, 2 -> 7\\n    # We modify the even indices if odd is greater and modify the odd indices if even is greater\\n    \\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 0\\n        result_even, result_odd, n = 0, 0, len(nums)\\n        for i, num in enumerate(nums):\\n            if i == 0:\\n                result_odd += max(0, nums[i] - nums[i+1] + 1)\\n            elif i == n-1:\\n                if i % 2 == 0:\\n                    result_odd += max(0, nums[i] - nums[i-1] + 1)\\n                else:\\n                    result_even += max(0, nums[i] - nums[i-1] + 1)\\n            else:\\n                if i % 2 == 0:\\n                    result_odd += max(0, nums[i] - nums[i-1] + 1, nums[i] - nums[i+1] + 1)\\n                else:\\n                    result_even += max(0, nums[i] - nums[i-1]+ 1, nums[i] - nums[i+1] + 1)\\n        return min(result_odd, result_even)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335999,
                "title": "java-clear-approach-o-n-time-space-complexity",
                "content": "```\\nclass Solution {\\n    /*\\n        firstly, check elements in odd indices are greater than its neighbours.\\n        if not, decrease its neigbours and update the cost.\\n        \\n        do same thing for even indices, because there can be two combinations as indicated in question.\\n    */\\n    \\n    private int calculateCost(int[] nums, int start){\\n        int res = 0;\\n        int n = nums.length;\\n        int[] arr = Arrays.copyOf(nums, nums.length); // nums array will be modified, so copy it.\\n        \\n        for(int i=start;i<n;i+=2){\\n            int prev = (i==0) ? Integer.MIN_VALUE : arr[i-1]; \\n            int cur = arr[i];\\n            int next = (i == n-1) ? Integer.MIN_VALUE : arr[i+1];\\n            \\n            if(prev < cur && next < cur)\\n                continue;\\n        \\n            if(prev >= cur){\\n                res += prev-cur +1;\\n                arr[i-1] = cur-1;\\n            } \\n            \\n            if(next >= cur){\\n                res += next-cur +1;\\n                arr[i+1] = cur-1;\\n            }\\n        }\\n        return res;\\n    }\\n        \\n    public int movesToMakeZigzag(int[] nums) {\\n        return Math.min(calculateCost(nums, 0), calculateCost(nums,1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n        firstly, check elements in odd indices are greater than its neighbours.\\n        if not, decrease its neigbours and update the cost.\\n        \\n        do same thing for even indices, because there can be two combinations as indicated in question.\\n    */\\n    \\n    private int calculateCost(int[] nums, int start){\\n        int res = 0;\\n        int n = nums.length;\\n        int[] arr = Arrays.copyOf(nums, nums.length); // nums array will be modified, so copy it.\\n        \\n        for(int i=start;i<n;i+=2){\\n            int prev = (i==0) ? Integer.MIN_VALUE : arr[i-1]; \\n            int cur = arr[i];\\n            int next = (i == n-1) ? Integer.MIN_VALUE : arr[i+1];\\n            \\n            if(prev < cur && next < cur)\\n                continue;\\n        \\n            if(prev >= cur){\\n                res += prev-cur +1;\\n                arr[i-1] = cur-1;\\n            } \\n            \\n            if(next >= cur){\\n                res += next-cur +1;\\n                arr[i+1] = cur-1;\\n            }\\n        }\\n        return res;\\n    }\\n        \\n    public int movesToMakeZigzag(int[] nums) {\\n        return Math.min(calculateCost(nums, 0), calculateCost(nums,1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322797,
                "title": "c-single-loop-with-comments",
                "content": "```\\npublic class Solution {\\n    public int MovesToMakeZigzag(int[] nums) {\\n        //Decrease only\\n        \\n        //Two patterns we can use (even greater/odd greater)\\n        //Return the min of trying those two patterns\\n\\n        var movesEvenGreater = 0;\\n        var movesOddGreater = 0;\\n        for(int i = 0; i < nums.Length; i++) {\\n            var prev = int.MaxValue;\\n            if (i - 1 >= 0) prev = nums[i-1];\\n            var next = int.MaxValue;\\n            if (i + 1 < nums.Length) next = nums[i+1];\\n            \\n            var adjacentMin = Math.Min(prev, next);\\n            \\n            //If the adjacent ones are smaller than current, we need to decrease it to zigzag\\n            if (adjacentMin <= nums[i]) {\\n                bool isEvenGreaterStep = i % 2 != 0; //If were on an odd index, we are making evens the greater one\\n                if (isEvenGreaterStep) {\\n                    //moves for even greater\\n                    movesEvenGreater += nums[i] - adjacentMin + 1; //+1 for strict less\\n                }\\n                else {\\n                    //moves for odd greater\\n                    movesOddGreater += nums[i] - adjacentMin + 1;\\n                }\\n            }\\n\\n        }\\n        \\n        return Math.Min(movesEvenGreater, movesOddGreater);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MovesToMakeZigzag(int[] nums) {\\n        //Decrease only\\n        \\n        //Two patterns we can use (even greater/odd greater)\\n        //Return the min of trying those two patterns\\n\\n        var movesEvenGreater = 0;\\n        var movesOddGreater = 0;\\n        for(int i = 0; i < nums.Length; i++) {\\n            var prev = int.MaxValue;\\n            if (i - 1 >= 0) prev = nums[i-1];\\n            var next = int.MaxValue;\\n            if (i + 1 < nums.Length) next = nums[i+1];\\n            \\n            var adjacentMin = Math.Min(prev, next);\\n            \\n            //If the adjacent ones are smaller than current, we need to decrease it to zigzag\\n            if (adjacentMin <= nums[i]) {\\n                bool isEvenGreaterStep = i % 2 != 0; //If were on an odd index, we are making evens the greater one\\n                if (isEvenGreaterStep) {\\n                    //moves for even greater\\n                    movesEvenGreater += nums[i] - adjacentMin + 1; //+1 for strict less\\n                }\\n                else {\\n                    //moves for odd greater\\n                    movesOddGreater += nums[i] - adjacentMin + 1;\\n                }\\n            }\\n\\n        }\\n        \\n        return Math.Min(movesEvenGreater, movesOddGreater);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227302,
                "title": "python-100-faster-well-written-perfect-code-simple-explained-well",
                "content": "# TIME AND SPACE COMPLEXITY\\nRuntime: 28 ms, faster than 100.00% of Python3 online submissions for Decrease Elements To Make Array Zigzag.\\nMemory Usage: 13.9 MB, less than 85.71% of Python3 online submissions for Decrease Elements To Make Array Zigzag.\\n\\n# FASTEST SOLUTION AVAILABLE\\n\\n\\n# EXPLANATION\\n```\\nThe idea is fix the array such that the array is a zig zag array till index i \\n\\nWe can have two types of zig zag array\\n1. Odd larger array\\n2. Even larger array\\n\\n-->>ODD LARGER ARRAY\\n   Here array  = [ 9, 6 , 1 , 6 ,2 ] will be represented as  9 < 6 > 1 < 6 > 2\\n   let\\'s start solving the problem :\\n   1. index = 0 : there will never be any problem at index  = 0\\n   2. index = 1: check if 6 > 9 or not \\n                 If 6 is less than 9 means our zig zag array is voilated so \\n\\t\\t\\t\\t we should decrease the 9 as we can only decrement value\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t So make 9 as 5 i.e. 6 - 1\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t Now we go to index  = 0 to make sure that changing 9 is not causing any problem\\n\\t\\t\\t\\t in previous side\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t new array = [ 5 , 6 , 1, 6 , 2]  ---> 5 < 6 > 1 < 6 > 2\\n3. index  = 0: always correct\\n4. index = 1 : 5 < 6 correct\\n5. index = 2: 6 > 1 correct\\n6. index = 3: 1 < 6 correct\\n7. index = 4: 6 > 2 correct\\n\\nSO we got the idea that during odd largest zig zag array there exists two cases:\\n1. when index % 2 == 0 : problem can occur if arr[i-1] < arr[i]\\n2. when index % 2 == 1: problem can occur if arr[i-1] > arr[i]\\n\\n\\nSIMILARLY WE CAN SOLVE FOR\\n--->EVEN LARGER ZIG ZAG ARRAY\\nHere our cases will be :\\n1. when index % 2 == 0 : problem can occur if arr[i-1] > arr[i]\\n2. when index % 2 == 1: problem can occur if arr[i-1] < arr[i]\\n```\\n\\n# CODE\\n```\\nclass Solution:\\n    def solve(self,arr,n,x):\\n        idx = 1\\n        ans = 0\\n        while idx < n:\\n            if idx == 0: idx += 1\\n            if idx % 2 == x:\\n                if arr[idx-1] >= arr[idx]:\\n                    ans += arr[idx-1] - arr[idx] + 1\\n                    arr[idx-1] = arr[idx] - 1\\n                    idx = idx-1\\n                else:\\n                    idx = idx+1\\n            else:\\n                if arr[idx-1] <= arr[idx]:\\n                    ans += arr[idx] - arr[idx - 1] + 1\\n                    arr[idx] = arr[idx-1] - 1\\n                idx += 1               \\n        return ans\\n    \\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        ans1 = self.solve([x for x in nums],len(nums),0)\\n        ans2 = self.solve([x for x in nums],len(nums),1)\\n        return min(ans1,ans2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nThe idea is fix the array such that the array is a zig zag array till index i \\n\\nWe can have two types of zig zag array\\n1. Odd larger array\\n2. Even larger array\\n\\n-->>ODD LARGER ARRAY\\n   Here array  = [ 9, 6 , 1 , 6 ,2 ] will be represented as  9 < 6 > 1 < 6 > 2\\n   let\\'s start solving the problem :\\n   1. index = 0 : there will never be any problem at index  = 0\\n   2. index = 1: check if 6 > 9 or not \\n                 If 6 is less than 9 means our zig zag array is voilated so \\n\\t\\t\\t\\t we should decrease the 9 as we can only decrement value\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t So make 9 as 5 i.e. 6 - 1\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t Now we go to index  = 0 to make sure that changing 9 is not causing any problem\\n\\t\\t\\t\\t in previous side\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t new array = [ 5 , 6 , 1, 6 , 2]  ---> 5 < 6 > 1 < 6 > 2\\n3. index  = 0: always correct\\n4. index = 1 : 5 < 6 correct\\n5. index = 2: 6 > 1 correct\\n6. index = 3: 1 < 6 correct\\n7. index = 4: 6 > 2 correct\\n\\nSO we got the idea that during odd largest zig zag array there exists two cases:\\n1. when index % 2 == 0 : problem can occur if arr[i-1] < arr[i]\\n2. when index % 2 == 1: problem can occur if arr[i-1] > arr[i]\\n\\n\\nSIMILARLY WE CAN SOLVE FOR\\n--->EVEN LARGER ZIG ZAG ARRAY\\nHere our cases will be :\\n1. when index % 2 == 0 : problem can occur if arr[i-1] > arr[i]\\n2. when index % 2 == 1: problem can occur if arr[i-1] < arr[i]\\n```\n```\\nclass Solution:\\n    def solve(self,arr,n,x):\\n        idx = 1\\n        ans = 0\\n        while idx < n:\\n            if idx == 0: idx += 1\\n            if idx % 2 == x:\\n                if arr[idx-1] >= arr[idx]:\\n                    ans += arr[idx-1] - arr[idx] + 1\\n                    arr[idx-1] = arr[idx] - 1\\n                    idx = idx-1\\n                else:\\n                    idx = idx+1\\n            else:\\n                if arr[idx-1] <= arr[idx]:\\n                    ans += arr[idx] - arr[idx - 1] + 1\\n                    arr[idx] = arr[idx-1] - 1\\n                idx += 1               \\n        return ans\\n    \\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        ans1 = self.solve([x for x in nums],len(nums),0)\\n        ans2 = self.solve([x for x in nums],len(nums),1)\\n        return min(ans1,ans2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212956,
                "title": "c-code-100-faster",
                "content": "Inspired by @lee215\\'s answer\\n\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& v) {\\n        int i;\\n        int n=v.size();\\n        \\n        vector<int> ans(2,0);\\n        for (i=0; i<n; i++){\\n            int a=(i>0)?v[i-1]:1001;\\n            int b=(i<n-1)?v[i+1]:1001;\\n            \\n            ans[i%2]+=max(0,v[i]-min(a,b)+1);\\n        }\\n        \\n     return min(ans[0],ans[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& v) {\\n        int i;\\n        int n=v.size();\\n        \\n        vector<int> ans(2,0);\\n        for (i=0; i<n; i++){\\n            int a=(i>0)?v[i-1]:1001;\\n            int b=(i<n-1)?v[i+1]:1001;\\n            \\n            ans[i%2]+=max(0,v[i]-min(a,b)+1);\\n        }\\n        \\n     return min(ans[0],ans[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203400,
                "title": "very-very-easy-cpp-solution",
                "content": "```\\npublic:\\n    //sirf decrease ka option hai\\n    // funny: odd positions ke liye indexes even honge\\n    //approch: pehle sari odd positions ko kam krke dekho ki kitne moves honge\\n    //simultaneously count for even positions, and return the min moves\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oddc = 0, evenc = 0;\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        for(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t//handling the corner cases:\\n            if(i==0 && i+1<nums.size()){\\n                oddc+=max(0,nums[i]-nums[i+1]+1);\\n            }\\n            else if(i==n-1){\\n                if(n%2){\\n                    oddc+=max(0,nums[i]-nums[i-1]+1);\\n                }\\n                else\\n                    evenc+=max(0,nums[i]-nums[i-1]+1);\\n            }\\n\\t\\t\\t\\n            else if(i%2==0)\\n                oddc+= max(0,(nums[i]-min(nums[i-1],nums[i+1])+1));\\n            else\\n                evenc+=max(0,(nums[i]-min(nums[i-1],nums[i+1])+1));\\n        }\\n        return min(oddc,evenc);\\n    }\\n};\\n```\\n//thanks and please upvote if it helped you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\npublic:\\n    //sirf decrease ka option hai\\n    // funny: odd positions ke liye indexes even honge\\n    //approch: pehle sari odd positions ko kam krke dekho ki kitne moves honge\\n    //simultaneously count for even positions, and return the min moves\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int oddc = 0, evenc = 0;\\n        int n = nums.size();\\n        if(n==1) return 0;\\n        for(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t//handling the corner cases:\\n            if(i==0 && i+1<nums.size()){\\n                oddc+=max(0,nums[i]-nums[i+1]+1);\\n            }\\n            else if(i==n-1){\\n                if(n%2){\\n                    oddc+=max(0,nums[i]-nums[i-1]+1);\\n                }\\n                else\\n                    evenc+=max(0,nums[i]-nums[i-1]+1);\\n            }\\n\\t\\t\\t\\n            else if(i%2==0)\\n                oddc+= max(0,(nums[i]-min(nums[i-1],nums[i+1])+1));\\n            else\\n                evenc+=max(0,(nums[i]-min(nums[i-1],nums[i+1])+1));\\n        }\\n        return min(oddc,evenc);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200582,
                "title": "c-approach",
                "content": "\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int count = 0;\\n        int counto = 0;\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            int xy = 0;\\n            if(i+1 < nums.size())\\n             xy = min(nums[i-1],nums[i+1]);\\n            else\\n                xy = nums[i-1];\\n            if(nums[i] >= xy)\\n            {\\n                count += (nums[i] - xy)+1;\\n            }\\n                \\n        }\\n         for(int i=1;i<nums.size();i+=2)\\n        {\\n             int f1 = nums[i-1],f2 = 0;\\n           if(i+1 < nums.size())\\n               f2 = nums[i+1];\\n             \\n             if(nums[i] <= f1)\\n             {\\n                 int value = (f1-nums[i])+1;\\n                 nums[i-1] -= value;\\n                 counto += value;\\n             }\\n             if(nums[i] <= f2)\\n             {\\n                 int value = (f2 - nums[i]) + 1;\\n                 nums[i+1] -= value;\\n                 counto += value;\\n              }\\n                 \\n                \\n        }\\n        return min(count, counto);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int count = 0;\\n        int counto = 0;\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            int xy = 0;\\n            if(i+1 < nums.size())\\n             xy = min(nums[i-1],nums[i+1]);\\n            else\\n                xy = nums[i-1];\\n            if(nums[i] >= xy)\\n            {\\n                count += (nums[i] - xy)+1;\\n            }\\n                \\n        }\\n         for(int i=1;i<nums.size();i+=2)\\n        {\\n             int f1 = nums[i-1],f2 = 0;\\n           if(i+1 < nums.size())\\n               f2 = nums[i+1];\\n             \\n             if(nums[i] <= f1)\\n             {\\n                 int value = (f1-nums[i])+1;\\n                 nums[i-1] -= value;\\n                 counto += value;\\n             }\\n             if(nums[i] <= f2)\\n             {\\n                 int value = (f2 - nums[i]) + 1;\\n                 nums[i+1] -= value;\\n                 counto += value;\\n              }\\n                 \\n                \\n        }\\n        return min(count, counto);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173740,
                "title": "java-easy-iterative-solution",
                "content": "class Solution {\\n\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i += 2){\\n            int num = nums[i];\\n            int cost = 0;\\n            if(i > 0 && i < n - 1){\\n                int left = nums[i-1];\\n                int right = nums[i+1];\\n                \\n                if(num < left && num < right){\\n                    continue;\\n                }else if(num >= left || num >= right){\\n                    cost = num - Math.min(left, right) + 1;\\n                }\\n            }else if(i == 0 && n > 1){\\n                int right = nums[i+1];\\n                if(num >= right){\\n                    cost = num-right+1;\\n                }\\n            }else if(i == n-1 && n > 1){\\n                int left = nums[i-1];\\n                if(num >= left){\\n                    cost = num-left+1;\\n                }\\n            }\\n            \\n            ans1 += cost;\\n        }\\n        \\n        \\n        for(int i = 1; i < n; i += 2){\\n            int num = nums[i];\\n            int cost = 0;\\n            if(i > 0 && i < n - 1){\\n                int left = nums[i-1];\\n                int right = nums[i+1];\\n                \\n                if(num < left && num < right){\\n                    continue;\\n                }else if(num >= left || num >= right){\\n                    cost = num - Math.min(left, right) + 1;\\n                }\\n            }else if(i == 0 && n > 1){\\n                int right = nums[i+1];\\n                if(num >= right){\\n                    cost = num-right+1;\\n                }\\n            }else if(i == n-1 && n > 1){\\n                int left = nums[i-1];\\n                if(num >= left){\\n                    cost = num-left+1;\\n                }\\n            }\\n            \\n            ans2 += cost;\\n        }\\n        \\n        return Math.min(ans1, ans2);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i += 2){\\n            int num = nums[i];\\n            int cost = 0;\\n            if(i > 0 && i < n - 1){\\n                int left = nums[i-1];\\n                int right = nums[i+1];\\n                \\n                if(num < left && num < right){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2143466,
                "title": "c-solution-by-recursion-and-adding-guard-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        \\n        vector<int> nums_a(nums), nums_b(nums), nums_c(nums), nums_d(nums);\\n        nums_a.insert(nums_a.begin(), INT_MAX); nums_a.push_back(INT_MAX);\\n        nums_b.insert(nums_b.begin(), INT_MAX); nums_b.push_back(INT_MIN);\\n        nums_c.insert(nums_c.begin(), INT_MIN); nums_c.push_back(INT_MIN);\\n        nums_d.insert(nums_d.begin(), INT_MIN); nums_d.push_back(INT_MAX);\\n        long n = nums_a.size(), sub, result = INT_MAX;\\n        sub = helper(nums_a, n, 1, 0);  result = min(result, sub);\\n        sub = helper(nums_b, n, 1, 0);  result = min(result, sub);\\n        sub = helper(nums_c, n, 1, 1);  result = min(result, sub);\\n        sub = helper(nums_d, n, 1, 1);  result = min(result, sub);\\n        return result;\\n    }\\n    /*\\n        initially, call:\\n        helper([INT_MAX, nums, INT_MAX], n, 1, style=0)\\n        helper([INT_MAX, nums, INT_MIN], n, 1, style=0)\\n        helper([INT_MIN, nums, INT_MIN], n, 1, style=1)\\n        helper([INT_MIN, nums, INT_MAX], n, 1, style=1)\\n        the 4 different cases are corresponding to 4 cases for adding guard\\n    */\\n    long helper(vector<int> &nums, int n, int p, int style){// style=0: local min, style=1, local max\\n        \\n        if (p > n - 2){\\n            return INT_MAX;\\n        }\\n        if (p == n - 2){\\n            if (style == 0){\\n                if (nums[p] < nums[p - 1] && nums[p] < nums[n - 1]){\\n                    return 0;\\n                }\\n                return INT_MAX;\\n            }\\n            // style == 1\\n            if (nums[p] > nums[p - 1] && nums[p] > nums[n - 1]){\\n                return 0;\\n            }\\n            return INT_MAX;\\n        }\\n        // regular:\\n        long sub, result = INT_MAX;\\n        if (style == 0){\\n            if (nums[p] < nums[p + 1]){// it\\'s right\\n                return helper(nums, n, p + 1, 1);\\n            }    \\n            // if it\\'s wrong\\n            long move = long(nums[p]) - long(nums[p + 1]) + 1;\\n            nums[p] = nums[p + 1] - 1;\\n            sub = move + helper(nums, n, p + 1, 1);\\n            nums[p] = nums[p + 1] - 1;\\n            result = min(result, sub);\\n        }\\n        else{// if style = 1\\n            if (nums[p] > nums[p + 1]){// it\\'s right\\n                return helper(nums, n, p + 1, 0);\\n            }\\n            long move = long(nums[p + 1]) - long(nums[p]) + 1;\\n            nums[p + 1] = nums[p] - 1;\\n            sub = move + helper(nums, n, p + 1, 0);\\n            nums[p + 1] = nums[p] + 1;\\n            result = min(result, sub);\\n        }\\n        \\n        return result;\\n    }\\n    void print(vector<int> vi){\\n        printf(\"[\");\\n        for (int i : vi){printf(\"%d, \", i);}\\n        printf(\"]\\\\n\");\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        \\n        vector<int> nums_a(nums), nums_b(nums), nums_c(nums), nums_d(nums);\\n        nums_a.insert(nums_a.begin(), INT_MAX); nums_a.push_back(INT_MAX);\\n        nums_b.insert(nums_b.begin(), INT_MAX); nums_b.push_back(INT_MIN);\\n        nums_c.insert(nums_c.begin(), INT_MIN); nums_c.push_back(INT_MIN);\\n        nums_d.insert(nums_d.begin(), INT_MIN); nums_d.push_back(INT_MAX);\\n        long n = nums_a.size(), sub, result = INT_MAX;\\n        sub = helper(nums_a, n, 1, 0);  result = min(result, sub);\\n        sub = helper(nums_b, n, 1, 0);  result = min(result, sub);\\n        sub = helper(nums_c, n, 1, 1);  result = min(result, sub);\\n        sub = helper(nums_d, n, 1, 1);  result = min(result, sub);\\n        return result;\\n    }\\n    /*\\n        initially, call:\\n        helper([INT_MAX, nums, INT_MAX], n, 1, style=0)\\n        helper([INT_MAX, nums, INT_MIN], n, 1, style=0)\\n        helper([INT_MIN, nums, INT_MIN], n, 1, style=1)\\n        helper([INT_MIN, nums, INT_MAX], n, 1, style=1)\\n        the 4 different cases are corresponding to 4 cases for adding guard\\n    */\\n    long helper(vector<int> &nums, int n, int p, int style){// style=0: local min, style=1, local max\\n        \\n        if (p > n - 2){\\n            return INT_MAX;\\n        }\\n        if (p == n - 2){\\n            if (style == 0){\\n                if (nums[p] < nums[p - 1] && nums[p] < nums[n - 1]){\\n                    return 0;\\n                }\\n                return INT_MAX;\\n            }\\n            // style == 1\\n            if (nums[p] > nums[p - 1] && nums[p] > nums[n - 1]){\\n                return 0;\\n            }\\n            return INT_MAX;\\n        }\\n        // regular:\\n        long sub, result = INT_MAX;\\n        if (style == 0){\\n            if (nums[p] < nums[p + 1]){// it\\'s right\\n                return helper(nums, n, p + 1, 1);\\n            }    \\n            // if it\\'s wrong\\n            long move = long(nums[p]) - long(nums[p + 1]) + 1;\\n            nums[p] = nums[p + 1] - 1;\\n            sub = move + helper(nums, n, p + 1, 1);\\n            nums[p] = nums[p + 1] - 1;\\n            result = min(result, sub);\\n        }\\n        else{// if style = 1\\n            if (nums[p] > nums[p + 1]){// it\\'s right\\n                return helper(nums, n, p + 1, 0);\\n            }\\n            long move = long(nums[p + 1]) - long(nums[p]) + 1;\\n            nums[p + 1] = nums[p] - 1;\\n            sub = move + helper(nums, n, p + 1, 0);\\n            nums[p + 1] = nums[p] + 1;\\n            result = min(result, sub);\\n        }\\n        \\n        return result;\\n    }\\n    void print(vector<int> vi){\\n        printf(\"[\");\\n        for (int i : vi){printf(\"%d, \", i);}\\n        printf(\"]\\\\n\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124249,
                "title": "c-easy-to-understand-ultimate-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n     int n=nums.size();\\n        int c1=0,c2=0;\\n        vector<int> nums2=nums;\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        else if(n==2)\\n        {\\n            return nums[0]==nums[1];\\n        }\\n        for(int i=0;i<n;i+=2)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]>nums[i+1])\\n                {\\n                    continue;\\n                }\\n                c1+=(nums[i+1]-nums[i])+1;\\n                nums[i+1]=nums[i]-1;\\n            }\\n            else if(i==n-1&&i%2==0)\\n            {\\n                if(nums[i]>nums[i-1])\\n                {\\n                    continue;\\n                }\\n                c1+=(nums[i-1]-nums[i])+1;\\n                nums[i-1]=nums[i]-1;\\n            }\\n            else\\n            {\\n                if(nums[i]>nums[i-1]&&nums[i]>nums[i+1])\\n                {\\n                    continue;\\n                }\\n                if(nums[i-1]>=nums[i])\\n                {\\n                    c1+=(nums[i-1]-nums[i])+1;\\n                    nums[i-1]=nums[i]-1;\\n                }\\n                if(nums[i+1]>=nums[i])\\n                {\\n                    c1+=(nums[i+1]-nums[i])+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n        }\\n        nums=nums2;\\n        c2=0;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            if(i==n-1)\\n            {\\n                if(nums[i]>nums[i-1])\\n                {\\n                    continue;\\n                }\\n                c2+=(nums[i-1]-nums[i])+1;\\n                nums[i-1]=nums[i]-1;\\n            }\\n            else \\n            {\\n                if(nums[i]>nums[i-1]&&nums[i]>nums[i+1])\\n                {\\n                    continue;\\n                }\\n                if(nums[i-1]>=nums[i])\\n                {\\n                    c2+=(nums[i-1]-nums[i])+1;\\n                    nums[i-1]=nums[i]-1;\\n                }\\n                if(nums[i+1]>=nums[i])\\n                {\\n                    c2+=(nums[i+1]-nums[i])+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n        }\\n        return min(c1,c2);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n     int n=nums.size();\\n        int c1=0,c2=0;\\n        vector<int> nums2=nums;\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        else if(n==2)\\n        {\\n            return nums[0]==nums[1];\\n        }\\n        for(int i=0;i<n;i+=2)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]>nums[i+1])\\n                {\\n                    continue;\\n                }\\n                c1+=(nums[i+1]-nums[i])+1;\\n                nums[i+1]=nums[i]-1;\\n            }\\n            else if(i==n-1&&i%2==0)\\n            {\\n                if(nums[i]>nums[i-1])\\n                {\\n                    continue;\\n                }\\n                c1+=(nums[i-1]-nums[i])+1;\\n                nums[i-1]=nums[i]-1;\\n            }\\n            else\\n            {\\n                if(nums[i]>nums[i-1]&&nums[i]>nums[i+1])\\n                {\\n                    continue;\\n                }\\n                if(nums[i-1]>=nums[i])\\n                {\\n                    c1+=(nums[i-1]-nums[i])+1;\\n                    nums[i-1]=nums[i]-1;\\n                }\\n                if(nums[i+1]>=nums[i])\\n                {\\n                    c1+=(nums[i+1]-nums[i])+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n        }\\n        nums=nums2;\\n        c2=0;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            if(i==n-1)\\n            {\\n                if(nums[i]>nums[i-1])\\n                {\\n                    continue;\\n                }\\n                c2+=(nums[i-1]-nums[i])+1;\\n                nums[i-1]=nums[i]-1;\\n            }\\n            else \\n            {\\n                if(nums[i]>nums[i-1]&&nums[i]>nums[i+1])\\n                {\\n                    continue;\\n                }\\n                if(nums[i-1]>=nums[i])\\n                {\\n                    c2+=(nums[i-1]-nums[i])+1;\\n                    nums[i-1]=nums[i]-1;\\n                }\\n                if(nums[i+1]>=nums[i])\\n                {\\n                    c2+=(nums[i+1]-nums[i])+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n        }\\n        return min(c1,c2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121136,
                "title": "javascript-greedy-70ms",
                "content": "```\\nconst movesToMakeZigzag = (a) => {\\n    let b = [...a], n = a.length, oddDec = 0, evenDec = 0;\\n    for (let i = 1; i < n; i += 2) { // a[0] > a[1] < a[2]\\n        if (i == n - 1) { // when n is odd, only two consecutive for final checking a[n-2], a[n - 1]\\n            if (a[i] >= a[i - 1]) {\\n                let update = a[i - 1] - 1;\\n                let old = a[i];\\n                a[i] = update;\\n                oddDec += old - update;\\n            }\\n        } else { // three consecutives a[i-1] a[i] a[i + 1]   needs to change a[i] (odd index)\\n            if (a[i] >= a[i - 1] || a[i] >= a[i + 1]) {\\n                update = Math.min(a[i - 1], a[i + 1]) - 1;\\n                let old = a[i];\\n                a[i] = update;\\n                oddDec += old - update;\\n            }\\n        }\\n    }\\n    for (let i = 1; i < n; i += 2) { // b[0] < b[1] > b[2]\\n        if (i == n - 1) { // when n is odd, only two consecutive for final checking b[n-2], b[n - 1]\\n            if (b[i] <= b[i - 1]) {\\n                let update = b[i - 1] + 1;\\n                let old = b[i];\\n                b[i] = update;\\n                evenDec += update - old;\\n            }\\n        } else { // three consecutives b[i-1] b[i] b[i + 1]   needs to change b[i-1] b[i+1] (even index)\\n            if (b[i] <= b[i - 1] || b[i] <= b[i + 1]) {\\n                let update = b[i] - 1;\\n                if (b[i] <= b[i - 1]) {\\n                    let old = b[i - 1];\\n                    b[i - 1] = update;\\n                    evenDec += old - update;\\n                }\\n                if (b[i] <= b[i + 1]) {\\n                    let old = b[i + 1];\\n                    b[i + 1] = update;\\n                    evenDec += old - update;\\n                }\\n            }\\n        }\\n    }\\n    return Math.min(oddDec, evenDec);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst movesToMakeZigzag = (a) => {\\n    let b = [...a], n = a.length, oddDec = 0, evenDec = 0;\\n    for (let i = 1; i < n; i += 2) { // a[0] > a[1] < a[2]\\n        if (i == n - 1) { // when n is odd, only two consecutive for final checking a[n-2], a[n - 1]\\n            if (a[i] >= a[i - 1]) {\\n                let update = a[i - 1] - 1;\\n                let old = a[i];\\n                a[i] = update;\\n                oddDec += old - update;\\n            }\\n        } else { // three consecutives a[i-1] a[i] a[i + 1]   needs to change a[i] (odd index)\\n            if (a[i] >= a[i - 1] || a[i] >= a[i + 1]) {\\n                update = Math.min(a[i - 1], a[i + 1]) - 1;\\n                let old = a[i];\\n                a[i] = update;\\n                oddDec += old - update;\\n            }\\n        }\\n    }\\n    for (let i = 1; i < n; i += 2) { // b[0] < b[1] > b[2]\\n        if (i == n - 1) { // when n is odd, only two consecutive for final checking b[n-2], b[n - 1]\\n            if (b[i] <= b[i - 1]) {\\n                let update = b[i - 1] + 1;\\n                let old = b[i];\\n                b[i] = update;\\n                evenDec += update - old;\\n            }\\n        } else { // three consecutives b[i-1] b[i] b[i + 1]   needs to change b[i-1] b[i+1] (even index)\\n            if (b[i] <= b[i - 1] || b[i] <= b[i + 1]) {\\n                let update = b[i] - 1;\\n                if (b[i] <= b[i - 1]) {\\n                    let old = b[i - 1];\\n                    b[i - 1] = update;\\n                    evenDec += old - update;\\n                }\\n                if (b[i] <= b[i + 1]) {\\n                    let old = b[i + 1];\\n                    b[i + 1] = update;\\n                    evenDec += old - update;\\n                }\\n            }\\n        }\\n    }\\n    return Math.min(oddDec, evenDec);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075114,
                "title": "java-greedy-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int odd = 0, even = 0;\\n        int n = nums.length;\\n        int prev = -1;\\n        for(int i = 0 ; i<n; i+=2){\\n            if(i!=0){\\n                even+=Math.max(prev-nums[i]+1,0);\\n            }\\n            if(i!=n-1){\\n                int val = Math.max(nums[i+1]-nums[i]+1,0);\\n                even+=val;\\n                prev = nums[i+1] - val;\\n            }\\n        }\\n        prev = nums[0];\\n        for(int i = 1 ; i<n; i+=2){\\n            if(i!=0){\\n                odd+=Math.max(prev-nums[i]+1,0);\\n            }\\n            if(i!=n-1){\\n                int val = Math.max(nums[i+1]-nums[i]+1,0);\\n                odd+=val;\\n                prev = nums[i+1] - val;\\n            }\\n        }\\n        return Math.min(odd,even);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int odd = 0, even = 0;\\n        int n = nums.length;\\n        int prev = -1;\\n        for(int i = 0 ; i<n; i+=2){\\n            if(i!=0){\\n                even+=Math.max(prev-nums[i]+1,0);\\n            }\\n            if(i!=n-1){\\n                int val = Math.max(nums[i+1]-nums[i]+1,0);\\n                even+=val;\\n                prev = nums[i+1] - val;\\n            }\\n        }\\n        prev = nums[0];\\n        for(int i = 1 ; i<n; i+=2){\\n            if(i!=0){\\n                odd+=Math.max(prev-nums[i]+1,0);\\n            }\\n            if(i!=n-1){\\n                int val = Math.max(nums[i+1]-nums[i]+1,0);\\n                odd+=val;\\n                prev = nums[i+1] - val;\\n            }\\n        }\\n        return Math.min(odd,even);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067838,
                "title": "typescript-easy-to-understand-100-faster-solution",
                "content": "Approach =>\\n\\n1. Calculate moves when odd index is lesser than neighbours.\\n2. Calculate moves when odd index is greater than neighbours.\\n3. Return the min value of step 1 && 2\\n\\n**Step 1 : We need to make the element lesser than left and right indices**\\n* Compare left and right index (if odd index is the last index then check only left side).\\n* If any left or right index is less than element then we need to move and decrease the element by min(leftIndexValue,rightIndexValue) + 1(One move lesser than the current value).\\n\\n**Step 2 : We need to make the element greater than left and right indices**\\n* Compare left and right index (if odd index is the last index then check only left side). In this case , we need to change the left and right values, as we can not increase the current element.\\n\\n* If both leftIndexValue and rightIndexValue is greater\\n\\t=> then we need to decrease both left and right, decreasing it to current element value - 1, and update the rightIndexValue for next odd index comparison.\\n\\n* If leftValueIndex is greater\\n\\t=> then we need to decrease left , decreasing it to current element value - 1, \\n\\n* If rightIndexValue is greater\\n\\t=> then we need to decrease right, decreasing it to current element value - 1, and update the rightIndexValue for next odd comparison.\\n\\n\\n\\n\\t\\n\\t\\n\\n\\n```\\nfunction movesToMakeZigzag(nums: number[]): number {\\n//return the min of both the calculations\\n   return Math.min(calculateOddLess(nums),calculateOddGreater(nums)); \\n};\\n\\n//function to check every odd position is less than from the neighbours\\nfunction calculateOddLess(nums: number[]):number{\\n    let count = 0;\\n    for(let i = 1; i < nums.length; i = i + 2){\\n\\t\\t//if not last element then we can compare left and right otherwise compare left element\\n        if(i != nums.length - 1){\\n            if(nums[i] >= nums[i-1] || nums[i] >= nums[i+1]){\\n                count += nums[i] - Math.min(nums[i-1],nums[i+1]) + 1;\\n            }\\n        }\\n        else{\\n            if(nums[i] >= nums[i-1]){\\n                count += nums[i] - nums[i-1] + 1;\\n            }\\n        }\\n        \\n    }\\n    return count;\\n}\\n\\n//function to check every odd position is greater than from the neighbours\\n\\nfunction calculateOddGreater(nums: number[]):number{\\n    let count = 0;\\n    for(let i = 1; i < nums.length; i = i+2){\\n        //if not last element then we can compare left and right element otherwise compare left element\\n        if(i != nums.length - 1){\\n\\t\\t\\t//if element is less than from left and right, then decrease left and right both and update the rightmost element for next comparison\\n            if(nums[i] <= nums[i-1] && nums[i] <= nums[i+1]){\\n                    count += nums[i-1] + nums[i+1] - (2 * nums[i]) + 2;\\n                    nums[i+1] = nums[i] -  1;\\n\\n            }\\n            else if(nums[i] <= nums[i-1] && nums[i] >= nums[i+1]){\\n\\t\\t\\t//if element is less than from left  then decrease left\\n                    count +=  nums[i-1] - nums[i] + 1;\\n            }\\n            else if(nums[i] >= nums[i-1] && nums[i] <= nums[i+1]){\\n\\t\\t\\t//if element is less than from  right, then decrease right and update the rightmost element for next compare\\n                    count +=  nums[i+1] - nums[i] + 1;\\n                    nums[i+1] = nums[i] - 1;\\n\\n            }\\n        }\\n        else{\\n            if(nums[i] <= nums[i-1]){\\n                    count +=  nums[i-1] - nums[i] + 1;\\n\\n            }\\n        }\\n\\n    }\\n\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction movesToMakeZigzag(nums: number[]): number {\\n//return the min of both the calculations\\n   return Math.min(calculateOddLess(nums),calculateOddGreater(nums)); \\n};\\n\\n//function to check every odd position is less than from the neighbours\\nfunction calculateOddLess(nums: number[]):number{\\n    let count = 0;\\n    for(let i = 1; i < nums.length; i = i + 2){\\n\\t\\t//if not last element then we can compare left and right otherwise compare left element\\n        if(i != nums.length - 1){\\n            if(nums[i] >= nums[i-1] || nums[i] >= nums[i+1]){\\n                count += nums[i] - Math.min(nums[i-1],nums[i+1]) + 1;\\n            }\\n        }\\n        else{\\n            if(nums[i] >= nums[i-1]){\\n                count += nums[i] - nums[i-1] + 1;\\n            }\\n        }\\n        \\n    }\\n    return count;\\n}\\n\\n//function to check every odd position is greater than from the neighbours\\n\\nfunction calculateOddGreater(nums: number[]):number{\\n    let count = 0;\\n    for(let i = 1; i < nums.length; i = i+2){\\n        //if not last element then we can compare left and right element otherwise compare left element\\n        if(i != nums.length - 1){\\n\\t\\t\\t//if element is less than from left and right, then decrease left and right both and update the rightmost element for next comparison\\n            if(nums[i] <= nums[i-1] && nums[i] <= nums[i+1]){\\n                    count += nums[i-1] + nums[i+1] - (2 * nums[i]) + 2;\\n                    nums[i+1] = nums[i] -  1;\\n\\n            }\\n            else if(nums[i] <= nums[i-1] && nums[i] >= nums[i+1]){\\n\\t\\t\\t//if element is less than from left  then decrease left\\n                    count +=  nums[i-1] - nums[i] + 1;\\n            }\\n            else if(nums[i] >= nums[i-1] && nums[i] <= nums[i+1]){\\n\\t\\t\\t//if element is less than from  right, then decrease right and update the rightmost element for next compare\\n                    count +=  nums[i+1] - nums[i] + 1;\\n                    nums[i+1] = nums[i] - 1;\\n\\n            }\\n        }\\n        else{\\n            if(nums[i] <= nums[i-1]){\\n                    count +=  nums[i-1] - nums[i] + 1;\\n\\n            }\\n        }\\n\\n    }\\n\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053268,
                "title": "o-n-in-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n\\n        int odd =0;\\n        int even = 0;\\n        int n = nums.size();\\n        \\n        int left =0,right =0;\\n        \\n        \\n        for(int i =0;i<n;i++){\\n            \\n            left = i == 0 ?INT_MAX : nums[i-1];\\n            right = i == n-1 ? INT_MAX : nums[i+1];\\n            \\n            if(i % 2 == 0)\\n                even += max(0,nums[i] - min(left,right) +  1);\\n            else{\\n                \\n                odd += max(0,nums[i] - min(left,right) + 1);\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        return min(odd,even);\\n        \\n        \\n        \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n\\n        int odd =0;\\n        int even = 0;\\n        int n = nums.size();\\n        \\n        int left =0,right =0;\\n        \\n        \\n        for(int i =0;i<n;i++){\\n            \\n            left = i == 0 ?INT_MAX : nums[i-1];\\n            right = i == n-1 ? INT_MAX : nums[i+1];\\n            \\n            if(i % 2 == 0)\\n                even += max(0,nums[i] - min(left,right) +  1);\\n            else{\\n                \\n                odd += max(0,nums[i] - min(left,right) + 1);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2050422,
                "title": "c-with-explain-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n\\n        int r1= search(nums,0,true,INT_MIN);  //consider the first one is upward\\n        int r2= search(nums,0,false,INT_MAX); //consider the first one is downward\\n        \\n        return min(r1,r2);\\n    }\\n\\n    int search(vector<int>& nums, int i, bool lastUp, int lastNum) {\\n        int n = nums.size();\\n        if (i >= n) return 0;\\n\\n        if (lastUp) {\\n            if (nums[i] > lastNum)\\n                return search(nums, i + 1, !lastUp, nums[i]);\\n        }\\n        else {\\n            int newNum= min(lastNum, i<n-1?nums[i+1]:INT_MAX)-1; //we need to reduce the current number below neighbouring left&right numbers\\n            \\n            int step= max(nums[i]-newNum,0);\\n            return step + search(nums, i + 1, !lastUp, newNum);\\n        }\\n        \\n        return INT_MAX;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n\\n        int r1= search(nums,0,true,INT_MIN);  //consider the first one is upward\\n        int r2= search(nums,0,false,INT_MAX); //consider the first one is downward\\n        \\n        return min(r1,r2);\\n    }\\n\\n    int search(vector<int>& nums, int i, bool lastUp, int lastNum) {\\n        int n = nums.size();\\n        if (i >= n) return 0;\\n\\n        if (lastUp) {\\n            if (nums[i] > lastNum)\\n                return search(nums, i + 1, !lastUp, nums[i]);\\n        }\\n        else {\\n            int newNum= min(lastNum, i<n-1?nums[i+1]:INT_MAX)-1; //we need to reduce the current number below neighbouring left&right numbers\\n            \\n            int step= max(nums[i]-newNum,0);\\n            return step + search(nums, i + 1, !lastUp, newNum);\\n        }\\n        \\n        return INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016111,
                "title": "0ms-100-faster-easy-cpp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        vector<int> A=nums,B=nums;\\n        for(int i=0;i<nums.size();i+=2){\\n            if(i==0){\\n                if(nums[1]<nums[0]);\\n                else{\\n                    nums[1]=nums[0]-1;\\n                }\\n            }\\n            else{\\n                if(nums[i]>nums[i-1]);\\n                else{\\n                    nums[i-1]=nums[i]-1;\\n                }\\n                if(nums[i]>nums[i+1]);\\n                else{\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n        }\\n        int cnt=0,cnt1=0;\\n        for(int i=1;i<nums.size();i+=2){\\n            cnt+=A[i]-nums[i];\\n        }\\n        for(int i=1;i<A.size();i+=2){\\n            if(i==A.size()-1){\\n                if(A[A.size()-2]<A[A.size()-1]);\\n                else{\\n                    A[A.size()-2]=A[A.size()-1]-1;\\n                }\\n            }\\n            else{\\n                if(A[i]>A[i-1]);\\n                else{\\n                    A[i-1]=A[i]-1;\\n                }\\n                if(A[i]>A[i+1]);\\n                else{\\n                    A[i+1]=A[i]-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums.size();i+=2){\\n            cnt1+=B[i]-A[i];\\n        }\\n        return min(cnt1,cnt);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        vector<int> A=nums,B=nums;\\n        for(int i=0;i<nums.size();i+=2){\\n            if(i==0){\\n                if(nums[1]<nums[0]);\\n                else{\\n                    nums[1]=nums[0]-1;\\n                }\\n            }\\n            else{\\n                if(nums[i]>nums[i-1]);\\n                else{\\n                    nums[i-1]=nums[i]-1;\\n                }\\n                if(nums[i]>nums[i+1]);\\n                else{\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n        }\\n        int cnt=0,cnt1=0;\\n        for(int i=1;i<nums.size();i+=2){\\n            cnt+=A[i]-nums[i];\\n        }\\n        for(int i=1;i<A.size();i+=2){\\n            if(i==A.size()-1){\\n                if(A[A.size()-2]<A[A.size()-1]);\\n                else{\\n                    A[A.size()-2]=A[A.size()-1]-1;\\n                }\\n            }\\n            else{\\n                if(A[i]>A[i-1]);\\n                else{\\n                    A[i-1]=A[i]-1;\\n                }\\n                if(A[i]>A[i+1]);\\n                else{\\n                    A[i+1]=A[i]-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums.size();i+=2){\\n            cnt1+=B[i]-A[i];\\n        }\\n        return min(cnt1,cnt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013544,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if(nums.length==1)\\n            return 0;\\n        int c=0;\\n\\t\\t//Decreasing the Odd Indices\\n        for(int i=1;i<nums.length;i+=2)\\n        {\\n            if(i==nums.length-1)\\n            {\\n                if(nums[i]>=nums[i-1])\\n                c+=nums[i]-nums[i-1]+1;\\n            }\\n            else\\n            {\\n                if(nums[i]>=Math.min(nums[i-1],nums[i+1]))\\n                c+=nums[i]-Math.min(nums[i-1],nums[i+1])+1;  \\n            }\\n        }\\n        int p=0;\\n\\t\\t//Decreasing the Even Indices\\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]>=nums[i+1])\\n                p+=nums[i]-nums[i+1]+1;\\n            }\\n            else if(i==nums.length-1)\\n            {\\n                if(nums[i]>=nums[i-1])\\n                p+=nums[i]-nums[i-1]+1;\\n            }\\n            else\\n            {\\n                if(nums[i]>=Math.min(nums[i-1],nums[i+1]))\\n                p+=nums[i]-Math.min(nums[i-1],nums[i+1])+1;  \\n            }\\n        }\\n        return Math.min(c,p);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if(nums.length==1)\\n            return 0;\\n        int c=0;\\n\\t\\t//Decreasing the Odd Indices\\n        for(int i=1;i<nums.length;i+=2)\\n        {\\n            if(i==nums.length-1)\\n            {\\n                if(nums[i]>=nums[i-1])\\n                c+=nums[i]-nums[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2003339,
                "title": "c-simple-o-n-solution",
                "content": "class Solution\\n{\\npublic:\\n    int movesToMakeZigzag(vector<int> &v)\\n    {\\n\\n        // MAKE ALL ODD INDEX LESSER THAN ITS LADJACENT INDEX\\n        int ans1 = 0;\\n        int size = v.size();\\n\\n        for (int i = 0; i < size; i++)\\n        {\\n            // IF I IS LESSER THAN SIZE-1\\n            if (i < size - 1 && i % 2 != 0)\\n            {\\n                int before = v[i - 1];\\n                int t = v[i];\\n                int after = v[i + 1];\\n                int minimum = min(before, after);\\n                if (t >= minimum)\\n                {\\n                    ans1 += t - minimum;\\n                    ans1 += 1;\\n                }\\n            }\\n            // IF I IS EQUAL T0 SIZE-1\\n            if (i == size - 1 && i % 2 != 0)\\n            {\\n                int before = v[i - 1];\\n                int t = v[i];\\n                if (t >= before)\\n                {\\n                    ans1 += t - before;\\n                    ans1 += 1;\\n                }\\n            }\\n        }\\n        // MAKE ALL EVEN INDEX LESSER THAN ITS LADJACENT INDEX\\n\\n        int ans2 = 0;\\n\\n        for (int i = 0; i < size; i++)\\n        {\\n            // IF I IS EQUAL TO ZERO AND SIZE IS GREATER THAN ONE\\n            if (i == 0 && size > 1)\\n            {\\n                int after = v[i + 1];\\n                int t = v[i];\\n                if (t >= after)\\n                {\\n                    ans2 += t - after;\\n                    ans2 += 1;\\n                }\\n            }\\n            //     IF INDEX  IS EQUAL TO SIZE- 1 BUT INDEX IS NOT EQUAL TO 0\\n            if (i > 0 && i == size - 1 && i % 2 == 0)\\n            {\\n                int before = v[i - 1];\\n                int t = v[i];\\n                if (t >= before)\\n                {\\n                    ans2 += t - before;\\n                    ans2 += 1;\\n                }\\n            }\\n            //     FOR ALL OTHER CASES\\n            if (i > 0 && i < size - 1 && i % 2 == 0)\\n            {\\n                int before = v[i - 1];\\n                int after = v[i + 1];\\n                int t = v[i];\\n                int minimum = min(after, before);\\n                if (t >= minimum)\\n                {\\n                    ans2 += t - minimum;\\n                    ans2 += 1;\\n                }\\n            }\\n        }\\n\\n        // cout<<\"ans1 is \"<<ans1<<endl;\\n        // cout<<\"ans2 is  \"<<ans2<<endl;\\n\\n        return min(ans1, ans2);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int movesToMakeZigzag(vector<int> &v)\\n    {\\n\\n        // MAKE ALL ODD INDEX LESSER THAN ITS LADJACENT INDEX\\n        int ans1 = 0;\\n        int size = v.size();\\n\\n        for (int i = 0; i < size; i++)\\n        {\\n            // IF I IS LESSER THAN SIZE-1\\n            if (i < size - 1 && i % 2 != 0)\\n            {\\n                int before = v[i - 1];\\n                int t = v[i];\\n                int after = v[i + 1];\\n                int minimum = min(before, after);\\n                if (t >= minimum)\\n                {\\n                    ans1 += t - minimum;\\n                    ans1 += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1940281,
                "title": "0ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size() == 1) return 0;\\n        \\n        int a = 0, b = 0;\\n        \\n        for(int i=0; i<nums.size(); i += 2){\\n            if(i == 0){\\n                if(nums[i] >= nums[i + 1]) a += nums[i] - nums[i + 1] + 1;\\n            }\\n            else if(i == nums.size() - 1){\\n                if(nums[i] >= nums[i - 1]) a += nums[i] - nums[i - 1] + 1;\\n            }\\n            else{\\n                if(nums[i] >= nums[i - 1] || nums[i] >= nums[i + 1]){\\n                    a += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<nums.size(); i += 2){\\n            if(i == nums.size() - 1){\\n                if(nums[i] >= nums[i - 1]) b += nums[i] - nums[i - 1] + 1;\\n            }\\n            else{\\n                if(nums[i] >= nums[i - 1] || nums[i] >= nums[i + 1]){\\n                    b += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;\\n                }\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        if(nums.size() == 1) return 0;\\n        \\n        int a = 0, b = 0;\\n        \\n        for(int i=0; i<nums.size(); i += 2){\\n            if(i == 0){\\n                if(nums[i] >= nums[i + 1]) a += nums[i] - nums[i + 1] + 1;\\n            }\\n            else if(i == nums.size() - 1){\\n                if(nums[i] >= nums[i - 1]) a += nums[i] - nums[i - 1] + 1;\\n            }\\n            else{\\n                if(nums[i] >= nums[i - 1] || nums[i] >= nums[i + 1]){\\n                    a += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<nums.size(); i += 2){\\n            if(i == nums.size() - 1){\\n                if(nums[i] >= nums[i - 1]) b += nums[i] - nums[i - 1] + 1;\\n            }\\n            else{\\n                if(nums[i] >= nums[i - 1] || nums[i] >= nums[i + 1]){\\n                    b += nums[i] - min(nums[i - 1], nums[i + 1]) + 1;\\n                }\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929380,
                "title": "c-easy-to-understand-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n\\n        int ans1=0;  // maintaining answer for positions indexed 0,2,4,6,.....\\n        int ans2=0;  //mainting answer for positions indexed 1,3,5,7,9......\\n        for(int i=0;i<nums.size();i+=2){\\n            int l;\\n            int r;\\n            if(i==0){\\n                l=INT_MAX;    //if left does not exists then try to make curr element less than the right element, so l is given the value of INT_MAX\\n            }\\n            else l=nums[i-1];  // if left exists\\n            if(i>=nums.size()-1){\\n                r=INT_MAX;  // if right does not exists then try to make curr element less than the left element, so r is given the value of INT_MAX\\n            }\\n            else r=nums[i+1]; // if r exists\\n            \\n            int mini=min(l,r); // setting minimum of the left and right element, because we have to make the current element locally minimum\\n            if(nums[i]<mini) ans1=ans1+0;  // if current element is already local minima\\n            else {\\n                ans1=ans1+nums[i]-mini+1; //if curr element is greater than both L and R or current elemnt lies in the range of [L,R] we set this value\\n                 }\\n            }\\n        \\n\\t\\t//repeat the same thing for the indexes of 1,3,5,7,9..........................\\n        \\n            for(int i=1;i<nums.size();i+=2){\\n            int l;\\n            int r;\\n            \\n                l=nums[i-1];\\n            \\n            if(i>=nums.size()-1){\\n                r=INT_MAX;\\n            }\\n            else r=nums[i+1];\\n            \\n            int mini=min(l,r);\\n            if(nums[i]<mini) ans2=ans2+0;\\n            else {\\n                ans2=ans2+nums[i]-mini+1;\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n\\n        int ans1=0;  // maintaining answer for positions indexed 0,2,4,6,.....\\n        int ans2=0;  //mainting answer for positions indexed 1,3,5,7,9......\\n        for(int i=0;i<nums.size();i+=2){\\n            int l;\\n            int r;\\n            if(i==0){\\n                l=INT_MAX;    //if left does not exists then try to make curr element less than the right element, so l is given the value of INT_MAX\\n            }\\n            else l=nums[i-1];  // if left exists\\n            if(i>=nums.size()-1){\\n                r=INT_MAX;  // if right does not exists then try to make curr element less than the left element, so r is given the value of INT_MAX\\n            }\\n            else r=nums[i+1]; // if r exists\\n            \\n            int mini=min(l,r); // setting minimum of the left and right element, because we have to make the current element locally minimum\\n            if(nums[i]<mini) ans1=ans1+0;  // if current element is already local minima\\n            else {\\n                ans1=ans1+nums[i]-mini+1; //if curr element is greater than both L and R or current elemnt lies in the range of [L,R] we set this value\\n                 }\\n            }\\n        \\n\\t\\t//repeat the same thing for the indexes of 1,3,5,7,9..........................\\n        \\n            for(int i=1;i<nums.size();i+=2){\\n            int l;\\n            int r;\\n            \\n                l=nums[i-1];\\n            \\n            if(i>=nums.size()-1){\\n                r=INT_MAX;\\n            }\\n            else r=nums[i+1];\\n            \\n            int mini=min(l,r);\\n            if(nums[i]<mini) ans2=ans2+0;\\n            else {\\n                ans2=ans2+nums[i]-mini+1;\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877981,
                "title": "python-dp-o-n",
                "content": "```\\n\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        @lru_cache(None)\\n        def dp(i):\\n            if i >= n:\\n                return 0\\n            neighbors = [nums[x] for x in [(i+1), (i-1)] if 0 <= x < n]\\n            \\n            if len(neighbors) == 0 or nums[i] < min(neighbors):\\n                return dp(i+2)\\n            else:\\n                return nums[i] - min(neighbors) + 1 + dp(i+2)\\n\\n        return min(dp(1), dp(0))\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        @lru_cache(None)\\n        def dp(i):\\n            if i >= n:\\n                return 0\\n            neighbors = [nums[x] for x in [(i+1), (i-1)] if 0 <= x < n]\\n            \\n            if len(neighbors) == 0 or nums[i] < min(neighbors):\\n                return dp(i+2)\\n            else:\\n                return nums[i] - min(neighbors) + 1 + dp(i+2)\\n\\n        return min(dp(1), dp(0))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853475,
                "title": "java-greedy-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        return Math.min(choose2decrease(nums, true), choose2decrease(nums, false));\\n    }\\n\\n    private int choose2decrease(int[] nums, boolean evenLarger) {\\n        int ret = 0;\\n        if(evenLarger) {\\n            for (int i = 1; i < nums.length; i += 2) {\\n                int delta = nums[i] < nums[i - 1] ? 0 : nums[i] - nums[i - 1] + 1;\\n                if (i + 1 < nums.length) {\\n                    delta = Math.max(delta, nums[i] < nums[i + 1] ? 0 : nums[i] - nums[i + 1] + 1);\\n                }\\n                ret += delta;\\n            }\\n        } else {\\n            for (int i = 0; i < nums.length; i+= 2) {\\n                int delta = 0;\\n                if (i - 1 >= 0) {\\n                    delta = nums[i - 1] - nums[i] > 0 ? 0 : nums[i] - nums[i - 1] + 1;\\n                }\\n                if (i + 1 < nums.length) {\\n                    delta = Math.max(delta, nums[i + 1] - nums[i] > 0 ? 0 : nums[i] - nums[i + 1] + 1);\\n                }\\n                ret += delta;\\n            }\\n        }\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        return Math.min(choose2decrease(nums, true), choose2decrease(nums, false));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1803800,
                "title": "python3-o-n-simple",
                "content": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        even=odd=0\\n        for i in range(len(nums)):\\n            pos=[x for x in [(i+1),(i-1)] if 0<=x<len(nums)]\\n            val=0\\n            for idx in pos:\\n                if nums[idx]<=nums[i]:\\n                    val=max(val,nums[i]-nums[idx]+1)\\n            if i%2==0:\\n                even+=val\\n            else:\\n                odd+=val\\n        return min(odd,even)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        even=odd=0\\n        for i in range(len(nums)):\\n            pos=[x for x in [(i+1),(i-1)] if 0<=x<len(nums)]\\n            val=0\\n            for idx in pos:\\n                if nums[idx]<=nums[i]:\\n                    val=max(val,nums[i]-nums[idx]+1)\\n            if i%2==0:\\n                even+=val\\n            else:\\n                odd+=val\\n        return min(odd,even)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757532,
                "title": "easy-c-solution-0ms-100",
                "content": "int movesToMakeZigzag(int* nums, int numsSize){    \\n    if(numsSize < 3) {\\n        return 0;\\n    }\\n    int even_move = 0;\\n    int odd_move = 0;\\n    int min_move = 0;\\n\\t\\n    for(int i = 1; i < numsSize; i = i + 2){\\n        if(i == (numsSize - 1)){\\n            even_move = even_move + fmax(0,(nums[i]- nums[i-1] + 1));\\n        }else{\\n            even_move = even_move + fmax(0,(nums[i]-fmin(nums[i+1],nums[i-1])+1));\\n        }\\n    }\\n    \\n    odd_move = odd_move + fmax(0,(nums[0] - nums[1] + 1 ));\\n\\t\\n    for(int i = 2; i < numsSize; i = i + 2){\\n        if(i == (numsSize - 1)){\\n            odd_move = odd_move + fmax(0,(nums[i]- nums[i-1] + 1));\\n        }else{\\n            odd_move = odd_move + fmax(0,(nums[i]-fmin(nums[i+1],nums[i-1])+1));\\n        }\\n    }\\n    min_move = fmin(odd_move,even_move);\\n    return min_move;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int movesToMakeZigzag(int* nums, int numsSize){    \\n    if(numsSize < 3) {\\n        return 0;\\n    }\\n    int even_move = 0;\\n    int odd_move = 0;\\n    int min_move = 0;\\n\\t\\n    for(int i = 1; i < numsSize; i = i + 2){\\n        if(i == (numsSize - 1)){\\n            even_move = even_move + fmax(0,(nums[i]- nums[i-1] + 1));\\n        }else{\\n            even_move = even_move + fmax(0,(nums[i]-fmin(nums[i+1],nums[i-1])+1));\\n        }\\n    }\\n    \\n    odd_move = odd_move + fmax(0,(nums[0] - nums[1] + 1 ));\\n\\t\\n    for(int i = 2; i < numsSize; i = i + 2){\\n        if(i == (numsSize - 1)){\\n            odd_move = odd_move + fmax(0,(nums[i]- nums[i-1] + 1));\\n        }else{\\n            odd_move = odd_move + fmax(0,(nums[i]-fmin(nums[i+1],nums[i-1])+1));\\n        }\\n    }\\n    min_move = fmin(odd_move,even_move);\\n    return min_move;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1755483,
                "title": "o-n-constant-space-python-solution",
                "content": "We only need to remember the value by which we decreased the last even and odd elements.\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        moves_even, moves_odd = 0, 0\\n        ldec_even, ldec_odd = 0, 0\\n        \\n        if len(nums) > 1:\\n            moves_even += max(0, nums[1] - nums[0] + 1)\\n            ldec_even = moves_even\\n            \\n        for i, num in enumerate(nums[1:], 1):\\n            if i % 2 == 0:\\n                # even\\n                moves_even += max(0, nums[i-1] - num - ldec_even + 1)\\n                if i+1 < len(nums):\\n                    ldec_even = max(0, nums[i+1] - num + 1) \\n                    moves_even += ldec_even\\n            else:\\n                # odd\\n                moves_odd += max(0, nums[i-1] - num - ldec_odd + 1)\\n                if i+1 < len(nums):\\n                    ldec_odd = max(0, nums[i+1] - num + 1) \\n                    moves_odd += ldec_odd\\n        \\n        return min(moves_even, moves_odd)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        moves_even, moves_odd = 0, 0\\n        ldec_even, ldec_odd = 0, 0\\n        \\n        if len(nums) > 1:\\n            moves_even += max(0, nums[1] - nums[0] + 1)\\n            ldec_even = moves_even\\n            \\n        for i, num in enumerate(nums[1:], 1):\\n            if i % 2 == 0:\\n                # even\\n                moves_even += max(0, nums[i-1] - num - ldec_even + 1)\\n                if i+1 < len(nums):\\n                    ldec_even = max(0, nums[i+1] - num + 1) \\n                    moves_even += ldec_even\\n            else:\\n                # odd\\n                moves_odd += max(0, nums[i-1] - num - ldec_odd + 1)\\n                if i+1 < len(nums):\\n                    ldec_odd = max(0, nums[i+1] - num + 1) \\n                    moves_odd += ldec_odd\\n        \\n        return min(moves_even, moves_odd)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744824,
                "title": "o-n-s-n-python-solution",
                "content": "```\\nclass Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        even=[nums[0]]\\n        op=0\\n        for i in range(1,len(nums)):\\n            if i%2==0:\\n                if even[-1]>=nums[i]:\\n                    op+=(even[-1]-nums[i]+1)\\n                    even[-1]=nums[i]-1\\n                even.append(nums[i])\\n            else:\\n                if even[-1]<=nums[i]:\\n                    op+=(nums[i]-even[-1]+1)\\n                    even.append(even[-1]-1)\\n                else:\\n                    even.append(nums[i])\\n        \\n        odd=[nums[0]]\\n        op1=0\\n        for i in range(1,len(nums)):\\n            if i%2==0:\\n                if odd[-1]<=nums[i]:\\n                    op1+=(nums[i]-odd[-1]+1)\\n                    odd.append(odd[-1]-1)\\n                else:\\n                    odd.append(nums[i])\\n            else:\\n                if odd[-1]>=nums[i]:\\n                    op1+=(odd[-1]-nums[i]+1)\\n                    odd[-1]=nums[i]-1\\n                odd.append(nums[i])\\n        return min(op,op1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        even=[nums[0]]\\n        op=0\\n        for i in range(1,len(nums)):\\n            if i%2==0:\\n                if even[-1]>=nums[i]:\\n                    op+=(even[-1]-nums[i]+1)\\n                    even[-1]=nums[i]-1\\n                even.append(nums[i])\\n            else:\\n                if even[-1]<=nums[i]:\\n                    op+=(nums[i]-even[-1]+1)\\n                    even.append(even[-1]-1)\\n                else:\\n                    even.append(nums[i])\\n        \\n        odd=[nums[0]]\\n        op1=0\\n        for i in range(1,len(nums)):\\n            if i%2==0:\\n                if odd[-1]<=nums[i]:\\n                    op1+=(nums[i]-odd[-1]+1)\\n                    odd.append(odd[-1]-1)\\n                else:\\n                    odd.append(nums[i])\\n            else:\\n                if odd[-1]>=nums[i]:\\n                    op1+=(odd[-1]-nums[i]+1)\\n                    odd[-1]=nums[i]-1\\n                odd.append(nums[i])\\n        return min(op,op1)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1717085,
                "title": "java-0ms-greedy-solution-o-2n",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans = Integer.MAX_VALUE, n = nums.length, cur = 0;\\n        if (n==1) return 0;\\n        int [] clone = nums.clone();\\n        for (int i = 0; i<n; i+=2) {\\n            if (i==0) {\\n                if (nums[i]<=nums[i+1]) {\\n                    cur+=(nums[i+1]-nums[i]+1);\\n                    nums[i+1] = nums[i]-1;\\n                }\\n            }\\n            else if (i==n-1) {\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n            else {\\n                if (nums[i]<=nums[i+1]) {\\n                    cur+=(nums[i+1]-nums[i]+1);\\n                    nums[i+1] = nums[i]-1;\\n                }\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n        }\\n        ans = Math.min(ans, cur);\\n        cur = 0;\\n        nums = clone;\\n        for (int i = 1; i<n; i+=2) {\\n            if (i==n-1) {\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n            else {\\n                if (nums[i]<=nums[i+1]) {\\n                    cur+=(nums[i+1]-nums[i]+1);\\n                    nums[i+1] = nums[i]-1;\\n                }\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n        }\\n        ans = Math.min(ans, cur);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans = Integer.MAX_VALUE, n = nums.length, cur = 0;\\n        if (n==1) return 0;\\n        int [] clone = nums.clone();\\n        for (int i = 0; i<n; i+=2) {\\n            if (i==0) {\\n                if (nums[i]<=nums[i+1]) {\\n                    cur+=(nums[i+1]-nums[i]+1);\\n                    nums[i+1] = nums[i]-1;\\n                }\\n            }\\n            else if (i==n-1) {\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n            else {\\n                if (nums[i]<=nums[i+1]) {\\n                    cur+=(nums[i+1]-nums[i]+1);\\n                    nums[i+1] = nums[i]-1;\\n                }\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n        }\\n        ans = Math.min(ans, cur);\\n        cur = 0;\\n        nums = clone;\\n        for (int i = 1; i<n; i+=2) {\\n            if (i==n-1) {\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n            else {\\n                if (nums[i]<=nums[i+1]) {\\n                    cur+=(nums[i+1]-nums[i]+1);\\n                    nums[i+1] = nums[i]-1;\\n                }\\n                if (nums[i]<=nums[i-1]) {\\n                    cur+=(nums[i-1]-nums[i]+1);\\n                }\\n            }\\n        }\\n        ans = Math.min(ans, cur);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701600,
                "title": "easy-and-concise-solution",
                "content": "```\\nint movesToMakeZigzag(vector<int>& nums) {\\n        vector<int>temp=nums;\\n        int a1=0,n=nums.size();\\n        for(int i=0;i<n;i+=2){\\n            if(i+1<n){\\n                if(temp[i+1]>=temp[i]){\\n                    a1+=temp[i+1]-temp[i]+1;\\n                    temp[i+1]=temp[i]-1;\\n                }\\n            }\\n            if(i-1>=0){\\n                if(temp[i-1]>=temp[i]){\\n                    a1+=temp[i-1]-temp[i]+1;\\n                    temp[i-1]=temp[i]-1;\\n                }\\n            }\\n        }\\n        int a2=0;\\n        for(int i=1;i<n;i+=2){\\n            if(i+1<n){\\n                if(nums[i+1]>=nums[i]){\\n                    a2+=nums[i+1]-nums[i]+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n           if(nums[i-1]>=nums[i]){\\n                a2+=nums[i-1]-nums[i]+1;\\n                nums[i-1]=nums[i]-1;\\n            }\\n        } \\n        return min(a1,a2);\\n    }\\n```",
                "solutionTags": [
                    "Array",
                    "Interactive"
                ],
                "code": "```\\nint movesToMakeZigzag(vector<int>& nums) {\\n        vector<int>temp=nums;\\n        int a1=0,n=nums.size();\\n        for(int i=0;i<n;i+=2){\\n            if(i+1<n){\\n                if(temp[i+1]>=temp[i]){\\n                    a1+=temp[i+1]-temp[i]+1;\\n                    temp[i+1]=temp[i]-1;\\n                }\\n            }\\n            if(i-1>=0){\\n                if(temp[i-1]>=temp[i]){\\n                    a1+=temp[i-1]-temp[i]+1;\\n                    temp[i-1]=temp[i]-1;\\n                }\\n            }\\n        }\\n        int a2=0;\\n        for(int i=1;i<n;i+=2){\\n            if(i+1<n){\\n                if(nums[i+1]>=nums[i]){\\n                    a2+=nums[i+1]-nums[i]+1;\\n                    nums[i+1]=nums[i]-1;\\n                }\\n            }\\n           if(nums[i-1]>=nums[i]){\\n                a2+=nums[i-1]-nums[i]+1;\\n                nums[i-1]=nums[i]-1;\\n            }\\n        } \\n        return min(a1,a2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673966,
                "title": "java-simple-greedy-solution-0-ms-faster-than-100-00",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions.**\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if(nums.length == 1)\\n            return 0;\\n        \\n        int moves1 = 0;\\n        \\n        for(int i=1; i<nums.length; i+=2){\\n            if(i < nums.length-1){\\n                if(nums[i] < nums[i-1] && nums[i] < nums[i+1])\\n                    continue;\\n                \\n                int max = Math.min(nums[i-1], nums[i+1]);\\n                moves1 += Math.abs(nums[i]-max)+1; \\n            }\\n            else{\\n                if(nums[i] < nums[i-1])\\n                    continue;\\n                \\n                moves1 += Math.abs(nums[i]-nums[i-1])+1;\\n            }\\n        }\\n        \\n        int moves2 = 0;\\n        \\n        for(int i=0; i<nums.length; i+=2){\\n            if(i == 0){\\n                if(nums[i] < nums[i+1])\\n                    continue;\\n                \\n                moves2 += Math.abs(nums[i] - nums[i+1])+1;\\n            }\\n            \\n            else if(i < nums.length-1){\\n                if(nums[i] < nums[i-1] && nums[i] < nums[i+1])\\n                    continue;\\n                \\n                int max = Math.min(nums[i-1], nums[i+1]);\\n                moves2 += Math.abs(nums[i] - max) + 1;\\n            }\\n            else{\\n                if(nums[i] < nums[i-1])\\n                    continue;\\n                \\n                moves2 += Math.abs(nums[i] - nums[i-1])+1;\\n            }\\n        }\\n        \\n        return Math.min(moves1, moves2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if(nums.length == 1)\\n            return 0;\\n        \\n        int moves1 = 0;\\n        \\n        for(int i=1; i<nums.length; i+=2){\\n            if(i < nums.length-1){\\n                if(nums[i] < nums[i-1] && nums[i] < nums[i+1])\\n                    continue;\\n                \\n                int max = Math.min(nums[i-1], nums[i+1]);\\n                moves1 += Math.abs(nums[i]-max)+1; \\n            }\\n            else{\\n                if(nums[i] < nums[i-1])\\n                    continue;\\n                \\n                moves1 += Math.abs(nums[i]-nums[i-1])+1;\\n            }\\n        }\\n        \\n        int moves2 = 0;\\n        \\n        for(int i=0; i<nums.length; i+=2){\\n            if(i == 0){\\n                if(nums[i] < nums[i+1])\\n                    continue;\\n                \\n                moves2 += Math.abs(nums[i] - nums[i+1])+1;\\n            }\\n            \\n            else if(i < nums.length-1){\\n                if(nums[i] < nums[i-1] && nums[i] < nums[i+1])\\n                    continue;\\n                \\n                int max = Math.min(nums[i-1], nums[i+1]);\\n                moves2 += Math.abs(nums[i] - max) + 1;\\n            }\\n            else{\\n                if(nums[i] < nums[i-1])\\n                    continue;\\n                \\n                moves2 += Math.abs(nums[i] - nums[i-1])+1;\\n            }\\n        }\\n        \\n        return Math.min(moves1, moves2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643212,
                "title": "c-0ms-100-double-pass",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decrease Elements To Make Array Zigzag.\\nMemory Usage: 7.1 MB, less than 87.27% of C++ online submissions for Decrease Elements To Make Array Zigzag.\\n```\\nclass Solution {\\npublic:\\n  int func(vector<int> &nums, int i){\\n    int sum = 0;\\n    if(i == 2 && nums[1] <= nums[0]) sum += nums[0] - nums[1] + 1;\\n    for(; i < nums.size(); i += 2)\\n      if(i + 1 != nums.size()){\\n        int mini = min(nums[i-1], nums[i+1]);\\n        if(nums[i] >= mini) sum += (nums[i] - mini) + 1;\\n      }\\n      else if(nums[i] >= nums[i-1]) sum += nums[i] - nums[i-1] + 1;\\n    return sum;\\n  }\\n  \\n  int movesToMakeZigzag(vector<int>& nums) {\\n    if(nums.size() == 1) return 0;\\n    return min( func(nums, 1), func(nums, 2));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int func(vector<int> &nums, int i){\\n    int sum = 0;\\n    if(i == 2 && nums[1] <= nums[0]) sum += nums[0] - nums[1] + 1;\\n    for(; i < nums.size(); i += 2)\\n      if(i + 1 != nums.size()){\\n        int mini = min(nums[i-1], nums[i+1]);\\n        if(nums[i] >= mini) sum += (nums[i] - mini) + 1;\\n      }\\n      else if(nums[i] >= nums[i-1]) sum += nums[i] - nums[i-1] + 1;\\n    return sum;\\n  }\\n  \\n  int movesToMakeZigzag(vector<int>& nums) {\\n    if(nums.size() == 1) return 0;\\n    return min( func(nums, 1), func(nums, 2));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632435,
                "title": "swift-solution",
                "content": "Time `O(N)`\\nSpace `O(2)`\\n\\n```\\nclass Solution {\\n    func movesToMakeZigzag(_ nums: [Int]) -> Int {\\n        var result = [0, 0]\\n        \\n        for i in 0..<nums.count {\\n            let left = (i > 0) ? nums[i-1] : Int.max\\n            let right = (i < nums.count - 1) ? nums[i+1] : Int.max\\n\\n            if (nums[i] >= left) || (nums[i] >= right) {\\n                result[i % 2] += nums[i] - min(left, right) + 1\\n            }\\n        }\\n        \\n        return min(result[0], result[1])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func movesToMakeZigzag(_ nums: [Int]) -> Int {\\n        var result = [0, 0]\\n        \\n        for i in 0..<nums.count {\\n            let left = (i > 0) ? nums[i-1] : Int.max\\n            let right = (i < nums.count - 1) ? nums[i+1] : Int.max\\n\\n            if (nums[i] >= left) || (nums[i] >= right) {\\n                result[i % 2] += nums[i] - min(left, right) + 1\\n            }\\n        }\\n        \\n        return min(result[0], result[1])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602732,
                "title": "simple-observation-c",
                "content": "```\\n        int op1 = 0; int op2 = 0;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            \\n            if(i % 2 == 0) {\\n                \\n                int h = min(i == 0? INT_MAX : nums[i - 1], \\n                            i == nums.size() - 1? INT_MAX : nums[i + 1]);\\n                \\n                if(h <= nums[i]) op1 += nums[i] - h + 1;\\n                continue;\\n            }\\n            \\n            int h = min(i == 0? INT_MAX : nums[i - 1], \\n                        i == nums.size() - 1? INT_MAX : nums[i + 1]);\\n\\n            if(h <= nums[i]) op2 += nums[i] - h + 1;\\n            continue;\\n        }\\n        \\n        return min(op1, op2);\\n```",
                "solutionTags": [],
                "code": "```\\n        int op1 = 0; int op2 = 0;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            \\n            if(i % 2 == 0) {\\n                \\n                int h = min(i == 0? INT_MAX : nums[i - 1], \\n                            i == nums.size() - 1? INT_MAX : nums[i + 1]);\\n                \\n                if(h <= nums[i]) op1 += nums[i] - h + 1;\\n                continue;\\n            }\\n            \\n            int h = min(i == 0? INT_MAX : nums[i - 1], \\n                        i == nums.size() - 1? INT_MAX : nums[i + 1]);\\n\\n            if(h <= nums[i]) op2 += nums[i] - h + 1;\\n            continue;\\n        }\\n        \\n        return min(op1, op2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555361,
                "title": "c-100-faster-o-n-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        \\n        int len=nums.size();\\n        \\n        int evenSum=0;\\n        int oddSum=0;\\n        //try to make the first condition true\\n        for(int i=0;i<len;i++)\\n        {\\n            int left=(i>0) ? nums[i-1] : INT_MAX;\\n            int right=(i<len-1) ? nums[i+1] : INT_MAX;\\n            if(nums[i]<left && nums[i]<right)\\n                continue;\\n            int mini=min(left,right);\\n            int curr=(nums[i]-(mini-1));\\n            if(i%2)\\n            {\\n                //odd index\\n                oddSum+=curr;\\n            }\\n            else{\\n                //even index\\n                evenSum+=curr;\\n            }\\n        }\\n        \\n        return min(oddSum,evenSum);\\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        \\n        int len=nums.size();\\n        \\n        int evenSum=0;\\n        int oddSum=0;\\n        //try to make the first condition true\\n        for(int i=0;i<len;i++)\\n        {\\n            int left=(i>0) ? nums[i-1] : INT_MAX;\\n            int right=(i<len-1) ? nums[i+1] : INT_MAX;\\n            if(nums[i]<left && nums[i]<right)\\n                continue;\\n            int mini=min(left,right);\\n            int curr=(nums[i]-(mini-1));\\n            if(i%2)\\n            {\\n                //odd index\\n                oddSum+=curr;\\n            }\\n            else{\\n                //even index\\n                evenSum+=curr;\\n            }\\n        }\\n        \\n        return min(oddSum,evenSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548241,
                "title": "java-solution-100-time-and-67-memory",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        if(nums.length==1)\\n            return 0;\\n\\n        int[] nums1 = nums.clone();\\n\\n        int oddMoves=0,evenMoves=0,i;\\n\\n        for (i=0;i<nums.length ;i=i+2 ) {\\n\\n            if(i==0)\\n            {\\n                if(nums[i]<=nums[i+1]){\\n                     evenMoves+=nums[i+1]+1-nums[i];\\n                     nums[i+1]=nums[i]-1;\\n                 }\\n            }\\n            else if(i==nums.length-1)\\n            {\\n                if(nums[i]<=nums[i-1])\\n                \\n                    evenMoves+=nums[i-1]+1-nums[i];\\n                // else\\n                //     oddMoves+=nums[i-1]+1-nums[i];\\n            }\\n            else {\\n               if(nums[i]<=nums[i-1]){\\n                    evenMoves+=nums[i-1]+1-nums[i];\\n                    nums[i-1]=nums[i]-1;\\n               }\\n                if(nums[i]<=nums[i+1]){\\n                    evenMoves+=nums[i+1]+1-nums[i];\\n                    nums[i+1]=nums[i]-1;\\n                }\\n        }\\n    }\\n    \\n     for (i=1;i<nums1.length ;i=i+2 ) {\\n\\n            if(i==0)\\n            {\\n                if(nums1[i]<=nums1[i+1]){\\n                     oddMoves+=nums1[i+1]+1-nums1[i];\\n                     nums1[i+1]=nums1[i]-1;\\n                 }\\n            }\\n            else if(i==nums1.length-1)\\n            {\\n                if(nums1[i]<=nums1[i-1])\\n                \\n                   oddMoves +=nums1[i-1]+1-nums1[i];\\n                // else\\n                //     oddMoves+=nums[i-1]+1-nums[i];\\n            }\\n            else {\\n               if(nums1[i]<=nums1[i-1]){\\n                   oddMoves +=nums1[i-1]+1-nums1[i];\\n                    nums1[i-1]=nums1[i]-1;\\n               }\\n                if(nums1[i]<=nums1[i+1]){\\n                   oddMoves +=nums1[i+1]+1-nums1[i];\\n                    nums1[i+1]=nums1[i]-1;\\n                }\\n        }\\n}\\n\\n        return Math.min(oddMoves,evenMoves);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        \\n        if(nums.length==1)\\n            return 0;\\n\\n        int[] nums1 = nums.clone();\\n\\n        int oddMoves=0,evenMoves=0,i;\\n\\n        for (i=0;i<nums.length ;i=i+2 ) {\\n\\n            if(i==0)\\n            {\\n                if(nums[i]<=nums[i+1]){\\n                     evenMoves+=nums[i+1]+1-nums[i];\\n                     nums[i+1]=nums[i]-1;\\n                 }\\n            }\\n            else if(i==nums.length-1)\\n            {\\n                if(nums[i]<=nums[i-1])\\n                \\n                    evenMoves+=nums[i-1]+1-nums[i];\\n                // else\\n                //     oddMoves+=nums[i-1]+1-nums[i];\\n            }\\n            else {\\n               if(nums[i]<=nums[i-1]){\\n                    evenMoves+=nums[i-1]+1-nums[i];\\n                    nums[i-1]=nums[i]-1;\\n               }\\n                if(nums[i]<=nums[i+1]){\\n                    evenMoves+=nums[i+1]+1-nums[i];\\n                    nums[i+1]=nums[i]-1;\\n                }\\n        }\\n    }\\n    \\n     for (i=1;i<nums1.length ;i=i+2 ) {\\n\\n            if(i==0)\\n            {\\n                if(nums1[i]<=nums1[i+1]){\\n                     oddMoves+=nums1[i+1]+1-nums1[i];\\n                     nums1[i+1]=nums1[i]-1;\\n                 }\\n            }\\n            else if(i==nums1.length-1)\\n            {\\n                if(nums1[i]<=nums1[i-1])\\n                \\n                   oddMoves +=nums1[i-1]+1-nums1[i];\\n                // else\\n                //     oddMoves+=nums[i-1]+1-nums[i];\\n            }\\n            else {\\n               if(nums1[i]<=nums1[i-1]){\\n                   oddMoves +=nums1[i-1]+1-nums1[i];\\n                    nums1[i-1]=nums1[i]-1;\\n               }\\n                if(nums1[i]<=nums1[i+1]){\\n                   oddMoves +=nums1[i+1]+1-nums1[i];\\n                    nums1[i+1]=nums1[i]-1;\\n                }\\n        }\\n}\\n\\n        return Math.min(oddMoves,evenMoves);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471367,
                "title": "c",
                "content": "The problem states that we can only desrease a number by 1.\\nSo in order to satisfy A[i] > A[i-1] and A[i] > A[i+1]. We can only decrease A[i-1] and A[i+1], if necessary, to A[i] - 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> copy = nums;\\n        int res1 = 0;\\n        for(int i=1; i<n; i+=2) {\\n            if(copy[i] <= copy[i-1]) {\\n                res1 += copy[i-1] - copy[i] + 1;\\n                copy[i-1] = copy[i] - 1;\\n            }\\n            if(i+1 < n && copy[i] <= copy[i+1]) {\\n                res1 += copy[i+1] - copy[i] + 1;\\n                copy[i+1] = copy[i] - 1;\\n            }            \\n        }\\n        \\n        copy = nums;\\n        int res2 = 0;\\n        for(int i=0; i<n; i+=2) {\\n            if(i-1 >= 0 && copy[i] <= copy[i-1]) {\\n                res2 += copy[i-1] - copy[i] + 1;\\n                copy[i-1] = copy[i] - 1;\\n            }\\n            if(i+1 < n && copy[i] <= copy[i+1]) {\\n                res2 += copy[i+1] - copy[i] + 1;\\n                copy[i+1] = copy[i] - 1;\\n            }            \\n        }\\n        \\n        return min(res1, res2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> copy = nums;\\n        int res1 = 0;\\n        for(int i=1; i<n; i+=2) {\\n            if(copy[i] <= copy[i-1]) {\\n                res1 += copy[i-1] - copy[i] + 1;\\n                copy[i-1] = copy[i] - 1;\\n            }\\n            if(i+1 < n && copy[i] <= copy[i+1]) {\\n                res1 += copy[i+1] - copy[i] + 1;\\n                copy[i+1] = copy[i] - 1;\\n            }            \\n        }\\n        \\n        copy = nums;\\n        int res2 = 0;\\n        for(int i=0; i<n; i+=2) {\\n            if(i-1 >= 0 && copy[i] <= copy[i-1]) {\\n                res2 += copy[i-1] - copy[i] + 1;\\n                copy[i-1] = copy[i] - 1;\\n            }\\n            if(i+1 < n && copy[i] <= copy[i+1]) {\\n                res2 += copy[i+1] - copy[i] + 1;\\n                copy[i+1] = copy[i] - 1;\\n            }            \\n        }\\n        \\n        return min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427428,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic int MovesToMakeZigzag(int[] nums) {\\n\\t\\t\\tint x = 0, y = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t\\tint left = i > 0 ? nums[i - 1] : 1005;\\n\\t\\t\\t\\tint right = i < nums.Length - 1 ? nums[i + 1] : 1005;\\n\\n\\t\\t\\t\\tif(i % 2 == 0)\\n\\t\\t\\t\\t\\tx += Math.Max(0, nums[i] - Math.Min(left, right) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ty += Math.Max(0, nums[i] - Math.Min(left, right) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Math.Min(x, y);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int MovesToMakeZigzag(int[] nums) {\\n\\t\\t\\tint x = 0, y = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t\\tint left = i > 0 ? nums[i - 1] : 1005;\\n\\t\\t\\t\\tint right = i < nums.Length - 1 ? nums[i + 1] : 1005;\\n\\n\\t\\t\\t\\tif(i % 2 == 0)\\n\\t\\t\\t\\t\\tx += Math.Max(0, nums[i] - Math.Min(left, right) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\ty += Math.Max(0, nums[i] - Math.Min(left, right) + 1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1408791,
                "title": "c-o-n-1-pass",
                "content": "```\\n\\tint movesToMakeZigzag(vector<int>& nums) {\\n        int sum1=0,sum2=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int left=i>0?nums[i-1]:1e5;\\n            int right=i<n-1?nums[i+1]:1e5;\\n            if(i&1){\\n                sum1+=max(0,nums[i]-min(left,right)+1);\\n            }else{\\n                sum2+=max(0,nums[i]-min(left,right)+1);\\n            }\\n        }\\n        return min(sum1,sum2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint movesToMakeZigzag(vector<int>& nums) {\\n        int sum1=0,sum2=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int left=i>0?nums[i-1]:1e5;\\n            int right=i<n-1?nums[i+1]:1e5;\\n            if(i&1){\\n                sum1+=max(0,nums[i]-min(left,right)+1);\\n            }else{\\n                sum2+=max(0,nums[i]-min(left,right)+1);\\n            }\\n        }\\n        return min(sum1,sum2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399902,
                "title": "easy-and-intuitive-python-solution-with-comments",
                "content": "```\\nimport math\\nclass Solution:\\n    def movesToMakeZigzag(self, nums):\\n        if len(nums)<3:\\n            return 0\\n        else:\\n            # To hold the penalty for case1 and case2\\n            evenp,oddp=0,0\\n            for i in range(0,len(nums)):\\n                # To Store the adj elements\\n                options=[]\\n                options.append(nums[i-1] if i-1>=0 else math.inf)\\n                options.append(nums[i+1] if i+1<len(nums) else math.inf)\\n                #Add penelaty incase the curr element is greather than its adj elements\\n                if i%2==0 and nums[i]>=min(options):\\n                    evenp+=nums[i]-min(options)\\n                    evenp+=1\\n                elif i%2==1 and nums[i]>=min(options):\\n                    oddp+=nums[i]-min(options)\\n                    oddp+=1\\n                else:\\n                    pass\\n                print(i,options,evenp,oddp)\\n            #Return min penalty from case1 and case2\\n            return min(evenp,oddp)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def movesToMakeZigzag(self, nums):\\n        if len(nums)<3:\\n            return 0\\n        else:\\n            # To hold the penalty for case1 and case2\\n            evenp,oddp=0,0\\n            for i in range(0,len(nums)):\\n                # To Store the adj elements\\n                options=[]\\n                options.append(nums[i-1] if i-1>=0 else math.inf)\\n                options.append(nums[i+1] if i+1<len(nums) else math.inf)\\n                #Add penelaty incase the curr element is greather than its adj elements\\n                if i%2==0 and nums[i]>=min(options):\\n                    evenp+=nums[i]-min(options)\\n                    evenp+=1\\n                elif i%2==1 and nums[i]>=min(options):\\n                    oddp+=nums[i]-min(options)\\n                    oddp+=1\\n                else:\\n                    pass\\n                print(i,options,evenp,oddp)\\n            #Return min penalty from case1 and case2\\n            return min(evenp,oddp)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368449,
                "title": "c-solution-0ms",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums)\\n    {\\n        int size = nums.size();\\n        if(size <= 1) return 0;\\n        int res1 = 0, res2 = 0;\\n        for(int i = 0; i < size; i+=2)\\n        {\\n            int& num = nums[i];\\n            int shift = 0;\\n            if(i == 0 && num >= nums[i+1])\\n                shift = num - nums[i+1] + 1;\\n            if(i == size - 1 && num >= nums[i-1])\\n                shift = num - nums[i-1] + 1;\\n            if(i > 0 && i < size - 1)\\n            {\\n                int m = min(nums[i-1], nums[i+1]);\\n                if(num >= m)\\n                    shift = num - m + 1;\\n            }\\n            res1 += shift;\\n        }\\n        for(int i = 1; i < size; i+=2)\\n        {\\n            int& num = nums[i];\\n            int shift = 0;\\n            if(i == 0 && num >= nums[i+1])\\n                shift = num - nums[i+1] + 1;\\n            if(i == size - 1 && num >= nums[i-1])\\n                shift = num - nums[i-1] + 1;\\n            if(i > 0 && i < size - 1)\\n            {\\n                int m = min(nums[i-1], nums[i+1]);\\n                if(num >= m)\\n                    shift = num - m + 1;\\n            }\\n            res2 += shift;\\n            if(res2 > res1) return res1;\\n        }\\n        return min(res1, res2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums)\\n    {\\n        int size = nums.size();\\n        if(size <= 1) return 0;\\n        int res1 = 0, res2 = 0;\\n        for(int i = 0; i < size; i+=2)\\n        {\\n            int& num = nums[i];\\n            int shift = 0;\\n            if(i == 0 && num >= nums[i+1])\\n                shift = num - nums[i+1] + 1;\\n            if(i == size - 1 && num >= nums[i-1])\\n                shift = num - nums[i-1] + 1;\\n            if(i > 0 && i < size - 1)\\n            {\\n                int m = min(nums[i-1], nums[i+1]);\\n                if(num >= m)\\n                    shift = num - m + 1;\\n            }\\n            res1 += shift;\\n        }\\n        for(int i = 1; i < size; i+=2)\\n        {\\n            int& num = nums[i];\\n            int shift = 0;\\n            if(i == 0 && num >= nums[i+1])\\n                shift = num - nums[i+1] + 1;\\n            if(i == size - 1 && num >= nums[i-1])\\n                shift = num - nums[i-1] + 1;\\n            if(i > 0 && i < size - 1)\\n            {\\n                int m = min(nums[i-1], nums[i+1]);\\n                if(num >= m)\\n                    shift = num - m + 1;\\n            }\\n            res2 += shift;\\n            if(res2 > res1) return res1;\\n        }\\n        return min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368058,
                "title": "clean-comments-try-make-alternate-elements-neighbours-evens-or-odds",
                "content": "```\\nclass Solution:\\n    def movesToMakeZigzag1(self, nums: List[int]) -> int:\\n        # try to make alternate less than left and right..\\n        def alternateLess(start, nums): # returns cost\\n            cost = 0\\n            for i in range(start, len(nums), 2):\\n                \\n                # 1. make me smaller than LEFT adjacent\\n                if i > 0 and nums[i-1] <= nums[i]:\\n                    change = nums[i] - nums[i-1] + 1 # +1 as strict < not <=\\n                    cost += change\\n                    nums[i] -= change\\n                \\n                # 2. do same for right neighbour\\n                if i < len(nums)-1 and nums[i+1] <= nums[i]:\\n                    change = nums[i] - nums[i+1] + 1\\n                    cost += change\\n                    nums[i] -= change\\n            \\n            return cost\\n        \\n        return min(alternateLess(0, nums[:]), alternateLess(1,nums[:]))\\n\\n    # cleaner and extensible to just take change to min(neighbours)\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        # try to make alternate less than left and right..\\n        \\n        def alternateLess(start): # returns cost\\n            cost = 0\\n            for i in range(start, len(nums), 2):\\n                change = 0\\n                # 1. make me smaller than LEFT adjacent\\n                if i > 0 and nums[i-1] <= nums[i]:\\n                    left_change = nums[i] - nums[i-1] + 1\\n                    change = max(left_change, change)\\n                \\n                # 2. do same for right neighbour\\n                if i < len(nums)-1 and nums[i+1] <= nums[i]:\\n                    right_change = nums[i] - nums[i+1] + 1\\n                    change = max(right_change, change)\\n                \\n                cost += change\\n            return cost\\n        \\n        return min(alternateLess(0), alternateLess(1))\\n\\n\\n\"\"\"\\ntests \\n[1,2,3]\\n[9,6,1,6,2]\\n[1]\\n[1,2]\\n[2,1,2] \\n\"\"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag1(self, nums: List[int]) -> int:\\n        # try to make alternate less than left and right..\\n        def alternateLess(start, nums): # returns cost\\n            cost = 0\\n            for i in range(start, len(nums), 2):\\n                \\n                # 1. make me smaller than LEFT adjacent\\n                if i > 0 and nums[i-1] <= nums[i]:\\n                    change = nums[i] - nums[i-1] + 1 # +1 as strict < not <=\\n                    cost += change\\n                    nums[i] -= change\\n                \\n                # 2. do same for right neighbour\\n                if i < len(nums)-1 and nums[i+1] <= nums[i]:\\n                    change = nums[i] - nums[i+1] + 1\\n                    cost += change\\n                    nums[i] -= change\\n            \\n            return cost\\n        \\n        return min(alternateLess(0, nums[:]), alternateLess(1,nums[:]))\\n\\n    # cleaner and extensible to just take change to min(neighbours)\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        # try to make alternate less than left and right..\\n        \\n        def alternateLess(start): # returns cost\\n            cost = 0\\n            for i in range(start, len(nums), 2):\\n                change = 0\\n                # 1. make me smaller than LEFT adjacent\\n                if i > 0 and nums[i-1] <= nums[i]:\\n                    left_change = nums[i] - nums[i-1] + 1\\n                    change = max(left_change, change)\\n                \\n                # 2. do same for right neighbour\\n                if i < len(nums)-1 and nums[i+1] <= nums[i]:\\n                    right_change = nums[i] - nums[i+1] + 1\\n                    change = max(right_change, change)\\n                \\n                cost += change\\n            return cost\\n        \\n        return min(alternateLess(0), alternateLess(1))\\n\\n\\n\"\"\"\\ntests \\n[1,2,3]\\n[9,6,1,6,2]\\n[1]\\n[1,2]\\n[2,1,2] \\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364902,
                "title": "javascript-solution-greedy-approach",
                "content": "When I first saw this problem, I didn\\'t know a way to approach it so I just took a greedy approach to it. As it turns out, this works.\\n\\n```\\nvar movesToMakeZigzag = function(nums) {\\n    const n = nums.length;\\n\\n    let lastEvenRight = Number.MIN_SAFE_INTEGER;\\n    let evenMoves = 0;\\n\\n    let lastOddRight = nums[0];\\n    let oddMoves = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        const currNum = nums[i];\\n        const nextNum = i < n - 1 ? nums[i + 1] : Number.MIN_SAFE_INTEGER;        \\n\\n        if (i % 2 === 0) {\\n            if (lastEvenRight >= currNum) evenMoves += lastEvenRight - currNum + 1;\\n\\n            if (currNum <= nextNum) {\\n                evenMoves += nextNum - currNum + 1;\\n            }\\n            \\n            lastEvenRight = Math.min(currNum - 1, nextNum);\\n        }\\n        else {\\n            if (lastOddRight >= currNum) oddMoves += lastOddRight - currNum + 1;\\n\\n            if (currNum <= nextNum) {\\n                oddMoves += nextNum - currNum + 1;\\n            }\\n            \\n            lastOddRight = Math.min(currNum - 1, nextNum);\\n        }\\n    } \\n\\n    return Math.min(oddMoves, evenMoves);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar movesToMakeZigzag = function(nums) {\\n    const n = nums.length;\\n\\n    let lastEvenRight = Number.MIN_SAFE_INTEGER;\\n    let evenMoves = 0;\\n\\n    let lastOddRight = nums[0];\\n    let oddMoves = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        const currNum = nums[i];\\n        const nextNum = i < n - 1 ? nums[i + 1] : Number.MIN_SAFE_INTEGER;        \\n\\n        if (i % 2 === 0) {\\n            if (lastEvenRight >= currNum) evenMoves += lastEvenRight - currNum + 1;\\n\\n            if (currNum <= nextNum) {\\n                evenMoves += nextNum - currNum + 1;\\n            }\\n            \\n            lastEvenRight = Math.min(currNum - 1, nextNum);\\n        }\\n        else {\\n            if (lastOddRight >= currNum) oddMoves += lastOddRight - currNum + 1;\\n\\n            if (currNum <= nextNum) {\\n                oddMoves += nextNum - currNum + 1;\\n            }\\n            \\n            lastOddRight = Math.min(currNum - 1, nextNum);\\n        }\\n    } \\n\\n    return Math.min(oddMoves, evenMoves);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295824,
                "title": "0-ms-100-faster-simple-solution",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        vector<int> nums1=nums,nums2=nums;\\n        int ans1=0;\\n        int ans2=0;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            if(i==n-1)\\n            {\\n                //for second element to be maximum\\n                if(nums1[i-1]>=nums1[i])\\n                {\\n                    ans1+=abs(nums1[i]-nums1[i-1])+1;\\n                    nums1[i-1]=nums1[i]-1;\\n                }\\n                //for second element to be minimum\\n                int mn=nums2[i-1];\\n                if(nums2[i]>=mn)\\n                {\\n                    ans2+=abs(nums2[i]-mn)+1;\\n                    nums2[i]=mn-1;\\n                }\\n            }\\n            else\\n            {\\n                //for second element to be maximum\\n                if(nums1[i-1]>=nums1[i])\\n                {\\n                    ans1+=abs(nums1[i]-nums1[i-1])+1;\\n                    nums1[i-1]=nums1[i]-1;\\n                }\\n                if(nums1[i+1]>=nums1[i])\\n                {\\n                    ans1+=abs(nums1[i]-nums1[i+1])+1;\\n                    nums1[i+1]=nums1[i]-1;\\n                }\\n                //for second element to be minimum\\n                int mn=min(nums2[i-1],nums2[i+1]);\\n                if(nums2[i]>=mn)\\n                {\\n                    ans2+=abs(nums2[i]-mn)+1;\\n                    nums2[i]=mn-1;\\n                }\\n            }\\n        }\\n        // cout<<ans1<<\" \"<<ans2<<endl;\\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        vector<int> nums1=nums,nums2=nums;\\n        int ans1=0;\\n        int ans2=0;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            if(i==n-1)\\n            {\\n                //for second element to be maximum\\n                if(nums1[i-1]>=nums1[i])\\n                {\\n                    ans1+=abs(nums1[i]-nums1[i-1])+1;\\n                    nums1[i-1]=nums1[i]-1;\\n                }\\n                //for second element to be minimum\\n                int mn=nums2[i-1];\\n                if(nums2[i]>=mn)\\n                {\\n                    ans2+=abs(nums2[i]-mn)+1;\\n                    nums2[i]=mn-1;\\n                }\\n            }\\n            else\\n            {\\n                //for second element to be maximum\\n                if(nums1[i-1]>=nums1[i])\\n                {\\n                    ans1+=abs(nums1[i]-nums1[i-1])+1;\\n                    nums1[i-1]=nums1[i]-1;\\n                }\\n                if(nums1[i+1]>=nums1[i])\\n                {\\n                    ans1+=abs(nums1[i]-nums1[i+1])+1;\\n                    nums1[i+1]=nums1[i]-1;\\n                }\\n                //for second element to be minimum\\n                int mn=min(nums2[i-1],nums2[i+1]);\\n                if(nums2[i]>=mn)\\n                {\\n                    ans2+=abs(nums2[i]-mn)+1;\\n                    nums2[i]=mn-1;\\n                }\\n            }\\n        }\\n        // cout<<ans1<<\" \"<<ans2<<endl;\\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1292652,
                "title": "follow-the-hint-91-speed",
                "content": "Runtime: 28 ms, faster than 91.43% of Python3 online submissions for Decrease Elements To Make Array Zigzag.\\nMemory Usage: 14.2 MB, less than 67.86% of Python3 online submissions for Decrease Elements To Make Array Zigzag.\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums) -> int:\\n        len_nums = len(nums)\\n        if len_nums < 2:\\n            return 0\\n        elif len_nums == 2:\\n            if nums[0] == nums[1]:\\n                return 1\\n            else:\\n                return 0\\n        even_moves = odd_moves = 0\\n        # even smaller\\n        if nums[0] >= nums[1]:\\n            even_moves += nums[0] - nums[1] + 1\\n        if len_nums % 2:\\n            if nums[-1] >= nums[-2]:\\n                even_moves += nums[-1] - nums[-2] + 1\\n        for i in range(2, len_nums - 1, 2):\\n            min_neighbours = min(nums[i - 1], nums[i + 1])\\n            if nums[i] >= min_neighbours:\\n                even_moves += nums[i] - min_neighbours + 1\\n\\n        # odd smaller\\n        if not len_nums % 2:\\n            if nums[-1] >= nums[-2]:\\n                odd_moves += nums[-1] - nums[-2] + 1\\n        for i in range(1, len_nums - 1, 2):\\n            min_neighbours = min(nums[i - 1], nums[i + 1])\\n            if nums[i] >= min_neighbours:\\n                odd_moves += nums[i] - min_neighbours + 1\\n\\n        return min(even_moves, odd_moves)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums) -> int:\\n        len_nums = len(nums)\\n        if len_nums < 2:\\n            return 0\\n        elif len_nums == 2:\\n            if nums[0] == nums[1]:\\n                return 1\\n            else:\\n                return 0\\n        even_moves = odd_moves = 0\\n        # even smaller\\n        if nums[0] >= nums[1]:\\n            even_moves += nums[0] - nums[1] + 1\\n        if len_nums % 2:\\n            if nums[-1] >= nums[-2]:\\n                even_moves += nums[-1] - nums[-2] + 1\\n        for i in range(2, len_nums - 1, 2):\\n            min_neighbours = min(nums[i - 1], nums[i + 1])\\n            if nums[i] >= min_neighbours:\\n                even_moves += nums[i] - min_neighbours + 1\\n\\n        # odd smaller\\n        if not len_nums % 2:\\n            if nums[-1] >= nums[-2]:\\n                odd_moves += nums[-1] - nums[-2] + 1\\n        for i in range(1, len_nums - 1, 2):\\n            min_neighbours = min(nums[i - 1], nums[i + 1])\\n            if nums[i] >= min_neighbours:\\n                odd_moves += nums[i] - min_neighbours + 1\\n\\n        return min(even_moves, odd_moves)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266654,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar movesToMakeZigzag = function(nums) {\\n    const len = nums.length\\n    \\n    \\n    let resultA = 0, resultB = 0\\n    // even indices are smaller\\n    nums[-1] = nums[len] = Infinity\\n    \\n    for (let i = 0; i < len; i += 2) {\\n        const val = nums[i]\\n        const valLeft = nums[i - 1], valRight = nums[i + 1]\\n        const valMin = Math.min(valLeft, valRight)\\n        const goal = -1 + valMin\\n        if (val > goal) resultA += val - goal\\n    }\\n    \\n    \\n    // odd indices are smaller\\n    for (let i = 1; i < len; i += 2) {\\n        const val = nums[i]\\n        const valLeft = nums[i - 1], valRight = nums[i + 1]\\n        const valMin = Math.min(valLeft, valRight)\\n        const goal = -1 + valMin\\n        if (val > goal) resultB += val - goal\\n    }\\n    \\n    \\n    let result = Math.min(resultA, resultB)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar movesToMakeZigzag = function(nums) {\\n    const len = nums.length\\n    \\n    \\n    let resultA = 0, resultB = 0\\n    // even indices are smaller\\n    nums[-1] = nums[len] = Infinity\\n    \\n    for (let i = 0; i < len; i += 2) {\\n        const val = nums[i]\\n        const valLeft = nums[i - 1], valRight = nums[i + 1]\\n        const valMin = Math.min(valLeft, valRight)\\n        const goal = -1 + valMin\\n        if (val > goal) resultA += val - goal\\n    }\\n    \\n    \\n    // odd indices are smaller\\n    for (let i = 1; i < len; i += 2) {\\n        const val = nums[i]\\n        const valLeft = nums[i - 1], valRight = nums[i + 1]\\n        const valMin = Math.min(valLeft, valRight)\\n        const goal = -1 + valMin\\n        if (val > goal) resultB += val - goal\\n    }\\n    \\n    \\n    let result = Math.min(resultA, resultB)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1199894,
                "title": "java-simple-modify-array-to-make-zigzag",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int[] d = Arrays.copyOfRange(nums, 0, nums.length);\\n        int r1 = makeZigzag(d, true);\\n        int r2 = makeZigzag(nums, false);\\n        return Math.min(r1, r2);\\n    }\\n    private int makeZigzag(int[] nums, boolean even){\\n        int res = 0;\\n        for(int i = 1; i < nums.length; i++){\\n            if((i-1) % 2 == 0 ^ !even){\\n                if(nums[i-1] <= nums[i]){\\n                    res += nums[i] - nums[i-1] + 1;\\n                    nums[i] = nums[i-1] - 1;\\n                }\\n            }\\n            else{\\n                if(nums[i-1] >= nums[i]){\\n                    res += nums[i-1] - nums[i] + 1;\\n                    nums[i - 1] = nums[i] - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int[] d = Arrays.copyOfRange(nums, 0, nums.length);\\n        int r1 = makeZigzag(d, true);\\n        int r2 = makeZigzag(nums, false);\\n        return Math.min(r1, r2);\\n    }\\n    private int makeZigzag(int[] nums, boolean even){\\n        int res = 0;\\n        for(int i = 1; i < nums.length; i++){\\n            if((i-1) % 2 == 0 ^ !even){\\n                if(nums[i-1] <= nums[i]){\\n                    res += nums[i] - nums[i-1] + 1;\\n                    nums[i] = nums[i-1] - 1;\\n                }\\n            }\\n            else{\\n                if(nums[i-1] >= nums[i]){\\n                    res += nums[i-1] - nums[i] + 1;\\n                    nums[i - 1] = nums[i] - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194274,
                "title": "o-n-brute-force-easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n         return zigzag(nums,nums.size());\\n    }\\n    int zigzag(vector<int> &a,int n) {\\n         if(n==1) return 0;\\n         if(n==2) return abs(a[0]-a[1])==0?1:0;\\n\\t\\t int op1=0,op2=0;\\n\\t\\t // make the odd positioned elements smaller than neighbouring even positioned elements\\n\\t\\t for(int i=0; i<n; i++) {\\n\\t\\t\\t   if(i%2) {\\n\\t\\t\\t\\t  if(i==n-1) {\\n\\t\\t\\t\\t\\top1+=max(a[i]-(a[i-1]-1),0);\\n\\t\\t\\t\\t  }else {\\n\\t\\t\\t\\t    int x=min(a[i-1],a[i+1]);\\n\\t\\t\\t\\t    x--;\\n\\t\\t\\t\\t    op1+=max(a[i]-x,0);\\n                  }\\n\\t\\t\\t   }\\n\\t\\t }\\n\\t\\t // make the even positioned elements smaller than the neighbouring odd positioned elements\\n\\t\\t for(int i=0; i<n; i+=2) {\\n\\t\\t\\t  if(i==0) {\\n\\t\\t\\t\\t op2+=a[i]-a[i+1]<0?0:(a[i]-a[i+1])+1;\\n\\t\\t\\t  }else if(i==n-1) {\\n\\t\\t\\t\\t op2+=a[i]-a[i-1]<0?0:(a[i]-a[i-1])+1;\\n\\t\\t\\t  }else {\\n\\t\\t\\t\\t op2+=a[i]-min(a[i-1],a[i+1])<0?0:a[i]-min(a[i-1],a[i+1])+1;\\n\\t\\t\\t  }\\n\\t\\t }\\n\\t  return min(op1,op2);  // min. of both operations is the answer\\n     }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n         return zigzag(nums,nums.size());\\n    }\\n    int zigzag(vector<int> &a,int n) {\\n         if(n==1) return 0;\\n         if(n==2) return abs(a[0]-a[1])==0?1:0;\\n\\t\\t int op1=0,op2=0;\\n\\t\\t // make the odd positioned elements smaller than neighbouring even positioned elements\\n\\t\\t for(int i=0; i<n; i++) {\\n\\t\\t\\t   if(i%2) {\\n\\t\\t\\t\\t  if(i==n-1) {\\n\\t\\t\\t\\t\\top1+=max(a[i]-(a[i-1]-1),0);\\n\\t\\t\\t\\t  }else {\\n\\t\\t\\t\\t    int x=min(a[i-1],a[i+1]);\\n\\t\\t\\t\\t    x--;\\n\\t\\t\\t\\t    op1+=max(a[i]-x,0);\\n                  }\\n\\t\\t\\t   }\\n\\t\\t }\\n\\t\\t // make the even positioned elements smaller than the neighbouring odd positioned elements\\n\\t\\t for(int i=0; i<n; i+=2) {\\n\\t\\t\\t  if(i==0) {\\n\\t\\t\\t\\t op2+=a[i]-a[i+1]<0?0:(a[i]-a[i+1])+1;\\n\\t\\t\\t  }else if(i==n-1) {\\n\\t\\t\\t\\t op2+=a[i]-a[i-1]<0?0:(a[i]-a[i-1])+1;\\n\\t\\t\\t  }else {\\n\\t\\t\\t\\t op2+=a[i]-min(a[i-1],a[i+1])<0?0:a[i]-min(a[i-1],a[i+1])+1;\\n\\t\\t\\t  }\\n\\t\\t }\\n\\t  return min(op1,op2);  // min. of both operations is the answer\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186212,
                "title": "clean-time-o-n-space-o-1-soln",
                "content": "```\\npublic class Solution {\\n    // Time O(n) Space O(1)\\n    public int MovesToMakeZigzag(int[] nums) {\\n        int[] originalNums = nums.ToArray();\\n        int evenMoves = 0, oddMoves = 0, l = nums.Length;\\n        // even index is greater\\n        for (int i = 0; i < l; i += 2)\\n        {\\n            if (i > 0 && nums[i - 1] >= nums[i])\\n            {\\n                evenMoves += 1 + nums[i - 1] - nums[i];\\n                nums[i - 1] = nums[i] - 1;\\n            }\\n            if (i + 1 < l && nums[i] <= nums[i + 1])\\n            {\\n                evenMoves += 1 + nums[i + 1] - nums[i];\\n                nums[i + 1] = nums[i] - 1;\\n            }\\n        }\\n        // odd index is greater\\n        for (int i = 1; i < l; i += 2)\\n        {\\n            if (originalNums[i - 1] >= originalNums[i])\\n            {\\n                oddMoves += 1 + originalNums[i - 1] - originalNums[i];\\n                originalNums[i - 1] = originalNums[i] - 1;\\n            }\\n            if (i + 1 < l && originalNums[i] <= originalNums[i + 1])\\n            {\\n                oddMoves += 1 + originalNums[i + 1] - originalNums[i];\\n                originalNums[i + 1] = originalNums[i] - 1;\\n            }\\n        }\\n        return Math.Min(evenMoves, oddMoves);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(n) Space O(1)\\n    public int MovesToMakeZigzag(int[] nums) {\\n        int[] originalNums = nums.ToArray();\\n        int evenMoves = 0, oddMoves = 0, l = nums.Length;\\n        // even index is greater\\n        for (int i = 0; i < l; i += 2)\\n        {\\n            if (i > 0 && nums[i - 1] >= nums[i])\\n            {\\n                evenMoves += 1 + nums[i - 1] - nums[i];\\n                nums[i - 1] = nums[i] - 1;\\n            }\\n            if (i + 1 < l && nums[i] <= nums[i + 1])\\n            {\\n                evenMoves += 1 + nums[i + 1] - nums[i];\\n                nums[i + 1] = nums[i] - 1;\\n            }\\n        }\\n        // odd index is greater\\n        for (int i = 1; i < l; i += 2)\\n        {\\n            if (originalNums[i - 1] >= originalNums[i])\\n            {\\n                oddMoves += 1 + originalNums[i - 1] - originalNums[i];\\n                originalNums[i - 1] = originalNums[i] - 1;\\n            }\\n            if (i + 1 < l && originalNums[i] <= originalNums[i + 1])\\n            {\\n                oddMoves += 1 + originalNums[i + 1] - originalNums[i];\\n                originalNums[i + 1] = originalNums[i] - 1;\\n            }\\n        }\\n        return Math.Min(evenMoves, oddMoves);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185645,
                "title": "simple-python-sol",
                "content": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        e,o=0,0\\n        if len(nums)==1:\\n            return 0\\n        for i in range(1,len(nums),2):\\n            back,front=i-1,i+1 \\n            if front<len(nums):\\n                b,f=nums[back],nums[front]\\n                t=min(b,f)\\n                if nums[i]>=t:\\n                    diff=nums[i]-t\\n                    e+=diff+1\\n            else:\\n                b=nums[back]\\n                if nums[i]>=b:\\n                    diff=nums[i]-b\\n                    e+=diff+1\\n        for i in range(0,len(nums),2):\\n            back,front=i-1,i+1 \\n            if back>=0 and front<len(nums):\\n                b,f=nums[back],nums[front]\\n                t=min(b,f)\\n                if nums[i]>=t:\\n                    diff=nums[i]-t\\n                    o+=diff+1\\n            elif front<len(nums):\\n                f=nums[front]\\n                if nums[i]>=f:\\n                    diff=nums[i]-f\\n                    o+=diff+1\\n            elif back>=0:\\n                b=nums[back]\\n                if nums[i]>=b:\\n                    diff=nums[i]-b\\n                    o+=diff+1\\n        return min(o,e)\\n                \\n                \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        e,o=0,0\\n        if len(nums)==1:\\n            return 0\\n        for i in range(1,len(nums),2):\\n            back,front=i-1,i+1 \\n            if front<len(nums):\\n                b,f=nums[back],nums[front]\\n                t=min(b,f)\\n                if nums[i]>=t:\\n                    diff=nums[i]-t\\n                    e+=diff+1\\n            else:\\n                b=nums[back]\\n                if nums[i]>=b:\\n                    diff=nums[i]-b\\n                    e+=diff+1\\n        for i in range(0,len(nums),2):\\n            back,front=i-1,i+1 \\n            if back>=0 and front<len(nums):\\n                b,f=nums[back],nums[front]\\n                t=min(b,f)\\n                if nums[i]>=t:\\n                    diff=nums[i]-t\\n                    o+=diff+1\\n            elif front<len(nums):\\n                f=nums[front]\\n                if nums[i]>=f:\\n                    diff=nums[i]-f\\n                    o+=diff+1\\n            elif back>=0:\\n                b=nums[back]\\n                if nums[i]>=b:\\n                    diff=nums[i]-b\\n                    o+=diff+1\\n        return min(o,e)\\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173822,
                "title": "java-100-faster-o-n",
                "content": "```\\n\\tpublic int movesToMakeZigzag(int[] nums) {\\n        if(nums.length==1) return 0;\\n        int evenSmall= 0, oddSmall= 0, size= nums.length;\\n        if(nums[0]>nums[1]-1) evenSmall+= nums[0]-nums[1]+1;\\n        for(int i=2; i<size; i= i+2){\\n            int left= nums[i]>nums[i-1]-1 ? nums[i]-nums[i-1]+1 : 0;\\n            if(i+1<size && nums[i]>nums[i+1]-1) left= Math.max(left,nums[i]-nums[i+1]+1);\\n            evenSmall+= left;\\n        }\\n        for(int i=1; i<size; i= i+2){\\n            int left= nums[i]>nums[i-1]-1 ? nums[i]-nums[i-1]+1 : 0;\\n            if(i+1<size && nums[i]>nums[i+1]-1) left= Math.max(left,nums[i]-nums[i+1]+1);\\n            oddSmall+= left;\\n        }\\n        return Math.min(evenSmall,oddSmall);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int movesToMakeZigzag(int[] nums) {\\n        if(nums.length==1) return 0;\\n        int evenSmall= 0, oddSmall= 0, size= nums.length;\\n        if(nums[0]>nums[1]-1) evenSmall+= nums[0]-nums[1]+1;\\n        for(int i=2; i<size; i= i+2){\\n            int left= nums[i]>nums[i-1]-1 ? nums[i]-nums[i-1]+1 : 0;\\n            if(i+1<size && nums[i]>nums[i+1]-1) left= Math.max(left,nums[i]-nums[i+1]+1);\\n            evenSmall+= left;\\n        }\\n        for(int i=1; i<size; i= i+2){\\n            int left= nums[i]>nums[i-1]-1 ? nums[i]-nums[i-1]+1 : 0;\\n            if(i+1<size && nums[i]>nums[i+1]-1) left= Math.max(left,nums[i]-nums[i+1]+1);\\n            oddSmall+= left;\\n        }\\n        return Math.min(evenSmall,oddSmall);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1171332,
                "title": "o-n-time-and-o-1-space-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) \\n    {\\n        if(nums.size()==1) return 0;\\n        int ans = 0, prev;\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]<=nums[i+1]) \\n                {\\n                    ans += nums[i+1]-nums[i]+1;\\n                    prev = nums[i] - 1;\\n                    continue;\\n                }\\n            }\\n            else if(i==nums.size()-1)\\n            {\\n                if(nums[i]<=prev) ans += prev-nums[i]+1;\\n            }\\n            else\\n            {\\n                if(nums[i]<=prev) ans+= prev - nums[i] +1;\\n                if(nums[i]<=nums[i+1])\\n                {\\n                    ans+= nums[i+1] - nums[i] +1;\\n                    prev = nums[i] - 1;\\n                    continue;\\n                }\\n            }\\n            if(i+1<nums.size()) prev = nums[i+1];\\n        }\\n        int mn = ans;\\n        ans = 0;\\n        prev = nums[0];\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(i==nums.size()-1)\\n            {\\n                if(nums[i]<=prev) ans += prev-nums[i]+1;\\n            }\\n            else\\n            {\\n                if(nums[i]<=prev) ans += prev - nums[i] +1;\\n                if(nums[i]<=nums[i+1])\\n                {\\n                    ans += nums[i+1] - nums[i] +1;\\n                    prev = nums[i] - 1;\\n                    continue;\\n                }\\n            }\\n            if(i+1<nums.size()) prev = nums[i+1];\\n        }\\n        return min(mn,ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) \\n    {\\n        if(nums.size()==1) return 0;\\n        int ans = 0, prev;\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]<=nums[i+1]) \\n                {\\n                    ans += nums[i+1]-nums[i]+1;\\n                    prev = nums[i] - 1;\\n                    continue;\\n                }\\n            }\\n            else if(i==nums.size()-1)\\n            {\\n                if(nums[i]<=prev) ans += prev-nums[i]+1;\\n            }\\n            else\\n            {\\n                if(nums[i]<=prev) ans+= prev - nums[i] +1;\\n                if(nums[i]<=nums[i+1])\\n                {\\n                    ans+= nums[i+1] - nums[i] +1;\\n                    prev = nums[i] - 1;\\n                    continue;\\n                }\\n            }\\n            if(i+1<nums.size()) prev = nums[i+1];\\n        }\\n        int mn = ans;\\n        ans = 0;\\n        prev = nums[0];\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(i==nums.size()-1)\\n            {\\n                if(nums[i]<=prev) ans += prev-nums[i]+1;\\n            }\\n            else\\n            {\\n                if(nums[i]<=prev) ans += prev - nums[i] +1;\\n                if(nums[i]<=nums[i+1])\\n                {\\n                    ans += nums[i+1] - nums[i] +1;\\n                    prev = nums[i] - 1;\\n                    continue;\\n                }\\n            }\\n            if(i+1<nums.size()) prev = nums[i+1];\\n        }\\n        return min(mn,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167161,
                "title": "python3-linear-sweep",
                "content": "\\n```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        ans = [0, 0] \\n        for i in range(len(nums)): \\n            val = 0 \\n            if i: val = max(val, nums[i] - nums[i-1] + 1)\\n            if i+1 < len(nums): val = max(val, nums[i] - nums[i+1] + 1)\\n            ans[i&1] += val\\n        return min(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        ans = [0, 0] \\n        for i in range(len(nums)): \\n            val = 0 \\n            if i: val = max(val, nums[i] - nums[i-1] + 1)\\n            if i+1 < len(nums): val = max(val, nums[i] - nums[i+1] + 1)\\n            ans[i&1] += val\\n        return min(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165523,
                "title": "c-o-n-2-cases",
                "content": "* Zigzag could start from nums[0] < nums[1] or nums[0] > nums[1]. So we calculate the movements for both cases and return the minimum value. Go through each element in nums array and store the previous value after decrement. \\n```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int m1 = 0, m2 = 0, prev1 = nums[0], prev2 = nums[0];\\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            if (i % 2 == 0 && nums[i] >= prev1) // 1st case, need to decrease nums[i]\\n            {\\n                m1 += nums[i] - prev1 + 1;\\n                --prev1;\\n            }\\n            else\\n            {\\n                if (i % 2 == 1 && nums[i] <= prev1) // 1st case, decrease previous value (index i - 1)\\n                {\\n                    m1 += prev1 - nums[i] + 1;\\n                }\\n                \\n                prev1 = nums[i];\\n            }\\n            \\n            if (i % 2 == 1 && nums[i] >= prev2) // 2nd case, decrease nums[i]\\n            {\\n                m2 += nums[i] - prev2 + 1;\\n                --prev2;\\n            }\\n            else \\n            {\\n                if (i % 2 == 0 && nums[i] <= prev2) // 2nd case, decrease previous value at index i - 1\\n                {\\n                    m2 += prev2 - nums[i] + 1;\\n                }\\n                \\n                prev2 = nums[i];\\n            }   \\n        }\\n        \\n        return min(m1, m2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int m1 = 0, m2 = 0, prev1 = nums[0], prev2 = nums[0];\\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            if (i % 2 == 0 && nums[i] >= prev1) // 1st case, need to decrease nums[i]\\n            {\\n                m1 += nums[i] - prev1 + 1;\\n                --prev1;\\n            }\\n            else\\n            {\\n                if (i % 2 == 1 && nums[i] <= prev1) // 1st case, decrease previous value (index i - 1)\\n                {\\n                    m1 += prev1 - nums[i] + 1;\\n                }\\n                \\n                prev1 = nums[i];\\n            }\\n            \\n            if (i % 2 == 1 && nums[i] >= prev2) // 2nd case, decrease nums[i]\\n            {\\n                m2 += nums[i] - prev2 + 1;\\n                --prev2;\\n            }\\n            else \\n            {\\n                if (i % 2 == 0 && nums[i] <= prev2) // 2nd case, decrease previous value at index i - 1\\n                {\\n                    m2 += prev2 - nums[i] + 1;\\n                }\\n                \\n                prev2 = nums[i];\\n            }   \\n        }\\n        \\n        return min(m1, m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162497,
                "title": "javascript-solution-with-comments",
                "content": "```\\n// there is one important catch we are not supposed to increment a value. to make a value larger we are supposed to decrement previous and next value alone. I missed this point and was heading in wrong direction for long time.\\n\\nvar movesToMakeZigzag = function(nums1) {\\n    \\n\\t//for even index start with 0\\n    let evenCount=calculateSteps(0)\\n\\t//for even index start with 1\\n    let oddCount=calculateSteps(1)\\n    \\n    return Math.min(evenCount,oddCount)\\n\\n     function calculateSteps(startPos){\\n         let count=0\\n\\t\\t // getting array copy so that it should not affect original array\\n         let nums=[...nums1]\\n\\t\\t //i is incremented by 2 as if its odd then only odd numbers must be iterated. same applies to even numbers\\n        for(let i=startPos;i<nums.length;i+=2){\\n\\t\\t//checking current value is lesser or equal to previous value\\n\\t\\t//even if it is equal we have to decrement\\n\\t\\t//[6,5,4] 5 is lesser than 6 so, 6-5 so difference is 1 so 6 will become 5 but then array will be [5,5,4] it has to be lesser than nums[i] thats y the additional 1 is added to equation nums[i-1]-nums[i] +1 now array will be [4,5,4]\\n            if(nums[i]<=nums[i-1]){\\n                count+= nums[i-1]-nums[i] +1\\n                nums[i-1]=nums[i] -1\\n            }\\n            if(nums[i]<=nums[i+1]){\\n                count+= nums[i+1]-nums[i] +1\\n                 nums[i+1]=nums[i] -1\\n            } \\n        }\\n             return count\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// there is one important catch we are not supposed to increment a value. to make a value larger we are supposed to decrement previous and next value alone. I missed this point and was heading in wrong direction for long time.\\n\\nvar movesToMakeZigzag = function(nums1) {\\n    \\n\\t//for even index start with 0\\n    let evenCount=calculateSteps(0)\\n\\t//for even index start with 1\\n    let oddCount=calculateSteps(1)\\n    \\n    return Math.min(evenCount,oddCount)\\n\\n     function calculateSteps(startPos){\\n         let count=0\\n\\t\\t // getting array copy so that it should not affect original array\\n         let nums=[...nums1]\\n\\t\\t //i is incremented by 2 as if its odd then only odd numbers must be iterated. same applies to even numbers\\n        for(let i=startPos;i<nums.length;i+=2){\\n\\t\\t//checking current value is lesser or equal to previous value\\n\\t\\t//even if it is equal we have to decrement\\n\\t\\t//[6,5,4] 5 is lesser than 6 so, 6-5 so difference is 1 so 6 will become 5 but then array will be [5,5,4] it has to be lesser than nums[i] thats y the additional 1 is added to equation nums[i-1]-nums[i] +1 now array will be [4,5,4]\\n            if(nums[i]<=nums[i-1]){\\n                count+= nums[i-1]-nums[i] +1\\n                nums[i-1]=nums[i] -1\\n            }\\n            if(nums[i]<=nums[i+1]){\\n                count+= nums[i+1]-nums[i] +1\\n                 nums[i+1]=nums[i] -1\\n            } \\n        }\\n             return count\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156643,
                "title": "python3-simple-solution",
                "content": "```\\ndef odd(arr):\\n    ##  A[0] < A[1] > A[2]\\n    c1=0\\n    for i in range(1,len(arr),2):\\n            if arr[i]<=arr[i-1]:\\n                while  arr[i]<=arr[i-1]:\\n                    arr[i-1]-=1\\n                    c1+=1\\n            if i+1<len(arr) and arr[i+1]>=arr[i]:\\n                while  arr[i+1]>=arr[i]:\\n                    arr[i+1]-=1\\n                    c1+=1\\n    return c1\\ndef even(arr):\\n    # A[0] > A[1] < A[2] > A[3]\\n    c2=0\\n    for i in range(1,len(arr),2):\\n            if arr[i]>=arr[i-1]:\\n                while  arr[i]>=arr[i-1]:\\n                    arr[i]-=1\\n                    c2+=1\\n            if i+1<len(arr) and arr[i+1]<=arr[i]:\\n                while  arr[i+1]<=arr[i]:\\n                    arr[i]-=1\\n                    c2+=1\\n    return c2\\n\\nclass Solution:\\n    def movesToMakeZigzag(self, arr: List[int]) -> int:\\n        return min(odd(arr[:]),even(arr[:]))",
                "solutionTags": [],
                "code": "```\\ndef odd(arr):\\n    ##  A[0] < A[1] > A[2]\\n    c1=0\\n    for i in range(1,len(arr),2):\\n            if arr[i]<=arr[i-1]:\\n                while  arr[i]<=arr[i-1]:\\n                    arr[i-1]-=1\\n                    c1+=1\\n            if i+1<len(arr) and arr[i+1]>=arr[i]:\\n                while  arr[i+1]>=arr[i]:\\n                    arr[i+1]-=1\\n                    c1+=1\\n    return c1\\ndef even(arr):\\n    # A[0] > A[1] < A[2] > A[3]\\n    c2=0\\n    for i in range(1,len(arr),2):\\n            if arr[i]>=arr[i-1]:\\n                while  arr[i]>=arr[i-1]:\\n                    arr[i]-=1\\n                    c2+=1\\n            if i+1<len(arr) and arr[i+1]<=arr[i]:\\n                while  arr[i+1]<=arr[i]:\\n                    arr[i]-=1\\n                    c2+=1\\n    return c2\\n\\nclass Solution:\\n    def movesToMakeZigzag(self, arr: List[int]) -> int:\\n        return min(odd(arr[:]),even(arr[:]))",
                "codeTag": "Java"
            },
            {
                "id": 1150928,
                "title": "java-100-faster-93-less-memory-smile-neat-commented",
                "content": "class Solution {\\n    \\n    // make central element bigger\\n    int getVal(int start, int end, int[] orignal) {\\n        int ans = 0;\\n        int[] copy = Arrays.copyOf(orignal, end);\\n        int sum = 0;\\n        for(int i = start; i < end; i += 2) {\\n            if(i - 1 >= 0 && copy[i - 1] >= copy[i]) {\\n                int diff = copy[i - 1] - copy[i] + 1;\\n                sum += diff;\\n            }\\n            if(i + 1 < end && copy[i] <= copy[i + 1]) {\\n                int diff = copy[i + 1] - copy[i] + 1;\\n                copy[i + 1] -= diff;\\n                sum += diff;\\n            }\\n        } \\n        return sum;    \\n    }\\n    \\n    public int movesToMakeZigzag(int[] nums) {\\n        int toBig = 0;\\n        int toSmall = 0;\\n        int n = nums.length;\\n        // make either even indexed bigger \\n        // or odd indexed bigger\\n        return Math.min(getVal(0, n, nums), getVal(1, n, nums));\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    // make central element bigger\\n    int getVal(int start, int end, int[] orignal) {\\n        int ans = 0;\\n        int[] copy = Arrays.copyOf(orignal, end);\\n        int sum = 0;\\n        for(int i = start; i < end; i += 2) {\\n            if(i - 1 >= 0 && copy[i - 1] >= copy[i]) {\\n                int diff = copy[i - 1] - copy[i] + 1;\\n                sum += diff;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1131212,
                "title": "java-faster-than-100-simple-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Decrease Elements To Make Array Zigzag.\\nMemory Usage: 36.6 MB, less than 27.34% of Java online submissions for Decrease Elements To Make Array Zigzag.\\n\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] a) {\\n        int n=a.length;\\n        \\n        int even[]=Arrays.copyOf(a,n);\\n        int evenReduce=0;\\n        for(int i=0;i<n;i+=2)\\n        {\\n            if(i!=0 && even[i]<=even[i-1])\\n            {\\n                evenReduce+=even[i-1]-even[i]+1;\\n                even[i-1]=even[i]-1;\\n            }\\n            if(i!=n-1 && even[i]<=even[i+1])\\n            {\\n                evenReduce+=even[i+1]-even[i]+1;\\n                even[i+1]=even[i]-1;\\n            }\\n        }\\n        \\n        int odd[]=Arrays.copyOf(a,n);\\n        int oddReduce=0;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            if(i!=0 && odd[i]<=odd[i-1])\\n            {\\n                oddReduce+=odd[i-1]-odd[i]+1;\\n                odd[i-1]=odd[i]-1;\\n            }\\n            if(i!=n-1 && odd[i]<=odd[i+1])\\n            {\\n                oddReduce+=odd[i+1]-odd[i]+1;\\n                odd[i+1]=odd[i]-1;\\n            }\\n        }\\n        \\n        return Math.min(evenReduce,oddReduce);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] a) {\\n        int n=a.length;\\n        \\n        int even[]=Arrays.copyOf(a,n);\\n        int evenReduce=0;\\n        for(int i=0;i<n;i+=2)\\n        {\\n            if(i!=0 && even[i]<=even[i-1])\\n            {\\n                evenReduce+=even[i-1]-even[i]+1;\\n                even[i-1]=even[i]-1;\\n            }\\n            if(i!=n-1 && even[i]<=even[i+1])\\n            {\\n                evenReduce+=even[i+1]-even[i]+1;\\n                even[i+1]=even[i]-1;\\n            }\\n        }\\n        \\n        int odd[]=Arrays.copyOf(a,n);\\n        int oddReduce=0;\\n        for(int i=1;i<n;i+=2)\\n        {\\n            if(i!=0 && odd[i]<=odd[i-1])\\n            {\\n                oddReduce+=odd[i-1]-odd[i]+1;\\n                odd[i-1]=odd[i]-1;\\n            }\\n            if(i!=n-1 && odd[i]<=odd[i+1])\\n            {\\n                oddReduce+=odd[i+1]-odd[i]+1;\\n                odd[i+1]=odd[i]-1;\\n            }\\n        }\\n        \\n        return Math.min(evenReduce,oddReduce);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111133,
                "title": "neat-and-clean-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int res[2]={0,0};\\n        int left,right;\\n        for(int i=0;i<nums.size();i++){\\n            left=i>0?nums[i-1]:1001;\\n            right=i+1<nums.size()?nums[i+1]:1001;\\n            res[i%2]+=max(0,nums[i]-min(left,right)+1);\\n        }\\n        return min(res[0],res[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int res[2]={0,0};\\n        int left,right;\\n        for(int i=0;i<nums.size();i++){\\n            left=i>0?nums[i-1]:1001;\\n            right=i+1<nums.size()?nums[i+1]:1001;\\n            res[i%2]+=max(0,nums[i]-min(left,right)+1);\\n        }\\n        return min(res[0],res[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102206,
                "title": "golang-100-o-n",
                "content": "```\\ntype ResInfo struct {\\n    IsGreater bool\\n    Val int\\n    Moves int\\n}\\n\\nfunc movesToMakeZigzag(nums []int) int {\\n    infos := resolve(nums, 0)\\n    if infos[0].Moves < infos[1].Moves { return infos[0].Moves }\\n    return infos[1].Moves\\n}\\n\\nfunc resolve(nums []int, start int) []*ResInfo {\\n    if start == len(nums) - 1 {\\n        return []*ResInfo{\\n            &ResInfo{ IsGreater: true, Val: nums[start], Moves: 0 },\\n            &ResInfo{ IsGreater: false, Val: nums[start], Moves: 0 },\\n        }\\n    }\\n    \\n    infos := resolve(nums, start + 1)\\n    val := nums[start]\\n    \\n    for _, info := range infos {\\n        if info.IsGreater {\\n            info.IsGreater = false\\n            if val >= info.Val {\\n                info.Val -= 1\\n                info.Moves += val - info.Val\\n            } else {\\n                info.Val = val\\n            }\\n        } else {\\n            info.IsGreater = true\\n            if val <= info.Val {\\n                info.Moves += info.Val - (val - 1)\\n            }\\n            info.Val = val\\n        }\\n        // fmt.Println(info, val)\\n    }\\n    \\n    return infos\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype ResInfo struct {\\n    IsGreater bool\\n    Val int\\n    Moves int\\n}\\n\\nfunc movesToMakeZigzag(nums []int) int {\\n    infos := resolve(nums, 0)\\n    if infos[0].Moves < infos[1].Moves { return infos[0].Moves }\\n    return infos[1].Moves\\n}\\n\\nfunc resolve(nums []int, start int) []*ResInfo {\\n    if start == len(nums) - 1 {\\n        return []*ResInfo{\\n            &ResInfo{ IsGreater: true, Val: nums[start], Moves: 0 },\\n            &ResInfo{ IsGreater: false, Val: nums[start], Moves: 0 },\\n        }\\n    }\\n    \\n    infos := resolve(nums, start + 1)\\n    val := nums[start]\\n    \\n    for _, info := range infos {\\n        if info.IsGreater {\\n            info.IsGreater = false\\n            if val >= info.Val {\\n                info.Val -= 1\\n                info.Moves += val - info.Val\\n            } else {\\n                info.Val = val\\n            }\\n        } else {\\n            info.IsGreater = true\\n            if val <= info.Val {\\n                info.Moves += info.Val - (val - 1)\\n            }\\n            info.Val = val\\n        }\\n        // fmt.Println(info, val)\\n    }\\n    \\n    return infos\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082213,
                "title": "python-solution-beats-98",
                "content": "class Solution:\\n\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        s1 = 0\\n        s2 = 0\\n\\n        for i in range(len(nums)):\\n            if i%2!=0: # even-indexed case \\n                if i+1<len(nums):\\n                    s1+= max(nums[i] - min(nums[i-1],nums[i+1]) + 1,0)\\n                else:\\n                    s1+= max(nums[i]-nums[i-1]+1,0)\\n            else: # odd-indexed case\\n                if i==0:\\n                    s2+= max(nums[i]-nums[i+1]+1,0)\\n                elif i == len(nums)-1:\\n                    s2+= max(nums[i]-nums[i-1]+1,0)\\n                else:\\n                    s2+= max(nums[i] - min(nums[i-1],nums[i+1]) + 1,0)\\n                \\n        return min(s1,s2)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\\n        s1 = 0\\n        s2 = 0\\n\\n        for i in range(len(nums)):\\n            if i%2!=0: # even-indexed case \\n                if i+1<len(nums):\\n                    s1+= max(nums[i] - min(nums[i-1],nums[i+1]) + 1,0)\\n                else:\\n                    s1+= max(nums[i]-nums[i-1]+1,0)\\n            else: # odd-indexed case\\n                if i==0:\\n                    s2+= max(nums[i]-nums[i+1]+1,0)\\n                elif i == len(nums)-1:\\n                    s2+= max(nums[i]-nums[i-1]+1,0)\\n                else:\\n                    s2+= max(nums[i] - min(nums[i-1],nums[i+1]) + 1,0)\\n                \\n        return min(s1,s2)",
                "codeTag": "Java"
            },
            {
                "id": 1065587,
                "title": "simple-python-o-n",
                "content": "We have only two options:\\n- start with going up\\n- start with going down\\n\\n```\\nclass Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        updown = [True,False]\\n        out = [0,0]\\n        \\n        \\n        for i in range(2):\\n            prev = nums[0]\\n            # once start with up once with down\\n            up = updown[i]\\n        \\n            for a in nums[1:]:\\n                if up:\\n                    if a > prev: prev = a\\n                    else:\\n                        new_prev = a-1\\n                        out[i] += prev-new_prev\\n                        prev = a\\n                else:\\n                    if a < prev: prev = a\\n                    else:\\n                        new_a = prev-1\\n                        out[i] += a-new_a\\n                        prev = new_a\\n                \\n                up = not up\\n\\n            \\n        return min(out)",
                "solutionTags": [],
                "code": "We have only two options:\\n- start with going up\\n- start with going down\\n\\n```\\nclass Solution(object):\\n    def movesToMakeZigzag(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        updown = [True,False]\\n        out = [0,0]\\n        \\n        \\n        for i in range(2):\\n            prev = nums[0]\\n            # once start with up once with down\\n            up = updown[i]\\n        \\n            for a in nums[1:]:\\n                if up:\\n                    if a > prev: prev = a\\n                    else:\\n                        new_prev = a-1\\n                        out[i] += prev-new_prev\\n                        prev = a\\n                else:\\n                    if a < prev: prev = a\\n                    else:\\n                        new_a = prev-1\\n                        out[i] += a-new_a\\n                        prev = new_a\\n                \\n                up = not up\\n\\n            \\n        return min(out)",
                "codeTag": "Java"
            },
            {
                "id": 1030121,
                "title": "c-dp-solution",
                "content": "Run-time is `O(N*K)`, space is `O(K)`, where `K` is range of numbers in `nums`. \\n\\n```\\n\\n#define MAX_VAL 1001\\n\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int size{(int)nums.size()};\\n        std::vector<std::vector<int>> dp1(2, std::vector<int>(MAX_VAL+1, INT32_MAX)), dp2(2, std::vector<int>(MAX_VAL+1, INT32_MAX)); // 1 == max, 2 == min\\n        for(int j{1}; j <= nums[0]; ++j) dp1[0][j] = nums[0]-j;\\n        for(int j{0}; j <= nums[0]; ++j) dp2[0][j] = nums[0]-j;\\n        for(int i{1}; i < size; ++i) {\\n            std::vector<int> tmp1(dp1[0].begin(), dp1[0].end()), tmp2(dp2[0].begin(), dp2[0].end());\\n            for(int j{1}, min_{INT32_MAX}; j <= nums[i]; ++j) {\\n                min_ = std::min(min_, tmp2[j-1]);\\n                dp1[1][j] = min_ + nums[i]-j;\\n            }\\n            for(int j{nums[i-1]}, min_{INT32_MAX}; j > 0; --j) {\\n                min_ = std::min(min_, tmp1[j]);\\n                if(j <= nums[i]+1) dp2[1][j-1] = min_ + nums[i]-j+1;\\n            }\\n            \\n            std::swap(dp1[0], dp1[1]);\\n            std::swap(dp2[0], dp2[1]);\\n            std::fill_n(dp1[1].begin(), MAX_VAL+1, INT32_MAX);\\n            std::fill_n(dp2[1].begin(), MAX_VAL+1, INT32_MAX);\\n        }\\n\\n        return std::min(*min_element(dp1[0].begin(), dp1[0].end()), *min_element(dp2[0].begin(), dp2[0].end()));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define MAX_VAL 1001\\n\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& nums) {\\n        int size{(int)nums.size()};\\n        std::vector<std::vector<int>> dp1(2, std::vector<int>(MAX_VAL+1, INT32_MAX)), dp2(2, std::vector<int>(MAX_VAL+1, INT32_MAX)); // 1 == max, 2 == min\\n        for(int j{1}; j <= nums[0]; ++j) dp1[0][j] = nums[0]-j;\\n        for(int j{0}; j <= nums[0]; ++j) dp2[0][j] = nums[0]-j;\\n        for(int i{1}; i < size; ++i) {\\n            std::vector<int> tmp1(dp1[0].begin(), dp1[0].end()), tmp2(dp2[0].begin(), dp2[0].end());\\n            for(int j{1}, min_{INT32_MAX}; j <= nums[i]; ++j) {\\n                min_ = std::min(min_, tmp2[j-1]);\\n                dp1[1][j] = min_ + nums[i]-j;\\n            }\\n            for(int j{nums[i-1]}, min_{INT32_MAX}; j > 0; --j) {\\n                min_ = std::min(min_, tmp1[j]);\\n                if(j <= nums[i]+1) dp2[1][j-1] = min_ + nums[i]-j+1;\\n            }\\n            \\n            std::swap(dp1[0], dp1[1]);\\n            std::swap(dp2[0], dp2[1]);\\n            std::fill_n(dp1[1].begin(), MAX_VAL+1, INT32_MAX);\\n            std::fill_n(dp2[1].begin(), MAX_VAL+1, INT32_MAX);\\n        }\\n\\n        return std::min(*min_element(dp1[0].begin(), dp1[0].end()), *min_element(dp2[0].begin(), dp2[0].end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028236,
                "title": "java-one-pass-0-ms-beats-100-detailed-explanation",
                "content": "I think about this problem in this way:\\n1. try make odd bigger, then just need to decrease even when needed.(no any action for odd)\\n2. try make even bigger, then just need to decrease odd when needed.(no any action for even)\\n3. compare which cost less\\n\\n2 demo:\\n![image](https://assets.leetcode.com/users/images/40ba2463-fe39-48e4-a837-e94297e3fe94_1611254927.3004303.png)\\n\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if (nums == null || nums.length <= 1) return 0;\\n        int odd = 0;\\n        int even = 0;\\n        // we want odd bigger, just dec even  9 6 1 6 2\\n        for (int i = 0; i < nums.length; i+=2) {\\n            if (i == 0) {\\n                odd += Math.max(0, nums[i] - nums[i+1] + 1);\\n            } else if (i == nums.length - 1) {\\n                odd += Math.max(0, nums[i] - nums[i-1] + 1);\\n            } else {\\n                odd += Math.max(0, nums[i] - nums[i-1] + 1);\\n                int tmp = nums[i] - Math.max(0, nums[i] - nums[i-1] + 1); // when u decrese for the left, it also contribute to the right;\\n                odd += Math.max(0, tmp - nums[i+1] + 1);\\n            }\\n        }\\n        // we want even bigger, just dec odd\\n        for (int i = 1; i < nums.length; i+=2) {\\n            if (i == nums.length - 1) {\\n                even += Math.max(0, nums[i] - nums[i-1] + 1);\\n            } else {\\n                even += Math.max(0, nums[i] - nums[i-1] + 1);\\n                int tmp = nums[i] - Math.max(0, nums[i] - nums[i-1] + 1);\\n                even += Math.max(0, tmp - nums[i+1] + 1);\\n            }\\n        }\\n        return odd < even ? odd : even;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        if (nums == null || nums.length <= 1) return 0;\\n        int odd = 0;\\n        int even = 0;\\n        // we want odd bigger, just dec even  9 6 1 6 2\\n        for (int i = 0; i < nums.length; i+=2) {\\n            if (i == 0) {\\n                odd += Math.max(0, nums[i] - nums[i+1] + 1);\\n            } else if (i == nums.length - 1) {\\n                odd += Math.max(0, nums[i] - nums[i-1] + 1);\\n            } else {\\n                odd += Math.max(0, nums[i] - nums[i-1] + 1);\\n                int tmp = nums[i] - Math.max(0, nums[i] - nums[i-1] + 1); // when u decrese for the left, it also contribute to the right;\\n                odd += Math.max(0, tmp - nums[i+1] + 1);\\n            }\\n        }\\n        // we want even bigger, just dec odd\\n        for (int i = 1; i < nums.length; i+=2) {\\n            if (i == nums.length - 1) {\\n                even += Math.max(0, nums[i] - nums[i-1] + 1);\\n            } else {\\n                even += Math.max(0, nums[i] - nums[i-1] + 1);\\n                int tmp = nums[i] - Math.max(0, nums[i] - nums[i-1] + 1);\\n                even += Math.max(0, tmp - nums[i+1] + 1);\\n            }\\n        }\\n        return odd < even ? odd : even;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003612,
                "title": "o-n-beats-100-simulation-solution",
                "content": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int even=0,odd=0,n=nums.length;\\n        int []ar1=nums.clone();\\n        int []ar2=nums.clone();\\n        for(int i=0;i<nums.length;i++){\\n            if(i%2==0){\\n                if(i>0 && ar1[i-1]>=ar1[i]){\\n                    even+=ar1[i-1]-ar1[i]+1;\\n                }\\n                if(i<n-1 && ar1[i+1]>=ar1[i]){\\n                    even+=ar1[i+1]-ar1[i]+1;\\n                    ar1[i+1]=ar1[i]-1;\\n                }\\n            }else{\\n                if(i>0 && ar2[i-1]>=ar2[i]){\\n                    odd+=ar2[i-1]-ar2[i]+1;\\n                }\\n                if(i<n-1 && ar2[i+1]>=ar2[i]){\\n                    odd+=ar2[i+1]-ar2[i]+1;\\n                    ar2[i+1]=ar2[i]-1;\\n                }\\n            }\\n        }\\n        return Math.min(even,odd);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int even=0,odd=0,n=nums.length;\\n        int []ar1=nums.clone();\\n        int []ar2=nums.clone();\\n        for(int i=0;i<nums.length;i++){\\n            if(i%2==0){\\n                if(i>0 && ar1[i-1]>=ar1[i]){\\n                    even+=ar1[i-1]-ar1[i]+1;\\n                }\\n                if(i<n-1 && ar1[i+1]>=ar1[i]){\\n                    even+=ar1[i+1]-ar1[i]+1;\\n                    ar1[i+1]=ar1[i]-1;\\n                }\\n            }else{\\n                if(i>0 && ar2[i-1]>=ar2[i]){\\n                    odd+=ar2[i-1]-ar2[i]+1;\\n                }\\n                if(i<n-1 && ar2[i+1]>=ar2[i]){\\n                    odd+=ar2[i+1]-ar2[i]+1;\\n                    ar2[i+1]=ar2[i]-1;\\n                }\\n            }\\n        }\\n        return Math.min(even,odd);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987497,
                "title": "100-faster-0ms-runtime-c-easy-greedly-approach",
                "content": "```\\nint solve(vector<int>&arr, int pos)\\n{\\n    int ans1=0;\\n    int n=arr.size();\\n        for(int i=pos;i<n;i+=2)\\n        {\\n            if(i-1>=0)\\n            {\\n                if(arr[i-1]>=arr[i])\\n                {\\n                    // then we have to do something\\n                    ans1+=(arr[i-1]-(arr[i]-1));\\n                    arr[i-1]=arr[i]-1;\\n                }\\n            }\\n            if(i+1<n)\\n            {\\n                if(arr[i+1]>=arr[i])\\n                {\\n                    ans1+=(arr[i+1]-(arr[i]-1));\\n                    arr[i+1]=arr[i]-1;\\n                }\\n            }\\n            \\n        }\\n    \\n    return ans1;\\n}\\n\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& arr) {\\n        // very easy and simple\\n        vector<int>temp;\\n        for(auto x: arr)\\n        temp.push_back(x);\\n       \\n        int ans1=solve(arr,0);\\n        int ans2=solve(temp,1);\\n        \\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(vector<int>&arr, int pos)\\n{\\n    int ans1=0;\\n    int n=arr.size();\\n        for(int i=pos;i<n;i+=2)\\n        {\\n            if(i-1>=0)\\n            {\\n                if(arr[i-1]>=arr[i])\\n                {\\n                    // then we have to do something\\n                    ans1+=(arr[i-1]-(arr[i]-1));\\n                    arr[i-1]=arr[i]-1;\\n                }\\n            }\\n            if(i+1<n)\\n            {\\n                if(arr[i+1]>=arr[i])\\n                {\\n                    ans1+=(arr[i+1]-(arr[i]-1));\\n                    arr[i+1]=arr[i]-1;\\n                }\\n            }\\n            \\n        }\\n    \\n    return ans1;\\n}\\n\\nclass Solution {\\npublic:\\n    int movesToMakeZigzag(vector<int>& arr) {\\n        // very easy and simple\\n        vector<int>temp;\\n        for(auto x: arr)\\n        temp.push_back(x);\\n       \\n        int ans1=solve(arr,0);\\n        int ans2=solve(temp,1);\\n        \\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951616,
                "title": "picture-explanation",
                "content": "Pairs create 3 shapes: `down, flat, up`.\\n\\nTriplets create 9 shapes, since triplets are composed of consecutive pairs:\\n`[a,b,c] composed of [a,b] and [b,c]` with `3x3` options for the shapes.\\n\\nTo make a triplet zig `(blue)`, only odds need adjustment.\\nTo make a triplet zag `(red)`, only evens need adjustment.\\n\\n<img src=\"https://github.com/mnorbi/algo-practice/blob/master/leetcode/images/ecc7cf6a-b0f6-4ec0-bebc-b8be74d0ccce.jpg?raw=true\" width=\"400\">\\n\\nChaining zig to a zag or zag to a zig, the adjustment locations stay fixed.\\n\\n<img src=\"https://github.com/mnorbi/algo-practice/blob/master/leetcode/images/d8f803cf-9393-4da7-b84a-4accdd816959.jpg?raw=true\" width=\"400\">\\n\\nThere is a choice for the first triplet to zig or zag, but no choice for consecutive triplets,\\nso both options can be tried.\\n\\n```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans = Integer.MAX_VALUE, n = nums.length;\\n        for(int d = 0; d < 2; ++d){\\n            int cost = 0;\\n            for(int i = d; i < n; i += 2){\\n                int left = i-1 < 0 ? Integer.MAX_VALUE : nums[i-1];\\n                int right = i+1 >= n ? Integer.MAX_VALUE : nums[i+1];\\n                cost += Math.max(0,nums[i]-Math.min(left,right)+1);\\n            }       \\n            ans = Math.min(ans,cost);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int movesToMakeZigzag(int[] nums) {\\n        int ans = Integer.MAX_VALUE, n = nums.length;\\n        for(int d = 0; d < 2; ++d){\\n            int cost = 0;\\n            for(int i = d; i < n; i += 2){\\n                int left = i-1 < 0 ? Integer.MAX_VALUE : nums[i-1];\\n                int right = i+1 >= n ? Integer.MAX_VALUE : nums[i+1];\\n                cost += Math.max(0,nums[i]-Math.min(left,right)+1);\\n            }       \\n            ans = Math.min(ans,cost);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565028,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            },
            {
                "id": 1565614,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            },
            {
                "id": 1565261,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            },
            {
                "id": 1568186,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            },
            {
                "id": 1566568,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            },
            {
                "id": 1568184,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            },
            {
                "id": 1885142,
                "content": [
                    {
                        "username": "jiah",
                        "content": "Statement:\\nThe optimal solution makes 0 or more moves at `even` indexes only, or at `odd` indexes only.\\n\\nBrief Proof:\\nConsider any solution that makes some moves at `even` positions and also some moves at `odd` positions:\\n1. If this solution makes number at `odd` positions larger than their neighbors. We can discard these moves at `odd` positions, and this new solution still ensures `odd`-indexed numbers larger than their neighbors.\\n2. If this solution makes number at `even` positions larger than their neighbors. We can discard these moves at `even` positions, and this new solution still ensures `even`-indexed numbers larger than neighbors.\\n3. From the above analysis, we can conclude that for any solution with both odd and even moves, there exists better solutions. In other words, optimal solution makes odd moves only or even moves only.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Ivan666",
                        "content": "Luckily I solved one of medium and hard questions in this contest, but I have totally no idea about this easy question. I cannot even come out of a brute force way.. Anyone in same situation with me?"
                    },
                    {
                        "username": "dionwang",
                        "content": "I feel frustrated for every Saturday night :("
                    },
                    {
                        "username": "nosensezzz",
                        "content": "Test case:\\n[10,4,4,10,10,6,2,3]\\n\\nMy Result:\\n12\\n\\nExpected:\\n13\\n\\nDoes this testcase wrong?\\nmy adjusted array\\n[ 10, 11, 4, 10, 9, 10, 2, 3 ]\\n[ 10, 4, 5, 4, 10, 6, 7, 3 ]\\n\\nboth only need 12 steps\\n\\nAnyone help?"
                    },
                    {
                        "username": "panhejia",
                        "content": "you are suppose to decrease value only. No value increase is permitted."
                    },
                    {
                        "username": "elvinyang",
                        "content": "How did some people get 23 points in the contest???"
                    },
                    {
                        "username": "VitusBlues",
                        "content": "Input:\\n[10,4,4,10,10,6,2,3]\\nOutput:\\n12\\nExpected:\\n13\\n\\nHow come the expected is 13?"
                    },
                    {
                        "username": "kunalr14082001",
                        "content": "[10,4,4,10,10,6,2,3]\\nOutput\\n12\\nExpected\\n13\\n\\nmy output explanation:-\\nfinal array = [10,4,5,4,10,6,7,3]\\nmoves = (5-4)+ (10-4) + (7-2)  = 12\\n\\nCan anybody tell error?\\n"
                    }
                ]
            }
        ]
    }
]