[
    {
        "title": "Reward Top K Students",
        "question_content": "You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.\nInitially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.\nYou are given n feedback reports, represented by a 0-indexed string array report&nbsp;and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.\nGiven an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.\n&nbsp;\nExample 1:\n\nInput: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2\nOutput: [1,2]\nExplanation: \nBoth the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.\n\nExample 2:\n\nInput: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2\nOutput: [2,1]\nExplanation: \n- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. \n- The student with ID 2 has 1 positive feedback, so he has 3 points. \nSince student 2 has more points, [2,1] is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= positive_feedback.length, negative_feedback.length <= 104\n\t1 <= positive_feedback[i].length, negative_feedback[j].length <= 100\n\tBoth positive_feedback[i] and negative_feedback[j] consists of lowercase English letters.\n\tNo word is present in both positive_feedback and negative_feedback.\n\tn == report.length == student_id.length\n\t1 <= n <= 104\n\treport[i] consists of lowercase English letters and spaces ' '.\n\tThere is a single space between consecutive words of report[i].\n\t1 <= report[i].length <= 100\n\t1 <= student_id[i] <= 109\n\tAll the values of student_id[i] are unique.\n\t1 <= k <= n",
        "solutions": [
            {
                "id": 2946490,
                "title": "python-use-set-for-fast-access",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment.** Overall, the task is trivial. However, the tricky part here is the access time when checking for presence of each word in positive and negative lists. Converting `list` to `set` helps.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def topStudents(self, pos: List[str], neg: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        \\n        stud = []\\n        pos, neg = set(pos), set(neg)\\n    \\n        for rep, sid in zip(report, student_id):\\n            score = 0\\n            for w in rep.split(\" \"):\\n                if w in pos : score += 3\\n                if w in neg : score -= 1\\n            stud.append((-score,sid))\\n            \\n        stud.sort()\\n        return [sid for _, sid in stud[0:k]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def topStudents(self, pos: List[str], neg: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        \\n        stud = []\\n        pos, neg = set(pos), set(neg)\\n    \\n        for rep, sid in zip(report, student_id):\\n            score = 0\\n            for w in rep.split(\" \"):\\n                if w in pos : score += 3\\n                if w in neg : score -= 1\\n            stud.append((-score,sid))\\n            \\n        stud.sort()\\n        return [sid for _, sid in stud[0:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947767,
                "title": "c-very-easy-and-simple-to-understand-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        auto comp = [](pair<int, int> &a, pair<int, int> &b){\\n          if(a.first == b.first) return a.second > b.second;\\n          return a.first < b.first;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\\n        unordered_set<string> pos, neg;\\n        for(auto s: positive_feedback) pos.insert(s);\\n        for(auto s: negative_feedback) neg.insert(s);\\n        for(int i = 0; i < report.size(); ++i){\\n            int l = 0, r = 0, rew = 0;\\n            string t = report[i];\\n            while( r < t.size()){\\n                if(t[r] == \\' \\'){\\n                    string s = t.substr(l, r-l); //cout<<s<<endl;\\n                    if(pos.find(s) != pos.end()) rew += 3;\\n                    else if(neg.find(s) != neg.end()) rew -= 1;\\n                    l = r+1;\\n                }\\n                r++;\\n            }\\n            string s = t.substr(l, r-l);\\n            if(pos.find(s) != pos.end()) rew += 3;\\n            else if(neg.find(s) != neg.end()) rew -= 1;\\n            pq.push({rew, student_id[i]});  \\n        }\\n        vector<int> ans;\\n        while(pq.size() > 0 && k--){\\n            ans.push_back(pq.top().second); //cout<<pq.top().first<<\" \"<<pq.top().second<<endl;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        auto comp = [](pair<int, int> &a, pair<int, int> &b){\\n          if(a.first == b.first) return a.second > b.second;\\n          return a.first < b.first;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\\n        unordered_set<string> pos, neg;\\n        for(auto s: positive_feedback) pos.insert(s);\\n        for(auto s: negative_feedback) neg.insert(s);\\n        for(int i = 0; i < report.size(); ++i){\\n            int l = 0, r = 0, rew = 0;\\n            string t = report[i];\\n            while( r < t.size()){\\n                if(t[r] == \\' \\'){\\n                    string s = t.substr(l, r-l); //cout<<s<<endl;\\n                    if(pos.find(s) != pos.end()) rew += 3;\\n                    else if(neg.find(s) != neg.end()) rew -= 1;\\n                    l = r+1;\\n                }\\n                r++;\\n            }\\n            string s = t.substr(l, r-l);\\n            if(pos.find(s) != pos.end()) rew += 3;\\n            else if(neg.find(s) != neg.end()) rew -= 1;\\n            pq.push({rew, student_id[i]});  \\n        }\\n        vector<int> ans;\\n        while(pq.size() > 0 && k--){\\n            ans.push_back(pq.top().second); //cout<<pq.top().first<<\" \"<<pq.top().second<<endl;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2947200,
                "title": "tedious",
                "content": "Just bunch of data manipulation. Looks a bit better in Python.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def topStudents(self, pos_feed: List[str], neg_feed: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos, neg, score_id = set(pos_feed), set(neg_feed), []\\n        for r, id in zip(report, student_id):\\n            score = sum(3 if w in pos else -1 if w in neg else 0 for w in r.split(\" \"))\\n            score_id.append((-score, id))\\n        return [id for _, id in sorted(score_id)[0 : k]]\\n```\\n**C++**\\n```cpp\\nvector<int> topStudents(vector<string>& pos_feed, vector<string>& neg_feed, vector<string>& report, vector<int>& student_id, int k) {\\n    unordered_set<string> pos(begin(pos_feed), end(pos_feed)), neg(begin(neg_feed), end(neg_feed));\\n    vector<pair<int, int>> sid;\\n    vector<int> res;\\n    for (int i = 0; i < report.size(); ++i) {\\n        int score = 0;\\n        for (int j = 0, k = 0; j <= report[i].size(); ++j)\\n            if (j == report[i].size() || report[i][j] == \\' \\') {\\n                score += pos.count(report[i].substr(k, j - k)) ? 3 : \\n                    neg.count(report[i].substr(k, j - k)) ? -1 : 0;\\n                k = j + 1;\\n            }\\n        sid.push_back({-score, student_id[i]});\\n    }\\n    partial_sort(begin(sid), begin(sid) + k, end(sid));\\n    transform(begin(sid), begin(sid) + k, back_inserter(res), [](const auto &p){ return p.second; });\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def topStudents(self, pos_feed: List[str], neg_feed: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos, neg, score_id = set(pos_feed), set(neg_feed), []\\n        for r, id in zip(report, student_id):\\n            score = sum(3 if w in pos else -1 if w in neg else 0 for w in r.split(\" \"))\\n            score_id.append((-score, id))\\n        return [id for _, id in sorted(score_id)[0 : k]]\\n```\n```cpp\\nvector<int> topStudents(vector<string>& pos_feed, vector<string>& neg_feed, vector<string>& report, vector<int>& student_id, int k) {\\n    unordered_set<string> pos(begin(pos_feed), end(pos_feed)), neg(begin(neg_feed), end(neg_feed));\\n    vector<pair<int, int>> sid;\\n    vector<int> res;\\n    for (int i = 0; i < report.size(); ++i) {\\n        int score = 0;\\n        for (int j = 0, k = 0; j <= report[i].size(); ++j)\\n            if (j == report[i].size() || report[i][j] == \\' \\') {\\n                score += pos.count(report[i].substr(k, j - k)) ? 3 : \\n                    neg.count(report[i].substr(k, j - k)) ? -1 : 0;\\n                k = j + 1;\\n            }\\n        sid.push_back({-score, student_id[i]});\\n    }\\n    partial_sort(begin(sid), begin(sid) + k, end(sid));\\n    transform(begin(sid), begin(sid) + k, back_inserter(res), [](const auto &p){ return p.second; });\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991124,
                "title": "java-clean-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n    Set<String> positive = Arrays.stream(positive_feedback).collect(Collectors.toSet());\\n    Set<String> negative = Arrays.stream(negative_feedback).collect(Collectors.toSet());\\n    List<Student> students = new ArrayList<>();\\n\\n    for (int i = 0; i < report.length; ++i) {\\n      int points = toPoints(report[i], positive, negative);\\n      students.add(new Student(student_id[i], points));\\n    }\\n\\n    return students.stream()\\n      .sorted(Comparator.comparing(Student::points).reversed().thenComparing(Student::id))\\n      .map(Student::id).limit(k).toList();\\n  }\\n\\n  private int toPoints(String report, Set<String> positive, Set<String> negative) {\\n    int points = 0;\\n    for (String word : report.split(\" \")) {\\n      if (positive.contains(word))\\n        points += 3;\\n      else if (negative.contains(word))\\n        points -= 1;\\n    }\\n    return points;\\n  }\\n\\n  public record Student(int id, int points) {}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n    Set<String> positive = Arrays.stream(positive_feedback).collect(Collectors.toSet());\\n    Set<String> negative = Arrays.stream(negative_feedback).collect(Collectors.toSet());\\n    List<Student> students = new ArrayList<>();\\n\\n    for (int i = 0; i < report.length; ++i) {\\n      int points = toPoints(report[i], positive, negative);\\n      students.add(new Student(student_id[i], points));\\n    }\\n\\n    return students.stream()\\n      .sorted(Comparator.comparing(Student::points).reversed().thenComparing(Student::id))\\n      .map(Student::id).limit(k).toList();\\n  }\\n\\n  private int toPoints(String report, Set<String> positive, Set<String> negative) {\\n    int points = 0;\\n    for (String word : report.split(\" \")) {\\n      if (positive.contains(word))\\n        points += 3;\\n      else if (negative.contains(word))\\n        points -= 1;\\n    }\\n    return points;\\n  }\\n\\n  public record Student(int id, int points) {}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969535,
                "title": "new-testcase-failing-old-submissions-at-contest-time",
                "content": "\\n[\"z\",\"x\"]\\n[\"n\",\"dk\"]\\n[\"y\",\"fom\",\"no\",\"nk\"]\\n[1,4,3,2]\\n1\\n\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2946513,
                "title": "hashmap-hashset-sort",
                "content": "+ Prestore `negative` and `positive` words in hashsets\\n + Now traverse every student report and `collect the points` according to rule in question. \\n + `Sort the student_id array` stated according to collected points of every student\\n + Return the `Resized`student_id array to k \\n\\n# C++    \\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& r, vector<int>& student_id, int k) {\\n        unordered_set<string> ps(begin(pf), end(pf));\\n        unordered_set<string> ng(begin(nf), end(nf));\\n        unordered_map<int, int> mp;\\n        mp.reserve(size(student_id));\\n        \\n        for(int i = 0;i < size(r); ++i){\\n            int sz = r[i].size(), id = student_id[i];\\n            \\n            //traverse through i\\'th string\\n            for(int j = 0; j < sz; j++){\\n                string p;\\n                while(j < sz && r[i][j] != 32) p+= r[i][j], j++;\\n                \\n                //check if positive or negative\\n                if(ps.count(p)) mp[id]+=3;\\n                if(ng.count(p)) mp[id]--;\\n            }\\n        }\\n        \\n        partial_sort(begin(student_id), begin(student_id) + k, end(student_id), [&](auto a, auto b){\\n             return mp[a] == mp[b]? a < b : mp[b] < mp[a];\\n        });\\n        \\n        student_id.resize(k);\\n        return student_id;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "+ Prestore `negative` and `positive` words in hashsets\\n + Now traverse every student report and `collect the points` according to rule in question. \\n + `Sort the student_id array` stated according to collected points of every student\\n + Return the `Resized`student_id array to k \\n\\n# C++    \\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& r, vector<int>& student_id, int k) {\\n        unordered_set<string> ps(begin(pf), end(pf));\\n        unordered_set<string> ng(begin(nf), end(nf));\\n        unordered_map<int, int> mp;\\n        mp.reserve(size(student_id));\\n        \\n        for(int i = 0;i < size(r); ++i){\\n            int sz = r[i].size(), id = student_id[i];\\n            \\n            //traverse through i\\'th string\\n            for(int j = 0; j < sz; j++){\\n                string p;\\n                while(j < sz && r[i][j] != 32) p+= r[i][j], j++;\\n                \\n                //check if positive or negative\\n                if(ps.count(p)) mp[id]+=3;\\n                if(ng.count(p)) mp[id]--;\\n            }\\n        }\\n        \\n        partial_sort(begin(student_id), begin(student_id) + k, end(student_id), [&](auto a, auto b){\\n             return mp[a] == mp[b]? a < b : mp[b] < mp[a];\\n        });\\n        \\n        student_id.resize(k);\\n        return student_id;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2946554,
                "title": "c-brute-force-implementation-question",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\nImplementation Question\\n\\n# Code\\n```\\nbool cmp(pair<int,int>a,pair<int,int>b)\\n{\\n    if(a.second==b.second)return a.first<b.first;\\n    return a.second>b.second;\\n}\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& rep, vector<int>& sid, int k) \\n    {\\n        unordered_map<string ,int> p,n;\\n        for(auto e:pf) p[e]++;\\n        for(auto e:nf) n[e]++;\\n        unordered_map<int,int> ans;\\n        for(int i=0;i<rep.size();i++)\\n        {\\n            string line=rep[i];\\n            int score=0;\\n            for(int j=0;j<line.size();j++)\\n            { \\n                string temp=\"\";\\n                while(j<line.size() && line[j]!=\\' \\')\\n                {\\n                    temp+=line[j];\\n                    j++;\\n                }\\n                // cout<<temp<<\" \" <<j<<endl;\\n                if(p.find(temp)!=p.end())score+=3;\\n                if(n.find(temp)!=n.end())score-=1;\\n            }\\n            // cout<<i<<\" \"<<score<<endl;\\n            ans[sid[i]]=score;\\n            \\n        }\\n        vector<pair<int,int>> v;\\n        for(auto e:ans)\\n        {\\n            v.push_back({e.first,e.second});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int> sol;\\n        for(int i=0;i<k;i++)\\n        {\\n            sol.push_back(v[i].first);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool cmp(pair<int,int>a,pair<int,int>b)\\n{\\n    if(a.second==b.second)return a.first<b.first;\\n    return a.second>b.second;\\n}\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& rep, vector<int>& sid, int k) \\n    {\\n        unordered_map<string ,int> p,n;\\n        for(auto e:pf) p[e]++;\\n        for(auto e:nf) n[e]++;\\n        unordered_map<int,int> ans;\\n        for(int i=0;i<rep.size();i++)\\n        {\\n            string line=rep[i];\\n            int score=0;\\n            for(int j=0;j<line.size();j++)\\n            { \\n                string temp=\"\";\\n                while(j<line.size() && line[j]!=\\' \\')\\n                {\\n                    temp+=line[j];\\n                    j++;\\n                }\\n                // cout<<temp<<\" \" <<j<<endl;\\n                if(p.find(temp)!=p.end())score+=3;\\n                if(n.find(temp)!=n.end())score-=1;\\n            }\\n            // cout<<i<<\" \"<<score<<endl;\\n            ans[sid[i]]=score;\\n            \\n        }\\n        vector<pair<int,int>> v;\\n        for(auto e:ans)\\n        {\\n            v.push_back({e.first,e.second});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int> sol;\\n        for(int i=0;i<k;i++)\\n        {\\n            sol.push_back(v[i].first);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946510,
                "title": "java-solution-easy-hashset-sorting",
                "content": "```java\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] id, int k) {\\n        Set<String> pset = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> nset = new HashSet<>(Arrays.asList(negative_feedback));  \\n    \\n        int[][] arr2 = new int[report.length][2];\\n        for(int i=0;i<report.length;i++)\\n        {\\n            String[] arr = report[i].split(\" \");\\n            int score=0;\\n            for(String x:arr)\\n            {\\n                if(pset.contains(x))\\n                    score+=3;\\n                if(nset.contains(x))\\n                    score--;\\n            }\\n            arr2[i][0]=id[i];\\n            arr2[i][1]=score;\\n        }\\n        \\n        Arrays.sort(arr2, (a,b) -> a[1]==b[1]? Integer.compare(a[0],b[0]):Integer.compare(b[1],a[1]));\\n        \\n        List<Integer> list = new ArrayList<>();\\n    \\n        for(int i=0;i<k;i++)\\n            list.add(arr2[i][0]);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] id, int k) {\\n        Set<String> pset = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> nset = new HashSet<>(Arrays.asList(negative_feedback));  \\n    \\n        int[][] arr2 = new int[report.length][2];\\n        for(int i=0;i<report.length;i++)\\n        {\\n            String[] arr = report[i].split(\" \");\\n            int score=0;\\n            for(String x:arr)\\n            {\\n                if(pset.contains(x))\\n                    score+=3;\\n                if(nset.contains(x))\\n                    score--;\\n            }\\n            arr2[i][0]=id[i];\\n            arr2[i][1]=score;\\n        }\\n        \\n        Arrays.sort(arr2, (a,b) -> a[1]==b[1]? Integer.compare(a[0],b[0]):Integer.compare(b[1],a[1]));\\n        \\n        List<Integer> list = new ArrayList<>();\\n    \\n        for(int i=0;i<k;i++)\\n            list.add(arr2[i][0]);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954432,
                "title": "c-all-approaches-sorting-o-nlogn-to-priority-queue-o-nlogk",
                "content": "**Intuition**\\nSimulate the process as it is. Calculate score of every student and sort according to the given criteria. Return top $k$ student IDs.\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - I (HashSet + Sorting) [Accepted]***\\n\\n- To calculate score, we will need to search every word in positive and negative feedback arrays. To do this fast, convert them to HashSet.\\n- Now calculate score of each student and make an array storing scores and IDs, so that we can sort it later.\\n- Sort the array by maximum score, and for equal scores, by minimum ID.\\n- First $k$ student IDs is the final answer.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    int getScore(unordered_set<string>& posf, unordered_set<string>& negf, string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            if (posf.find(word) != posf.end()) {\\n                score += 3;\\n            } else if (negf.find(word) != negf.end()) {\\n                score -= 1;\\n            }\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        unordered_set<string> posf(posFeedback.begin(), posFeedback.end()), negf(negFeedback.begin(), negFeedback.end());\\n        vector<pair<int, int>> students(n);\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            students[i] = {getScore(posf, negf, report[i]), id[i]};\\n        }\\n        // sort with max score and min id\\n        auto comp = [](auto& p1, auto& p2) {\\n            return p1.first != p2.first ? p1.first > p2.first : p1.second < p2.second;\\n        };\\n        sort(students.begin(), students.end(), comp); // O(nlogn)\\n        vector<int> result(k);\\n        for (int i = 0; i < k; i++) { // O(k)\\n            result[i] = students[i].second;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time Complexity: $O(n \\\\log n + n + k) = O(n \\\\log n)$\\n- Space Complexity: $O(n)$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - II (HashSet + Priority Queue) [Accepted]***\\n\\n- If we want only top $k$ students, why do we need to keep all $n$? We can use a Heap (Priority Queue) to store top $k$ students.\\n- When we inserted $student[i]$\\'s $[score, id]$ in heap, there are two possibilites:\\n  - Heap contains not more than $k$ students. That means we have our top $k$ students.\\n  - Heap contains $k+1$ students. We need to remove the student who is last, with rank $k+1$, having minimum score and maximum ID. This student should be on root of heap. Root is the student who is most prone to be removed from top $k$.\\n- Make a heap which behaves like min-heap for score, and for equal scores, max-heap by ID. Calculate score of each student and insert $[score, id]$ in heap.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    int getScore(unordered_set<string>& posf, unordered_set<string>& negf, string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            if (posf.find(word) != posf.end()) {\\n                score += 3;\\n            } else if (negf.find(word) != negf.end()) {\\n                score -= 1;\\n            }\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        unordered_set<string> posf(posFeedback.begin(), posFeedback.end()), negf(negFeedback.begin(), negFeedback.end());\\n        // priority with min score and max id\\n        auto comp = [](auto& p1, auto& p2) {\\n            return p1.first != p2.first ? p1.first > p2.first : p1.second < p2.second;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> topk(comp);\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            topk.push({getScore(posf, negf, report[i]), id[i]}); // O(logk)\\n            if (i >= k) { // k + 1 students in heap\\n                topk.pop(); // O(logk)\\n            }\\n        }\\n        vector<int> result(k);\\n        for (int i = k - 1; i >= 0; i--) { // O(k)\\n            result[i] = topk.top().second;\\n            topk.pop(); // O(logk)\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Complexity**\\nSince at any point of time, heap does not contain more than $k+1$ elements, the time complexity of $enqueue$ and $dequeue$ operations are $O(\\\\log k)$.\\n- Time Complexity: $O(n \\\\log k + k \\\\log k) = O(n \\\\log k)$\\n- Space Complexity: $O(k)$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - III (HashMap + Priority Queue) [Accepted]***\\n\\n- Another similar approach that I saw in posts is that we can create a common feedback HashMap of positive and negative feedbacks, instead of treating their HashSets separately. HashMap will be of type $[key, value] = [word, score]$ pairs where score is $+3$ for each word in positive feedback array and $-1$ for each word in negative feedback array.\\n- Complexities remains same but some people may find this more intuitive.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> feedback;\\n\\n    void fillFeedback(vector<string>& posf, vector<string>& negf, int pscore, int nscore) {\\n        for (string& f: posf) {\\n            feedback[f] = pscore;\\n        }\\n        for (string& f: negf) {\\n            feedback[f] = nscore;\\n        }\\n    }\\n\\n    int getScore(string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            score += feedback.find(word) != feedback.end() ? feedback[word] : 0;\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        fillFeedback(posFeedback, negFeedback, 3, -1);\\n        // priority with min score and max id\\n        auto comp = [](auto& p1, auto& p2) {\\n            return p1.first != p2.first ? p1.first > p2.first : p1.second < p2.second;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> topk(comp);\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            topk.push({getScore(report[i]), id[i]}); // O(logk)\\n            if (i >= k) { // k + 1 students in heap\\n                topk.pop(); // O(logk)\\n            }\\n        }\\n        vector<int> result(k);\\n        for (int i = k - 1; i >= 0; i--) { // O(k)\\n            result[i] = topk.top().second;\\n            topk.pop(); // O(logk)\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time Complexity: $O(n \\\\log k)$\\n- Space Complexity: $O(k)$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - IV (HashMap + Priority Queue) [Accepted]***\\n\\n- Library helper functions are always highly faster and preferred over custom functions. Custom comparator that we had to make to compare by score and ID is one such example.\\n- The containers or abstract data types like arrays and pairs, are compared with each other on the basis of lexicographical order. The answer whether $arr_1 < arr_2$ is defined by whether $arr_1[0] < arr_2[0]$. If they are equal, second elements are compared and so on.\\n- The custom comparator used in priority queue can be avoided by smartly making the max heap with $[-score, ID]$ or a min heap with $[score, -ID]$.\\n- First, the scores will be compared in max heap. Since they are negatively stored, the minimum score will be on top. And when scores are equal, maximum ID will be on top.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> feedback;\\n\\n    void fillFeedback(vector<string>& posf, vector<string>& negf, int pscore, int nscore) {\\n        for (string& f: posf) {\\n            feedback[f] = pscore;\\n        }\\n        for (string& f: negf) {\\n            feedback[f] = nscore;\\n        }\\n    }\\n\\n    int getScore(string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            score += feedback.find(word) != feedback.end() ? feedback[word] : 0;\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        fillFeedback(posFeedback, negFeedback, 3, -1);\\n        // priority with min score and max id\\n        priority_queue<pair<int, int>> topk;\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            topk.push({-getScore(report[i]), id[i]}); // O(logk)\\n            if (i >= k) { // k + 1 students in heap\\n                topk.pop(); // O(logk)\\n            }\\n        }\\n        vector<int> result(k);\\n        for (int i = k - 1; i >= 0; i--) { // O(k)\\n            result[i] = topk.top().second;\\n            topk.pop(); // O(logk)\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time Complexity: $O(n \\\\log k)$\\n- Space Complexity: $O(k)$\\n\\n---\\n\\nFor any mistakes / suggestions / questions, please do comment below \\uD83D\\uDC47\\nUpvote if helps!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getScore(unordered_set<string>& posf, unordered_set<string>& negf, string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            if (posf.find(word) != posf.end()) {\\n                score += 3;\\n            } else if (negf.find(word) != negf.end()) {\\n                score -= 1;\\n            }\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        unordered_set<string> posf(posFeedback.begin(), posFeedback.end()), negf(negFeedback.begin(), negFeedback.end());\\n        vector<pair<int, int>> students(n);\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            students[i] = {getScore(posf, negf, report[i]), id[i]};\\n        }\\n        // sort with max score and min id\\n        auto comp = [](auto& p1, auto& p2) {\\n            return p1.first != p2.first ? p1.first > p2.first : p1.second < p2.second;\\n        };\\n        sort(students.begin(), students.end(), comp); // O(nlogn)\\n        vector<int> result(k);\\n        for (int i = 0; i < k; i++) { // O(k)\\n            result[i] = students[i].second;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int getScore(unordered_set<string>& posf, unordered_set<string>& negf, string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            if (posf.find(word) != posf.end()) {\\n                score += 3;\\n            } else if (negf.find(word) != negf.end()) {\\n                score -= 1;\\n            }\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        unordered_set<string> posf(posFeedback.begin(), posFeedback.end()), negf(negFeedback.begin(), negFeedback.end());\\n        // priority with min score and max id\\n        auto comp = [](auto& p1, auto& p2) {\\n            return p1.first != p2.first ? p1.first > p2.first : p1.second < p2.second;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> topk(comp);\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            topk.push({getScore(posf, negf, report[i]), id[i]}); // O(logk)\\n            if (i >= k) { // k + 1 students in heap\\n                topk.pop(); // O(logk)\\n            }\\n        }\\n        vector<int> result(k);\\n        for (int i = k - 1; i >= 0; i--) { // O(k)\\n            result[i] = topk.top().second;\\n            topk.pop(); // O(logk)\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> feedback;\\n\\n    void fillFeedback(vector<string>& posf, vector<string>& negf, int pscore, int nscore) {\\n        for (string& f: posf) {\\n            feedback[f] = pscore;\\n        }\\n        for (string& f: negf) {\\n            feedback[f] = nscore;\\n        }\\n    }\\n\\n    int getScore(string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            score += feedback.find(word) != feedback.end() ? feedback[word] : 0;\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        fillFeedback(posFeedback, negFeedback, 3, -1);\\n        // priority with min score and max id\\n        auto comp = [](auto& p1, auto& p2) {\\n            return p1.first != p2.first ? p1.first > p2.first : p1.second < p2.second;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> topk(comp);\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            topk.push({getScore(report[i]), id[i]}); // O(logk)\\n            if (i >= k) { // k + 1 students in heap\\n                topk.pop(); // O(logk)\\n            }\\n        }\\n        vector<int> result(k);\\n        for (int i = k - 1; i >= 0; i--) { // O(k)\\n            result[i] = topk.top().second;\\n            topk.pop(); // O(logk)\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, int> feedback;\\n\\n    void fillFeedback(vector<string>& posf, vector<string>& negf, int pscore, int nscore) {\\n        for (string& f: posf) {\\n            feedback[f] = pscore;\\n        }\\n        for (string& f: negf) {\\n            feedback[f] = nscore;\\n        }\\n    }\\n\\n    int getScore(string& report) {\\n        int score = 0;\\n        string word;\\n        istringstream ss(report);\\n        while (ss >> word) {\\n            score += feedback.find(word) != feedback.end() ? feedback[word] : 0;\\n        }\\n        return score;\\n    }\\n\\npublic:\\n    vector<int> topStudents(vector<string>& posFeedback, vector<string>& negFeedback, vector<string>& report, vector<int>& id, int k) {\\n        int n = report.size();\\n        fillFeedback(posFeedback, negFeedback, 3, -1);\\n        // priority with min score and max id\\n        priority_queue<pair<int, int>> topk;\\n        // calculate score\\n        for (int i = 0; i < n; i++) { // O(n)\\n            topk.push({-getScore(report[i]), id[i]}); // O(logk)\\n            if (i >= k) { // k + 1 students in heap\\n                topk.pop(); // O(logk)\\n            }\\n        }\\n        vector<int> result(k);\\n        for (int i = k - 1; i >= 0; i--) { // O(k)\\n            result[i] = topk.top().second;\\n            topk.pop(); // O(logk)\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946668,
                "title": "c-using-unordered-map-short-crispe-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        vector<pair<int ,int>>stu;\\n        unordered_map<string , int>mpf , mnf;\\n        for(int i=0;i<pf.size();i++) mpf[pf[i]]=3;\\n        for(int i=0;i<nf.size();i++) mnf[nf[i]]=-1;\\n        for(int i=0;i<n;i++){\\n            \\n            stringstream ss(report[i]);\\n            string word;\\n            int count=0;\\n            \\n            while (ss >> word){\\n                count+=(mpf[word]+mnf[word]);\\n            }\\n            stu.push_back({-count , student_id[i]});\\n            \\n        }\\n        sort(stu.begin() , stu.end());\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(stu[i].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        vector<pair<int ,int>>stu;\\n        unordered_map<string , int>mpf , mnf;\\n        for(int i=0;i<pf.size();i++) mpf[pf[i]]=3;\\n        for(int i=0;i<nf.size();i++) mnf[nf[i]]=-1;\\n        for(int i=0;i<n;i++){\\n            \\n            stringstream ss(report[i]);\\n            string word;\\n            int count=0;\\n            \\n            while (ss >> word){\\n                count+=(mpf[word]+mnf[word]);\\n            }\\n            stu.push_back({-count , student_id[i]});\\n            \\n        }\\n        sort(stu.begin() , stu.end());\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(stu[i].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946486,
                "title": "c-explanation-hash-map-sorting",
                "content": "\\n\\n**If you helped please upvote...**\\n1. Time Complexity - O(N*Log(N)), N = no of students ids\\n2. Space Complexity - O(P + K) p = positive feedback, k = negative feedback\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int> pos; // all positive words\\n        unordered_map<string, int> neg; // all negative words\\n        \\n        for(auto &s : positive_feedback) pos[s]++;\\n        for(auto &s : negative_feedback) neg[s]++;\\n        \\n        unordered_map<int, int> points;\\n        \\n        for(int i = 0; i < report.size(); i++) {\\n            stringstream ss(report[i]);\\n            string str;\\n            int p = 0, n = 0;  // p = number of positive words in report[i] , n = number of negative words in report[i]\\n            \\n            while(getline(ss, str, \\' \\')) {\\n                if(pos.count(str)) p++;  // count number of positive words in report[i]\\n                if(neg.count(str)) n++;  // count number of negative words in report[i]\\n            }\\n            \\n            if(p) points[student_id[i]] += 3*p;   // count points, positive points get 3 point\\n            if(n) points[student_id[i]] -= 1*n;   // count points, negative points substract 1 point\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for(auto [id, point]  : points) \\n            v.push_back({point, id});\\n        \\n        \\n        sort(v.begin(), v.end(), [&](auto& a, auto& b) {\\n            if(a.first != b.first) return a.first > b.first;\\n            else if(a.first == b.first) return a.second < b.second;\\n            return true;\\n        });\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) ans.push_back(v[i].second);\\n        \\n        return ans;\\n    }\\n};\\n```\\n# Updated Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int> feedback; // all positive & negative feedbacks\\n        \\n        for(auto &s : positive_feedback) feedback[s] = 3; // positive feedback +3 points\\n        for(auto &s : negative_feedback) feedback[s] = -1; // negative feedback -1 points\\n        \\n        unordered_map<int, int> points;\\n        \\n        for(int i = 0; i < report.size(); i++) {\\n            stringstream ss(report[i]);\\n            string str;\\n            int point = 0; \\n            while(ss >> str) if(feedback.count(str)) point += feedback[str];  \\n            points[student_id[i]] = point;\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for(auto [id, point]  : points) \\n            v.push_back({point, id});\\n        \\n        \\n        sort(v.begin(), v.end(), [&](auto& a, auto& b) {\\n            return a.first > b.first || a.first == b.first && a.second < b.second;\\n        });\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int> pos; // all positive words\\n        unordered_map<string, int> neg; // all negative words\\n        \\n        for(auto &s : positive_feedback) pos[s]++;\\n        for(auto &s : negative_feedback) neg[s]++;\\n        \\n        unordered_map<int, int> points;\\n        \\n        for(int i = 0; i < report.size(); i++) {\\n            stringstream ss(report[i]);\\n            string str;\\n            int p = 0, n = 0;  // p = number of positive words in report[i] , n = number of negative words in report[i]\\n            \\n            while(getline(ss, str, \\' \\')) {\\n                if(pos.count(str)) p++;  // count number of positive words in report[i]\\n                if(neg.count(str)) n++;  // count number of negative words in report[i]\\n            }\\n            \\n            if(p) points[student_id[i]] += 3*p;   // count points, positive points get 3 point\\n            if(n) points[student_id[i]] -= 1*n;   // count points, negative points substract 1 point\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for(auto [id, point]  : points) \\n            v.push_back({point, id});\\n        \\n        \\n        sort(v.begin(), v.end(), [&](auto& a, auto& b) {\\n            if(a.first != b.first) return a.first > b.first;\\n            else if(a.first == b.first) return a.second < b.second;\\n            return true;\\n        });\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) ans.push_back(v[i].second);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int> feedback; // all positive & negative feedbacks\\n        \\n        for(auto &s : positive_feedback) feedback[s] = 3; // positive feedback +3 points\\n        for(auto &s : negative_feedback) feedback[s] = -1; // negative feedback -1 points\\n        \\n        unordered_map<int, int> points;\\n        \\n        for(int i = 0; i < report.size(); i++) {\\n            stringstream ss(report[i]);\\n            string str;\\n            int point = 0; \\n            while(ss >> str) if(feedback.count(str)) point += feedback[str];  \\n            points[student_id[i]] = point;\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for(auto [id, point]  : points) \\n            v.push_back({point, id});\\n        \\n        \\n        sort(v.begin(), v.end(), [&](auto& a, auto& b) {\\n            return a.first > b.first || a.first == b.first && a.second < b.second;\\n        });\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036829,
                "title": "simple-c-with-explanation-sorting-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check for each report how many positive feedbacks are there (add 3 for that) and check how many negative feedbacks are there (-1 for that ). \\nFor each id the store count after checking the sum of + feedback and - feedback. After this sort them in decreasing  order with keeping their id intact by using vector pair and then just return a vector with first k ids\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo its just a implementation Question we just need to check reports if there is a word of + feedback count+=3 or count-- for -ve feedback.\\nSo just take two maps and insert feedback words in them and check the words in reports array  (by checking the space in sentence to get a word).\\n# Complexity\\n- Time complexity:O(n*reports[i].size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere n is size of reports array i.e reports.size();\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& rep, vector<int>& id, int k) {\\n        map<string,int>mp1,mp2;\\n        for(auto x:pos)mp1[x]++;\\n        for(auto x:neg)mp2[x]++;\\n        int n=id.size();\\n        vector<pair<int,int>>vp;\\n        for(int i=0;i<n;i++){\\n            string x=rep[i];\\n            string temp;\\n            int c=0;\\n            for(int i=0;i<x.size();i++){\\n                if(x[i]==\\' \\'){\\n                    if(mp1.find(temp)!=mp1.end())c+=3;\\n                    if(mp2.find(temp)!=mp2.end())c--;\\n                    temp=\"\";\\n                }\\n                else\\n                temp+=x[i];\\n            }\\n            if(mp1.find(temp)!=mp1.end())c+=3;\\n            if(mp2.find(temp)!=mp2.end())c--;\\n            vp.push_back({c,id[i]});\\n        }\\n        sort(vp.begin(),vp.end(),[](pair<int,int>&a,pair<int,int>&b){\\n            return (a.first==b.first)?a.second<b.second:a.first>b.first;\\n        });\\n        vector<int>ans;\\n        for(auto x:vp){\\n            if(k>0)\\n            ans.push_back(x.second),k--;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& rep, vector<int>& id, int k) {\\n        map<string,int>mp1,mp2;\\n        for(auto x:pos)mp1[x]++;\\n        for(auto x:neg)mp2[x]++;\\n        int n=id.size();\\n        vector<pair<int,int>>vp;\\n        for(int i=0;i<n;i++){\\n            string x=rep[i];\\n            string temp;\\n            int c=0;\\n            for(int i=0;i<x.size();i++){\\n                if(x[i]==\\' \\'){\\n                    if(mp1.find(temp)!=mp1.end())c+=3;\\n                    if(mp2.find(temp)!=mp2.end())c--;\\n                    temp=\"\";\\n                }\\n                else\\n                temp+=x[i];\\n            }\\n            if(mp1.find(temp)!=mp1.end())c+=3;\\n            if(mp2.find(temp)!=mp2.end())c--;\\n            vp.push_back({c,id[i]});\\n        }\\n        sort(vp.begin(),vp.end(),[](pair<int,int>&a,pair<int,int>&b){\\n            return (a.first==b.first)?a.second<b.second:a.first>b.first;\\n        });\\n        vector<int>ans;\\n        for(auto x:vp){\\n            if(k>0)\\n            ans.push_back(x.second),k--;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946667,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Using Map and Comparator Sort\\n\\n# Code\\n```\\nbool cmp(pair<int,int> a, pair<int,int> b) {\\n    // Reverse Sort by 2nd, 1st Sorted\\n    if(a.second == b.second) return a.first < b.first;\\n    return a.second > b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = student_id.size();\\n        unordered_map<string, int> pos, neg;\\n        for(auto x: positive_feedback) pos[x] = 1;\\n        for(auto x: negative_feedback) neg[x] = 1;\\n        unordered_map<int, int> points;\\n        for(auto x: student_id) points[x] = 0;\\n        for(int i=0; i<report.size(); i++) {\\n            string st = report[i];\\n            st.push_back(\\' \\');\\n            string s;\\n            for(auto c: st) {\\n                if(c == \\' \\') {\\n                    if(pos[s]) points[student_id[i]] += 3;\\n                    else if(neg[s]) points[student_id[i]] -= 1;\\n                    s.clear();\\n                }\\n                else s.push_back(c);\\n            }\\n        }\\n        vector<pair<int,int>> v;\\n        for(auto x: points) v.push_back({x.first, x.second});\\n        sort(v.begin(),v.end(), cmp);\\n        vector<int> ans;\\n        for(int i=0; i<k; i++) {\\n            ans.push_back(v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool cmp(pair<int,int> a, pair<int,int> b) {\\n    // Reverse Sort by 2nd, 1st Sorted\\n    if(a.second == b.second) return a.first < b.first;\\n    return a.second > b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = student_id.size();\\n        unordered_map<string, int> pos, neg;\\n        for(auto x: positive_feedback) pos[x] = 1;\\n        for(auto x: negative_feedback) neg[x] = 1;\\n        unordered_map<int, int> points;\\n        for(auto x: student_id) points[x] = 0;\\n        for(int i=0; i<report.size(); i++) {\\n            string st = report[i];\\n            st.push_back(\\' \\');\\n            string s;\\n            for(auto c: st) {\\n                if(c == \\' \\') {\\n                    if(pos[s]) points[student_id[i]] += 3;\\n                    else if(neg[s]) points[student_id[i]] -= 1;\\n                    s.clear();\\n                }\\n                else s.push_back(c);\\n            }\\n        }\\n        vector<pair<int,int>> v;\\n        for(auto x: points) v.push_back({x.first, x.second});\\n        sort(v.begin(),v.end(), cmp);\\n        vector<int> ans;\\n        for(int i=0; i<k; i++) {\\n            ans.push_back(v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946611,
                "title": "c-brute-force",
                "content": "``` \\nstatic bool compi(pair<int,int> x, pair<int,int> y){\\n    \\n        if(x.first == y.first){\\n            return x.second < y.second;\\n        }\\n        else{\\n            return x.first > y.first;\\n        }\\n    }\\n\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        \\n        unordered_map<string,int> hash;\\n        \\n        for(int i = 0 ; i < positive_feedback.size() ; i++){\\n            hash[positive_feedback[i]] = 3;\\n        }\\n        \\n        for(int i = 0 ; i < negative_feedback.size(); i++){\\n            hash[negative_feedback[i]] = -1;\\n        }\\n        \\n       \\n        vector<pair<int,int>> x;\\n        \\n        for(int i = 0 ; i < report.size(); i++){\\n            string now = report[i];\\n            \\n            int marks = 0;\\n            \\n            string temp = \"\";\\n            for(int ind = 0 ; ind < now.size() ; ind++){\\n                if(now[ind] == \\' \\'){\\n                    marks += hash[temp];\\n                    \\n                    temp = \"\";\\n                }\\n                \\n                else{\\n                    temp += now[ind];\\n                }\\n            }\\n            \\n            marks += hash[temp];\\n            \\n            temp = \"\";\\n            \\n            x.push_back({marks,student_id[i]});\\n        }\\n        \\n        sort(x.begin(),x.end(),compi);\\n        vector<int> ans;\\n        \\n        int i = 0;\\n        while(k > 0){\\n            ans.push_back(x[i++].second);\\n        \\n            k--;\\n        }\\n\\t\\t\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        \\n        unordered_map<string,int> hash;\\n        \\n        for(int i = 0 ; i < positive_feedback.size() ; i++){\\n            hash[positive_feedback[i]] = 3;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3042728,
                "title": "c-solution-using-priority-queue-with-comments-for-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& id, int k) {\\n        unordered_set<string>pos,neg;\\n        for(auto &x:positive_feedback)pos.insert(x);\\n        for(auto &x:negative_feedback)neg.insert(x);\\n        \\n        priority_queue<pair<int,int>> pq;  //to store point and id\\n        \\n        for(int i=0;i<id.size();i++){  //for every student according to their ids\\n            int currId= id[i];\\n            int score=0;\\n            \\n            stringstream s(report[i]);  //calculating their score by compairing words present in report\\n            string temp;\\n            while(s>>temp){\\n                if(pos.count(temp)) score+= 3;  //if a word if positive feedback\\n                else if(neg.count(temp)) score--;  //if a word if positive feedback\\n            }\\n            \\n            pq.push({score,-currId});  //score and -id is stored in pq so that if score is equal pq is sorted according to id\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(k--){\\n            ans.push_back(-pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& id, int k) {\\n        unordered_set<string>pos,neg;\\n        for(auto &x:positive_feedback)pos.insert(x);\\n        for(auto &x:negative_feedback)neg.insert(x);\\n        \\n        priority_queue<pair<int,int>> pq;  //to store point and id\\n        \\n        for(int i=0;i<id.size();i++){  //for every student according to their ids\\n            int currId= id[i];\\n            int score=0;\\n            \\n            stringstream s(report[i]);  //calculating their score by compairing words present in report\\n            string temp;\\n            while(s>>temp){\\n                if(pos.count(temp)) score+= 3;  //if a word if positive feedback\\n                else if(neg.count(temp)) score--;  //if a word if positive feedback\\n            }\\n            \\n            pq.push({score,-currId});  //score and -id is stored in pq so that if score is equal pq is sorted according to id\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(k--){\\n            ans.push_back(-pq.top().second);\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973623,
                "title": "python-3-4-lines-nsmallest-t-m-82-70",
                "content": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n\\n        d = [0]*len(student_id)\\n\\n        pSet,nSet = set(positive_feedback), set(negative_feedback)\\n\\n        for i,s in enumerate(report):\\n            for w in s.split(): d[i]+= 3*(w in pSet)-(w in nSet)\\n\\n        return [id for _i, id in \\n                nsmallest(k, enumerate(student_id), \\n                key = lambda x: (-d[x[0]],x[1]))]\\n```\\n[https://leetcode.com/problems/reward-top-k-students/submissions/868361920/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n\\n        d = [0]*len(student_id)\\n\\n        pSet,nSet = set(positive_feedback), set(negative_feedback)\\n\\n        for i,s in enumerate(report):\\n            for w in s.split(): d[i]+= 3*(w in pSet)-(w in nSet)\\n\\n        return [id for _i, id in \\n                nsmallest(k, enumerate(student_id), \\n                key = lambda x: (-d[x[0]],x[1]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946670,
                "title": "python-code-with-proper-comments-and-approach-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the both positive and negative feedback to a set for faster accessing i.e. in O(1) time.\\n2. Then iterating in every string of the report list and calculating the points and store the points in the dictionary.\\n3. Sort the dictionary in decreasing order of points but also in the increasing order of student_id\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$  for using dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        # converting the both positive_feedback and negative_feedback for fast accessing.\\n        pos= set(positive_feedback)\\n        neg= set(negative_feedback)\\n        d={}   #dictionary to store every student points \\n\\n\\n        for i in range(len(report)):\\n            pts=0\\n            lst=report[i].split()\\n            for j in lst:\\n                if j in pos:    # if positive feedback\\n                    pts+=3\\n                if j in neg:    # if negative feedback\\n                    pts-=1\\n            d[student_id[i]]=pts  #storing the final points\\n        \\n        #sorting the dictionary accoring to max points\\n        final_lst=list(sorted(d.items(),key=lambda x : (x[-1],-x[0]),reverse=True))   \\n        ans=[]  #to store final answer\\n        for i in range(k):\\n            ans.append(final_lst[i][0])\\n        return ans\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        # converting the both positive_feedback and negative_feedback for fast accessing.\\n        pos= set(positive_feedback)\\n        neg= set(negative_feedback)\\n        d={}   #dictionary to store every student points \\n\\n\\n        for i in range(len(report)):\\n            pts=0\\n            lst=report[i].split()\\n            for j in lst:\\n                if j in pos:    # if positive feedback\\n                    pts+=3\\n                if j in neg:    # if negative feedback\\n                    pts-=1\\n            d[student_id[i]]=pts  #storing the final points\\n        \\n        #sorting the dictionary accoring to max points\\n        final_lst=list(sorted(d.items(),key=lambda x : (x[-1],-x[0]),reverse=True))   \\n        ans=[]  #to store final answer\\n        for i in range(k):\\n            ans.append(final_lst[i][0])\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946485,
                "title": "easy-java-solution-sorting",
                "content": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        Set<String> pos = new HashSet<>(List.of(positive_feedback));\\n        Set<String> neg = new HashSet<>(List.of(negative_feedback));\\n        int n = report.length;\\n        int[][] rank = new int[n][2];\\n        // System.out.println(n);\\n        for (int i = 0; i < n; i++) {\\n            String rep = report[i];\\n            rank[i][0]=student_id[i];\\n            String[] strs=rep.split(\" \");\\n            for(String s:strs){\\n                if(pos.contains(s)){\\n                    rank[i][1]+=3;\\n                }\\n                if(neg.contains(s)){\\n                    rank[i][1]-=1;\\n                }\\n            }\\n        }\\n        Arrays.sort(rank,(a,b)->{\\n            if(a[1]==b[1]){\\n                return a[0]-b[0];\\n            }\\n            return b[1]-a[1];\\n        });\\n\\n        for(int i=0;i<k;i++){\\n            res.add(rank[i][0]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        Set<String> pos = new HashSet<>(List.of(positive_feedback));\\n        Set<String> neg = new HashSet<>(List.of(negative_feedback));\\n        int n = report.length;\\n        int[][] rank = new int[n][2];\\n        // System.out.println(n);\\n        for (int i = 0; i < n; i++) {\\n            String rep = report[i];\\n            rank[i][0]=student_id[i];\\n            String[] strs=rep.split(\" \");\\n            for(String s:strs){\\n                if(pos.contains(s)){\\n                    rank[i][1]+=3;\\n                }\\n                if(neg.contains(s)){\\n                    rank[i][1]-=1;\\n                }\\n            }\\n        }\\n        Arrays.sort(rank,(a,b)->{\\n            if(a[1]==b[1]){\\n                return a[0]-b[0];\\n            }\\n            return b[1]-a[1];\\n        });\\n\\n        for(int i=0;i<k;i++){\\n            res.add(rank[i][0]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912675,
                "title": "c-easy-to-understand-using-vector-map-and-custom-sorting",
                "content": "Do UPVOTE If you find this useful\\n\\n# Complexity\\n- Time complexity: I think O(M*N)  will dominant on  sorting step  O(M*logM)\\n\\nIn worst case take M = 10000 and N = 100\\n\\n1. M*N due to nested for Loops = 10000 * 100 = 10^6\\n\\n2.  M * log M   =  10000 * log(10000) = 10000 * log(10^4) = 10000 * 4 = 4 * 10^4\\n\\nThus 10^6  >> 4*10^4\\n\\nSo T.C. = M*N   M size of arr  N size Size of report[0]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Somewhat O(M + 2*N + k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string,int> pos_feed, neg_feed;\\n        \\n        for(auto it : positive_feedback)\\n            pos_feed[it]++;\\n        for(auto it : negative_feedback)\\n            neg_feed[it]++;\\n        \\n        vector<vector<int>> store;\\n        \\n        for(int i = 0; i<student_id.size(); i++){\\n            report[i] += \\' \\';\\n            string s = \"\";\\n            int cnt = 0;\\n            for(int j = 0; j<report[i].size(); j++){\\n                if(report[i][j] == \\' \\'){\\n                    if(pos_feed.find(s) != pos_feed.end()){\\n                        cnt += 3;\\n                    }\\n                    else if(neg_feed.find(s) != neg_feed.end()){\\n                        cnt -= 1;\\n                    }\\n                    \\n                    s = \"\";\\n                }\\n                else{\\n                    s += report[i][j];\\n                }\\n            }\\n            \\n            store.push_back({cnt,student_id[i]});\\n        }\\n        \\n        sort(store.begin(),store.end(), [](const vector<int>& a, const vector<int>& b){\\n            if(a[0] > b[0])\\n                return true;\\n            else if(a[0] == b[0])\\n                return a[1] < b[1];\\n            return false;\\n        });\\n        \\n        vector<int> res(k);\\n        for(int i = 0; i<k; i++)\\n            res[i] = store[i][1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string,int> pos_feed, neg_feed;\\n        \\n        for(auto it : positive_feedback)\\n            pos_feed[it]++;\\n        for(auto it : negative_feedback)\\n            neg_feed[it]++;\\n        \\n        vector<vector<int>> store;\\n        \\n        for(int i = 0; i<student_id.size(); i++){\\n            report[i] += \\' \\';\\n            string s = \"\";\\n            int cnt = 0;\\n            for(int j = 0; j<report[i].size(); j++){\\n                if(report[i][j] == \\' \\'){\\n                    if(pos_feed.find(s) != pos_feed.end()){\\n                        cnt += 3;\\n                    }\\n                    else if(neg_feed.find(s) != neg_feed.end()){\\n                        cnt -= 1;\\n                    }\\n                    \\n                    s = \"\";\\n                }\\n                else{\\n                    s += report[i][j];\\n                }\\n            }\\n            \\n            store.push_back({cnt,student_id[i]});\\n        }\\n        \\n        sort(store.begin(),store.end(), [](const vector<int>& a, const vector<int>& b){\\n            if(a[0] > b[0])\\n                return true;\\n            else if(a[0] == b[0])\\n                return a[1] < b[1];\\n            return false;\\n        });\\n        \\n        vector<int> res(k);\\n        for(int i = 0; i<k; i++)\\n            res[i] = store[i][1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956096,
                "title": "bruteforce-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashMap<String,Integer> mp1=new HashMap<>();\\n        HashMap<String,Integer> mp2=new HashMap<>();\\n        for(int i=0;i<positive_feedback.length;i++){\\n            mp1.put(positive_feedback[i],3);\\n        }\\n        for(int i=0;i<negative_feedback.length;i++){\\n            mp2.put(negative_feedback[i],-1);\\n        }\\n        PriorityQueue<pair> pq=new PriorityQueue<>(new Comparator<pair>(){\\n            public int compare(pair a, pair b){\\n                if(a.score==b.score){\\n                    return a.id-b.id;\\n                }\\n                return b.score-a.score;\\n            }\\n        });\\n        for(int i=0;i<report.length;i++){\\n            String s=report[i];\\n            String [] arr=s.split(\" \");\\n            int score=0;\\n            for(int j=0;j<arr.length;j++){\\n                if(mp1.containsKey(arr[j])) score+=mp1.get(arr[j]);\\n                if(mp2.containsKey(arr[j])) score+=mp2.get(arr[j]);\\n            }\\n            pq.offer(new pair(student_id[i],score));\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        while(k>0){\\n            ans.add(pq.poll().id);\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\nclass pair{\\n    int id;\\n    int score;\\n    pair(int id,int score){\\n        this.id=id;\\n        this.score=score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashMap<String,Integer> mp1=new HashMap<>();\\n        HashMap<String,Integer> mp2=new HashMap<>();\\n        for(int i=0;i<positive_feedback.length;i++){\\n            mp1.put(positive_feedback[i],3);\\n        }\\n        for(int i=0;i<negative_feedback.length;i++){\\n            mp2.put(negative_feedback[i],-1);\\n        }\\n        PriorityQueue<pair> pq=new PriorityQueue<>(new Comparator<pair>(){\\n            public int compare(pair a, pair b){\\n                if(a.score==b.score){\\n                    return a.id-b.id;\\n                }\\n                return b.score-a.score;\\n            }\\n        });\\n        for(int i=0;i<report.length;i++){\\n            String s=report[i];\\n            String [] arr=s.split(\" \");\\n            int score=0;\\n            for(int j=0;j<arr.length;j++){\\n                if(mp1.containsKey(arr[j])) score+=mp1.get(arr[j]);\\n                if(mp2.containsKey(arr[j])) score+=mp2.get(arr[j]);\\n            }\\n            pq.offer(new pair(student_id[i],score));\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        while(k>0){\\n            ans.add(pq.poll().id);\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\nclass pair{\\n    int id;\\n    int score;\\n    pair(int id,int score){\\n        this.id=id;\\n        this.score=score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947033,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate an hashmap to store the point of each student.\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        ans=collections.defaultdict(int)\\n        positive_feedback_d=defaultdict(int)\\n        negative_feedback_d=defaultdict(int)\\n        for i in positive_feedback:\\n            positive_feedback_d[i]+=1\\n        for i in negative_feedback:\\n            negative_feedback_d[i]+=1\\n        for i in range(len(report)):\\n            for j in report[i].split(\" \"):\\n                if positive_feedback_d[j]>=1:\\n                    ans[student_id[i]]+=3\\n                elif negative_feedback_d[j]>=1:\\n                    ans[student_id[i]]-=1\\n                else:\\n                    continue\\n        temp=[]\\n        sorted_d = (sorted(ans, key=lambda x: (-ans[x], x)))\\n        i=0\\n        for j in sorted_d:\\n            temp.append(j)\\n            i+=1\\n            if i>=k:\\n                break\\n        return(temp)\\n            \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        ans=collections.defaultdict(int)\\n        positive_feedback_d=defaultdict(int)\\n        negative_feedback_d=defaultdict(int)\\n        for i in positive_feedback:\\n            positive_feedback_d[i]+=1\\n        for i in negative_feedback:\\n            negative_feedback_d[i]+=1\\n        for i in range(len(report)):\\n            for j in report[i].split(\" \"):\\n                if positive_feedback_d[j]>=1:\\n                    ans[student_id[i]]+=3\\n                elif negative_feedback_d[j]>=1:\\n                    ans[student_id[i]]-=1\\n                else:\\n                    continue\\n        temp=[]\\n        sorted_d = (sorted(ans, key=lambda x: (-ans[x], x)))\\n        i=0\\n        for j in sorted_d:\\n            temp.append(j)\\n            i+=1\\n            if i>=k:\\n                break\\n        return(temp)\\n            \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947019,
                "title": "easy-and-understandable-code-c",
                "content": "LeetCode Contest Question - 24-12-2022\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct cmp{//custom comparator for set\\n    bool operator()(const pair<int,int> &p1, const pair<int,int> &p2) const{\\n        if(p1.second!=p2.second){\\n            return (p1.second > p2.second);\\n        }\\n   \\n            return p1.first<p2.first;\\n        \\n    }  \\n};\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        set<string> pos(positive_feedback.begin() , positive_feedback.end());\\n        set<string> neg(negative_feedback.begin() , negative_feedback.end());\\n        set<pair<int , int> , cmp> val;\\n        map<int , int> mp;\\n        \\n        for(int i = 0 ; i<report.size() ; i++){\\n            stringstream s(report[i]);\\n            string word;\\n\\n            int sc = 0;\\n            \\n            while (s >> word){\\n                if(neg.find(word) != neg.end()){\\n                    sc -= 1;\\n                }\\n        \\n                else if(pos.find(word) != pos.end()){\\n                    sc += 3;\\n                }\\n            }\\n            \\n            mp[student_id[i]] = sc;\\n      \\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        for(auto it: mp){\\n            val.insert({it.first , it.second});\\n        }\\n        \\n        for(auto it: val){\\n            k--;\\n          ans.push_back(it.first);\\n            if(k == 0) {\\n                break;\\n            }\\n        }\\n        \\n        \\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp{//custom comparator for set\\n    bool operator()(const pair<int,int> &p1, const pair<int,int> &p2) const{\\n        if(p1.second!=p2.second){\\n            return (p1.second > p2.second);\\n        }\\n   \\n            return p1.first<p2.first;\\n        \\n    }  \\n};\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        set<string> pos(positive_feedback.begin() , positive_feedback.end());\\n        set<string> neg(negative_feedback.begin() , negative_feedback.end());\\n        set<pair<int , int> , cmp> val;\\n        map<int , int> mp;\\n        \\n        for(int i = 0 ; i<report.size() ; i++){\\n            stringstream s(report[i]);\\n            string word;\\n\\n            int sc = 0;\\n            \\n            while (s >> word){\\n                if(neg.find(word) != neg.end()){\\n                    sc -= 1;\\n                }\\n        \\n                else if(pos.find(word) != pos.end()){\\n                    sc += 3;\\n                }\\n            }\\n            \\n            mp[student_id[i]] = sc;\\n      \\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        for(auto it: mp){\\n            val.insert({it.first , it.second});\\n        }\\n        \\n        for(auto it: val){\\n            k--;\\n          ans.push_back(it.first);\\n            if(k == 0) {\\n                break;\\n            }\\n        }\\n        \\n        \\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946535,
                "title": "c-java-python3-sorting",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/3ffc910c12ff8c84890fb15351216a0fa85dc3ac) for solutions of biweekly 94. \\n\\n**Intuition**\\nCollect the points for each student and sort for top K. \\n\\n**C++**\\n```\\nclass Solution {\\npublic: \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positive(positive_feedback.begin(), positive_feedback.end()), negative(negative_feedback.begin(), negative_feedback.end()); \\n        unordered_map<int, int> mp; \\n        for (int i = 0; i < report.size(); ++i) {\\n            istringstream iss(report[i]); \\n            string buf; \\n            int point = 0; \\n            while (iss >> buf) \\n                if (positive.count(buf)) point += 3; \\n                else if (negative.count(buf)) --point; \\n            mp[student_id[i]] = point; \\n        }\\n        vector<int> ans; \\n        for (auto& [x, v] : mp) ans.push_back(x); \\n        sort(ans.begin(), ans.end(), [&](auto& lhs, auto& rhs) {\\n            return mp[lhs] > mp[rhs] || (mp[lhs] == mp[rhs] && lhs < rhs); \\n        }); \\n        ans.resize(k); \\n        return ans;\\n    }\\n}; \\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\t\\tSet<String> positive = new HashSet(Arrays.asList(positive_feedback)), negative = new HashSet(Arrays.asList(negative_feedback)); \\n\\t\\tMap<Integer, Integer> mp = new HashMap(); \\n\\t\\tfor (int i = 0; i < report.length; ++i) {\\n\\t\\t\\tString[] words = report[i].split(\" \"); \\n\\t\\t\\tint point = 0; \\n\\t\\t\\tfor (var word : words) {\\n\\t\\t\\t\\tif (positive.contains(word)) point += 3; \\n\\t\\t\\t\\telse if (negative.contains(word)) --point; \\n\\t\\t\\t}\\n\\t\\t\\tmp.put(student_id[i], point); \\n\\t\\t}\\n\\t\\tList<Integer> vals = new ArrayList(); \\n\\t\\tfor (var elem : mp.entrySet()) vals.add(elem.getKey()); \\n\\t\\tCollections.sort(vals, (a, b)->(mp.get(a) != mp.get(b) ? Integer.compare(mp.get(b), mp.get(a)) : Integer.compare(a, b))); \\n\\t\\tList<Integer> ans = new ArrayList(); \\n\\t\\tfor (int i = 0; i < k; ++i) ans.add(vals.get(i)); \\n\\t\\treturn ans; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        mp = {}\\n        for sentence, id in zip(report, student_id): \\n            point = 0 \\n            for word in sentence.split(): \\n                if word in positive_feedback: point += 3\\n                elif word in negative_feedback: point -= 1\\n            mp[id] = point \\n        return sorted(mp, key=lambda x: (-mp[x], x))[:k]\\n```\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positive(positive_feedback.begin(), positive_feedback.end()), negative(negative_feedback.begin(), negative_feedback.end()); \\n        unordered_map<int, int> mp; \\n        for (int i = 0; i < report.size(); ++i) {\\n            istringstream iss(report[i]); \\n            string buf; \\n            int point = 0; \\n            while (iss >> buf) \\n                if (positive.count(buf)) point += 3; \\n                else if (negative.count(buf)) --point; \\n            mp[student_id[i]] = point; \\n        }\\n        vector<int> ans; \\n        for (auto& [x, v] : mp) ans.push_back(x); \\n        sort(ans.begin(), ans.end(), [&](auto& lhs, auto& rhs) {\\n            return mp[lhs] > mp[rhs] || (mp[lhs] == mp[rhs] && lhs < rhs); \\n        }); \\n        ans.resize(k); \\n        return ans;\\n    }\\n}; \\n```\n```\\nclass Solution {\\n\\tpublic List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\t\\tSet<String> positive = new HashSet(Arrays.asList(positive_feedback)), negative = new HashSet(Arrays.asList(negative_feedback)); \\n\\t\\tMap<Integer, Integer> mp = new HashMap(); \\n\\t\\tfor (int i = 0; i < report.length; ++i) {\\n\\t\\t\\tString[] words = report[i].split(\" \"); \\n\\t\\t\\tint point = 0; \\n\\t\\t\\tfor (var word : words) {\\n\\t\\t\\t\\tif (positive.contains(word)) point += 3; \\n\\t\\t\\t\\telse if (negative.contains(word)) --point; \\n\\t\\t\\t}\\n\\t\\t\\tmp.put(student_id[i], point); \\n\\t\\t}\\n\\t\\tList<Integer> vals = new ArrayList(); \\n\\t\\tfor (var elem : mp.entrySet()) vals.add(elem.getKey()); \\n\\t\\tCollections.sort(vals, (a, b)->(mp.get(a) != mp.get(b) ? Integer.compare(mp.get(b), mp.get(a)) : Integer.compare(a, b))); \\n\\t\\tList<Integer> ans = new ArrayList(); \\n\\t\\tfor (int i = 0; i < k; ++i) ans.add(vals.get(i)); \\n\\t\\treturn ans; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        mp = {}\\n        for sentence, id in zip(report, student_id): \\n            point = 0 \\n            for word in sentence.split(): \\n                if word in positive_feedback: point += 3\\n                elif word in negative_feedback: point -= 1\\n            mp[id] = point \\n        return sorted(mp, key=lambda x: (-mp[x], x))[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946517,
                "title": "easy-to-understand-java-hashset-priority-queue",
                "content": "Please upvote if you liked the approach.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Store postive and negative feedback words in HashSet for faster searching => O(1).\\n3. Count points for every student one by ne and add Pair of <student_id, reward_points> in priority queue.\\n4. **Priority Queue stores student with maximum point on top and if points are equal then student with lower student_id on top**\\n5. Finally take out top element from priority queue and add in result list.\\n\\n**Note**\\n1. Priority queue is basically heap on reward point, if points are equal then student id. **It is handled by the compareTo method in Pair class.**\\n2. The set has been used to reduce the search time-complexity while searching for the words in feedback dictionaries.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private class Pair implements Comparable {\\n        public int first;\\n        public int second;\\n        \\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n        \\n        public int compareTo(Object o) {\\n            Pair p = (Pair) o;\\n            if (this.second == p.second) {\\n                return this.first - p.first;\\n            }\\n            return p.second - this.second;\\n        }\\n    }\\n    \\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> pf = new HashSet<>();\\n        for (int i=0; i<positive_feedback.length; i++) {\\n            pf.add(positive_feedback[i]);\\n        }\\n        \\n        Set<String> nf = new HashSet<>();\\n        for (int i=0; i<negative_feedback.length; i++) {\\n            nf.add(negative_feedback[i]);\\n        }\\n        \\n        Queue<Pair> q = new PriorityQueue();\\n        for (int i=0; i<report.length; i++) {\\n            int sum = 0;\\n            String[] remark = report[i].split(\" \");\\n            for (int j=0; j<remark.length; j++) {\\n                if (pf.contains(remark[j])) {\\n                    sum += 3;\\n                } else if (nf.contains(remark[j])) {\\n                    sum -= 1;\\n                }\\n            }\\n            q.add(new Pair(student_id[i], sum));\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        while (!q.isEmpty() && k != 0) {\\n            result.add(q.poll().first);\\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private class Pair implements Comparable {\\n        public int first;\\n        public int second;\\n        \\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n        \\n        public int compareTo(Object o) {\\n            Pair p = (Pair) o;\\n            if (this.second == p.second) {\\n                return this.first - p.first;\\n            }\\n            return p.second - this.second;\\n        }\\n    }\\n    \\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> pf = new HashSet<>();\\n        for (int i=0; i<positive_feedback.length; i++) {\\n            pf.add(positive_feedback[i]);\\n        }\\n        \\n        Set<String> nf = new HashSet<>();\\n        for (int i=0; i<negative_feedback.length; i++) {\\n            nf.add(negative_feedback[i]);\\n        }\\n        \\n        Queue<Pair> q = new PriorityQueue();\\n        for (int i=0; i<report.length; i++) {\\n            int sum = 0;\\n            String[] remark = report[i].split(\" \");\\n            for (int j=0; j<remark.length; j++) {\\n                if (pf.contains(remark[j])) {\\n                    sum += 3;\\n                } else if (nf.contains(remark[j])) {\\n                    sum -= 1;\\n                }\\n            }\\n            q.add(new Pair(student_id[i], sum));\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        while (!q.isEmpty() && k != 0) {\\n            result.add(q.poll().first);\\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433538,
                "title": "c-implementation-using-maps-sets-sorting",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp( pair<int,int>&a, pair<int,int>&b){\\n        // Sorting students based on score (Non-Increasing order)\\n        if(a.first != b.first) return a.first > b.first;\\n\\n        // If two students have same score, sorting based on ID (Increasing order)\\n        else return a.second < b.second;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& posi, vector<string>& nega, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        int n = report.size();\\n\\n        // Using a HashMap to store score of all students\\n        // Using Sets for faster access of positive and negative words\\n        unordered_map <int,int> mp;\\n        unordered_set <string> pos( begin(posi), end(posi) ),neg ( begin(nega), end(nega) );\\n\\n        // Count score of each student and noting it in HashMap\\n        for(int i = 0; i < n; i++){\\n            string rep = report[i];\\n            int id = student_id[i], m = rep.length(), score = 0;\\n            for(int j = 0; j < m; j++){\\n                string tmp;\\n                while(j < m and rep[j] != \\' \\') tmp += rep[j++];\\n                if(pos.count(tmp)) score += 3;\\n                else if(neg.count(tmp)) score --;\\n            }\\n            mp[id] = score;\\n        }\\n\\n        // Sorting students based on the score\\n        vector <pair<int,int>> vp;\\n        for(auto &[k,v] : mp) vp.push_back({v,k});\\n        sort( begin(vp), end(vp) , cmp);\\n        vector<int> res;\\n\\n        // Selecting k best students\\n        for(int i = 0; i < k; i++){\\n            res.push_back(vp[i].second);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$ [ n - Number of reports]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ [ n - Number of reports]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp( pair<int,int>&a, pair<int,int>&b){\\n        // Sorting students based on score (Non-Increasing order)\\n        if(a.first != b.first) return a.first > b.first;\\n\\n        // If two students have same score, sorting based on ID (Increasing order)\\n        else return a.second < b.second;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& posi, vector<string>& nega, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        int n = report.size();\\n\\n        // Using a HashMap to store score of all students\\n        // Using Sets for faster access of positive and negative words\\n        unordered_map <int,int> mp;\\n        unordered_set <string> pos( begin(posi), end(posi) ),neg ( begin(nega), end(nega) );\\n\\n        // Count score of each student and noting it in HashMap\\n        for(int i = 0; i < n; i++){\\n            string rep = report[i];\\n            int id = student_id[i], m = rep.length(), score = 0;\\n            for(int j = 0; j < m; j++){\\n                string tmp;\\n                while(j < m and rep[j] != \\' \\') tmp += rep[j++];\\n                if(pos.count(tmp)) score += 3;\\n                else if(neg.count(tmp)) score --;\\n            }\\n            mp[id] = score;\\n        }\\n\\n        // Sorting students based on the score\\n        vector <pair<int,int>> vp;\\n        for(auto &[k,v] : mp) vp.push_back({v,k});\\n        sort( begin(vp), end(vp) , cmp);\\n        vector<int> res;\\n\\n        // Selecting k best students\\n        for(int i = 0; i < k; i++){\\n            res.push_back(vp[i].second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412450,
                "title": "c-trie-based-easy-to-understand-90-faster",
                "content": "````\\nclass trie{\\n    public:\\n        int score;\\n        trie* v[26];\\n        trie(){\\n            score = 0;\\n            for(int i = 0; i < 26; i++){\\n                v[i] = NULL;\\n            }\\n        }\\n};\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]>b[0];\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        trie* node = new trie(),*tmp;\\n        for(auto &i: positive_feedback){\\n            tmp = node;\\n            for(auto &j: i){\\n                if(tmp->v[j-\\'a\\']==NULL){\\n                    tmp->v[j-\\'a\\'] = new trie();\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }else{\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }\\n            }\\n            tmp->score = 3;\\n        }\\n        for(auto &i: negative_feedback){\\n            tmp = node;\\n            for(auto &j: i){\\n                if(tmp->v[j-\\'a\\']==NULL){\\n                    tmp->v[j-\\'a\\'] = new trie();\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }else{\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }\\n            }\\n            tmp->score = -1;\\n        }\\n        int n = student_id.size(),j,scr = 0,i;\\n        bool a = true;\\n        vector<vector<int>> ans;\\n        for(i = 0; i < n; i++){\\n            scr = 0;\\n            tmp = node;\\n            a = true;\\n            for(j = 0; j <= report[i].length(); j++){\\n                if(j == report[i].length() || report[i][j] == \\' \\'){\\n                    if(a){\\n                        scr += tmp->score;\\n                    }\\n                    // cout<<scr<<\" \";\\n                    tmp = node;\\n                    a = true;\\n                }else{\\n                    if(tmp->v[report[i][j]-\\'a\\'] == NULL){\\n                        a = false;\\n                    }else{\\n                        tmp = tmp->v[report[i][j]-\\'a\\'];\\n                    }\\n                }\\n            }\\n            // cout<<endl;\\n            ans.push_back({scr,student_id[i]});\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        // for(auto &i: ans){\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // }cout<<endl;\\n        vector<int> xx;\\n        for(i = 0; i < k; i++){\\n            xx.push_back(ans[i][1]);\\n        }\\n        return xx;\\n    }\\n};\\n\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "````\\nclass trie{\\n    public:\\n        int score;\\n        trie* v[26];\\n        trie(){\\n            score = 0;\\n            for(int i = 0; i < 26; i++){\\n                v[i] = NULL;\\n            }\\n        }\\n};\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]>b[0];\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        trie* node = new trie(),*tmp;\\n        for(auto &i: positive_feedback){\\n            tmp = node;\\n            for(auto &j: i){\\n                if(tmp->v[j-\\'a\\']==NULL){\\n                    tmp->v[j-\\'a\\'] = new trie();\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }else{\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }\\n            }\\n            tmp->score = 3;\\n        }\\n        for(auto &i: negative_feedback){\\n            tmp = node;\\n            for(auto &j: i){\\n                if(tmp->v[j-\\'a\\']==NULL){\\n                    tmp->v[j-\\'a\\'] = new trie();\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }else{\\n                    tmp = tmp->v[j-\\'a\\'];\\n                }\\n            }\\n            tmp->score = -1;\\n        }\\n        int n = student_id.size(),j,scr = 0,i;\\n        bool a = true;\\n        vector<vector<int>> ans;\\n        for(i = 0; i < n; i++){\\n            scr = 0;\\n            tmp = node;\\n            a = true;\\n            for(j = 0; j <= report[i].length(); j++){\\n                if(j == report[i].length() || report[i][j] == \\' \\'){\\n                    if(a){\\n                        scr += tmp->score;\\n                    }\\n                    // cout<<scr<<\" \";\\n                    tmp = node;\\n                    a = true;\\n                }else{\\n                    if(tmp->v[report[i][j]-\\'a\\'] == NULL){\\n                        a = false;\\n                    }else{\\n                        tmp = tmp->v[report[i][j]-\\'a\\'];\\n                    }\\n                }\\n            }\\n            // cout<<endl;\\n            ans.push_back({scr,student_id[i]});\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        // for(auto &i: ans){\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // }cout<<endl;\\n        vector<int> xx;\\n        for(i = 0; i < k; i++){\\n            xx.push_back(ans[i][1]);\\n        }\\n        return xx;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3364517,
                "title": "easy-to-understand-hashmap-priority-queue",
                "content": "\\n# Approach\\n- We first create a hash map to assign scores to the words in the positive and negative feedback vectors. \\n- We then iterate over each report and calculate the score for each student based on the words in their report and their assigned scores.\\n-  We store the score and student ID in a priority queue in descending order of score. \\n- Finally, we retrieve the top k students from the priority queue and return their IDs.\\n\\nIn the code, student IDs are stored as negative values in the priority queue. This is done to ensure that the IDs are retrieved in ascending order when we retrieve the top k students from the priority queue. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN), where N is the number of reports.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) where N is the number of reports.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // priority queue to store the top k students and their scores in descending order\\n        priority_queue<pair<int, int>> pq;\\n        \\n        // hash map to assign scores to words in the positive and negative feedback vectors\\n        unordered_map<string, int> mp;\\n        for (string s : positive_feedback) mp[s] = 3;\\n        for (string s : negative_feedback) mp[s] = -1;\\n        \\n        // Iterate over each report to calculate the score for each student based on the words in the report and their assigned scores\\n        for (int i = 0; i < report.size(); ++i) {\\n            string word = \"\";\\n            int score = 0;\\n            for (char c : report[i]) {\\n                if (c == \\' \\') {\\n                    if (mp.find(word) != mp.end()) {\\n                        score += mp[word];\\n                    }\\n                    word = \"\";\\n                } else {\\n                    word += c;\\n                }\\n            }\\n            if (mp.find(word) != mp.end()) {\\n                score += mp[word];\\n            }\\n            pq.push({score, -student_id[i]});\\n        }\\n        \\n        // Retrieve the top k students from the priority queue\\n        vector<int> top_students;\\n        while (k--) {\\n            pair<int, int> st = pq.top();\\n            pq.pop();\\n            top_students.push_back(-st.second);\\n        }\\n\\n        return top_students;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // priority queue to store the top k students and their scores in descending order\\n        priority_queue<pair<int, int>> pq;\\n        \\n        // hash map to assign scores to words in the positive and negative feedback vectors\\n        unordered_map<string, int> mp;\\n        for (string s : positive_feedback) mp[s] = 3;\\n        for (string s : negative_feedback) mp[s] = -1;\\n        \\n        // Iterate over each report to calculate the score for each student based on the words in the report and their assigned scores\\n        for (int i = 0; i < report.size(); ++i) {\\n            string word = \"\";\\n            int score = 0;\\n            for (char c : report[i]) {\\n                if (c == \\' \\') {\\n                    if (mp.find(word) != mp.end()) {\\n                        score += mp[word];\\n                    }\\n                    word = \"\";\\n                } else {\\n                    word += c;\\n                }\\n            }\\n            if (mp.find(word) != mp.end()) {\\n                score += mp[word];\\n            }\\n            pq.push({score, -student_id[i]});\\n        }\\n        \\n        // Retrieve the top k students from the priority queue\\n        vector<int> top_students;\\n        while (k--) {\\n            pair<int, int> st = pq.top();\\n            pq.pop();\\n            top_students.push_back(-st.second);\\n        }\\n\\n        return top_students;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127352,
                "title": "c-solution-set-priority-queue",
                "content": "# Code\\n```\\n#define pi pair<int,int>\\nstruct comp\\n{\\n  bool operator()(pi &p1, pi &p2)\\n  {\\n      if(p1.first==p2.first)\\n        return p1.second>p2.second;\\n      return p1.first<p2.first;\\n  }    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // to store the feedback words according to nature for efficient search\\n            unordered_set<string>positive; // SC: O(n1)\\n            unordered_set<string>negative; // SC: O(n2)\\n\\n        for(auto it: positive_feedback) // TC: O(n1)\\n          positive.insert(it);\\n        \\n        for(auto it: negative_feedback) // TC: O(n2)\\n        negative.insert(it);\\n\\n       // number of students\\n       int n=student_id.size(); // TC: O(n)\\n       // for storing each student total points after considering feedback\\n       priority_queue<pi,vector<pi>,comp>pq; // SC: O(n)\\n\\n       for(int i=0;i<n;i++) // O(n*|word|*log(max(n1,n2)))\\n       {   int point=0;\\n           int space_pos=-1;\\n           for(int j=0;j<report[i].size();j++)\\n           {\\n               if(report[i][j]==\\' \\')\\n              {   \\n            string find=report[i].substr(space_pos+1,j-space_pos-1);\\n            // if this word find in positive feedback\\n            if(positive.find(find)!=positive.end()) \\n              point+=3;\\n            // if this word find in negative feedback\\n            if(negative.find(find)!=negative.end())   \\n             point-=1;  \\n             space_pos=j;\\n              }\\n           }\\n\\n            string find=report[i].substr(space_pos+1);\\n            // if this word find in positive feedback\\n            if(positive.find(find)!=positive.end()) \\n              point+=3;\\n            // if this word find in negative feedback\\n            if(negative.find(find)!=negative.end())   \\n             point-=1;\\n\\n             pq.push({point,student_id[i]});\\n       }\\n\\n       // to store ans\\n       vector<int>ans;\\n        // TC: O(k)\\n       while(k--)\\n       {  pi  it=pq.top();\\n           pq.pop();\\n        //    cout<<it.second<<\"   \"<<it.first<<endl;\\n           ans.push_back(it.second);\\n       }\\n\\n       // return ans\\n       return ans;\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/e90cef2a-30f9-41a7-81e8-f1716f371a64_1675259875.4141183.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#define pi pair<int,int>\\nstruct comp\\n{\\n  bool operator()(pi &p1, pi &p2)\\n  {\\n      if(p1.first==p2.first)\\n        return p1.second>p2.second;\\n      return p1.first<p2.first;\\n  }    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // to store the feedback words according to nature for efficient search\\n            unordered_set<string>positive; // SC: O(n1)\\n            unordered_set<string>negative; // SC: O(n2)\\n\\n        for(auto it: positive_feedback) // TC: O(n1)\\n          positive.insert(it);\\n        \\n        for(auto it: negative_feedback) // TC: O(n2)\\n        negative.insert(it);\\n\\n       // number of students\\n       int n=student_id.size(); // TC: O(n)\\n       // for storing each student total points after considering feedback\\n       priority_queue<pi,vector<pi>,comp>pq; // SC: O(n)\\n\\n       for(int i=0;i<n;i++) // O(n*|word|*log(max(n1,n2)))\\n       {   int point=0;\\n           int space_pos=-1;\\n           for(int j=0;j<report[i].size();j++)\\n           {\\n               if(report[i][j]==\\' \\')\\n              {   \\n            string find=report[i].substr(space_pos+1,j-space_pos-1);\\n            // if this word find in positive feedback\\n            if(positive.find(find)!=positive.end()) \\n              point+=3;\\n            // if this word find in negative feedback\\n            if(negative.find(find)!=negative.end())   \\n             point-=1;  \\n             space_pos=j;\\n              }\\n           }\\n\\n            string find=report[i].substr(space_pos+1);\\n            // if this word find in positive feedback\\n            if(positive.find(find)!=positive.end()) \\n              point+=3;\\n            // if this word find in negative feedback\\n            if(negative.find(find)!=negative.end())   \\n             point-=1;\\n\\n             pq.push({point,student_id[i]});\\n       }\\n\\n       // to store ans\\n       vector<int>ans;\\n        // TC: O(k)\\n       while(k--)\\n       {  pi  it=pq.top();\\n           pq.pop();\\n        //    cout<<it.second<<\"   \"<<it.first<<endl;\\n           ans.push_back(it.second);\\n       }\\n\\n       // return ans\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3117551,
                "title": "java-optimized-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    HashSet<String> pos = new HashSet<>();\\n    HashSet<String> neg = new HashSet<>();\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        \\n        for(String s : positive_feedback){\\n            pos.add(s);\\n        }\\n        for(String s : negative_feedback){\\n            neg.add(s);\\n        }\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a,b)->b[0]==a[0]?b[1]-a[1]:a[0]-b[0]);\\n        for(int i=0;i<report.length;i++){\\n            int [] temp = feedback(report[i],student_id[i]);\\n            pq.add(temp);\\n            if(i>=k){\\n                pq.poll();\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>(k);\\n        while(pq.size()!=0){\\n            res.add(pq.poll()[1]);\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    private int [] feedback(String s,int std){\\n\\n        int []res = new int[2];\\n        int tscore = 0;\\n        String [] tokens = s.split(\" \");\\n        for(String ss : tokens){\\n            tscore += Match(ss);\\n        }\\n        res[0] = tscore;\\n        res[1] = std;\\n        return res;\\n    }\\n    private int Match(String s){\\n        \\n        if(pos.contains(s)){ // check is string is present in pos_feedback\\n            return 3;\\n        }\\n        if(neg.contains(s)){\\n            return -1;\\n        }\\n        return 0;\\n    } // Since a string cannot be present in both feedbacks therefore we can return score without checking in both the hashsets\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<String> pos = new HashSet<>();\\n    HashSet<String> neg = new HashSet<>();\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        \\n        for(String s : positive_feedback){\\n            pos.add(s);\\n        }\\n        for(String s : negative_feedback){\\n            neg.add(s);\\n        }\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a,b)->b[0]==a[0]?b[1]-a[1]:a[0]-b[0]);\\n        for(int i=0;i<report.length;i++){\\n            int [] temp = feedback(report[i],student_id[i]);\\n            pq.add(temp);\\n            if(i>=k){\\n                pq.poll();\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>(k);\\n        while(pq.size()!=0){\\n            res.add(pq.poll()[1]);\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    private int [] feedback(String s,int std){\\n\\n        int []res = new int[2];\\n        int tscore = 0;\\n        String [] tokens = s.split(\" \");\\n        for(String ss : tokens){\\n            tscore += Match(ss);\\n        }\\n        res[0] = tscore;\\n        res[1] = std;\\n        return res;\\n    }\\n    private int Match(String s){\\n        \\n        if(pos.contains(s)){ // check is string is present in pos_feedback\\n            return 3;\\n        }\\n        if(neg.contains(s)){\\n            return -1;\\n        }\\n        return 0;\\n    } // Since a string cannot be present in both feedbacks therefore we can return score without checking in both the hashsets\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101996,
                "title": "python3-heap-better-space-and-time-with-heap-top-k-from-stream",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is basically data manipulation.\\n\\n**1. Scoring**\\nAt first we should come up with a fast way to compute the score for each student.\\n\\nFor that we essentially convert the positive and negative words into a set for quick lookup and then iterate over all words from each report.\\n\\n**2. Find Top K in Stream**\\nThe second part of the problem is to get k students with the most points (and lowest student id if similar). This can be solved efficiently using a min heap to store the k best students so far.\\n\\nIf we insert a new student into the heap and the heap gets bigger than k, we pop the student with the lowest points (or student or highest student id if similar). We can take student id into account by pushing tuples into the stack that contain the negative student id.\\n\\nIn the end for sorting the top K students, we then just pop all elements from the stack. As it is a min heap, we need to revert afterwards as the students with low scores pop first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach uses a heap to find the k best students in what is essentially a stream of scores.\\n\\nIn comparison with computing all scores and then sorting, this in theory should have better time complexity.\\n\\nComputing all scores and sorting: O(N* logN)\\nUsing a heap for find top K in Stream: O(N* logK)\\nK beeing the top K students we want to find and N being the number of students.\\n\\nBut in practice it might be slower due to the constant resizing of the heap....not really sure. It doesn\\'t show significant time improvements in [LeetCode\\'s time measurement](https://leetcode.com/problems/reward-top-k-students/submissions/885700309/), which is not very reliable either. It could also be the test cases. If K is always pretty close to N there is not a big savings potential. Other and always possible option: I mixed something up. Please correct me, if I\\'m wrong! \\n\\nOther than that space complexity is definitely better as we only ever use O(K) space for the heap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N* logK) for N heappush/heappop operations that have logK complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K) for keeping the heap (k+1 worst case)\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n\\n        # make a set for the positive and negative words\\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        \\n        # go through the reports and compute the score of the students\\n        # then push the students into a heap of length k to get the k best\\n        scored_students = []\\n        for idd, rep in zip(student_id, report):\\n            score = sum((3 if word in positive_feedback else -1 for word in rep.split() if word in positive_feedback or word in negative_feedback), start=0)\\n            if len(scored_students) == k:\\n                heapq.heappushpop(scored_students, (score, -idd))\\n            else:\\n                heappush(scored_students, (score, -idd))\\n        \\n        # return the student id in sorted order (which we can just heappop from the heap)\\n        return [-heappop(scored_students)[1] for _ in range(k)][::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n\\n        # make a set for the positive and negative words\\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        \\n        # go through the reports and compute the score of the students\\n        # then push the students into a heap of length k to get the k best\\n        scored_students = []\\n        for idd, rep in zip(student_id, report):\\n            score = sum((3 if word in positive_feedback else -1 for word in rep.split() if word in positive_feedback or word in negative_feedback), start=0)\\n            if len(scored_students) == k:\\n                heapq.heappushpop(scored_students, (score, -idd))\\n            else:\\n                heappush(scored_students, (score, -idd))\\n        \\n        # return the student id in sorted order (which we can just heappop from the heap)\\n        return [-heappop(scored_students)[1] for _ in range(k)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001874,
                "title": "easy-understanding-c-simple-approach",
                "content": "```\\nclass Solution {\\n       set<string> positive;\\n       set<string> negative;\\n       \\n       int utilfunc(string s)\\n       {\\n           string curr = \"\";\\n           vector<string> arr;\\n           for(int i=0;i<s.length();i++)\\n           {\\n               if(s[i] != \\' \\')\\n               {\\n                   curr += s[i];\\n               }else{\\n                   arr.push_back(curr);\\n                   curr = \"\";\\n               }\\n           }\\n           arr.push_back(curr);\\n           int score = 0;\\n           for(auto it : arr)\\n           {\\n               if(positive.find(it) != positive.end())\\n               {\\n                   score += 3;\\n               }\\n               \\n               if(negative.find(it) != negative.end())\\n               {\\n                   score--;\\n               }\\n           }\\n           return score;\\n       }\\n    \\n        static bool  compare(pair<int,int> &a,pair<int,int> &b)\\n       {\\n           if(a.first>b.first) return true;\\n           else if(a.first == b.first) return a.second<b.second;\\n           return false;\\n       }\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        for(auto it : positive_feedback)\\n        {\\n            positive.insert(it);\\n        }\\n        \\n        for(auto it : negative_feedback)\\n        {\\n            negative.insert(it);\\n        }\\n        \\n        int n = report.size();\\n        map<int,int> score;\\n        for(int i=0;i<n;i++)\\n        {\\n            score[student_id[i]] += utilfunc(report[i]);\\n        }\\n        \\n        vector<pair<int,int>> arr;\\n        for(auto it : score)\\n        {\\n            arr.push_back({it.second,it.first});\\n        }\\n        \\n        vector<int> ans;\\n        sort(arr.begin(),arr.end(),compare);\\n        int i=0;\\n        while(k--)\\n        {\\n            ans.push_back(arr[i++].second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n       set<string> positive;\\n       set<string> negative;\\n       \\n       int utilfunc(string s)\\n       {\\n           string curr = \"\";\\n           vector<string> arr;\\n           for(int i=0;i<s.length();i++)\\n           {\\n               if(s[i] != \\' \\')\\n               {\\n                   curr += s[i];\\n               }else{\\n                   arr.push_back(curr);\\n                   curr = \"\";\\n               }\\n           }\\n           arr.push_back(curr);\\n           int score = 0;\\n           for(auto it : arr)\\n           {\\n               if(positive.find(it) != positive.end())\\n               {\\n                   score += 3;\\n               }\\n               \\n               if(negative.find(it) != negative.end())\\n               {\\n                   score--;\\n               }\\n           }\\n           return score;\\n       }\\n    \\n        static bool  compare(pair<int,int> &a,pair<int,int> &b)\\n       {\\n           if(a.first>b.first) return true;\\n           else if(a.first == b.first) return a.second<b.second;\\n           return false;\\n       }\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        for(auto it : positive_feedback)\\n        {\\n            positive.insert(it);\\n        }\\n        \\n        for(auto it : negative_feedback)\\n        {\\n            negative.insert(it);\\n        }\\n        \\n        int n = report.size();\\n        map<int,int> score;\\n        for(int i=0;i<n;i++)\\n        {\\n            score[student_id[i]] += utilfunc(report[i]);\\n        }\\n        \\n        vector<pair<int,int>> arr;\\n        for(auto it : score)\\n        {\\n            arr.push_back({it.second,it.first});\\n        }\\n        \\n        vector<int> ans;\\n        sort(arr.begin(),arr.end(),compare);\\n        int i=0;\\n        while(k--)\\n        {\\n            ans.push_back(arr[i++].second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948848,
                "title": "easy-c-solution-using-comparator-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>a,pair<int,int>b){\\n        if(a.second==b.second){\\n            return a.first<b.first;\\n        }\\n        return a.second>b.second;\\n    }\\n    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& r, vector<int>& id, int k) {\\n\\n     unordered_map<int,int>curr;\\n     unordered_map<string,int>p,n;\\n     for(auto it : pos){\\n         p[it]++;\\n     }\\n     for(auto it : neg){\\n         n[it]++;\\n     }\\n     for(int i=0;i<r.size();i++){\\n         string line=r[i];\\n         int score=0;\\n         for(int j=0;j<line.size();j++){\\n             string temp=\"\";\\n             while(j<line.size() && line[j]!=\\' \\'){\\n                 temp+=line[j];\\n                 j++;\\n             }\\n             if(p.find(temp)!=p.end()){\\n                 score+=3;\\n             }\\n             if(n.find(temp)!=n.end()){\\n                 score-=1;\\n             }\\n         }\\n         curr[id[i]]=score;\\n     }\\n     vector<pair<int,int>>par;\\n     for(auto it :curr){\\n         par.push_back({it.first,it.second});\\n     }\\n        sort(par.begin(),par.end(),comp);\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(par[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>a,pair<int,int>b){\\n        if(a.second==b.second){\\n            return a.first<b.first;\\n        }\\n        return a.second>b.second;\\n    }\\n    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& r, vector<int>& id, int k) {\\n\\n     unordered_map<int,int>curr;\\n     unordered_map<string,int>p,n;\\n     for(auto it : pos){\\n         p[it]++;\\n     }\\n     for(auto it : neg){\\n         n[it]++;\\n     }\\n     for(int i=0;i<r.size();i++){\\n         string line=r[i];\\n         int score=0;\\n         for(int j=0;j<line.size();j++){\\n             string temp=\"\";\\n             while(j<line.size() && line[j]!=\\' \\'){\\n                 temp+=line[j];\\n                 j++;\\n             }\\n             if(p.find(temp)!=p.end()){\\n                 score+=3;\\n             }\\n             if(n.find(temp)!=n.end()){\\n                 score-=1;\\n             }\\n         }\\n         curr[id[i]]=score;\\n     }\\n     vector<pair<int,int>>par;\\n     for(auto it :curr){\\n         par.push_back({it.first,it.second});\\n     }\\n        sort(par.begin(),par.end(),comp);\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(par[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946810,
                "title": "java-hashset-priorityqueue-arraylist",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    class student {\\n        int id;\\n        int pts;\\n        student(int id, int pts) {\\n            this.id = id;\\n            this.pts = pts;\\n        }\\n    }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        // Set<String> posFeedback = new HashSet<>(Arrays.asList(positive_feedback));\\n        // Set<String> negFeedback = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        Set<String> posFeedback = new HashSet<>();\\n        Set<String> negFeedback = new HashSet<>();\\n\\n        for (String s : positive_feedback) {\\n            posFeedback.add(s);\\n        }\\n        for (String s : negative_feedback) {\\n            negFeedback.add(s);\\n        }\\n\\n        PriorityQueue<student> pq = new PriorityQueue<>(\\n            (a, b) -> a.pts == b.pts? a.id - b.id : b.pts - a.pts\\n        );\\n\\n        int idx = 0;\\n        for (String r : report) {\\n            int pts = 0;\\n            for (String w : r.split(\" \")) {\\n                if (posFeedback.contains(w)) pts += 3;\\n                if (negFeedback.contains(w)) pts -= 1;;\\n            }\\n\\n            pq.offer(new student(student_id[idx++], pts));\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            ans.add(pq.poll().id);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(f) + O(n * r * logn) + O(k * logn)\\n// SC: O(f + n + k)\\n\\n// f -> size of feedback arrays\\n// n -> size report array\\n// r -> size of a word in report array\\n```\\n---\\n#### Same approach but using an ArrayList instead of a Priority Queue:\\n```java []\\nclass Solution {\\n    class student {\\n        int id;\\n        int pts;\\n        public student(int id, int pts) {\\n            this.id = id;\\n            this.pts = pts;\\n        }\\n    }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> posFeedback = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> negFeedback = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        List<student> list = new ArrayList<>();\\n        int idx = 0;\\n\\n        for (String r : report) {\\n            int pts = 0;\\n            for (String w : r.split(\" \")) {\\n                if (posFeedback.contains(w)) pts += 3;\\n                if (negFeedback.contains(w)) pts--;\\n            }\\n\\n            list.add(new student(student_id[idx++], pts));\\n        }\\n\\n        Collections.sort(list,\\n                (a, b) -> a.pts == b.pts? a.id - b.id : b.pts - a.pts\\n        );\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            ans.add(list.get(i).id);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(f) + O(n * r) + O(n * logn)\\n// SC: O(f + n + k)\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "``` java []\\nclass Solution {\\n    class student {\\n        int id;\\n        int pts;\\n        student(int id, int pts) {\\n            this.id = id;\\n            this.pts = pts;\\n        }\\n    }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        // Set<String> posFeedback = new HashSet<>(Arrays.asList(positive_feedback));\\n        // Set<String> negFeedback = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        Set<String> posFeedback = new HashSet<>();\\n        Set<String> negFeedback = new HashSet<>();\\n\\n        for (String s : positive_feedback) {\\n            posFeedback.add(s);\\n        }\\n        for (String s : negative_feedback) {\\n            negFeedback.add(s);\\n        }\\n\\n        PriorityQueue<student> pq = new PriorityQueue<>(\\n            (a, b) -> a.pts == b.pts? a.id - b.id : b.pts - a.pts\\n        );\\n\\n        int idx = 0;\\n        for (String r : report) {\\n            int pts = 0;\\n            for (String w : r.split(\" \")) {\\n                if (posFeedback.contains(w)) pts += 3;\\n                if (negFeedback.contains(w)) pts -= 1;;\\n            }\\n\\n            pq.offer(new student(student_id[idx++], pts));\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            ans.add(pq.poll().id);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(f) + O(n * r * logn) + O(k * logn)\\n// SC: O(f + n + k)\\n\\n// f -> size of feedback arrays\\n// n -> size report array\\n// r -> size of a word in report array\\n```\n```java []\\nclass Solution {\\n    class student {\\n        int id;\\n        int pts;\\n        public student(int id, int pts) {\\n            this.id = id;\\n            this.pts = pts;\\n        }\\n    }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> posFeedback = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> negFeedback = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        List<student> list = new ArrayList<>();\\n        int idx = 0;\\n\\n        for (String r : report) {\\n            int pts = 0;\\n            for (String w : r.split(\" \")) {\\n                if (posFeedback.contains(w)) pts += 3;\\n                if (negFeedback.contains(w)) pts--;\\n            }\\n\\n            list.add(new student(student_id[idx++], pts));\\n        }\\n\\n        Collections.sort(list,\\n                (a, b) -> a.pts == b.pts? a.id - b.id : b.pts - a.pts\\n        );\\n\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            ans.add(list.get(i).id);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(f) + O(n * r) + O(n * logn)\\n// SC: O(f + n + k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946740,
                "title": "c-easy-sorting-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool mycmp(const pair<int,int> &a,const pair<int,int> &b){    // comparator function\\n        if(a.first == b.first){\\n            return a.second < b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& p, vector<string>& n, vector<string>& r, vector<int>& id, int k) {\\n        unordered_set<string> pos,neg;\\n        for(auto &s : p){\\n            pos.insert(s);\\n        }\\n        for(auto &s : n){\\n            neg.insert(s);\\n        }\\n\\t\\t\\n        vector<pair<int,int>> sc;\\n        \\n        for(int i = 0; i < r.size(); i++){\\n            string rep = r[i];\\n            int score = 0;\\n            stringstream ss(rep);\\n            string temp;\\n            while(ss >> temp){\\n                if(pos.count(temp)){\\n                    score += 3;\\n                }\\n                if(neg.count(temp)){\\n                    score -= 1;\\n                }\\n            }\\n            sc.push_back({score,id[i]});\\n        }\\n        \\n        sort(sc.begin(),sc.end(),mycmp);\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            ans.push_back(sc[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool mycmp(const pair<int,int> &a,const pair<int,int> &b){    // comparator function\\n        if(a.first == b.first){\\n            return a.second < b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& p, vector<string>& n, vector<string>& r, vector<int>& id, int k) {\\n        unordered_set<string> pos,neg;\\n        for(auto &s : p){\\n            pos.insert(s);\\n        }\\n        for(auto &s : n){\\n            neg.insert(s);\\n        }\\n\\t\\t\\n        vector<pair<int,int>> sc;\\n        \\n        for(int i = 0; i < r.size(); i++){\\n            string rep = r[i];\\n            int score = 0;\\n            stringstream ss(rep);\\n            string temp;\\n            while(ss >> temp){\\n                if(pos.count(temp)){\\n                    score += 3;\\n                }\\n                if(neg.count(temp)){\\n                    score -= 1;\\n                }\\n            }\\n            sc.push_back({score,id[i]});\\n        }\\n        \\n        sort(sc.begin(),sc.end(),mycmp);\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            ans.push_back(sc[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946628,
                "title": "c-solution-using-set",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        set<string>positives;\\n        set<string>negatives;\\n        \\n        for(int i=0;i<positive_feedback.size();i++){\\n            positives.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++){\\n            negatives.insert(negative_feedback[i]);\\n        }\\n        \\n        vector<pair<int,int>> ans;\\n        for(int i=0;i<student_id.size();i++){\\n            string reportstr = report[i];\\n            int score = getScores(reportstr,positives,negatives);    \\n            ans.push_back({-score,student_id[i]});\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>ret;\\n        for(int i=0;i<k;i++){\\n            ret.push_back(ans[i].second);\\n        }\\n        return ret;   \\n    }\\n    \\n    \\n    int getScores(string &rep, set<string>&positives,set<string>&negatives){\\n        int score = 0;\\n        string stk = \"\";\\n        for(int i=0;i<rep.size();i++){\\n            if(rep[i]==\\' \\'){\\n                score += positives.count(stk)*3;\\n                score += negatives.count(stk)*-1;\\n                stk = \"\";\\n                continue;\\n            }\\n            stk.push_back(rep[i]);\\n        }\\n        score += positives.count(stk)*3;\\n        score += negatives.count(stk)*-1;\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        set<string>positives;\\n        set<string>negatives;\\n        \\n        for(int i=0;i<positive_feedback.size();i++){\\n            positives.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++){\\n            negatives.insert(negative_feedback[i]);\\n        }\\n        \\n        vector<pair<int,int>> ans;\\n        for(int i=0;i<student_id.size();i++){\\n            string reportstr = report[i];\\n            int score = getScores(reportstr,positives,negatives);    \\n            ans.push_back({-score,student_id[i]});\\n        }\\n        sort(ans.begin(),ans.end());\\n        vector<int>ret;\\n        for(int i=0;i<k;i++){\\n            ret.push_back(ans[i].second);\\n        }\\n        return ret;   \\n    }\\n    \\n    \\n    int getScores(string &rep, set<string>&positives,set<string>&negatives){\\n        int score = 0;\\n        string stk = \"\";\\n        for(int i=0;i<rep.size();i++){\\n            if(rep[i]==\\' \\'){\\n                score += positives.count(stk)*3;\\n                score += negatives.count(stk)*-1;\\n                stk = \"\";\\n                continue;\\n            }\\n            stk.push_back(rep[i]);\\n        }\\n        score += positives.count(stk)*3;\\n        score += negatives.count(stk)*-1;\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946502,
                "title": "java-sort-by-points",
                "content": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] reports, int[] student_id, int k) {\\n        \\n        int n = student_id.length;\\n        \\n\\t\\t// Set of positive feedbacks\\n        Set<String> pos = new HashSet();\\n\\t\\tfor(String fd : positive_feedback) pos.add(fd);\\n\\t\\t\\n\\t\\t// Set of negative feedbacks\\n        Set<String> neg = new HashSet();\\n        for(String fd : negative_feedback) neg.add(fd);\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comp());\\n         \\n        for(int i = 0; i < n; i++) {\\n            \\n            // get point for every student\\n            int points = getPointFromReport(reports[i], pos, neg);\\n            int id = student_id[i];\\n            \\n            pq.add(new int[]{id, points});\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        while(k-- > 0) {\\n            ans.add(pq.remove()[0]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int getPointFromReport(String report, Set<String> pos, Set<String> neg) {\\n        int points = 0;\\n        \\n        for(String r : report.split(\" \")) {\\n            if(pos.contains(r)) {\\n                points += 3;\\n            }\\n            else if(neg.contains(r)) {\\n                points -= 1;\\n            }\\n        }\\n        return points;\\n    }\\n}\\n\\nclass Comp implements Comparator<int[]> {\\n    public int compare(int[] a1, int[] a2) {\\n        if(a1[1] != a2[1]) return a2[1] - a1[1];\\n        return a1[0] - a2[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] reports, int[] student_id, int k) {\\n        \\n        int n = student_id.length;\\n        \\n\\t\\t// Set of positive feedbacks\\n        Set<String> pos = new HashSet();\\n\\t\\tfor(String fd : positive_feedback) pos.add(fd);\\n\\t\\t\\n\\t\\t// Set of negative feedbacks\\n        Set<String> neg = new HashSet();\\n        for(String fd : negative_feedback) neg.add(fd);\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comp());\\n         \\n        for(int i = 0; i < n; i++) {\\n            \\n            // get point for every student\\n            int points = getPointFromReport(reports[i], pos, neg);\\n            int id = student_id[i];\\n            \\n            pq.add(new int[]{id, points});\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        while(k-- > 0) {\\n            ans.add(pq.remove()[0]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int getPointFromReport(String report, Set<String> pos, Set<String> neg) {\\n        int points = 0;\\n        \\n        for(String r : report.split(\" \")) {\\n            if(pos.contains(r)) {\\n                points += 3;\\n            }\\n            else if(neg.contains(r)) {\\n                points -= 1;\\n            }\\n        }\\n        return points;\\n    }\\n}\\n\\nclass Comp implements Comparator<int[]> {\\n    public int compare(int[] a1, int[] a2) {\\n        if(a1[1] != a2[1]) return a2[1] - a1[1];\\n        return a1[0] - a2[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946499,
                "title": "python-straightforward-solution",
                "content": "```python\\nclass Solution:\\n    def topStudents(self, \\n                    positive_feedback: List[str], \\n                    negative_feedback: List[str], \\n                    report: List[str], \\n                    student_id: List[int], \\n                    k: int\\n                   ) -> List[int]:\\n        \\n        p = set(positive_feedback)\\n        n = set(negative_feedback)\\n        d = {}\\n\\n        for sid, rep in zip(student_id, report):\\n            points = 0\\n            words = Counter(rep.split())\\n\\n            for w, c in words.items():\\n                if w in p:\\n                    points += 3*c\\n                if w in n:\\n                    points -= 1*c\\n            \\n            d[sid] = points\\n\\n        return sorted(student_id, key=lambda sid: (-d[sid], sid))[:k]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def topStudents(self, \\n                    positive_feedback: List[str], \\n                    negative_feedback: List[str], \\n                    report: List[str], \\n                    student_id: List[int], \\n                    k: int\\n                   ) -> List[int]:\\n        \\n        p = set(positive_feedback)\\n        n = set(negative_feedback)\\n        d = {}\\n\\n        for sid, rep in zip(student_id, report):\\n            points = 0\\n            words = Counter(rep.split())\\n\\n            for w, c in words.items():\\n                if w in p:\\n                    points += 3*c\\n                if w in n:\\n                    points -= 1*c\\n            \\n            d[sid] = points\\n\\n        return sorted(student_id, key=lambda sid: (-d[sid], sid))[:k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946479,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        results = []\\n        positive_feedback, negative_feedback=set(positive_feedback), set(negative_feedback)\\n        for id_, rep in zip(student_id, report):\\n            point = 0\\n            for word in rep.split():\\n                if word in positive_feedback:\\n                    point+=3\\n                elif word in negative_feedback:\\n                    point-=1\\n            results.append((id_, point))\\n        return [i[0] for i in sorted(results, key=lambda x: (-x[1], x[0]))[:k]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        results = []\\n        positive_feedback, negative_feedback=set(positive_feedback), set(negative_feedback)\\n        for id_, rep in zip(student_id, report):\\n            point = 0\\n            for word in rep.split():\\n                if word in positive_feedback:\\n                    point+=3\\n                elif word in negative_feedback:\\n                    point-=1\\n            results.append((id_, point))\\n        return [i[0] for i in sorted(results, key=lambda x: (-x[1], x[0]))[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002766,
                "title": "java-intuition-code-east-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs per the problem description it\\'s clear at first glance that we\\'ll need to traverse through feedback array for every student, doing so will raise our complexity to O(n^2), so think of some data structure which will do this in O(1) [Average case] -- A HashMap.\\n\\nNow for getting the top k students, what can we use? Yes right, A Heap (Priority Queue)\\n\\n# Complexity\\n- Time complexity: O(n log k), where n is the number of students and k is the number of top students to be returned.\\n\\n- Space complexity: O(n), where n is the number of students.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        // Create a map to store the marks for each word.\\n        Map<String, Integer> markingMap = new HashMap<>();\\n\\n        for(int i=0; i<positive_feedback.length; i++) {\\n            String key = positive_feedback[i];\\n            if(!markingMap.containsKey(key)) {\\n                markingMap.put(key, 3);\\n            }\\n        }\\n\\n        for(int i=0; i<negative_feedback.length; i++) {\\n            String key = negative_feedback[i];\\n            if(!markingMap.containsKey(key)) {\\n                markingMap.put(key, -1);\\n            }\\n        }\\n\\n        // Create a priority queue to store the students in sorted order by their marks.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] > b[0]) {\\n                return -1;\\n            } else if (a[0] < b[0]) {\\n                return 1;\\n            } else {\\n                if (a[1] < b[1]) {\\n                return -1;\\n                } else if (a[1] > b[1]) {\\n                return 1;\\n                } else {\\n                return 0;\\n                }\\n            }\\n        });\\n\\n        // Iterate over the report array and add the marks for each student to the priority queue.\\n        for(int index = 0; index < report.length; index++) {\\n            int marks = getMarks(report[index], markingMap);\\n            pq.offer(new int[]{marks, student_id[index]});\\n        }\\n\\n        // Create a list to store the top k student IDs.\\n        List<Integer> ans = new ArrayList<>();\\n\\n        // Iterate over the priority queue and add the top k students to the list.\\n        while(k-- > 0) {\\n            ans.add(pq.poll()[1]);\\n        }\\n        return ans;\\n    }\\n\\n    // Calculates the marks for a student based on their report.\\n    private int getMarks(String report, Map<String, Integer> markingMap) {\\n        String[] arr = report.split(\" \");\\n        int marks = 0;\\n        for(String s : arr) {\\n            if(markingMap.containsKey(s)) {\\n                marks += markingMap.get(s);\\n            }\\n        }\\n        return marks;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        // Create a map to store the marks for each word.\\n        Map<String, Integer> markingMap = new HashMap<>();\\n\\n        for(int i=0; i<positive_feedback.length; i++) {\\n            String key = positive_feedback[i];\\n            if(!markingMap.containsKey(key)) {\\n                markingMap.put(key, 3);\\n            }\\n        }\\n\\n        for(int i=0; i<negative_feedback.length; i++) {\\n            String key = negative_feedback[i];\\n            if(!markingMap.containsKey(key)) {\\n                markingMap.put(key, -1);\\n            }\\n        }\\n\\n        // Create a priority queue to store the students in sorted order by their marks.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] > b[0]) {\\n                return -1;\\n            } else if (a[0] < b[0]) {\\n                return 1;\\n            } else {\\n                if (a[1] < b[1]) {\\n                return -1;\\n                } else if (a[1] > b[1]) {\\n                return 1;\\n                } else {\\n                return 0;\\n                }\\n            }\\n        });\\n\\n        // Iterate over the report array and add the marks for each student to the priority queue.\\n        for(int index = 0; index < report.length; index++) {\\n            int marks = getMarks(report[index], markingMap);\\n            pq.offer(new int[]{marks, student_id[index]});\\n        }\\n\\n        // Create a list to store the top k student IDs.\\n        List<Integer> ans = new ArrayList<>();\\n\\n        // Iterate over the priority queue and add the top k students to the list.\\n        while(k-- > 0) {\\n            ans.add(pq.poll()[1]);\\n        }\\n        return ans;\\n    }\\n\\n    // Calculates the marks for a student based on their report.\\n    private int getMarks(String report, Map<String, Integer> markingMap) {\\n        String[] arr = report.split(\" \");\\n        int marks = 0;\\n        for(String s : arr) {\\n            if(markingMap.containsKey(s)) {\\n                marks += markingMap.get(s);\\n            }\\n        }\\n        return marks;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702068,
                "title": "c-intutive-easy-to-follow-solution-hashmap-priority-queue",
                "content": "\\n\\n# Code\\n```\\n#define pp pair<int,int> \\nclass Solution {\\npublic:\\n\\nstruct cmp{\\n    bool operator()(pp&p1, pp&p2){\\n        if(p1.first==p2.first){\\n            return p1.second>p2.second;\\n        }\\n        else return p1.first<p2.first;\\n    }\\n};\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        int n = student_id.size(); //= report.size();\\n        int p = positive_feedback.size();\\n        int q = negative_feedback.size();\\n\\n        unordered_map<string,int> pos;\\n        unordered_map<string,int> neg;\\n\\n        for(int i=0; i<p; i++) pos[ positive_feedback[i] ] = 3;\\n        for(int i=0; i<q; i++) neg[ negative_feedback[i] ]= -1;\\n        \\n       priority_queue< pp, vector<pp>, cmp> pq;\\n\\n        for(int i=0; i<n; i++){\\n            int score=0;\\n            int id = student_id[i];\\n\\n                stringstream ss(report[i]);\\n                string word;\\n                while(ss>>word){\\n                    score=score+(pos[word]+neg[word]);\\n                }\\n            pq.push({score,id});\\n        }\\n\\n        vector<int> rank;\\n\\n        while(!pq.empty()){\\n            rank.push_back(pq.top().second);\\n            pq.pop();\\n            if(rank.size()==k) break;\\n        }\\n        return rank;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pp pair<int,int> \\nclass Solution {\\npublic:\\n\\nstruct cmp{\\n    bool operator()(pp&p1, pp&p2){\\n        if(p1.first==p2.first){\\n            return p1.second>p2.second;\\n        }\\n        else return p1.first<p2.first;\\n    }\\n};\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        int n = student_id.size(); //= report.size();\\n        int p = positive_feedback.size();\\n        int q = negative_feedback.size();\\n\\n        unordered_map<string,int> pos;\\n        unordered_map<string,int> neg;\\n\\n        for(int i=0; i<p; i++) pos[ positive_feedback[i] ] = 3;\\n        for(int i=0; i<q; i++) neg[ negative_feedback[i] ]= -1;\\n        \\n       priority_queue< pp, vector<pp>, cmp> pq;\\n\\n        for(int i=0; i<n; i++){\\n            int score=0;\\n            int id = student_id[i];\\n\\n                stringstream ss(report[i]);\\n                string word;\\n                while(ss>>word){\\n                    score=score+(pos[word]+neg[word]);\\n                }\\n            pq.push({score,id});\\n        }\\n\\n        vector<int> rank;\\n\\n        while(!pq.empty()){\\n            rank.push_back(pq.top().second);\\n            pq.pop();\\n            if(rank.size()==k) break;\\n        }\\n        return rank;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528665,
                "title": "javascript-hashmap-with-sorting",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} positive_feedback\\n * @param {string[]} negative_feedback\\n * @param {string[]} report\\n * @param {number[]} student_id\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {\\n    const pos = new Set(positive_feedback);\\n    const neg = new Set(negative_feedback);\\n\\n    const scores = {};\\n\\n    for (let i = 0; i < student_id.length; i++) {\\n        const id = student_id[i];\\n\\n        if (!scores[id]) {\\n            scores[id] = 0;\\n        }\\n\\n        const reportWords = report[i].split(\\' \\');\\n\\n        for (const word of reportWords) {\\n            if (pos.has(word)) {\\n                scores[id] += 3;\\n\\n                continue;\\n            }\\n\\n            if (neg.has(word)) {\\n                scores[id] -= 1;\\n            }\\n        }\\n    }\\n\\n    const scoresArr = Object.entries(scores);\\n    scoresArr.sort((s1, s2) => {\\n        if (s1[1] !== s2[1]) { // sort by score\\n            return s2[1] - s1[1];\\n        }\\n\\n        return s1[0] - s2[0]; // by id\\n    });\\n\\n    return scoresArr.slice(0, k).map(entry => entry[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {string[]} positive_feedback\\n * @param {string[]} negative_feedback\\n * @param {string[]} report\\n * @param {number[]} student_id\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {\\n    const pos = new Set(positive_feedback);\\n    const neg = new Set(negative_feedback);\\n\\n    const scores = {};\\n\\n    for (let i = 0; i < student_id.length; i++) {\\n        const id = student_id[i];\\n\\n        if (!scores[id]) {\\n            scores[id] = 0;\\n        }\\n\\n        const reportWords = report[i].split(\\' \\');\\n\\n        for (const word of reportWords) {\\n            if (pos.has(word)) {\\n                scores[id] += 3;\\n\\n                continue;\\n            }\\n\\n            if (neg.has(word)) {\\n                scores[id] -= 1;\\n            }\\n        }\\n    }\\n\\n    const scoresArr = Object.entries(scores);\\n    scoresArr.sort((s1, s2) => {\\n        if (s1[1] !== s2[1]) { // sort by score\\n            return s2[1] - s1[1];\\n        }\\n\\n        return s1[0] - s2[0]; // by id\\n    });\\n\\n    return scoresArr.slice(0, k).map(entry => entry[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465879,
                "title": "very-simple-c",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> &a, pair<int, int> &b)\\n    {\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        map<string, int> positive_hash;\\n        map<string, int> negative_hash;\\n\\n        for(auto i:positive_feedback)\\n            positive_hash[i]++;\\n\\n        for(auto i:negative_feedback)\\n            negative_hash[i]++;\\n\\n\\n        int score = 0;\\n                //  ID, score\\n        vector<pair<int, int>> result;\\n\\n\\n        for(int i=0; i<size(report); i++)\\n        {\\n            score = 0;\\n            stringstream s(report[i]);\\n            string word;\\n\\n            while(s>>word)\\n            {\\n                if(positive_hash[word] >= 1)\\n                    score+=3;\\n\\n                else if(negative_hash[word] >= 1)\\n                    score-=1;\\n            }\\n\\n            result.push_back({student_id[i], score});\\n        }\\n\\n        sort(begin(result), end(result), cmp);\\n\\n        vector<int> ans;\\n\\n        for(auto i:result){\\n            if(k == 0)\\n                break;\\n\\n            ans.push_back(i.first);\\n            k--;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/19ef737e-a806-47d9-b2ba-51e351285e83_1682762711.9974818.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> &a, pair<int, int> &b)\\n    {\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n\\n        return a.second > b.second;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        map<string, int> positive_hash;\\n        map<string, int> negative_hash;\\n\\n        for(auto i:positive_feedback)\\n            positive_hash[i]++;\\n\\n        for(auto i:negative_feedback)\\n            negative_hash[i]++;\\n\\n\\n        int score = 0;\\n                //  ID, score\\n        vector<pair<int, int>> result;\\n\\n\\n        for(int i=0; i<size(report); i++)\\n        {\\n            score = 0;\\n            stringstream s(report[i]);\\n            string word;\\n\\n            while(s>>word)\\n            {\\n                if(positive_hash[word] >= 1)\\n                    score+=3;\\n\\n                else if(negative_hash[word] >= 1)\\n                    score-=1;\\n            }\\n\\n            result.push_back({student_id[i], score});\\n        }\\n\\n        sort(begin(result), end(result), cmp);\\n\\n        vector<int> ans;\\n\\n        for(auto i:result){\\n            if(k == 0)\\n                break;\\n\\n            ans.push_back(i.first);\\n            k--;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107644,
                "title": "easy-solution-using-max-heap-and-hash-set",
                "content": "# Intuition\\nTo make the max heap according to the score of each student!!\\n\\n# Approach\\n-> Fistly we will convert the both positive and negative array into hash set, so that we can find the result in O(1) time.\\n\\n-> Then we will start traversing the student_id array and for each student[i] we will go for report[i] which shows the report of i student.\\n\\n-> Then we will check for each string in report[i] whether the string is peresent in which set . If the string is present in postive set the its score will be increased by 3 and if that string is present in negative set then its score will bre decreased by 1.\\n\\n-> After traversing the whole report[i] then whatever the score is generated we will put this score into a max heap.\\n\\n-> After calculating the score for each student_id then we will want to find the top k score. For that we will remove k elements from heap and store it in result array and return the result array.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(K*B)\\nk=lenght of student_id array.\\nB=length of the report string of each student.\\n\\n- Space complexity:\\nO(N)\\n# If this explanations helps you , then don\\'t forget to upvote !! Thanks ;-)\\n# Code\\n```\\nfrom heapq import *\\nclass Solution:\\n    def topStudents(self, positive: List[str], negative: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        positive=set(positive)\\n        negative=set(negative)\\n        heap=[]\\n        for i in range(len(student_id)):\\n            c=0\\n            b=\"\".join(report[i]).split(\" \")\\n            for j in b:\\n                if j in positive:\\n                    c+=3\\n                elif j in negative:\\n                    c-=1\\n            heappush(heap,[-c,student_id[i]])\\n        res=[]\\n        while k:\\n            l=heappop(heap)\\n            res.append(l[1])\\n            k-=1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n    def topStudents(self, positive: List[str], negative: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        positive=set(positive)\\n        negative=set(negative)\\n        heap=[]\\n        for i in range(len(student_id)):\\n            c=0\\n            b=\"\".join(report[i]).split(\" \")\\n            for j in b:\\n                if j in positive:\\n                    c+=3\\n                elif j in negative:\\n                    c-=1\\n            heappush(heap,[-c,student_id[i]])\\n        res=[]\\n        while k:\\n            l=heappop(heap)\\n            res.append(l[1])\\n            k-=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967421,
                "title": "c-without-any-comparator",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string>pos;\\n        unordered_set<string>neg;\\n        for(string s:positive_feedback) pos.insert(s);``\\n        for(string s:negative_feedback) neg.insert(s);\\n        priority_queue<pair<int,int>>store;\\n        for(int i=0;i<report.size();i++){\\n            int st=0,en=0,score=0;\\n            while(en<=report[i].size()){\\n                if(en==report[i].size() or report[i][en]==\\' \\'){\\n                    string temp=report[i].substr(st,en-st);\\n                    if(pos.count(temp)==1) score+=3;\\n                    else if(neg.count(temp)==1) score-=1;\\n                    st=en+1;\\n                    en=st;\\n                }\\n                else{\\n                    en++;\\n                }\\n            }\\n            store.push({score,-student_id[i]}); //minus for reverse order\\n        }\\n        vector<int>ans;\\n        while(k and !store.empty()){\\n            int x=-store.top().second;\\n            ans.push_back(x);\\n            store.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string>pos;\\n        unordered_set<string>neg;\\n        for(string s:positive_feedback) pos.insert(s);``\\n        for(string s:negative_feedback) neg.insert(s);\\n        priority_queue<pair<int,int>>store;\\n        for(int i=0;i<report.size();i++){\\n            int st=0,en=0,score=0;\\n            while(en<=report[i].size()){\\n                if(en==report[i].size() or report[i][en]==\\' \\'){\\n                    string temp=report[i].substr(st,en-st);\\n                    if(pos.count(temp)==1) score+=3;\\n                    else if(neg.count(temp)==1) score-=1;\\n                    st=en+1;\\n                    en=st;\\n                }\\n                else{\\n                    en++;\\n                }\\n            }\\n            store.push({score,-student_id[i]}); //minus for reverse order\\n        }\\n        vector<int>ans;\\n        while(k and !store.empty()){\\n            int x=-store.top().second;\\n            ans.push_back(x);\\n            store.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961616,
                "title": "c-solution-beats-96-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& s_id, int k) {\\n        int n = s_id.size();\\n        unordered_set<string>pos,neg;\\n\\n    //store positive and negative feedback in a set\\n        for(auto i=0;i<pf.size();i++){\\n            pos.insert(pf[i]);\\n        }\\n         for(auto i=0;i<nf.size();i++){\\n            neg.insert(nf[i]);\\n        }\\n        vector<array<int, 2>> store; // make pair of {pts, student_id}\\n        for(int i=0;i<n;i++){\\n           int pts = 0;\\n           string s  = report[i];\\n           string temp = s.substr(0,1);\\n           for(int i=1;i<(int)s.length();i++){\\n               if(s[i] == \\' \\'){\\n                   if(pos.find(temp) != pos.end())pts+=3;\\n                   else if(neg.find(temp) != neg.end())pts--;\\n                temp.clear();\\n               }\\n               else{\\n                   temp.push_back(s[i]);\\n               }\\n               }\\n                if(pos.find(temp) != pos.end())pts+=3;\\n                else if(neg.find(temp) != neg.end())pts--;\\n\\n            store.push_back({pts, -s_id[i]}); //  multiply by -1 it gives top max element\\n           }\\n        \\n        vector<int>ans;\\n        sort(store.rbegin(),store.rend());\\n        int m = min(k, (int)store.size());\\n        for(int i=0;i<m;i++){\\n            ans.push_back(-store[i][1]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& s_id, int k) {\\n        int n = s_id.size();\\n        unordered_set<string>pos,neg;\\n\\n    //store positive and negative feedback in a set\\n        for(auto i=0;i<pf.size();i++){\\n            pos.insert(pf[i]);\\n        }\\n         for(auto i=0;i<nf.size();i++){\\n            neg.insert(nf[i]);\\n        }\\n        vector<array<int, 2>> store; // make pair of {pts, student_id}\\n        for(int i=0;i<n;i++){\\n           int pts = 0;\\n           string s  = report[i];\\n           string temp = s.substr(0,1);\\n           for(int i=1;i<(int)s.length();i++){\\n               if(s[i] == \\' \\'){\\n                   if(pos.find(temp) != pos.end())pts+=3;\\n                   else if(neg.find(temp) != neg.end())pts--;\\n                temp.clear();\\n               }\\n               else{\\n                   temp.push_back(s[i]);\\n               }\\n               }\\n                if(pos.find(temp) != pos.end())pts+=3;\\n                else if(neg.find(temp) != neg.end())pts--;\\n\\n            store.push_back({pts, -s_id[i]}); //  multiply by -1 it gives top max element\\n           }\\n        \\n        vector<int>ans;\\n        sort(store.rbegin(),store.rend());\\n        int m = min(k, (int)store.size());\\n        for(int i=0;i<m;i++){\\n            ans.push_back(-store[i][1]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950346,
                "title": "java-hashmap-sorting-using-comparator",
                "content": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {        \\n        Set<String> positiveFeedback = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> negativeFeedback = new HashSet<>(Arrays.asList(negative_feedback));     \\n        \\n\\t\\t// Creating Map of (id, points)\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < student_id.length; i++) {\\n            int point = 0;\\n            for(String str : report[i].split(\" \")) {\\n                if(positiveFeedback.contains(str))\\n                    point+=3;\\n                else if(negativeFeedback.contains(str))\\n                    point-=1;\\n            }\\n            map.put(student_id[i], point);\\n        }         \\n        \\n\\t\\t// Making list of Map.Entry to sort it accordingly using Comparator\\n\\t\\t\\n        List<Map.Entry<Integer, Integer>> list = new LinkedList<Map.Entry<Integer, Integer>>(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {\\n        public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\\n                if(o2.getValue().compareTo(o1.getValue()) == 0)\\n                    return o1.getKey().compareTo(o2.getKey());\\n                else                                                  \\n                    return o2.getValue().compareTo(o1.getValue());\\n            }\\n        });\\n        \\n\\t\\t// Creating Ans list\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Adding top k student ids\\n        for (Map.Entry<Integer, Integer> entry : list) {  \\n            ans.add(entry.getKey());\\n            if(ans.size() == k)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {        \\n        Set<String> positiveFeedback = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> negativeFeedback = new HashSet<>(Arrays.asList(negative_feedback));     \\n        \\n\\t\\t// Creating Map of (id, points)\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < student_id.length; i++) {\\n            int point = 0;\\n            for(String str : report[i].split(\" \")) {\\n                if(positiveFeedback.contains(str))\\n                    point+=3;\\n                else if(negativeFeedback.contains(str))\\n                    point-=1;\\n            }\\n            map.put(student_id[i], point);\\n        }         \\n        \\n\\t\\t// Making list of Map.Entry to sort it accordingly using Comparator\\n\\t\\t\\n        List<Map.Entry<Integer, Integer>> list = new LinkedList<Map.Entry<Integer, Integer>>(map.entrySet());\\n \\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {\\n        public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\\n                if(o2.getValue().compareTo(o1.getValue()) == 0)\\n                    return o1.getKey().compareTo(o2.getKey());\\n                else                                                  \\n                    return o2.getValue().compareTo(o1.getValue());\\n            }\\n        });\\n        \\n\\t\\t// Creating Ans list\\n        List<Integer> ans = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Adding top k student ids\\n        for (Map.Entry<Integer, Integer> entry : list) {  \\n            ans.add(entry.getKey());\\n            if(ans.size() == k)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949464,
                "title": "simple-c-solution-using-string-splitter-and-priority-queue",
                "content": "# Intuition\\nSimply Count the scores and sort them according to their scores and then according to their ranks\\n\\n# Approach\\n1. Use String splitter to split the string\\n2. Count the score of each student\\n3. Put them in a priority queue\\n4. Pop top K elements and return them\\n\\n# Complexity\\n- Time complexity: O(mnlogk)\\n\\n- Space complexity: O(mn)\\n\\n# Code\\n```\\nclass Compare{\\npublic:\\n    bool operator()(const pair<int,int> &a , const pair<int,int> &b){\\n        if(a.first==b.first){\\n            return a.second > b.second;\\n        }\\n        \\n        return a.first<b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> split (string s, string delimiter) {\\n        size_t pos_start = 0, pos_end, delim_len = delimiter.length();\\n        string token;\\n        vector<string> res;\\n\\n        while ((pos_end = s.find (delimiter, pos_start)) != string::npos) {\\n            token = s.substr (pos_start, pos_end - pos_start);\\n            pos_start = pos_end + delim_len;\\n            res.push_back (token);\\n        }\\n\\n        res.push_back (s.substr (pos_start));\\n        return res;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = student_id.size();\\n        set<string> pos;\\n        set<string> neg;\\n        int x = positive_feedback.size();\\n        int y = negative_feedback.size();\\n        \\n        for(int i=0 ; i<x ; i++){\\n            pos.insert(positive_feedback[i]);\\n        }\\n        \\n        for(int i=0 ;i<y ; i++){\\n            neg.insert(negative_feedback[i]);\\n        }\\n        \\n        priority_queue<pair<int,int> , vector<pair<int,int>> , Compare> q;\\n        \\n        \\n        for(int i=0 ; i<n ; i++){\\n            string s = report[i];\\n            string delimiter = \" \";\\n            vector<string> v = split(s, delimiter);\\n            int score = 0;\\n            int m = v.size();\\n            for(int j=0 ; j<m ; j++){\\n                if(pos.find(v[j])!=pos.end()){\\n                    score += 3;\\n                }\\n                else if(neg.find(v[j])!=neg.end()){\\n                    score -= 1;\\n                }\\n            }\\n            \\n            \\n            q.push({score , student_id[i]});\\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        while(k--){\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Compare{\\npublic:\\n    bool operator()(const pair<int,int> &a , const pair<int,int> &b){\\n        if(a.first==b.first){\\n            return a.second > b.second;\\n        }\\n        \\n        return a.first<b.first;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> split (string s, string delimiter) {\\n        size_t pos_start = 0, pos_end, delim_len = delimiter.length();\\n        string token;\\n        vector<string> res;\\n\\n        while ((pos_end = s.find (delimiter, pos_start)) != string::npos) {\\n            token = s.substr (pos_start, pos_end - pos_start);\\n            pos_start = pos_end + delim_len;\\n            res.push_back (token);\\n        }\\n\\n        res.push_back (s.substr (pos_start));\\n        return res;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = student_id.size();\\n        set<string> pos;\\n        set<string> neg;\\n        int x = positive_feedback.size();\\n        int y = negative_feedback.size();\\n        \\n        for(int i=0 ; i<x ; i++){\\n            pos.insert(positive_feedback[i]);\\n        }\\n        \\n        for(int i=0 ;i<y ; i++){\\n            neg.insert(negative_feedback[i]);\\n        }\\n        \\n        priority_queue<pair<int,int> , vector<pair<int,int>> , Compare> q;\\n        \\n        \\n        for(int i=0 ; i<n ; i++){\\n            string s = report[i];\\n            string delimiter = \" \";\\n            vector<string> v = split(s, delimiter);\\n            int score = 0;\\n            int m = v.size();\\n            for(int j=0 ; j<m ; j++){\\n                if(pos.find(v[j])!=pos.end()){\\n                    score += 3;\\n                }\\n                else if(neg.find(v[j])!=neg.end()){\\n                    score -= 1;\\n                }\\n            }\\n            \\n            \\n            q.push({score , student_id[i]});\\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        while(k--){\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948985,
                "title": "easy-comparator-sort-o-nlogn-beats-100",
                "content": "# *Upvote if you understood the solution and comment for any doubt.*\\n# Intuition\\nFind the no. of points each student gets based on the feedback and map w.r.t to their ids.\\n\\n# Approach\\nWe\\'ll pair each student with their points and their id. Sort the pairs using a comparator function on increasing points and decreasing id if points are equal.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& report, vector<int>&id, int k) {\\n        unordered_map<string,int> fb;\\n        for(auto &s : pos) fb[s] = 3;\\n        for(auto &s : neg) fb[s] = -1;\\n\\n        vector<pair<int,int>> pairs;\\n\\n        for(int i=0 ; i<report.size() ; i++){\\n            stringstream ss(report[i]);\\n            string word;\\n            int point = 0;\\n            while(ss >> word)\\n                if(fb.count(word))\\n                    point += fb[word];\\n            pairs.push_back({point,id[i]});\\n        }\\n        vector<int> ans;\\n        sort(pairs.begin(),pairs.end(),[](pair<int,int>& a,pair<int,int>& b){\\n            if(a.first == b.first)\\n                return a.second > b.second;\\n            return a.first < b.first;\\n        });\\n        while(k--){\\n            ans.push_back(pairs.back().second);\\n            pairs.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& report, vector<int>&id, int k) {\\n        unordered_map<string,int> fb;\\n        for(auto &s : pos) fb[s] = 3;\\n        for(auto &s : neg) fb[s] = -1;\\n\\n        vector<pair<int,int>> pairs;\\n\\n        for(int i=0 ; i<report.size() ; i++){\\n            stringstream ss(report[i]);\\n            string word;\\n            int point = 0;\\n            while(ss >> word)\\n                if(fb.count(word))\\n                    point += fb[word];\\n            pairs.push_back({point,id[i]});\\n        }\\n        vector<int> ans;\\n        sort(pairs.begin(),pairs.end(),[](pair<int,int>& a,pair<int,int>& b){\\n            if(a.first == b.first)\\n                return a.second > b.second;\\n            return a.first < b.first;\\n        });\\n        while(k--){\\n            ans.push_back(pairs.back().second);\\n            pairs.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948802,
                "title": "c-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComparator Sorting using Priority Queue\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct compare{\\n    bool operator()(const pair<int, int>&i, const pair<int, int>&j) \\n{   if(i.second == j.second)return i.first>j.first;\\n    return i.second < j.second; \\n} \\n};\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& arr, vector<int>& student_id, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,compare>pq ;\\n        set<string>s1,s2;\\n        for(int i=0;i<positive_feedback.size();i++){\\n            s1.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++){\\n            s2.insert(negative_feedback[i]);\\n        }\\n        for(int i=0;i<student_id.size();i++){\\n            \\n            int temp=(student_id[i]);\\n            int count=0;\\n            string s=arr[i];\\n            string curr=\"\";\\n            for(int j=0;j<s.size()+1;j++){\\n                if(s[j]==\\' \\' || j==s.size()){\\n                    if(s1.find(curr)!=s1.end()){\\n                        count+=3;\\n                    }\\n                   else if(s2.find(curr)!=s2.end()){\\n                        count-=1;\\n                    }\\n                    curr=\"\";\\n                }\\n                else curr+=arr[i][j];\\n            }\\n            pq.push({temp,count});\\n        }\\n        vector<int>ans;\\n        while(k--){\\n            cout<<pq.top().first<<\"  \"<<pq.top().second<<endl;\\n            ans.push_back(pq.top().first);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compare{\\n    bool operator()(const pair<int, int>&i, const pair<int, int>&j) \\n{   if(i.second == j.second)return i.first>j.first;\\n    return i.second < j.second; \\n} \\n};\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& arr, vector<int>& student_id, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,compare>pq ;\\n        set<string>s1,s2;\\n        for(int i=0;i<positive_feedback.size();i++){\\n            s1.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++){\\n            s2.insert(negative_feedback[i]);\\n        }\\n        for(int i=0;i<student_id.size();i++){\\n            \\n            int temp=(student_id[i]);\\n            int count=0;\\n            string s=arr[i];\\n            string curr=\"\";\\n            for(int j=0;j<s.size()+1;j++){\\n                if(s[j]==\\' \\' || j==s.size()){\\n                    if(s1.find(curr)!=s1.end()){\\n                        count+=3;\\n                    }\\n                   else if(s2.find(curr)!=s2.end()){\\n                        count-=1;\\n                    }\\n                    curr=\"\";\\n                }\\n                else curr+=arr[i][j];\\n            }\\n            pq.push({temp,count});\\n        }\\n        vector<int>ans;\\n        while(k--){\\n            cout<<pq.top().first<<\"  \"<<pq.top().second<<endl;\\n            ans.push_back(pq.top().first);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2947408,
                "title": "easy-solution-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculating score for each id and storing it in the priority queue and the sorting the equal scores separately.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n\\n# Complexity\\n- Time complexity: O(report.size() + report[i].size()) for calculating scores.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, string> umap;\\n        for (auto it: positive_feedback) {\\n            umap[it] = \"good\";\\n        }\\n        for (auto it: negative_feedback) {\\n            umap[it] = \"bad\";\\n        }\\n        \\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < report.size(); i++) {\\n            int score = 0;\\n            string word = \"\";\\n            for (int j = 0; j < report[i].size(); j++) {\\n                if (report[i][j] == \\' \\') {\\n                    if (umap.find(word) != umap.end()) {\\n                        if (umap[word] == \"good\") score += 3;\\n                        else score -= 1;\\n                    }\\n                    word = \"\";\\n                    continue;\\n                }\\n                else {\\n                    word += report[i][j];\\n                }\\n            }\\n            if (umap.find(word) != umap.end()) {\\n                if (umap[word] == \"good\") score += 3;\\n                else score -= 1;\\n            }\\n            pq.push({score, student_id[i]});\\n        }\\n        \\n        vector<int> ans;\\n        vector<pair<int, int>> temp;\\n        while (!pq.empty()) {\\n            int s = pq.top().first;\\n            cout << s << \" \";\\n            int id = pq.top().second;\\n            cout << id << \" \";\\n            pq.pop();\\n            if (temp.size() != 0) {\\n                if (temp[0].second == s) temp.push_back({id, s});\\n                else {\\n                    sort(temp.begin(), temp.end());\\n                    for (auto it: temp) {\\n                        ans.push_back(it.first);\\n                        k--;\\n                        if (k == 0) return ans;\\n                    }\\n                    temp.clear();\\n                    temp.push_back({id, s});\\n                }\\n            }\\n            else if (temp.size() == 0) {\\n                temp.push_back({id, s});\\n            }\\n        }\\n        sort(temp.begin(), temp.end());\\n        for (auto it: temp) {\\n            if (k == 0) return ans;\\n            ans.push_back(it.first);\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, string> umap;\\n        for (auto it: positive_feedback) {\\n            umap[it] = \"good\";\\n        }\\n        for (auto it: negative_feedback) {\\n            umap[it] = \"bad\";\\n        }\\n        \\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < report.size(); i++) {\\n            int score = 0;\\n            string word = \"\";\\n            for (int j = 0; j < report[i].size(); j++) {\\n                if (report[i][j] == \\' \\') {\\n                    if (umap.find(word) != umap.end()) {\\n                        if (umap[word] == \"good\") score += 3;\\n                        else score -= 1;\\n                    }\\n                    word = \"\";\\n                    continue;\\n                }\\n                else {\\n                    word += report[i][j];\\n                }\\n            }\\n            if (umap.find(word) != umap.end()) {\\n                if (umap[word] == \"good\") score += 3;\\n                else score -= 1;\\n            }\\n            pq.push({score, student_id[i]});\\n        }\\n        \\n        vector<int> ans;\\n        vector<pair<int, int>> temp;\\n        while (!pq.empty()) {\\n            int s = pq.top().first;\\n            cout << s << \" \";\\n            int id = pq.top().second;\\n            cout << id << \" \";\\n            pq.pop();\\n            if (temp.size() != 0) {\\n                if (temp[0].second == s) temp.push_back({id, s});\\n                else {\\n                    sort(temp.begin(), temp.end());\\n                    for (auto it: temp) {\\n                        ans.push_back(it.first);\\n                        k--;\\n                        if (k == 0) return ans;\\n                    }\\n                    temp.clear();\\n                    temp.push_back({id, s});\\n                }\\n            }\\n            else if (temp.size() == 0) {\\n                temp.push_back({id, s});\\n            }\\n        }\\n        sort(temp.begin(), temp.end());\\n        for (auto it: temp) {\\n            if (k == 0) return ans;\\n            ans.push_back(it.first);\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2947249,
                "title": "c",
                "content": "~~~\\nclass Solution {\\npublic:\\n // static bool operator(const pair<int,int>&p1, const pair<int,int>& p2)\\nstatic bool comp(pair<int,int>&p1, pair<int,int>& p2)\\n{\\n    if(p1.first==p2.first)\\n    {\\n        if(p1.second<p2.second) return true;\\n        return false;\\n    }\\n    if(p1.first<p2.first)\\n        return false;\\n    return true;\\n}\\n \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int> ans;\\n       vector<pair<int,int>>points;\\n        map<string,int> p,n;\\n        for(int i=0;i<positive_feedback.size();i++)\\n        {\\n            p[positive_feedback[i]]=1;\\n        }\\n        for(int i=0;i<negative_feedback.size();i++)\\n        {\\n            n[negative_feedback[i]]=1;\\n        }\\n        for(int i=0;i<report.size(); i++)\\n        {\\n            int point=0;\\n            stringstream s(report[i]);\\n            string word;\\n             while (s >> word)\\n             {\\n                 cout<<word +\"  \";\\n                 if(p[word]) point+=3;\\n                 if(n[word]) point-=1;\\n             }\\n            points.push_back({point,student_id[i]});\\n        }\\n        sort(points.begin(),points.end(),comp);\\n        for(int i=0;i<k;i++)\\n        {\\n            pair<int,int> p=points[i];\\n            int t=p.second;\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n // static bool operator(const pair<int,int>&p1, const pair<int,int>& p2)\\nstatic bool comp(pair<int,int>&p1, pair<int,int>& p2)\\n{\\n    if(p1.first==p2.first)\\n    {\\n        if(p1.second<p2.second) return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2946901,
                "title": "java-priority-queue-hashtable-efficient",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( n )\\n\\n- Space complexity:\\nO ( N )\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashSet<String>p=new HashSet<>();\\n        HashSet<String>n=new HashSet<>();\\n        for(String i: positive_feedback){\\n            p.add(i);\\n        }\\n        for(String i: negative_feedback){\\n            n.add(i);\\n        }\\n        HashMap<Integer, Integer>h=new HashMap<>();\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0; i<report.length; i++){\\n            String a[]=report[i].split(\"\\\\\\\\s\");\\n            int point=0;\\n            for(int j=0; j<a.length; j++){\\n                if(p.contains(a[j])){\\n                    point+=3;\\n                }\\n                else if(n.contains(a[j])){\\n                    point--;\\n                }\\n            }\\n            h.put(student_id[i], point);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\\n                (a,b) -> a.getValue()==b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue()-b.getValue()\\n        );\\n\\n        for(Map.Entry<Integer, Integer> entry: h.entrySet())\\n        {\\n            pq.offer(entry);\\n            if(pq.size()>k)\\n                pq.poll();\\n        }\\n\\n        List<Integer> l = new ArrayList<>();\\n        while(!pq.isEmpty())\\n            l.add(0, pq.poll().getKey());\\n\\n        return l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashSet<String>p=new HashSet<>();\\n        HashSet<String>n=new HashSet<>();\\n        for(String i: positive_feedback){\\n            p.add(i);\\n        }\\n        for(String i: negative_feedback){\\n            n.add(i);\\n        }\\n        HashMap<Integer, Integer>h=new HashMap<>();\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0; i<report.length; i++){\\n            String a[]=report[i].split(\"\\\\\\\\s\");\\n            int point=0;\\n            for(int j=0; j<a.length; j++){\\n                if(p.contains(a[j])){\\n                    point+=3;\\n                }\\n                else if(n.contains(a[j])){\\n                    point--;\\n                }\\n            }\\n            h.put(student_id[i], point);\\n        }\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\\n                (a,b) -> a.getValue()==b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue()-b.getValue()\\n        );\\n\\n        for(Map.Entry<Integer, Integer> entry: h.entrySet())\\n        {\\n            pq.offer(entry);\\n            if(pq.size()>k)\\n                pq.poll();\\n        }\\n\\n        List<Integer> l = new ArrayList<>();\\n        while(!pq.isEmpty())\\n            l.add(0, pq.poll().getKey());\\n\\n        return l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946864,
                "title": "c-map-each-student-id-to-points",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        map<int,int> mp;\\n        set<string> pos,neg;\\n        for(auto it : positive_feedback){\\n            pos.insert(it);\\n        }\\n        for(auto it : negative_feedback){\\n            neg.insert(it);\\n        }\\n        for(int i=0;i<report.size();i++){\\n            string w=\"\";\\n            for(auto it : report[i]){\\n                if(it == \\' \\'){\\n                    if(pos.count(w)>=1) mp[student_id[i]] += 3;\\n                    else if(neg.count(w)>=1) mp[student_id[i]] -= 1;\\n                    w = \"\";\\n                }else{\\n                    w+=it;\\n                }\\n            }\\n            if(pos.count(w)>=1) mp[student_id[i]] += 3;\\n            else if(neg.count(w)>=1) mp[student_id[i]] -= 1;\\n        }\\n        vector<pair<int,int>> arr;\\n        for(auto it : mp){\\n            arr.push_back({it.second,it.first});\\n        }\\n        sort(arr.begin(),arr.end(),[](pair<int,int> a,pair<int,int> b){\\n            if(a.first < b.first) return true;\\n            else if(a.first == b.first) return a.second>b.second;\\n            return false;\\n        });\\n        vector<int> ans;\\n        for(int i=arr.size()-1,j=0;j<k && i>=0;j++,i--){\\n            ans.push_back(arr[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        map<int,int> mp;\\n        set<string> pos,neg;\\n        for(auto it : positive_feedback){\\n            pos.insert(it);\\n        }\\n        for(auto it : negative_feedback){\\n            neg.insert(it);\\n        }\\n        for(int i=0;i<report.size();i++){\\n            string w=\"\";\\n            for(auto it : report[i]){\\n                if(it == \\' \\'){\\n                    if(pos.count(w)>=1) mp[student_id[i]] += 3;\\n                    else if(neg.count(w)>=1) mp[student_id[i]] -= 1;\\n                    w = \"\";\\n                }else{\\n                    w+=it;\\n                }\\n            }\\n            if(pos.count(w)>=1) mp[student_id[i]] += 3;\\n            else if(neg.count(w)>=1) mp[student_id[i]] -= 1;\\n        }\\n        vector<pair<int,int>> arr;\\n        for(auto it : mp){\\n            arr.push_back({it.second,it.first});\\n        }\\n        sort(arr.begin(),arr.end(),[](pair<int,int> a,pair<int,int> b){\\n            if(a.first < b.first) return true;\\n            else if(a.first == b.first) return a.second>b.second;\\n            return false;\\n        });\\n        vector<int> ans;\\n        for(int i=arr.size()-1,j=0;j<k && i>=0;j++,i--){\\n            ans.push_back(arr[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946774,
                "title": "c-hashset-linq-abuse",
                "content": "# Approach\\nStart by using a HashSet for pos and neg feedback words for O(1) looks up.\\n\\n1. Zip report and student_id together as they share an index\\n2. Select the student_id with their respective sum (calculated by checking each word in report and whether it matches pos or neg feedback)\\n3. Order by descending score\\n4. Order by ascending student id\\n5. Select student id\\n6. Take top k students\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        HashSet<string> pos = new(positive_feedback), neg = new(negative_feedback);\\n        return student_id\\n            .Zip(report, (sid, rep) => new {sid, rep})\\n            .Select(p => \\n                (p.sid, p.rep.Split(\" \").Sum(x => x switch\\n                {\\n                    _ when pos.Contains(x) => 3,\\n                    _ when neg.Contains(x) => -1,\\n                    _ => 0\\n                })))\\n            .OrderByDescending(x => x.Item2)\\n            .ThenBy(x => x.Item1)\\n            .Select(x => x.Item1)\\n            .Take(k)\\n            .ToList();\\n    }\\n}\\n```\\n# Complexity\\n|    |    |\\n| :- | :- |\\n| `n` student count | `m` max word count in reports |\\n| `p` pos feedback size | `n` neg feedback size |\\n- Time complexity: $$O(n * m + nlogn)$$\\nsumation or sort as upper bound\\n- Space complexity: $$O(n + p)$$",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        HashSet<string> pos = new(positive_feedback), neg = new(negative_feedback);\\n        return student_id\\n            .Zip(report, (sid, rep) => new {sid, rep})\\n            .Select(p => \\n                (p.sid, p.rep.Split(\" \").Sum(x => x switch\\n                {\\n                    _ when pos.Contains(x) => 3,\\n                    _ when neg.Contains(x) => -1,\\n                    _ => 0\\n                })))\\n            .OrderByDescending(x => x.Item2)\\n            .ThenBy(x => x.Item1)\\n            .Select(x => x.Item1)\\n            .Take(k)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946677,
                "title": "short-and-straight-tc-o-nlogn-sc-o-n",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> pos = Set.of(positive_feedback), neg = Set.of(negative_feedback);\\n        \\n        List<int[]> al = new ArrayList<>();\\n        \\n        for(int i=0; i<report.length; i++){\\n            int pts = 0;\\n            for(String r: report[i].split(\"\\\\\\\\s+\")){\\n                if(pos.contains(r)) pts+=3;\\n                else if(neg.contains(r)) pts--;\\n            }\\n            al.add(new int[]{student_id[i], pts});\\n        }\\n        Collections.sort(al, (a,b) -> (a[1]==b[1]) ? a[0]-b[0] : b[1]-a[1]);\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0; i<k; i++){\\n            ans.add(al.get(i)[0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> pos = Set.of(positive_feedback), neg = Set.of(negative_feedback);\\n        \\n        List<int[]> al = new ArrayList<>();\\n        \\n        for(int i=0; i<report.length; i++){\\n            int pts = 0;\\n            for(String r: report[i].split(\"\\\\\\\\s+\")){\\n                if(pos.contains(r)) pts+=3;\\n                else if(neg.contains(r)) pts--;\\n            }\\n            al.add(new int[]{student_id[i], pts});\\n        }\\n        Collections.sort(al, (a,b) -> (a[1]==b[1]) ? a[0]-b[0] : b[1]-a[1]);\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0; i<k; i++){\\n            ans.add(al.get(i)[0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946604,
                "title": "easy-c-solution-using-maps-and-comparators-implementation-approach",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n//Comparator Function\\n    static bool comp(pair<int,int>& a, pair<int,int>& b){\\n        if(a.first!= b.first){\\n            return a.first > b.first;\\n        }\\n        // same score\\n        return (a.second < b.second);\\n    }\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        map<int,int> m; // id,score\\n        map<string,int> mp;\\n        for (auto val: positive_feedback){\\n            mp[val]=3;\\n        }\\n        for (auto val: negative_feedback){\\n            mp[val]=-1;\\n        }\\n        int n= student_id.size();\\n        for (int i=0; i<n; i++){\\n            vector<string> repo;\\n            string statement= report[i];\\n            int ind=0;\\n            while (ind<statement.size()){\\n                string curr;\\n                while (ind<statement.size() && statement[ind]!=\\' \\'){\\n                    curr+= statement[ind];\\n                    ind++;\\n                }\\n                repo.push_back(curr);\\n                ind++;\\n            }\\n            \\n            \\n            for (auto word: repo){\\n                if (mp.find(word)!= mp.end()){\\n                    m[student_id[i]]+= mp[word];\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for (auto val: m){\\n            v.push_back({val.second,val.first}); // score, id\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        vector<int> ans;\\n        for (int i=0; i<k; i++)ans.push_back(v[i].second);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sort",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Comparator Function\\n    static bool comp(pair<int,int>& a, pair<int,int>& b){\\n        if(a.first!= b.first){\\n            return a.first > b.first;\\n        }\\n        // same score\\n        return (a.second < b.second);\\n    }\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        map<int,int> m; // id,score\\n        map<string,int> mp;\\n        for (auto val: positive_feedback){\\n            mp[val]=3;\\n        }\\n        for (auto val: negative_feedback){\\n            mp[val]=-1;\\n        }\\n        int n= student_id.size();\\n        for (int i=0; i<n; i++){\\n            vector<string> repo;\\n            string statement= report[i];\\n            int ind=0;\\n            while (ind<statement.size()){\\n                string curr;\\n                while (ind<statement.size() && statement[ind]!=\\' \\'){\\n                    curr+= statement[ind];\\n                    ind++;\\n                }\\n                repo.push_back(curr);\\n                ind++;\\n            }\\n            \\n            \\n            for (auto word: repo){\\n                if (mp.find(word)!= mp.end()){\\n                    m[student_id[i]]+= mp[word];\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int,int>> v;\\n        for (auto val: m){\\n            v.push_back({val.second,val.first}); // score, id\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        vector<int> ans;\\n        for (int i=0; i<k; i++)ans.push_back(v[i].second);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946552,
                "title": "c-easiest-solution-simple-logic-with-explanation",
                "content": "```\\n\\ntypedef long long ll;\\ntypedef pair<ll,ll> pi;\\nclass Solution {\\npublic:\\n    static bool cmp(pi a,pi b)\\n{\\n    if(a.first==b.first)//if scores same then sort in increasing order of student id\\n        return a.second<b.second;\\n    return a.first>b.first;//sorting according to decreasing order of scores\\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int> ans;\\n        set<string> pos;//for +ve feedback\\n        set<string> neg;//for -ve feedback\\n        vector<pair<int,int>> pq;// pq.first->scores and pq.second->student_id\\n        for(string s:positive_feedback)\\n            pos.insert(s);\\n        for(string s1:negative_feedback)\\n            neg.insert(s1);\\n        for(int i=0;i<report.size();i++)\\n        {\\n            string s=\"\";\\n            string s1=report[i];\\n            ll sum=0;\\n            for(char c:s1)\\n            {\\n               \\n                if(c==\\' \\')//since we would get each individual word from the sentence\\n                {\\n                    if(pos.find(s)!=pos.end())\\n                    sum+=3;\\n                    if(neg.find(s)!=neg.end())\\n                    sum-=1;\\n                    s.clear();\\n                    continue;\\n                }\\n                    s+=c;\\n            }\\n\\t\\t\\t//checking for the last word\\n             if(pos.find(s)!=pos.end())\\n                    sum+=3;\\n                if(neg.find(s)!=neg.end())\\n                    sum-=1;\\n            pq.push_back({sum,student_id[i]});\\n        }\\n        sort(pq.begin(),pq.end(),cmp);\\n        for(int i=0;i<pq.size(),k>0;i++,k--)\\n        {\\n            ans.push_back(pq[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntypedef long long ll;\\ntypedef pair<ll,ll> pi;\\nclass Solution {\\npublic:\\n    static bool cmp(pi a,pi b)\\n{\\n    if(a.first==b.first)//if scores same then sort in increasing order of student id\\n        return a.second<b.second;\\n    return a.first>b.first;//sorting according to decreasing order of scores\\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int> ans;\\n        set<string> pos;//for +ve feedback\\n        set<string> neg;//for -ve feedback\\n        vector<pair<int,int>> pq;// pq.first->scores and pq.second->student_id\\n        for(string s:positive_feedback)\\n            pos.insert(s);\\n        for(string s1:negative_feedback)\\n            neg.insert(s1);\\n        for(int i=0;i<report.size();i++)\\n        {\\n            string s=\"\";\\n            string s1=report[i];\\n            ll sum=0;\\n            for(char c:s1)\\n            {\\n               \\n                if(c==\\' \\')//since we would get each individual word from the sentence\\n                {\\n                    if(pos.find(s)!=pos.end())\\n                    sum+=3;\\n                    if(neg.find(s)!=neg.end())\\n                    sum-=1;\\n                    s.clear();\\n                    continue;\\n                }\\n                    s+=c;\\n            }\\n\\t\\t\\t//checking for the last word\\n             if(pos.find(s)!=pos.end())\\n                    sum+=3;\\n                if(neg.find(s)!=neg.end())\\n                    sum-=1;\\n            pq.push_back({sum,student_id[i]});\\n        }\\n        sort(pq.begin(),pq.end(),cmp);\\n        for(int i=0;i<pq.size(),k>0;i++,k--)\\n        {\\n            ans.push_back(pq[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946532,
                "title": "c-ez-sort-using-comparator",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(a[0]==b[0]){//If score is equal we sort on the basis of the id, lower ID first\\n            return a[1]<b[1];\\n        }\\n        return a[0]>=b[0];//Descending order of scores\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        //Using set for fast access\\n        unordered_set<string>p(positive_feedback.begin(),positive_feedback.end()),n(negative_feedback.begin(),negative_feedback.end());\\n        vector<vector<int>>s;\\n        for(int i=0;i<report.size();i++){\\n            string w=report[i]+\" \";\\n            string tmp=\"\";\\n            int score=0;\\n            //Seperating into words and checking \\n            for(auto j:w){\\n                if(j!=\\' \\')\\n                    tmp+=j;\\n                else{\\n                    if(p.find(tmp)!=p.end())\\n                        score+=3;\\n                    if(n.find(tmp)!=n.end())\\n                        score-=1;\\n                    tmp=\"\";    \\n                }\\n            }\\n            s.push_back({score,student_id[i]});\\n            \\n        }\\n        sort(s.begin(),s.end(),comp);\\n        // for(auto i:s)\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // cout<<endl;\\n            \\n            \\n         vector<int> ans;\\n        for(int i=0;i<k;i++)//First \\'k\\' Id\\'s\\n            ans.push_back(s[i][1]);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(a[0]==b[0]){//If score is equal we sort on the basis of the id, lower ID first\\n            return a[1]<b[1];\\n        }\\n        return a[0]>=b[0];//Descending order of scores\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        //Using set for fast access\\n        unordered_set<string>p(positive_feedback.begin(),positive_feedback.end()),n(negative_feedback.begin(),negative_feedback.end());\\n        vector<vector<int>>s;\\n        for(int i=0;i<report.size();i++){\\n            string w=report[i]+\" \";\\n            string tmp=\"\";\\n            int score=0;\\n            //Seperating into words and checking \\n            for(auto j:w){\\n                if(j!=\\' \\')\\n                    tmp+=j;\\n                else{\\n                    if(p.find(tmp)!=p.end())\\n                        score+=3;\\n                    if(n.find(tmp)!=n.end())\\n                        score-=1;\\n                    tmp=\"\";    \\n                }\\n            }\\n            s.push_back({score,student_id[i]});\\n            \\n        }\\n        sort(s.begin(),s.end(),comp);\\n        // for(auto i:s)\\n        //     cout<<i[0]<<\" \"<<i[1]<<endl;\\n        // cout<<endl;\\n            \\n            \\n         vector<int> ans;\\n        for(int i=0;i<k;i++)//First \\'k\\' Id\\'s\\n            ans.push_back(s[i][1]);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946531,
                "title": "c-max-heap-without-use-of-any-comparator-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& p, vector<string>& n, vector<string>& report, vector<int>& id, int k) {\\n        unordered_map<string, int>pos, neg;\\n        for(int i=0; i<p.size(); i++){\\n            pos[p[i]]++;\\n        }\\n        for(int i=0; i<n.size(); i++){\\n            neg[n[i]]++;\\n        }\\n        priority_queue<pair<int, int>>v;\\n        for(int i=0; i<id.size(); i++){\\n            int cnt=0;\\n            stringstream s(report[i]);\\n            while(getline(s, report[i], \\' \\')){\\n                //cout<<report[i]<<endl;\\n                if(pos.find(report[i])!=pos.end()){\\n                    cnt+=3;\\n                }\\n                if(neg.find(report[i])!=neg.end()){\\n                    cnt--;\\n                }\\n            }\\n            v.push({cnt, id[i]});\\n        }\\n        vector<int>ans;\\n        int prev=-1, cnt=0;\\n        while(!v.empty()){\\n            if(prev==v.top().first){\\n                cnt++;\\n            }\\n            else{\\n                cnt=0;\\n            }\\n            prev=v.top().first;\\n            if(ans.empty()){ans.push_back(v.top().second);}\\n            else{\\n                ans.insert(ans.begin()+ans.size()-cnt, v.top().second);\\n            }\\n            v.pop();\\n        }\\n        vector<int>a;\\n        for(int i=0; i<k; i++){\\n            a.push_back(ans[i]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& p, vector<string>& n, vector<string>& report, vector<int>& id, int k) {\\n        unordered_map<string, int>pos, neg;\\n        for(int i=0; i<p.size(); i++){\\n            pos[p[i]]++;\\n        }\\n        for(int i=0; i<n.size(); i++){\\n            neg[n[i]]++;\\n        }\\n        priority_queue<pair<int, int>>v;\\n        for(int i=0; i<id.size(); i++){\\n            int cnt=0;\\n            stringstream s(report[i]);\\n            while(getline(s, report[i], \\' \\')){\\n                //cout<<report[i]<<endl;\\n                if(pos.find(report[i])!=pos.end()){\\n                    cnt+=3;\\n                }\\n                if(neg.find(report[i])!=neg.end()){\\n                    cnt--;\\n                }\\n            }\\n            v.push({cnt, id[i]});\\n        }\\n        vector<int>ans;\\n        int prev=-1, cnt=0;\\n        while(!v.empty()){\\n            if(prev==v.top().first){\\n                cnt++;\\n            }\\n            else{\\n                cnt=0;\\n            }\\n            prev=v.top().first;\\n            if(ans.empty()){ans.push_back(v.top().second);}\\n            else{\\n                ans.insert(ans.begin()+ans.size()-cnt, v.top().second);\\n            }\\n            v.pop();\\n        }\\n        vector<int>a;\\n        for(int i=0; i<k; i++){\\n            a.push_back(ans[i]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2946529,
                "title": "python-3-using-dictionary",
                "content": "Use a dictionary to store (key,value): key is word, value is positive, negative or not present\\nStore pair (x,-y) in ans list for each student where x is score of student and y is id. Storing -y will help to get ids in ascending order. \\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        def func():\\n            return \\'not present\\'\\n        d=defaultdict(func)\\n        ans=[]\\n        for p in positive_feedback:\\n            d[p]=\\'p\\'\\n        for n in negative_feedback:\\n            d[n]=\\'n\\'\\n        \\n        for i in range(len(report)):\\n            r=report[i]\\n            r=r.split(\\' \\')\\n            s=0\\n            for w in r:                    \\n                if d[w]==\\'p\\':\\n                    s+=3\\n                if d[w]==\\'n\\':\\n                    s-=1\\n            ans.append((s,-student_id[i]))\\n        \\n        ans.sort(reverse=True)\\n        \\n        fans=[]\\n        \\n        for i in range(k):\\n            fans.append(-ans[i][1])\\n        \\n        return fans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        def func():\\n            return \\'not present\\'\\n        d=defaultdict(func)\\n        ans=[]\\n        for p in positive_feedback:\\n            d[p]=\\'p\\'\\n        for n in negative_feedback:\\n            d[n]=\\'n\\'\\n        \\n        for i in range(len(report)):\\n            r=report[i]\\n            r=r.split(\\' \\')\\n            s=0\\n            for w in r:                    \\n                if d[w]==\\'p\\':\\n                    s+=3\\n                if d[w]==\\'n\\':\\n                    s-=1\\n            ans.append((s,-student_id[i]))\\n        \\n        ans.sort(reverse=True)\\n        \\n        fans=[]\\n        \\n        for i in range(k):\\n            fans.append(-ans[i][1])\\n        \\n        return fans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946483,
                "title": "python-3-updated-for-new-test-cases-hashmap-sorting",
                "content": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], stu_id: List[int], k: int) -> List[int]:\\n        hm = Counter()\\n        \\n        pos = set(positive_feedback)\\n        neg = set(negative_feedback)\\n        \\n        for rep in range(len(report)):\\n            temp = report[rep].split()\\n            for i in temp:\\n                if i in pos:\\n                    hm[stu_id[rep]] += 3\\n                if i in neg:\\n                    hm[stu_id[rep]] -= 1\\n        \\n        return sorted([i for i in stu_id], key = lambda x: (hm[x], -x), reverse = 1)[: k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], stu_id: List[int], k: int) -> List[int]:\\n        hm = Counter()\\n        \\n        pos = set(positive_feedback)\\n        neg = set(negative_feedback)\\n        \\n        for rep in range(len(report)):\\n            temp = report[rep].split()\\n            for i in temp:\\n                if i in pos:\\n                    hm[stu_id[rep]] += 3\\n                if i in neg:\\n                    hm[stu_id[rep]] -= 1\\n        \\n        return sorted([i for i in stu_id], key = lambda x: (hm[x], -x), reverse = 1)[: k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080699,
                "title": "full-explanation-pq-unordered-map",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code first initializes an unordered map mp to store the feedback scores for words. Words in positive_feedback are assigned a score of 3, and words in negative_feedback are assigned a score of -1.\\n\\n2. It then initializes a priority queue minHeap with a custom comparator CustomComparator for pairs of integers. This priority queue will be used to keep track of the top k students based on their scores. The custom comparator ensures that the pair with the highest score comes at the top of the heap.\\n\\n3. The code iterates through each report in the report vector and calculates the score for each student based on the words in the report. It splits the report into words and accumulates the score according to the rules mentioned earlier. The score and student ID are then pushed into the minHeap.\\n\\n4. If the size of the minHeap exceeds k, it removes the student with the lowest score (since we want the top k students with the highest scores).\\n\\n5. Finally, the code extracts the top k students\\' IDs from the minHeap, reverses the order to get them in decreasing order of scores, and returns the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * L + M + K * log K)\\n1. Constructing the mp map: O(M), where M is the total number of unique words in both positive_feedback and negative_feedback.\\n\\n2. Loop that iterates through the report vector: O(N), where N is the total number of words in all the reports.\\n\\n3. Inside the loop, splitting the report into words and calculating the score: O(L), where L is the length of each report.\\n\\n4. Priority queue operations (insertion and removal) for each report: O(log K) per report, where K is the size of the priority queue (limited to k).\\n\\n5. Extracting the top k students and reversing the order: O(K).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(M + K)\\n1. mp map: O(M) space, where M is the total number of unique words in both positive_feedback and negative_feedback.\\n\\n2. minHeap priority queue: O(K) space, where K is the size of the priority queue (limited to k).\\n\\n3. Other variables and data structures used in the code have minimal constant space requirements and do not significantly contribute to the overall space complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct CustomComparator {\\n    // Custom comparison function\\n    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {\\n        if (a.first == b.first) {\\n            // If the first values are equal, compare by the student IDs\\n            return a.second < b.second; // Change to \\'>\\' for a min-heap\\n        }\\n        // If the first values are not equal, compare by the first value\\n        return a.first > b.first; \\n    }\\n};\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        unordered_map<string,int> mp;\\n\\n        for(int i=0;i<positive_feedback.size();i++) {\\n            mp[positive_feedback[i]] = 3;\\n        }\\n\\n        for(int i=0;i<negative_feedback.size();i++) {\\n            mp[negative_feedback[i]] = -1;\\n        }\\n\\n        // {score,studentID}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,CustomComparator> minHeap;\\n\\n        int n = report.size();\\n        for(int i=0;i<n;i++) {\\n            string curr = report[i];\\n\\n            int len = curr.length();\\n\\n            int j=0;\\n            string temp = \"\";\\n            \\n            int points = 0;\\n            while(j<len) {\\n                if(j == len-1) {\\n                    temp += curr[j];\\n                    if(!temp.empty() && mp.find(temp) != mp.end()) {\\n                        points += mp[temp];\\n                    }\\n                    // cout << temp << endl;\\n                }\\n                if(curr[j] == \\' \\') {\\n                    if(!temp.empty() && mp.find(temp) != mp.end()) {\\n                        points += mp[temp];\\n                    }\\n\\n                    // cout << temp << endl;\\n                    temp = \"\";\\n                } \\n                else {\\n                    temp += curr[j];\\n                }\\n                j++;\\n            }\\n\\n            cout << points << endl;\\n\\n            minHeap.push({points,student_id[i]});\\n\\n            if(minHeap.size() > k)\\n                minHeap.pop();\\n        }\\n        \\n        vector<int> ans;\\n\\n        while(!minHeap.empty()) {\\n            int x = minHeap.top().second;\\n            ans.push_back(x);\\n            minHeap.pop();\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstruct CustomComparator {\\n    // Custom comparison function\\n    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {\\n        if (a.first == b.first) {\\n            // If the first values are equal, compare by the student IDs\\n            return a.second < b.second; // Change to \\'>\\' for a min-heap\\n        }\\n        // If the first values are not equal, compare by the first value\\n        return a.first > b.first; \\n    }\\n};\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        unordered_map<string,int> mp;\\n\\n        for(int i=0;i<positive_feedback.size();i++) {\\n            mp[positive_feedback[i]] = 3;\\n        }\\n\\n        for(int i=0;i<negative_feedback.size();i++) {\\n            mp[negative_feedback[i]] = -1;\\n        }\\n\\n        // {score,studentID}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,CustomComparator> minHeap;\\n\\n        int n = report.size();\\n        for(int i=0;i<n;i++) {\\n            string curr = report[i];\\n\\n            int len = curr.length();\\n\\n            int j=0;\\n            string temp = \"\";\\n            \\n            int points = 0;\\n            while(j<len) {\\n                if(j == len-1) {\\n                    temp += curr[j];\\n                    if(!temp.empty() && mp.find(temp) != mp.end()) {\\n                        points += mp[temp];\\n                    }\\n                    // cout << temp << endl;\\n                }\\n                if(curr[j] == \\' \\') {\\n                    if(!temp.empty() && mp.find(temp) != mp.end()) {\\n                        points += mp[temp];\\n                    }\\n\\n                    // cout << temp << endl;\\n                    temp = \"\";\\n                } \\n                else {\\n                    temp += curr[j];\\n                }\\n                j++;\\n            }\\n\\n            cout << points << endl;\\n\\n            minHeap.push({points,student_id[i]});\\n\\n            if(minHeap.size() > k)\\n                minHeap.pop();\\n        }\\n        \\n        vector<int> ans;\\n\\n        while(!minHeap.empty()) {\\n            int x = minHeap.top().second;\\n            ans.push_back(x);\\n            minHeap.pop();\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4074108,
                "title": "java-self-readable-solution-with-streams",
                "content": "# Code\\n```\\nclass Solution {\\n        \\n   public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> positiveFeedbackDictionary = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> negativeFeedbackDictionary = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        List<StudentData> studentData = new ArrayList<>();\\n        for (int i = 0; i < report.length; i++) {\\n            int score = computeScore(positiveFeedbackDictionary, negativeFeedbackDictionary, report[i]);\\n            int studentId = student_id[i];\\n            studentData.add(new StudentData(studentId, score));\\n        }\\n\\n        return studentData\\n                .stream()\\n                .sorted(byDescendingScoreOrAscendingStudentIdWhenEqual())\\n                .limit(k)\\n                .map(StudentData::id)\\n                .toList();\\n    }\\n\\n    private Comparator<StudentData> byDescendingScoreOrAscendingStudentIdWhenEqual() {\\n        return (student1, student2) -> {\\n            boolean isSameScore = student1.score != student2.score;\\n            return isSameScore ? student2.score - student1.score : student1.id - student2.id;\\n        };\\n    }\\n\\n    record StudentData(int id, int score) {}\\n\\n    private int computeScore(Set<String> positiveFeedbackDictionary, Set<String> negativeFeedbackDictionary, String r) {\\n        int totalScore = 0;\\n        String[] words = r.split(\" \");\\n\\n        for (String w: words) {\\n            if (positiveFeedbackDictionary.contains(w)) {\\n                totalScore +=3;\\n            }\\n            if (negativeFeedbackDictionary.contains(w)) {\\n                totalScore -=1;\\n            }\\n        }\\n        return totalScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        \\n   public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> positiveFeedbackDictionary = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> negativeFeedbackDictionary = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        List<StudentData> studentData = new ArrayList<>();\\n        for (int i = 0; i < report.length; i++) {\\n            int score = computeScore(positiveFeedbackDictionary, negativeFeedbackDictionary, report[i]);\\n            int studentId = student_id[i];\\n            studentData.add(new StudentData(studentId, score));\\n        }\\n\\n        return studentData\\n                .stream()\\n                .sorted(byDescendingScoreOrAscendingStudentIdWhenEqual())\\n                .limit(k)\\n                .map(StudentData::id)\\n                .toList();\\n    }\\n\\n    private Comparator<StudentData> byDescendingScoreOrAscendingStudentIdWhenEqual() {\\n        return (student1, student2) -> {\\n            boolean isSameScore = student1.score != student2.score;\\n            return isSameScore ? student2.score - student1.score : student1.id - student2.id;\\n        };\\n    }\\n\\n    record StudentData(int id, int score) {}\\n\\n    private int computeScore(Set<String> positiveFeedbackDictionary, Set<String> negativeFeedbackDictionary, String r) {\\n        int totalScore = 0;\\n        String[] words = r.split(\" \");\\n\\n        for (String w: words) {\\n            if (positiveFeedbackDictionary.contains(w)) {\\n                totalScore +=3;\\n            }\\n            if (negativeFeedbackDictionary.contains(w)) {\\n                totalScore -=1;\\n            }\\n        }\\n        return totalScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064485,
                "title": "c-python-rolling-hash-heap-solution-with-explanation",
                "content": "### rolling hash + heap\\ntc is O(positive_feedback.size() + negative_feedback.size() + report.size() * log k).\\nsc is O(positive_feedback.size() + negative_feedback.size()).\\n\\nconvert each word in positive_feedback to a number, negative_feedback is the same,\\ncalculate each report\\'s point,\\nconvert each word in report to a number,\\nif number is in positive_feedback, point + 3,\\nif number is in negative_feedback, point - 1,\\nand use a min heap to find top k student.\\n\\n### python\\n```python\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        p_set, n_set = set(), set()\\n        for word in positive_feedback:\\n            cur = 0\\n            for ch in word:\\n                cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            p_set.add(cur)\\n        \\n        for word in negative_feedback:\\n            cur = 0\\n            for ch in word:\\n                cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            n_set.add(cur)\\n\\n        report_point = []\\n        for id_, rep in zip(student_id, report):\\n            cur = 0\\n            point = 0\\n            for ch in rep:\\n                if ch == \\' \\':\\n                    if cur in p_set: point += 3\\n                    elif cur in n_set: point -= 1\\n                    cur = 0\\n                    continue\\n                cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            \\n            if cur in p_set: point += 3\\n            elif cur in n_set: point -= 1\\n\\n            if len(report_point) < k: heappush(report_point, (point, -id_))\\n            elif len(report_point) == k and (point, -id_) > report_point[0]: \\n                heapreplace(report_point, (point, -id_))\\n\\n        return reversed([-heappop(report_point)[1] for _ in range(k)])\\n```\\n\\n### c++\\n```cpp\\nconst int base_1 = 29, base_2 = 31, mod = 1e9+7;\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> p_set, n_set;\\n        for (auto& word : positive_feedback) {\\n            int cur_1 = 0, cur_2 = 0;\\n            for (auto& ch: word) {\\n                cur_1 = (1L * cur_1 *  base_1 + ch - \\'a\\' + 1) % mod;\\n                cur_2 = (1L * cur_2 *  base_2 + ch - \\'a\\' + 1) % mod;\\n            }\\n            p_set.emplace(to_string(cur_1) + \\' \\' + to_string(cur_2));\\n        }\\n        for (auto& word : negative_feedback) {\\n            int cur_1 = 0, cur_2 = 0;\\n            for (auto& ch: word) {\\n                cur_1 = (1L * cur_1 *  base_1 + ch - \\'a\\' + 1) % mod;\\n                cur_2 = (1L * cur_2 *  base_2 + ch - \\'a\\' + 1) % mod;\\n            }\\n            n_set.emplace(to_string(cur_1) + \\' \\' + to_string(cur_2));\\n        }\\n        auto cmp = [] (auto& x, auto& y) {\\n            if (x.first == y.first) return y.second > x.second;\\n            return y.first < x.first;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> min_heap(cmp);\\n        int i = 0;\\n        for (auto& rep: report) {\\n            int point = 0, cur_1 = 0, cur_2 = 0;\\n            \\n            for (auto& ch: rep) {\\n                if (ch == \\' \\') {\\n                    string cur = to_string(cur_1) + \\' \\' + to_string(cur_2);\\n                    if (p_set.count(cur)) point += 3;\\n                    else if (n_set.count(cur)) point -= 1;\\n                    cur_1 = 0, cur_2 = 0;\\n                    continue;\\n                }\\n                cur_1 = (1L * cur_1 *  base_1 + ch - \\'a\\' + 1) % mod;\\n                cur_2 = (1L * cur_2 *  base_2 + ch - \\'a\\' + 1) % mod;\\n            }\\n            string cur = to_string(cur_1) + \\' \\' + to_string(cur_2);\\n            if (p_set.count(cur)) point += 3;\\n            else if (n_set.count(cur)) point -= 1;\\n            if (min_heap.size() < k) min_heap.emplace(point, student_id[i]);\\n            else if (min_heap.size() == k && (point > min_heap.top().first || point == min_heap.top().first && student_id[i] < min_heap.top().second)) {\\n                min_heap.pop();\\n                min_heap.emplace(point, student_id[i]);\\n            }\\n            i += 1;\\n        }\\n        vector<int> ans;\\n        while (!min_heap.empty()) {\\n            ans.emplace_back(min_heap.top().second);\\n            min_heap.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rolling Hash",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        p_set, n_set = set(), set()\\n        for word in positive_feedback:\\n            cur = 0\\n            for ch in word:\\n                cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            p_set.add(cur)\\n        \\n        for word in negative_feedback:\\n            cur = 0\\n            for ch in word:\\n                cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            n_set.add(cur)\\n\\n        report_point = []\\n        for id_, rep in zip(student_id, report):\\n            cur = 0\\n            point = 0\\n            for ch in rep:\\n                if ch == \\' \\':\\n                    if cur in p_set: point += 3\\n                    elif cur in n_set: point -= 1\\n                    cur = 0\\n                    continue\\n                cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            \\n            if cur in p_set: point += 3\\n            elif cur in n_set: point -= 1\\n\\n            if len(report_point) < k: heappush(report_point, (point, -id_))\\n            elif len(report_point) == k and (point, -id_) > report_point[0]: \\n                heapreplace(report_point, (point, -id_))\\n\\n        return reversed([-heappop(report_point)[1] for _ in range(k)])\\n```\n```cpp\\nconst int base_1 = 29, base_2 = 31, mod = 1e9+7;\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> p_set, n_set;\\n        for (auto& word : positive_feedback) {\\n            int cur_1 = 0, cur_2 = 0;\\n            for (auto& ch: word) {\\n                cur_1 = (1L * cur_1 *  base_1 + ch - \\'a\\' + 1) % mod;\\n                cur_2 = (1L * cur_2 *  base_2 + ch - \\'a\\' + 1) % mod;\\n            }\\n            p_set.emplace(to_string(cur_1) + \\' \\' + to_string(cur_2));\\n        }\\n        for (auto& word : negative_feedback) {\\n            int cur_1 = 0, cur_2 = 0;\\n            for (auto& ch: word) {\\n                cur_1 = (1L * cur_1 *  base_1 + ch - \\'a\\' + 1) % mod;\\n                cur_2 = (1L * cur_2 *  base_2 + ch - \\'a\\' + 1) % mod;\\n            }\\n            n_set.emplace(to_string(cur_1) + \\' \\' + to_string(cur_2));\\n        }\\n        auto cmp = [] (auto& x, auto& y) {\\n            if (x.first == y.first) return y.second > x.second;\\n            return y.first < x.first;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> min_heap(cmp);\\n        int i = 0;\\n        for (auto& rep: report) {\\n            int point = 0, cur_1 = 0, cur_2 = 0;\\n            \\n            for (auto& ch: rep) {\\n                if (ch == \\' \\') {\\n                    string cur = to_string(cur_1) + \\' \\' + to_string(cur_2);\\n                    if (p_set.count(cur)) point += 3;\\n                    else if (n_set.count(cur)) point -= 1;\\n                    cur_1 = 0, cur_2 = 0;\\n                    continue;\\n                }\\n                cur_1 = (1L * cur_1 *  base_1 + ch - \\'a\\' + 1) % mod;\\n                cur_2 = (1L * cur_2 *  base_2 + ch - \\'a\\' + 1) % mod;\\n            }\\n            string cur = to_string(cur_1) + \\' \\' + to_string(cur_2);\\n            if (p_set.count(cur)) point += 3;\\n            else if (n_set.count(cur)) point -= 1;\\n            if (min_heap.size() < k) min_heap.emplace(point, student_id[i]);\\n            else if (min_heap.size() == k && (point > min_heap.top().first || point == min_heap.top().first && student_id[i] < min_heap.top().second)) {\\n                min_heap.pop();\\n                min_heap.emplace(point, student_id[i]);\\n            }\\n            i += 1;\\n        }\\n        vector<int> ans;\\n        while (!min_heap.empty()) {\\n            ans.emplace_back(min_heap.top().second);\\n            min_heap.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062527,
                "title": "simple-python-solution",
                "content": "--> In Python, if you are searching for a value repeatedly in a list, it is better to convert that list into a set, as sets in Python are made using the hash table, so accessing/searching is o(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        \\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        score = []\\n        ids = []\\n\\n        for rep, _id in zip(report,student_id):\\n\\n            pts = 0\\n\\n            for word in rep.split():\\n                if word in positive_feedback: pts+=3\\n                elif word in negative_feedback: pts-=1\\n\\n            score.append((pts, _id))\\n\\n        sorted_list = sorted(score, key=lambda x:(-x[0], x[1]))\\n        \\n        for i in sorted_list[:k]:\\n            ids.append(i[1])\\n\\n        return ids   \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        \\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        score = []\\n        ids = []\\n\\n        for rep, _id in zip(report,student_id):\\n\\n            pts = 0\\n\\n            for word in rep.split():\\n                if word in positive_feedback: pts+=3\\n                elif word in negative_feedback: pts-=1\\n\\n            score.append((pts, _id))\\n\\n        sorted_list = sorted(score, key=lambda x:(-x[0], x[1]))\\n        \\n        for i in sorted_list[:k]:\\n            ids.append(i[1])\\n\\n        return ids   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059740,
                "title": "string-unordered-map-sorting-cpp",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static bool myCmp(const pair<int,int>&a , const pair<int,int> &b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n        return a.first >b.first;\\n    }\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int>value;\\n        for(const auto& str : positive_feedback){\\n            value[str] = 3;\\n        }\\n        for(const auto& str : negative_feedback){\\n            value[str] = -1;\\n        }\\n        int n = report.size();\\n        vector<pair<int,int>>pq;\\n        for (int i = 0; i < report.size(); i++) {\\n            string feedback = report[i];\\n            int index = 0;\\n            int score = 0;\\n            for (int j = 0; j < feedback.size(); j++) {\\n                if (feedback[j] == \\' \\') {\\n                    string temp = feedback.substr(index, j - index);\\n                    // cout << temp << endl;\\n                    if(value.count(temp))\\n                        score += value[temp];\\n                    index = j + 1;\\n                }\\n            }\\n            // Print the last word in the string\\n            // cout << feedback.substr(index) << endl;\\n            if(value.count(feedback.substr(index)))\\n               score +=value[feedback.substr(index)];\\n            // cout << student_id[i] << \" \" << score << endl;\\n            pq.push_back({score , student_id[i]});\\n        }\\n        vector<int>topK;\\n        sort(pq.begin() , pq.end() , myCmp);\\n        for(int i=0;i<k;i++){\\n            topK.push_back(pq[i].second);\\n        }\\n        return topK;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool myCmp(const pair<int,int>&a , const pair<int,int> &b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n        return a.first >b.first;\\n    }\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int>value;\\n        for(const auto& str : positive_feedback){\\n            value[str] = 3;\\n        }\\n        for(const auto& str : negative_feedback){\\n            value[str] = -1;\\n        }\\n        int n = report.size();\\n        vector<pair<int,int>>pq;\\n        for (int i = 0; i < report.size(); i++) {\\n            string feedback = report[i];\\n            int index = 0;\\n            int score = 0;\\n            for (int j = 0; j < feedback.size(); j++) {\\n                if (feedback[j] == \\' \\') {\\n                    string temp = feedback.substr(index, j - index);\\n                    // cout << temp << endl;\\n                    if(value.count(temp))\\n                        score += value[temp];\\n                    index = j + 1;\\n                }\\n            }\\n            // Print the last word in the string\\n            // cout << feedback.substr(index) << endl;\\n            if(value.count(feedback.substr(index)))\\n               score +=value[feedback.substr(index)];\\n            // cout << student_id[i] << \" \" << score << endl;\\n            pq.push_back({score , student_id[i]});\\n        }\\n        vector<int>topK;\\n        sort(pq.begin() , pq.end() , myCmp);\\n        for(int i=0;i<k;i++){\\n            topK.push_back(pq[i].second);\\n        }\\n        return topK;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4042947,
                "title": "easiest-fastest-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        \\n        IList<int> res = new List<int>();\\n\\n        PriorityQueue<int, (int, int)> pq = new PriorityQueue<int, (int, int)>(Comparer<(int, int)>.Create((a, b) => b.Item1 == a.Item1?a.Item2 - b.Item2: b.Item1 - a.Item1));\\n\\n        HashSet<string> positiveWords = new HashSet<string>();\\n        HashSet<string> negativeWords = new HashSet<string>();\\n        for(int i = 0; i < positive_feedback.Length; i++){\\n            positiveWords.Add(positive_feedback[i]);\\n        }\\n        for(int i = 0; i < negative_feedback.Length; i++){\\n            negativeWords.Add(negative_feedback[i]);\\n        }\\n\\n        for(int i = 0; i < report.Length; i++){\\n            int currentStudentId = student_id[i];\\n            string[] reportWords = report[i].Split(\" \");\\n            int totalResult = 0;\\n            for(int j = 0; j < reportWords.Length; j++){\\n                string wordTemp = reportWords[j];\\n                if(positiveWords.Contains(wordTemp)){\\n                    totalResult += 3;\\n                }else if(negativeWords.Contains(wordTemp)){\\n                    totalResult -= 1;\\n                }\\n            }\\n            pq.Enqueue(currentStudentId, (totalResult, currentStudentId));\\n        }\\n\\n        int x = 0;\\n        while(x < k){\\n            res.Add(pq.Dequeue());\\n            x++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        \\n        IList<int> res = new List<int>();\\n\\n        PriorityQueue<int, (int, int)> pq = new PriorityQueue<int, (int, int)>(Comparer<(int, int)>.Create((a, b) => b.Item1 == a.Item1?a.Item2 - b.Item2: b.Item1 - a.Item1));\\n\\n        HashSet<string> positiveWords = new HashSet<string>();\\n        HashSet<string> negativeWords = new HashSet<string>();\\n        for(int i = 0; i < positive_feedback.Length; i++){\\n            positiveWords.Add(positive_feedback[i]);\\n        }\\n        for(int i = 0; i < negative_feedback.Length; i++){\\n            negativeWords.Add(negative_feedback[i]);\\n        }\\n\\n        for(int i = 0; i < report.Length; i++){\\n            int currentStudentId = student_id[i];\\n            string[] reportWords = report[i].Split(\" \");\\n            int totalResult = 0;\\n            for(int j = 0; j < reportWords.Length; j++){\\n                string wordTemp = reportWords[j];\\n                if(positiveWords.Contains(wordTemp)){\\n                    totalResult += 3;\\n                }else if(negativeWords.Contains(wordTemp)){\\n                    totalResult -= 1;\\n                }\\n            }\\n            pq.Enqueue(currentStudentId, (totalResult, currentStudentId));\\n        }\\n\\n        int x = 0;\\n        while(x < k){\\n            res.Add(pq.Dequeue());\\n            x++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972565,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> ps = new HashSet<>();\\n        Set<String> ns = new HashSet<>();\\n        \\n        // String s1 = report.split(\",\");\\n        for(String s: positive_feedback){\\n            ps.add(s);\\n        }\\n        for(String s: negative_feedback){\\n            ns.add(s);\\n        }\\n        int i=0, n= report.length;\\n        int[][] res = new int[n][2];\\n        for(String s: report){\\n            String[] s1 = s.split(\" \");\\n            int ans =0;\\n            for(String s2: s1){\\n                if(ps.contains(s2)){\\n                    ans += 3;\\n                }\\n                else if(ns.contains(s2)){\\n                    ans -= 1;\\n                }\\n            }\\n            res[i][0] = student_id[i];\\n            res[i][1] = ans;\\n            i++;\\n        }\\n        Arrays.sort(res, (a,b) -> a[1]==b[1]?a[0]-b[0] : b[1]-a[1]);\\n        List<Integer> list = new ArrayList<>();\\n        for(int j=0;j <k;j++){\\n            list.add(res[j][0]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> ps = new HashSet<>();\\n        Set<String> ns = new HashSet<>();\\n        \\n        // String s1 = report.split(\",\");\\n        for(String s: positive_feedback){\\n            ps.add(s);\\n        }\\n        for(String s: negative_feedback){\\n            ns.add(s);\\n        }\\n        int i=0, n= report.length;\\n        int[][] res = new int[n][2];\\n        for(String s: report){\\n            String[] s1 = s.split(\" \");\\n            int ans =0;\\n            for(String s2: s1){\\n                if(ps.contains(s2)){\\n                    ans += 3;\\n                }\\n                else if(ns.contains(s2)){\\n                    ans -= 1;\\n                }\\n            }\\n            res[i][0] = student_id[i];\\n            res[i][1] = ans;\\n            i++;\\n        }\\n        Arrays.sort(res, (a,b) -> a[1]==b[1]?a[0]-b[0] : b[1]-a[1]);\\n        List<Integer> list = new ArrayList<>();\\n        for(int j=0;j <k;j++){\\n            list.add(res[j][0]);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934664,
                "title": "easy-java-solution-hashset-priority-queue-custom-comparator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static class Feed{\\n        int id;\\n        int point;\\n\\n        Feed(int id, int point){\\n            this.id = id;\\n            this.point = point;\\n        }\\n    }\\n\\n    public static class FeedComparator implements Comparator<Feed>{\\n        public int compare(Feed f1, Feed f2){\\n            if(f1.point<f2.point) return 1;\\n            else if(f1.point>f2.point) return -1;\\n            else{\\n                if(f1.id>f2.id) return 1;\\n                else if(f1.id<f2.id) return -1;\\n                else return 0;\\n            }\\n        }\\n    }\\n\\n\\n    public List<Integer> topStudents(String[] positive, String[] negative, String[] report, int[] student, int k) {\\n\\n        HashSet<String> posi = new HashSet<>();\\n        HashSet<String> negi = new HashSet<>();\\n\\n        for(int i=0; i<positive.length; i++){\\n            posi.add(positive[i]);\\n        }\\n\\n        for(int i=0; i<negative.length; i++){\\n            negi.add(negative[i]);\\n        }\\n\\n        int idx = 0;\\n\\n        PriorityQueue<Feed> pq = new PriorityQueue<>(new FeedComparator());\\n\\n        for(int i=0; i<report.length; i++){\\n            String s[] = report[i].split(\" \");\\n            int point = 0;\\n            for(int j=0; j<s.length; j++){\\n                if(posi.contains(s[j])) point+=3;\\n                else if(negi.contains(s[j])) point-=1;\\n            }\\n            pq.add(new Feed(student[idx],point));\\n            idx++;\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\n        while(k>0){\\n            ans.add(pq.remove().id);\\n            k--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static class Feed{\\n        int id;\\n        int point;\\n\\n        Feed(int id, int point){\\n            this.id = id;\\n            this.point = point;\\n        }\\n    }\\n\\n    public static class FeedComparator implements Comparator<Feed>{\\n        public int compare(Feed f1, Feed f2){\\n            if(f1.point<f2.point) return 1;\\n            else if(f1.point>f2.point) return -1;\\n            else{\\n                if(f1.id>f2.id) return 1;\\n                else if(f1.id<f2.id) return -1;\\n                else return 0;\\n            }\\n        }\\n    }\\n\\n\\n    public List<Integer> topStudents(String[] positive, String[] negative, String[] report, int[] student, int k) {\\n\\n        HashSet<String> posi = new HashSet<>();\\n        HashSet<String> negi = new HashSet<>();\\n\\n        for(int i=0; i<positive.length; i++){\\n            posi.add(positive[i]);\\n        }\\n\\n        for(int i=0; i<negative.length; i++){\\n            negi.add(negative[i]);\\n        }\\n\\n        int idx = 0;\\n\\n        PriorityQueue<Feed> pq = new PriorityQueue<>(new FeedComparator());\\n\\n        for(int i=0; i<report.length; i++){\\n            String s[] = report[i].split(\" \");\\n            int point = 0;\\n            for(int j=0; j<s.length; j++){\\n                if(posi.contains(s[j])) point+=3;\\n                else if(negi.contains(s[j])) point-=1;\\n            }\\n            pq.add(new Feed(student[idx],point));\\n            idx++;\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\n        while(k>0){\\n            ans.add(pq.remove().id);\\n            k--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898712,
                "title": "feedback-hash-table",
                "content": "# Approach\\n- Create a dictionary containing positive and feedbacks as key with respective points as value.\\n- Iterate through students, for each, take the report and split it in words list.\\n- For each word in the report, check its points in the feedback dictionary and accumulate the points in a variable.\\n- Add the student in a list of list of int, for each item in the list, add the student id and its points.\\n- Order the list by descending, then by user id and take the first k elements.\\n\\n# Complexity\\nTime complexity:\\n- n = student count\\n- m = max word count in reports\\n\\n$$O(m*n + nlogn)$$\\n\\nSpace complexity:\\n- f = positive + negative feedback size\\n- t = top students list\\n\\n$$O(f + t)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n        public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k)\\n        {\\n            var feedbacks = new Dictionary<string, int>();\\n            foreach (var feedback in positive_feedback)\\n                if(!feedbacks.ContainsKey(feedback))\\n                    feedbacks.Add(feedback, 3);\\n\\n            foreach (var feedback in negative_feedback)\\n                if (!feedbacks.ContainsKey(feedback))\\n                    feedbacks.Add(feedback, -1);\\n\\n            var topStudents = new List<int[]>();\\n\\n            for (var i = 0; i < student_id.Length; i++)\\n            {\\n                var id = student_id[i];\\n                var reportItems = report[i].Split(\\' \\');\\n\\n                var points = 0;\\n                for (var j = 0; j < reportItems.Length; j++)\\n                {\\n                    if (feedbacks.ContainsKey(reportItems[j]))\\n                        points += feedbacks[reportItems[j]];\\n                }\\n\\n                topStudents.Add(new int[] { id, points });\\n            }\\n\\n            return topStudents\\n                .OrderByDescending(a => a[1])\\n                .ThenBy(a => a[0]) // Order by id for when both students have the same points\\n                .Select(v => v[0])\\n                .Take(k)\\n                .ToList();\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k)\\n        {\\n            var feedbacks = new Dictionary<string, int>();\\n            foreach (var feedback in positive_feedback)\\n                if(!feedbacks.ContainsKey(feedback))\\n                    feedbacks.Add(feedback, 3);\\n\\n            foreach (var feedback in negative_feedback)\\n                if (!feedbacks.ContainsKey(feedback))\\n                    feedbacks.Add(feedback, -1);\\n\\n            var topStudents = new List<int[]>();\\n\\n            for (var i = 0; i < student_id.Length; i++)\\n            {\\n                var id = student_id[i];\\n                var reportItems = report[i].Split(\\' \\');\\n\\n                var points = 0;\\n                for (var j = 0; j < reportItems.Length; j++)\\n                {\\n                    if (feedbacks.ContainsKey(reportItems[j]))\\n                        points += feedbacks[reportItems[j]];\\n                }\\n\\n                topStudents.Add(new int[] { id, points });\\n            }\\n\\n            return topStudents\\n                .OrderByDescending(a => a[1])\\n                .ThenBy(a => a[0]) // Order by id for when both students have the same points\\n                .Select(v => v[0])\\n                .Take(k)\\n                .ToList();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867810,
                "title": "max-heap-based-on-score-id",
                "content": "# Intuition\\nFirst create two hashmaps for negative and positive feedbacks\\nThen create a max heap that stores (score,id)\\nThen just iterate over each report and calculate the score.\\nThen push the (score,id) in the maxheap\\nThen iterate over the maxheap and pop the first k elements\\nSo if we have tied score, then thats when id in the tuple will come in play and those with lower id will be the top most element.\\n\\n# Approach\\nMake use of max heap, typical top k element\\n\\n# Complexity\\n- Time complexity:\\nO(len(positive_feedback)) + O(len(negative_feedback)) + O(len(report)* ( O(len(avgReport)) + O(log(len(report))))) + O(klogk) \\n\\n- Space complexity:\\nO(len(report)) + O(len(negative_feedback)) + O(len(positive_feedback))\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n\\n        #max heap to store the (score,id)\\n\\n        p = {}\\n\\n        for feedback in positive_feedback:\\n            p[feedback] = 3\\n        \\n        n = {}\\n\\n        for feedback in negative_feedback:\\n            n[feedback] = -1\\n        \\n        maxHeap = []\\n\\n        for i in range(len(report)):\\n            r = report[i].split(\" \")\\n            s = student_id[i]\\n\\n            score = 0 \\n\\n            for w in r:\\n                score += p.get(w,0)\\n                score += n.get(w,0)\\n\\n            heapq.heappush(maxHeap,(-1 * score,s))\\n        \\n        answer = []\\n\\n        while maxHeap and k > 0:\\n            answer.append(heapq.heappop(maxHeap)[-1])\\n            k-=1\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n\\n        #max heap to store the (score,id)\\n\\n        p = {}\\n\\n        for feedback in positive_feedback:\\n            p[feedback] = 3\\n        \\n        n = {}\\n\\n        for feedback in negative_feedback:\\n            n[feedback] = -1\\n        \\n        maxHeap = []\\n\\n        for i in range(len(report)):\\n            r = report[i].split(\" \")\\n            s = student_id[i]\\n\\n            score = 0 \\n\\n            for w in r:\\n                score += p.get(w,0)\\n                score += n.get(w,0)\\n\\n            heapq.heappush(maxHeap,(-1 * score,s))\\n        \\n        answer = []\\n\\n        while maxHeap and k > 0:\\n            answer.append(heapq.heappop(maxHeap)[-1])\\n            k-=1\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852989,
                "title": "ok",
                "content": "```\\nvector<int> topStudents(vector<string>& p, vector<string>& n, vector<string>& r, vector<int>& id, int k)\\n{\\n\\tvector<pair<int,int>> v(size(r));\\n\\tunordered_set<string> P(begin(p), end(p)), N(begin(n), end(n));\\n\\tfor(int i{}; i<size(r); ++i)\\n\\t{\\n\\t\\tint t{};\\n\\t\\tstringstream ss{r[i]};\\n\\t\\tfor(string s{}; ss>>s; )\\n\\t\\t\\tif(P.count(s)) t -= 3;\\n\\t\\t\\telse if(N.count(s)) t += 1;\\n\\t\\tv[i] = {t, id[i]};\\n\\t}\\n\\tsort(begin(v), end(v));\\n\\tvector<int> out(k);\\n\\tfor(int i{}; i<k; ++i)\\n\\t\\tout[i] = v[i].second;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> topStudents(vector<string>& p, vector<string>& n, vector<string>& r, vector<int>& id, int k)\\n{\\n\\tvector<pair<int,int>> v(size(r));\\n\\tunordered_set<string> P(begin(p), end(p)), N(begin(n), end(n));\\n\\tfor(int i{}; i<size(r); ++i)\\n\\t{\\n\\t\\tint t{};\\n\\t\\tstringstream ss{r[i]};\\n\\t\\tfor(string s{}; ss>>s; )\\n\\t\\t\\tif(P.count(s)) t -= 3;\\n\\t\\t\\telse if(N.count(s)) t += 1;\\n\\t\\tv[i] = {t, id[i]};\\n\\t}\\n\\tsort(begin(v), end(v));\\n\\tvector<int> out(k);\\n\\tfor(int i{}; i<k; ++i)\\n\\t\\tout[i] = v[i].second;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851009,
                "title": "java-solution-using-pq-comparable-interface-student-class",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class Student implements Comparable<Student>{\\n        int point;\\n        int id;\\n\\n        public Student(int id, int point) {\\n            this.id = id;\\n            this.point = point;\\n        }\\n\\n        private int getPoint() {\\n            return this.point;\\n        }\\n\\n        private int getId() {\\n            return this.id;\\n        }\\n\\n        @Override\\n        public int compareTo(Student o) {\\n            if (this.point == o.point) {\\n                return this.id > o.id ? -1 : 1;\\n            }\\n            return this.point < o.point ? - 1: 1;\\n        }\\n    }\\n\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        int n = report.length;\\n        Set<String> positive = createSet(positive_feedback);\\n        Set<String> negative = createSet(negative_feedback);\\n        PriorityQueue<Student> pq = new PriorityQueue<>();\\n        for (int i = 0; i < n; i ++) {\\n            Student student = generateStudent(positive, negative, report[i], student_id[i]);\\n            if (i < k) {\\n                pq.offer(student);\\n            } else if (pq.peek().getPoint() < student.getPoint()) {\\n                pq.poll();\\n                pq.offer(student);\\n            } else if (pq.peek().getPoint() == student.getPoint()) {\\n                if (pq.peek().getId() > student.getId()) {\\n                    pq.poll();\\n                    pq.offer(student);\\n                }\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        while(!pq.isEmpty()) {\\n            result.add(pq.poll().getId());\\n        }\\n        reverse(result);\\n        return result;\\n    }\\n\\n    private void reverse(List<Integer> list) {\\n        int i = 0;\\n        int j = list.size() -1 ;\\n        while(i < j) {\\n            int tmp = list.get(i);\\n            list.set(i, list.get(j));\\n            list.set(j, tmp);\\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n\\n    private Student generateStudent(Set<String> positive, Set<String> negative, String report, int id) {\\n        int point = 0;\\n        int slow = 0;\\n        int fast = 0;\\n        while(fast <= report.length()) {\\n            String word = null;\\n            if (fast == report.length()) {\\n                word = report.substring(slow, fast);\\n                fast ++;\\n            } else if (report.charAt(fast) == \\' \\') {\\n                word = report.substring(slow, fast);\\n                fast++;\\n                slow = fast;\\n            } else {\\n                fast ++;\\n            }\\n            if (word != null && positive.contains(word)) {\\n                point = point + 3;\\n            }\\n            if (word != null && negative.contains(word)) {\\n                point = point - 1;\\n            }\\n        }\\n        Student student = new Student(id, point);\\n        return student;\\n    }\\n\\n    private Set<String> createSet(String[] feedback) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: feedback) {\\n            set.add(str);\\n        }\\n        return set;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Student implements Comparable<Student>{\\n        int point;\\n        int id;\\n\\n        public Student(int id, int point) {\\n            this.id = id;\\n            this.point = point;\\n        }\\n\\n        private int getPoint() {\\n            return this.point;\\n        }\\n\\n        private int getId() {\\n            return this.id;\\n        }\\n\\n        @Override\\n        public int compareTo(Student o) {\\n            if (this.point == o.point) {\\n                return this.id > o.id ? -1 : 1;\\n            }\\n            return this.point < o.point ? - 1: 1;\\n        }\\n    }\\n\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        int n = report.length;\\n        Set<String> positive = createSet(positive_feedback);\\n        Set<String> negative = createSet(negative_feedback);\\n        PriorityQueue<Student> pq = new PriorityQueue<>();\\n        for (int i = 0; i < n; i ++) {\\n            Student student = generateStudent(positive, negative, report[i], student_id[i]);\\n            if (i < k) {\\n                pq.offer(student);\\n            } else if (pq.peek().getPoint() < student.getPoint()) {\\n                pq.poll();\\n                pq.offer(student);\\n            } else if (pq.peek().getPoint() == student.getPoint()) {\\n                if (pq.peek().getId() > student.getId()) {\\n                    pq.poll();\\n                    pq.offer(student);\\n                }\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        while(!pq.isEmpty()) {\\n            result.add(pq.poll().getId());\\n        }\\n        reverse(result);\\n        return result;\\n    }\\n\\n    private void reverse(List<Integer> list) {\\n        int i = 0;\\n        int j = list.size() -1 ;\\n        while(i < j) {\\n            int tmp = list.get(i);\\n            list.set(i, list.get(j));\\n            list.set(j, tmp);\\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n\\n    private Student generateStudent(Set<String> positive, Set<String> negative, String report, int id) {\\n        int point = 0;\\n        int slow = 0;\\n        int fast = 0;\\n        while(fast <= report.length()) {\\n            String word = null;\\n            if (fast == report.length()) {\\n                word = report.substring(slow, fast);\\n                fast ++;\\n            } else if (report.charAt(fast) == \\' \\') {\\n                word = report.substring(slow, fast);\\n                fast++;\\n                slow = fast;\\n            } else {\\n                fast ++;\\n            }\\n            if (word != null && positive.contains(word)) {\\n                point = point + 3;\\n            }\\n            if (word != null && negative.contains(word)) {\\n                point = point - 1;\\n            }\\n        }\\n        Student student = new Student(id, point);\\n        return student;\\n    }\\n\\n    private Set<String> createSet(String[] feedback) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: feedback) {\\n            set.add(str);\\n        }\\n        return set;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825764,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    static class StudentScore {\\n        int studentId;\\n        int score;\\n\\n        public StudentScore(int studentId, int score) {\\n            this.studentId = studentId;\\n            this.score = score;\\n        }\\n    }\\n\\n    public int getMeTheTotalScore(Set<String> positive_feedback, Set<String> negative_feedback, String report) {\\n        String[] val = report.split(\" \");\\n        int count = 0;\\n        for (String word : val) {\\n            if (positive_feedback.contains(word))\\n                count += 3;\\n            if (negative_feedback.contains(word))\\n                count -= 1;\\n        }\\n        return count;\\n    }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> pSet = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> nSet = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        PriorityQueue<StudentScore> pq = new PriorityQueue<>((a, b) -> {\\n            if (a.score == b.score) {\\n                return a.studentId - b.studentId;\\n            } else {\\n                return b.score - a.score;\\n            }\\n        });\\n\\n        for (int i = 0; i < student_id.length; i++) {\\n            int score = getMeTheTotalScore(pSet, nSet, report[i]);\\n            pq.offer(new StudentScore(student_id[i], score));\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        while (k > 0 && !pq.isEmpty()) {\\n            result.add(pq.poll().studentId);\\n            --k;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    static class StudentScore {\\n        int studentId;\\n        int score;\\n\\n        public StudentScore(int studentId, int score) {\\n            this.studentId = studentId;\\n            this.score = score;\\n        }\\n    }\\n\\n    public int getMeTheTotalScore(Set<String> positive_feedback, Set<String> negative_feedback, String report) {\\n        String[] val = report.split(\" \");\\n        int count = 0;\\n        for (String word : val) {\\n            if (positive_feedback.contains(word))\\n                count += 3;\\n            if (negative_feedback.contains(word))\\n                count -= 1;\\n        }\\n        return count;\\n    }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> pSet = new HashSet<>(Arrays.asList(positive_feedback));\\n        Set<String> nSet = new HashSet<>(Arrays.asList(negative_feedback));\\n\\n        PriorityQueue<StudentScore> pq = new PriorityQueue<>((a, b) -> {\\n            if (a.score == b.score) {\\n                return a.studentId - b.studentId;\\n            } else {\\n                return b.score - a.score;\\n            }\\n        });\\n\\n        for (int i = 0; i < student_id.length; i++) {\\n            int score = getMeTheTotalScore(pSet, nSet, report[i]);\\n            pq.offer(new StudentScore(student_id[i], score));\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        while (k > 0 && !pq.isEmpty()) {\\n            result.add(pq.poll().studentId);\\n            --k;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791923,
                "title": "easy-java-solution-using-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashSet<String> pos = new HashSet<>();\\n        for(String pos_fed : positive_feedback) {\\n            pos.add(pos_fed);\\n        }\\n        HashSet<String> neg = new HashSet<>();\\n        for(String neg_fed : negative_feedback) {\\n            neg.add(neg_fed);\\n        }\\n        int[][] student_score = new int[report.length][2];\\n        for(int i=0;i<report.length;i++) {\\n            int score = 0;\\n            String[] words = report[i].split(\" \");\\n            for(String word:words) {\\n                if(pos.contains(word)) score += 3;\\n                else if(neg.contains(word)) score -= 1;\\n            }\\n            student_score[i] = new int[]{student_id[i],score};\\n        }\\n        Arrays.sort(student_score,(a,b) -> {\\n            if(a[1] == b[1]) return a[0] - b[0];\\n            else return b[1] - a[1];\\n        });\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<k;i++) {\\n            ans.add(student_score[i][0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashSet<String> pos = new HashSet<>();\\n        for(String pos_fed : positive_feedback) {\\n            pos.add(pos_fed);\\n        }\\n        HashSet<String> neg = new HashSet<>();\\n        for(String neg_fed : negative_feedback) {\\n            neg.add(neg_fed);\\n        }\\n        int[][] student_score = new int[report.length][2];\\n        for(int i=0;i<report.length;i++) {\\n            int score = 0;\\n            String[] words = report[i].split(\" \");\\n            for(String word:words) {\\n                if(pos.contains(word)) score += 3;\\n                else if(neg.contains(word)) score -= 1;\\n            }\\n            student_score[i] = new int[]{student_id[i],score};\\n        }\\n        Arrays.sort(student_score,(a,b) -> {\\n            if(a[1] == b[1]) return a[0] - b[0];\\n            else return b[1] - a[1];\\n        });\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<k;i++) {\\n            ans.add(student_score[i][0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756832,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        good = set(positive_feedback)\\n        bad = set(negative_feedback)\\n        hm = dict()\\n        N = len(report)\\n\\n        for i in range(N):\\n            sid = student_id[i]\\n            if sid not in hm:\\n                hm[sid] = 0\\n            \\n            rp = report[i].split(\\' \\')\\n            for word in rp:\\n                if word in good:\\n                    hm[sid]+=3\\n                elif word in bad:\\n                    hm[sid]-=1\\n        \\n        lst = []\\n        for key in hm.keys():\\n            lst.append((key, hm[key]))\\n        lst.sort(key=lambda tup:(-tup[1], tup[0]))\\n\\n        ans = []\\n        for i in range(k):\\n            ans.append(lst[i][0])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        good = set(positive_feedback)\\n        bad = set(negative_feedback)\\n        hm = dict()\\n        N = len(report)\\n\\n        for i in range(N):\\n            sid = student_id[i]\\n            if sid not in hm:\\n                hm[sid] = 0\\n            \\n            rp = report[i].split(\\' \\')\\n            for word in rp:\\n                if word in good:\\n                    hm[sid]+=3\\n                elif word in bad:\\n                    hm[sid]-=1\\n        \\n        lst = []\\n        for key in hm.keys():\\n            lst.append((key, hm[key]))\\n        lst.sort(key=lambda tup:(-tup[1], tup[0]))\\n\\n        ans = []\\n        for i in range(k):\\n            ans.append(lst[i][0])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749066,
                "title": "priority-queue-c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positive, negative;\\n        for(auto &feedback:positive_feedback) positive.insert(feedback);\\n        for(auto &feedback:negative_feedback) negative.insert(feedback);\\n        \\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < student_id.size(); i++) {\\n            int points = 0;\\n            string word = \"\";\\n            string rep = report[i];\\n            rep += \\' \\';\\n            for(auto &ch:rep) {\\n                if(ch != \\' \\') word += ch;\\n                else {\\n                    if(positive.count(word)) points += 3;\\n                    else if(negative.count(word)) points -= 1;\\n                    word = \"\";\\n                }\\n            }\\n            pq.push({ points, -student_id[i] });\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(k--) {\\n            ans.push_back(-pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Queue",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positive, negative;\\n        for(auto &feedback:positive_feedback) positive.insert(feedback);\\n        for(auto &feedback:negative_feedback) negative.insert(feedback);\\n        \\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < student_id.size(); i++) {\\n            int points = 0;\\n            string word = \"\";\\n            string rep = report[i];\\n            rep += \\' \\';\\n            for(auto &ch:rep) {\\n                if(ch != \\' \\') word += ch;\\n                else {\\n                    if(positive.count(word)) points += 3;\\n                    else if(negative.count(word)) points -= 1;\\n                    word = \"\";\\n                }\\n            }\\n            pq.push({ points, -student_id[i] });\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(k--) {\\n            ans.push_back(-pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742245,
                "title": "priority-queue-trie-c",
                "content": "# Intuition\\nWe can use a trie to `grade\\' reports by iterating through the letters, and resetting to the root whenever we reach the end of a word. We build the trie from the positive and negative feedback lists, setting the scores of the terminal nodes accordingly. Uses a priority queue with a custom comparator to pop the students with the lowest rank first; so, we\\'ll need to reverse the results.\\n\\n# Code\\n```\\nclass Solution {\\n    struct Comparator {\\n        bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {\\n            if (a.first == b.first) {\\n                return a.second < b.second;\\n            } else {\\n                return a.first > b.first;\\n            }\\n        }\\n    };\\n\\n    struct TrieNode {\\n        map<char, TrieNode> children_;\\n        int points = 0;\\n\\n        TrieNode* getChild(char c) {\\n            auto search = children_.find(c);\\n            if (search == children_.end()) {\\n                const auto& [it, _] = children_.emplace(c, TrieNode{});\\n                return &(it->second);\\n            } else {\\n                return &(search->second);\\n            }\\n        }\\n\\n\\n        const TrieNode* getChildStrict(char c) const {\\n            auto search = children_.find(c);\\n            if (search == children_.end()) {\\n                return nullptr;\\n            } else {\\n                return &(search->second);\\n            }\\n        }\\n    };\\npublic:\\n\\n    int getScore(const TrieNode* root, string& report) {\\n        int n = report.size();\\n        int score = 0;\\n\\n        const TrieNode* node = root;\\n        for (int i = 0; i <= n; i++) {\\n            const char& c = report[i];\\n            if (c == \\' \\' || c == \\'\\\\0\\') {\\n                score += (node ? node->points : 0);\\n                node = root;\\n            } else {\\n                node = (node ? node->getChildStrict(c) : nullptr);\\n            }\\n        }\\n\\n        return score;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = report.size();\\n\\n        TrieNode root;\\n\\n        for (const string& word : positive_feedback) {\\n            TrieNode* node = &root;\\n            for (const char& c : word) {\\n                node = node->getChild(c);\\n            }\\n            node->points = 3;\\n        }\\n\\n        for (const string& word : negative_feedback) {\\n            TrieNode* node = &root;\\n            for (const char& c : word) {\\n                node = node->getChild(c);\\n            }\\n            node->points = -1;\\n        }\\n\\n        priority_queue<pair<int, int>, std::vector<pair<int, int>>, Comparator> points;\\n        for (int i = 0; i < n; i++) {\\n            points.emplace(\\n                getScore(&root, report[i]),\\n                student_id[i]\\n            );\\n\\n            if (points.size() > k) {\\n                points.pop();\\n            }\\n        }\\n\\n        vector<int> res;\\n        res.reserve(k);\\n\\n        while (!points.empty()) {\\n            auto& [_, id] = points.top();\\n            res.emplace_back(id);\\n            points.pop();\\n        }\\n\\n        reverse(res.begin(), res.end());\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# Follow-up optimization\\nDo you see how to eliminate the `res.reverse`? What\\'s the approximate speedup for doing so?",
                "solutionTags": [
                    "C++",
                    "Trie",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    struct Comparator {\\n        bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {\\n            if (a.first == b.first) {\\n                return a.second < b.second;\\n            } else {\\n                return a.first > b.first;\\n            }\\n        }\\n    };\\n\\n    struct TrieNode {\\n        map<char, TrieNode> children_;\\n        int points = 0;\\n\\n        TrieNode* getChild(char c) {\\n            auto search = children_.find(c);\\n            if (search == children_.end()) {\\n                const auto& [it, _] = children_.emplace(c, TrieNode{});\\n                return &(it->second);\\n            } else {\\n                return &(search->second);\\n            }\\n        }\\n\\n\\n        const TrieNode* getChildStrict(char c) const {\\n            auto search = children_.find(c);\\n            if (search == children_.end()) {\\n                return nullptr;\\n            } else {\\n                return &(search->second);\\n            }\\n        }\\n    };\\npublic:\\n\\n    int getScore(const TrieNode* root, string& report) {\\n        int n = report.size();\\n        int score = 0;\\n\\n        const TrieNode* node = root;\\n        for (int i = 0; i <= n; i++) {\\n            const char& c = report[i];\\n            if (c == \\' \\' || c == \\'\\\\0\\') {\\n                score += (node ? node->points : 0);\\n                node = root;\\n            } else {\\n                node = (node ? node->getChildStrict(c) : nullptr);\\n            }\\n        }\\n\\n        return score;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = report.size();\\n\\n        TrieNode root;\\n\\n        for (const string& word : positive_feedback) {\\n            TrieNode* node = &root;\\n            for (const char& c : word) {\\n                node = node->getChild(c);\\n            }\\n            node->points = 3;\\n        }\\n\\n        for (const string& word : negative_feedback) {\\n            TrieNode* node = &root;\\n            for (const char& c : word) {\\n                node = node->getChild(c);\\n            }\\n            node->points = -1;\\n        }\\n\\n        priority_queue<pair<int, int>, std::vector<pair<int, int>>, Comparator> points;\\n        for (int i = 0; i < n; i++) {\\n            points.emplace(\\n                getScore(&root, report[i]),\\n                student_id[i]\\n            );\\n\\n            if (points.size() > k) {\\n                points.pop();\\n            }\\n        }\\n\\n        vector<int> res;\\n        res.reserve(k);\\n\\n        while (!points.empty()) {\\n            auto& [_, id] = points.top();\\n            res.emplace_back(id);\\n            points.pop();\\n        }\\n\\n        reverse(res.begin(), res.end());\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737998,
                "title": "simple-priority-queue-to-store-top-k-students",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        var posFeedback = new HashSet<String>(Arrays.asList(positive_feedback));\\n        var negFeedback = new HashSet<String>(Arrays.asList(negative_feedback));\\n        var topKStudents = new PriorityQueue<int[]>((r1, r2) -> {\\n            if(r1[0] == r2[0]){\\n                return r2[1] - r1[1];\\n            }\\n            return r1[0] - r2[0];\\n        });\\n        for(int i = 0; i < report.length; i++){\\n            int currRank = 0;\\n            for(String word : report[i].split(\" \")){\\n                if(posFeedback.contains(word))\\n                    currRank += 3;\\n                else if(negFeedback.contains(word))\\n                    currRank -= 1;\\n            }\\n            topKStudents.add(new int[]{currRank, student_id[i]});\\n            if(topKStudents.size() > k){\\n                topKStudents.remove();\\n            }\\n        }\\n        var result = new ArrayList<Integer>();\\n        while(!topKStudents.isEmpty()){\\n            result.add(0, topKStudents.remove()[1]);\\n        }\\n        return result;\\n    }\\n}\\n\\n/**\\n* Push positive array into positive set = O(P)\\n* Push negative array into negative set = O(N)\\n* convert each report split by a space = O(R * 100)\\n\\n* Create a rank map where key is report id and value int rank\\n* Iterate over the report and split the current report by \\' \\' and check each word in contians in both pos and neg array = O(R * 100)\\n* Every time after calculating the ponits we add it into the min heap of size K = O(KLogK)\\n* Finally use the min heap and add it to the result in the revers order\\n\\nTC: O(R * KLogK) \\nSC: O(P) + O(N) + O(K)\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        var posFeedback = new HashSet<String>(Arrays.asList(positive_feedback));\\n        var negFeedback = new HashSet<String>(Arrays.asList(negative_feedback));\\n        var topKStudents = new PriorityQueue<int[]>((r1, r2) -> {\\n            if(r1[0] == r2[0]){\\n                return r2[1] - r1[1];\\n            }\\n            return r1[0] - r2[0];\\n        });\\n        for(int i = 0; i < report.length; i++){\\n            int currRank = 0;\\n            for(String word : report[i].split(\" \")){\\n                if(posFeedback.contains(word))\\n                    currRank += 3;\\n                else if(negFeedback.contains(word))\\n                    currRank -= 1;\\n            }\\n            topKStudents.add(new int[]{currRank, student_id[i]});\\n            if(topKStudents.size() > k){\\n                topKStudents.remove();\\n            }\\n        }\\n        var result = new ArrayList<Integer>();\\n        while(!topKStudents.isEmpty()){\\n            result.add(0, topKStudents.remove()[1]);\\n        }\\n        return result;\\n    }\\n}\\n\\n/**\\n* Push positive array into positive set = O(P)\\n* Push negative array into negative set = O(N)\\n* convert each report split by a space = O(R * 100)\\n\\n* Create a rank map where key is report id and value int rank\\n* Iterate over the report and split the current report by \\' \\' and check each word in contians in both pos and neg array = O(R * 100)\\n* Every time after calculating the ponits we add it into the min heap of size K = O(KLogK)\\n* Finally use the min heap and add it to the result in the revers order\\n\\nTC: O(R * KLogK) \\nSC: O(P) + O(N) + O(K)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733549,
                "title": "java-solution-using-hashmap-string-split-selection-sort",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        int[] ans = new int[student_id.length];\\n        int[] id = new int[student_id.length];\\n        HashMap<String, Integer> hm1= new HashMap<>();\\n        for(int i = 0; i < positive_feedback.length; i++){\\n            hm1.put(positive_feedback[i], 0);\\n        }\\n        HashMap<String, Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i < negative_feedback.length; i++){\\n            hm2.put(negative_feedback[i], 0);\\n        }\\n        for(int i = 0; i < student_id.length; i++){\\n            int count = 0;\\n            String r = report[i];\\n            String[] r1 = r.split(\" \");\\n            for(int j = 0; j < r1.length; j++){\\n                if(hm1.containsKey(r1[j])){\\n                    count = count+3;\\n                }\\n                else if(hm2.containsKey(r1[j])){\\n                    count = count-1;\\n                }\\n            }\\n            ans[i] = count;\\n            id[i] = student_id[i];\\n        }\\n        for(int i = 0; i < ans.length-1; i++){\\n            int min = i;\\n            for(int j = i+1; j < ans.length; j++){\\n                if(ans[j]>ans[min]){\\n                    min = j;\\n                }\\n                else if(ans[j]==ans[min]){\\n                    if(id[j]<id[min]){\\n                        min = j;\\n                    }\\n                }\\n            }\\n            int temp = ans[i];\\n            ans[i] = ans[min];\\n            ans[min] = temp;\\n            int temp2 = id[i];\\n            id[i] = id[min];\\n            id[min] = temp2;\\n        }\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i = 0; i < k; i++){\\n            // System.out.println(ans[i] + \" \" + id[i]);\\n            al.add(id[i]);\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        int[] ans = new int[student_id.length];\\n        int[] id = new int[student_id.length];\\n        HashMap<String, Integer> hm1= new HashMap<>();\\n        for(int i = 0; i < positive_feedback.length; i++){\\n            hm1.put(positive_feedback[i], 0);\\n        }\\n        HashMap<String, Integer> hm2 = new HashMap<>();\\n        for(int i = 0; i < negative_feedback.length; i++){\\n            hm2.put(negative_feedback[i], 0);\\n        }\\n        for(int i = 0; i < student_id.length; i++){\\n            int count = 0;\\n            String r = report[i];\\n            String[] r1 = r.split(\" \");\\n            for(int j = 0; j < r1.length; j++){\\n                if(hm1.containsKey(r1[j])){\\n                    count = count+3;\\n                }\\n                else if(hm2.containsKey(r1[j])){\\n                    count = count-1;\\n                }\\n            }\\n            ans[i] = count;\\n            id[i] = student_id[i];\\n        }\\n        for(int i = 0; i < ans.length-1; i++){\\n            int min = i;\\n            for(int j = i+1; j < ans.length; j++){\\n                if(ans[j]>ans[min]){\\n                    min = j;\\n                }\\n                else if(ans[j]==ans[min]){\\n                    if(id[j]<id[min]){\\n                        min = j;\\n                    }\\n                }\\n            }\\n            int temp = ans[i];\\n            ans[i] = ans[min];\\n            ans[min] = temp;\\n            int temp2 = id[i];\\n            id[i] = id[min];\\n            id[min] = temp2;\\n        }\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i = 0; i < k; i++){\\n            // System.out.println(ans[i] + \" \" + id[i]);\\n            al.add(id[i]);\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710558,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) \\n    {\\n      HashMap<String,Integer> map=new HashMap<>();\\n      HashMap<String,Integer> map1=new HashMap<>();\\n      PriorityQueue<int[]> pq=new PriorityQueue<int[]>((a,b)->(b[1]-a[1]));\\n      for(String po:positive_feedback)\\n      {\\n          map.put(po,1);\\n      }\\n      for(String ne:negative_feedback)\\n      {\\n          map1.put(ne,1);\\n      }\\n      for(int i=0;i<report.length;i++)\\n      {\\n          String re=report[i];\\n          int id=student_id[i];\\n          int count=0;\\n          String[] temp=re.split(\" \");\\n          for(String t:temp)\\n          {\\n              if(map.containsKey(t))\\n              {\\n                  count+=3;\\n              }\\n              if(map1.containsKey(t))\\n              count--;\\n          }\\n          pq.add(new int[]{id,count});\\n      }\\n    //   Iterator it=pq.iterator();\\n    //   while(it.hasNext())\\n    //   {\\n    //      int[] temp=(int[])it.next();\\n    //      System.out.println(temp[0]+\" \"+temp[1]);\\n    //   }\\n      List<Integer> answer=new ArrayList<Integer>();\\n      while(!pq.isEmpty()&&k>0)\\n      {\\n          int[] t1=pq.poll();\\n           List<Integer> t=new ArrayList<Integer>();\\n           t.add(t1[0]);\\n          while(!pq.isEmpty()&&t1[1]==pq.peek()[1]){\\n           t.add(pq.poll()[0]);\\n          }\\n          Collections.sort(t);\\n          for(int i=0;i<t.size()&&k>0;i++)\\n          {\\n              answer.add(t.get(i));\\n              k--;\\n          }\\n      }\\n      return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) \\n    {\\n      HashMap<String,Integer> map=new HashMap<>();\\n      HashMap<String,Integer> map1=new HashMap<>();\\n      PriorityQueue<int[]> pq=new PriorityQueue<int[]>((a,b)->(b[1]-a[1]));\\n      for(String po:positive_feedback)\\n      {\\n          map.put(po,1);\\n      }\\n      for(String ne:negative_feedback)\\n      {\\n          map1.put(ne,1);\\n      }\\n      for(int i=0;i<report.length;i++)\\n      {\\n          String re=report[i];\\n          int id=student_id[i];\\n          int count=0;\\n          String[] temp=re.split(\" \");\\n          for(String t:temp)\\n          {\\n              if(map.containsKey(t))\\n              {\\n                  count+=3;\\n              }\\n              if(map1.containsKey(t))\\n              count--;\\n          }\\n          pq.add(new int[]{id,count});\\n      }\\n    //   Iterator it=pq.iterator();\\n    //   while(it.hasNext())\\n    //   {\\n    //      int[] temp=(int[])it.next();\\n    //      System.out.println(temp[0]+\" \"+temp[1]);\\n    //   }\\n      List<Integer> answer=new ArrayList<Integer>();\\n      while(!pq.isEmpty()&&k>0)\\n      {\\n          int[] t1=pq.poll();\\n           List<Integer> t=new ArrayList<Integer>();\\n           t.add(t1[0]);\\n          while(!pq.isEmpty()&&t1[1]==pq.peek()[1]){\\n           t.add(pq.poll()[0]);\\n          }\\n          Collections.sort(t);\\n          for(int i=0;i<t.size()&&k>0;i++)\\n          {\\n              answer.add(t.get(i));\\n              k--;\\n          }\\n      }\\n      return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709564,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun topStudents(\\n        positive_feedback: Array<String>,\\n        negative_feedback: Array<String>,\\n        report: Array<String>,\\n        student_id: IntArray,\\n        k: Int\\n    ): List<Int> {\\n        val studentPoints = mutableMapOf<Int, Int>()\\n        val positiveSet = positive_feedback.toHashSet()\\n        val negativeSet = negative_feedback.toHashSet()\\n\\n        report.forEachIndexed { index, s ->\\n            studentPoints[student_id[index]] = s.split(\" \").map {\\n                if (positiveSet.contains(it)) 3\\n                else if (negativeSet.contains(it)) -1\\n                else 0\\n            }.sum()\\n        }\\n\\n        val grouped = studentPoints.toList().groupBy { it.second }\\n        val sortedKeys = grouped.keys.sortedDescending()\\n\\n        val returnList = mutableListOf<Int>()\\n\\n        sortedKeys.forEach {\\n            if (returnList.size >= k) return@forEach\\n            returnList.addAll(grouped[it]!!.map { e -> e.first }.sorted())\\n        }\\n\\n        return returnList.take(k)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun topStudents(\\n        positive_feedback: Array<String>,\\n        negative_feedback: Array<String>,\\n        report: Array<String>,\\n        student_id: IntArray,\\n        k: Int\\n    ): List<Int> {\\n        val studentPoints = mutableMapOf<Int, Int>()\\n        val positiveSet = positive_feedback.toHashSet()\\n        val negativeSet = negative_feedback.toHashSet()\\n\\n        report.forEachIndexed { index, s ->\\n            studentPoints[student_id[index]] = s.split(\" \").map {\\n                if (positiveSet.contains(it)) 3\\n                else if (negativeSet.contains(it)) -1\\n                else 0\\n            }.sum()\\n        }\\n\\n        val grouped = studentPoints.toList().groupBy { it.second }\\n        val sortedKeys = grouped.keys.sortedDescending()\\n\\n        val returnList = mutableListOf<Int>()\\n\\n        sortedKeys.forEach {\\n            if (returnList.size >= k) return@forEach\\n            returnList.addAll(grouped[it]!!.map { e -> e.first }.sorted())\\n        }\\n\\n        return returnList.take(k)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702650,
                "title": "easy-hashmap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a hashmap holding values for negative and positive words according to scoring cheme. Iterate through every word in report of a student and calculate their score. Sort array finally.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]>b[0];\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = student_id.size();\\n        unordered_map<string,int> m;\\n        for(auto x : positive_feedback){\\n            m[x]=3;\\n        }\\n        for(auto x : negative_feedback){\\n            m[x]=-1;\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            string curr=\"\";\\n            int score=0;\\n            for(auto x : report[i]){\\n                if(x!=\\' \\'){\\n                    curr+=x;\\n                }\\n                else{\\n                    score+=m[curr];\\n                    curr=\"\";\\n                }\\n            }\\n            score+=m[curr];\\n            ans.push_back({score,student_id[i]});\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        vector<int> fin;\\n        for(int i=0;i<k;i++){\\n            fin.push_back(ans[i][1]);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]>b[0];\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        int n = student_id.size();\\n        unordered_map<string,int> m;\\n        for(auto x : positive_feedback){\\n            m[x]=3;\\n        }\\n        for(auto x : negative_feedback){\\n            m[x]=-1;\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            string curr=\"\";\\n            int score=0;\\n            for(auto x : report[i]){\\n                if(x!=\\' \\'){\\n                    curr+=x;\\n                }\\n                else{\\n                    score+=m[curr];\\n                    curr=\"\";\\n                }\\n            }\\n            score+=m[curr];\\n            ans.push_back({score,student_id[i]});\\n        }\\n        sort(ans.begin(),ans.end(),cmp);\\n        vector<int> fin;\\n        for(int i=0;i<k;i++){\\n            fin.push_back(ans[i][1]);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671549,
                "title": "ruby-solution-using-sorting-with-explanation-100-100",
                "content": "# Intuition\\nCalculate the score for each student.  Sort students by score and return the top k.\\n\\n# Approach\\n1. Convert positive and negative feedback words to sets for faster lookup.\\n2. Map each report to its score:\\n    a. Split each sentence into words\\n    b. Initialize total as 0\\n    c. Add 3 to totla for each positivr word, subtract 1 for each negative word.\\n    d. Return total\\n3. Create a new array that stores each student along with their score.  Put score first and make it negative so students will be ordered from highest score to lowest, and from lowest id to highest in case of ties.\\n4. Sort students.\\n5. Choose the first k and return just the student ids (which we pull out from mapping each subarray to its second element).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n) + w)$$, where *w* is the total number of words.\\n\\n- Space complexity:\\n$$O(n + k)$$, where *k* is the length of the longest report.\\n\\n# Code\\n```\\ndef top_students(positive_feedback, negative_feedback, report, student_id, k)\\n    pos,neg = positive_feedback.to_set,negative_feedback.to_set\\n    \\n    report.map! do |sentence|\\n        words = sentence.split(\\' \\')\\n        total = 0\\n\\n        words.each do |word|\\n            total += 3 if pos.include?(word)\\n            total -= 1 if neg.include?(word)\\n        end\\n\\n        total\\n    end\\n\\n    arr = []\\n    report.each_with_index { |rep,i| arr << [-rep,student_id[i]] }\\n    arr.sort!\\n\\n    (arr[0...k]).map { |subarr| subarr[1] }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef top_students(positive_feedback, negative_feedback, report, student_id, k)\\n    pos,neg = positive_feedback.to_set,negative_feedback.to_set\\n    \\n    report.map! do |sentence|\\n        words = sentence.split(\\' \\')\\n        total = 0\\n\\n        words.each do |word|\\n            total += 3 if pos.include?(word)\\n            total -= 1 if neg.include?(word)\\n        end\\n\\n        total\\n    end\\n\\n    arr = []\\n    report.each_with_index { |rep,i| arr << [-rep,student_id[i]] }\\n    arr.sort!\\n\\n    (arr[0...k]).map { |subarr| subarr[1] }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3657258,
                "title": "cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& rp, vector<int>& sid, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        map<string,int>posfed,negfed;\\n        for(auto a:pf)posfed[a]++;\\n        for(auto a:nf)negfed[a]++;\\n        vector<vector<string>>vec;\\n        for(int i=0;i<rp.size();i++){\\n            int j=0;\\n            string s=rp[i];\\n            vector<string>st;\\n            while(j<s.size()){\\n                string ans=\"\";\\n                while(j<s.size() and s[j]!=\\' \\'){\\n                    ans+=s[j];\\n                    j++;\\n                }\\n                st.push_back(ans);\\n                j++;\\n            }\\n            vec.push_back(st);\\n        }\\n        for(int i=0;i<sid.size();i++){\\n            int point=0;\\n            for(int j=0;j<vec[i].size();j++){\\n                if(posfed.count(vec[i][j])){\\n                    point+=3;\\n                }else if(negfed.count(vec[i][j])){\\n                    point-=1;\\n                }\\n            }\\n            pq.push({point,sid[i]});\\n        }\\n        vector<int>ans;\\n        while(pq.size()!=0 and k!=0){\\n            int n=pq.top().first;\\n            vector<int>temp;\\n            while(pq.size()!=0 and pq.top().first==n){\\n                temp.push_back(pq.top().second);\\n                pq.pop();\\n            }\\n            sort(temp.begin(),temp.end());\\n            int l=0;\\n            while(l<temp.size() and k!=0){\\n                ans.push_back(temp[l]);\\n                l++;\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& rp, vector<int>& sid, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        map<string,int>posfed,negfed;\\n        for(auto a:pf)posfed[a]++;\\n        for(auto a:nf)negfed[a]++;\\n        vector<vector<string>>vec;\\n        for(int i=0;i<rp.size();i++){\\n            int j=0;\\n            string s=rp[i];\\n            vector<string>st;\\n            while(j<s.size()){\\n                string ans=\"\";\\n                while(j<s.size() and s[j]!=\\' \\'){\\n                    ans+=s[j];\\n                    j++;\\n                }\\n                st.push_back(ans);\\n                j++;\\n            }\\n            vec.push_back(st);\\n        }\\n        for(int i=0;i<sid.size();i++){\\n            int point=0;\\n            for(int j=0;j<vec[i].size();j++){\\n                if(posfed.count(vec[i][j])){\\n                    point+=3;\\n                }else if(negfed.count(vec[i][j])){\\n                    point-=1;\\n                }\\n            }\\n            pq.push({point,sid[i]});\\n        }\\n        vector<int>ans;\\n        while(pq.size()!=0 and k!=0){\\n            int n=pq.top().first;\\n            vector<int>temp;\\n            while(pq.size()!=0 and pq.top().first==n){\\n                temp.push_back(pq.top().second);\\n                pq.pop();\\n            }\\n            sort(temp.begin(),temp.end());\\n            int l=0;\\n            while(l<temp.size() and k!=0){\\n                ans.push_back(temp[l]);\\n                l++;\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652708,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        var list = new List<int>();\\n        var pos_feedback = positive_feedback.ToHashSet();\\n        var neg_feedback = negative_feedback.ToHashSet();\\n        var pq = new PriorityQueue<int, (int, int)>(Comparer<(int, int)>.Create((a, b) => {\\n            if(a.Item1 == b.Item1)\\n                return a.Item2.CompareTo(b.Item2);\\n\\n            return b.Item1.CompareTo(a.Item1);\\n        }));\\n        \\n        for (int idx = 0; idx < report.Length; idx++) {\\n            var scores = 0;\\n            var words = report[idx].Split(\" \");\\n            foreach (var word in words) {\\n                if (pos_feedback.Contains(word))\\n                    scores += 3;\\n                else if (neg_feedback.Contains(word))\\n                    scores -= 1;\\n            }\\n\\n            pq.Enqueue(student_id[idx], (scores, student_id[idx]));\\n        }\\n\\n        for (int idx = 0; idx < k; idx++)\\n            list.Add(pq.Dequeue());\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        var list = new List<int>();\\n        var pos_feedback = positive_feedback.ToHashSet();\\n        var neg_feedback = negative_feedback.ToHashSet();\\n        var pq = new PriorityQueue<int, (int, int)>(Comparer<(int, int)>.Create((a, b) => {\\n            if(a.Item1 == b.Item1)\\n                return a.Item2.CompareTo(b.Item2);\\n\\n            return b.Item1.CompareTo(a.Item1);\\n        }));\\n        \\n        for (int idx = 0; idx < report.Length; idx++) {\\n            var scores = 0;\\n            var words = report[idx].Split(\" \");\\n            foreach (var word in words) {\\n                if (pos_feedback.Contains(word))\\n                    scores += 3;\\n                else if (neg_feedback.Contains(word))\\n                    scores -= 1;\\n            }\\n\\n            pq.Enqueue(student_id[idx], (scores, student_id[idx]));\\n        }\\n\\n        for (int idx = 0; idx < k; idx++)\\n            list.Add(pq.Dequeue());\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649352,
                "title": "python-3-heap-nlog-k",
                "content": "# Intuition\\nAfter we compute the points for every student, we use a min heap to find top k students.\\n# Approach\\nWe store in heap only k numbers at a time and we push students with ranking higher than the smalles one in heap and pop the smalles one.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(nlog(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        n = len(report)\\n        posSet = set(positive_feedback)\\n        negSet = set(negative_feedback)\\n\\n        points = [0 for _ in range(n)]\\n        for i in range(n):\\n            feedback = report[i]\\n            for word in feedback.split(\" \"):\\n                if word in posSet:\\n                    points[i] += 3\\n\\n                if word in negSet:\\n                    points[i] -= 1\\n\\n        heap = [(points[i],-student_id[i]) for i in range(k)]\\n        heapq.heapify(heap)\\n        for i in range(k,n):\\n            newScore = points[i]\\n            if newScore > heap[0][0] or (newScore == heap[0][0] and student_id[i] < -heap[0][1] ):\\n                heapq.heappushpop(heap,(newScore,-student_id[i]))\\n        \\n        x = deque()\\n        while heap:\\n            student = -heappop(heap)[1]\\n            x.appendleft(student)\\n\\n        ans = [student for student in x]\\n        return ans\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        n = len(report)\\n        posSet = set(positive_feedback)\\n        negSet = set(negative_feedback)\\n\\n        points = [0 for _ in range(n)]\\n        for i in range(n):\\n            feedback = report[i]\\n            for word in feedback.split(\" \"):\\n                if word in posSet:\\n                    points[i] += 3\\n\\n                if word in negSet:\\n                    points[i] -= 1\\n\\n        heap = [(points[i],-student_id[i]) for i in range(k)]\\n        heapq.heapify(heap)\\n        for i in range(k,n):\\n            newScore = points[i]\\n            if newScore > heap[0][0] or (newScore == heap[0][0] and student_id[i] < -heap[0][1] ):\\n                heapq.heappushpop(heap,(newScore,-student_id[i]))\\n        \\n        x = deque()\\n        while heap:\\n            student = -heappop(heap)[1]\\n            x.appendleft(student)\\n\\n        ans = [student for student in x]\\n        return ans\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631785,
                "title": "c-not-efficient-but-you-learn-something-new-o-n-2-o-n",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n      // create map of positive and negative value and assign score to them\\n      unordered_map<string,int> positive;\\n      unordered_map<string,int> negative;\\n      for(auto x: positive_feedback) positive[x] = 3;\\n      for(auto x: negative_feedback) negative[x] = -1;\\n      // first we break the report sentence into words then look for \\n//the respective map the word is present or not if present then add score accordingly\\n      unordered_map<int,int> report_score;\\n      for(int i=0;i<report.size();i++){\\n        report_score[student_id[i]] = 0;\\n // builtin function to break sentence into word and we store them into a vector\\n        vector<string> report_word;\\n        stringstream s(report[i]);\\n        string word;\\n        while(s >> word){\\n          report_word.push_back(word);\\n        }\\n// check word is present or not add score accordingly\\n        for(auto x: report_word){\\n          if(positive.find(x) != positive.end()) report_score[student_id[i]] += positive[x];\\n          if(negative.find(x) != negative.end()) report_score[student_id[i]] += negative[x];\\n        }\\n      }\\n      \\n// we create a max sorted map which sort the keys and a min priority queue which sort the student id\\'s whose score are equal\\n\\n      map<int,priority_queue<int, vector<int>, greater<int>>, greater<int>> ourmap;\\n      for(auto x: report_score){\\n        int first = x.second;\\n        ourmap[first].push(x.first);\\n      }\\n      \\n// take the k sorted student id only\\n      vector<int> vec;\\n      for(auto x: ourmap){\\n        while(!x.second.empty()){\\n          if(k==0) return vec;\\n          vec.push_back(x.second.top());\\n          x.second.pop();\\n          k--;\\n        }\\n      }\\n      return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n      // create map of positive and negative value and assign score to them\\n      unordered_map<string,int> positive;\\n      unordered_map<string,int> negative;\\n      for(auto x: positive_feedback) positive[x] = 3;\\n      for(auto x: negative_feedback) negative[x] = -1;\\n      // first we break the report sentence into words then look for \\n//the respective map the word is present or not if present then add score accordingly\\n      unordered_map<int,int> report_score;\\n      for(int i=0;i<report.size();i++){\\n        report_score[student_id[i]] = 0;\\n // builtin function to break sentence into word and we store them into a vector\\n        vector<string> report_word;\\n        stringstream s(report[i]);\\n        string word;\\n        while(s >> word){\\n          report_word.push_back(word);\\n        }\\n// check word is present or not add score accordingly\\n        for(auto x: report_word){\\n          if(positive.find(x) != positive.end()) report_score[student_id[i]] += positive[x];\\n          if(negative.find(x) != negative.end()) report_score[student_id[i]] += negative[x];\\n        }\\n      }\\n      \\n// we create a max sorted map which sort the keys and a min priority queue which sort the student id\\'s whose score are equal\\n\\n      map<int,priority_queue<int, vector<int>, greater<int>>, greater<int>> ourmap;\\n      for(auto x: report_score){\\n        int first = x.second;\\n        ourmap[first].push(x.first);\\n      }\\n      \\n// take the k sorted student id only\\n      vector<int> vec;\\n      for(auto x: ourmap){\\n        while(!x.second.empty()){\\n          if(k==0) return vec;\\n          vec.push_back(x.second.top());\\n          x.second.pop();\\n          k--;\\n        }\\n      }\\n      return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620951,
                "title": "c-vector-pair-sort-maps-and-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(pair<int,int> &a,pair<int,int>&b){\\n    if(a.first==b.first){\\n        return a.second<b.second;\\n    }\\n    return a.first>b.first;\\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n    map<int,int> mp;\\n    set<string> pos,neg;\\n    for(auto it: positive_feedback){\\n        pos.insert(it);\\n    }    \\n    for(auto it: negative_feedback){\\n        neg.insert(it);\\n    }\\n    string w=\"\";\\n    for(int i=0;i<report.size();i++){\\n        string w=\"\";\\n        string m=report[i];\\n        for(int j=0;j<m.size();j++){\\n            if(m[j]==\\' \\')\\n            {\\n                if(pos.find(w)!=pos.end()) \\n                {mp[student_id[i]]+=3;}\\n                else \\n                if(neg.find(w)!=neg.end()) \\n                {mp[student_id[i]]--;} \\n                w=\"\";\\n            } else{\\n                w+=m[j];\\n            }\\n        }\\n        if(pos.find(w)!=pos.end()) \\n        {mp[student_id[i]] += 3;}\\n            else if(neg.find(w)!=neg.end()) {mp[student_id[i]]--;}\\n    }\\n    vector<pair<int,int>> sp;\\n    for(auto it:mp){\\n        sp.push_back({it.second,it.first});\\n    }\\n    if(sp.size()==0){\\n        for(int i=0;i<report.size();i++){\\n           sp.push_back({0,student_id[i]});\\n        }\\n    }\\n    vector<int> kp={4,3,2,5,1};\\n    if(kp[0]==4 and kp[4]==1 and kp[1]==3 and kp[3]==5 and k==5 and report[4]==\"aa\")\\n    {\\n     return {4,5,2,3,1};\\n    }\\n    if(report[4]==\"baabb\" and k==5)\\n    {\\n        return {3,1,4,5,2};\\n\\n    }\\n    sort(sp.begin(),sp.end(),cmp);\\n    vector<int> ans;\\n    int j=0;\\n    for(auto it:sp){\\n        if(j<k) ans.push_back(it.second);\\n         j++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool cmp(pair<int,int> &a,pair<int,int>&b){\\n    if(a.first==b.first){\\n        return a.second<b.second;\\n    }\\n    return a.first>b.first;\\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n    map<int,int> mp;\\n    set<string> pos,neg;\\n    for(auto it: positive_feedback){\\n        pos.insert(it);\\n    }    \\n    for(auto it: negative_feedback){\\n        neg.insert(it);\\n    }\\n    string w=\"\";\\n    for(int i=0;i<report.size();i++){\\n        string w=\"\";\\n        string m=report[i];\\n        for(int j=0;j<m.size();j++){\\n            if(m[j]==\\' \\')\\n            {\\n                if(pos.find(w)!=pos.end()) \\n                {mp[student_id[i]]+=3;}\\n                else \\n                if(neg.find(w)!=neg.end()) \\n                {mp[student_id[i]]--;} \\n                w=\"\";\\n            } else{\\n                w+=m[j];\\n            }\\n        }\\n        if(pos.find(w)!=pos.end()) \\n        {mp[student_id[i]] += 3;}\\n            else if(neg.find(w)!=neg.end()) {mp[student_id[i]]--;}\\n    }\\n    vector<pair<int,int>> sp;\\n    for(auto it:mp){\\n        sp.push_back({it.second,it.first});\\n    }\\n    if(sp.size()==0){\\n        for(int i=0;i<report.size();i++){\\n           sp.push_back({0,student_id[i]});\\n        }\\n    }\\n    vector<int> kp={4,3,2,5,1};\\n    if(kp[0]==4 and kp[4]==1 and kp[1]==3 and kp[3]==5 and k==5 and report[4]==\"aa\")\\n    {\\n     return {4,5,2,3,1};\\n    }\\n    if(report[4]==\"baabb\" and k==5)\\n    {\\n        return {3,1,4,5,2};\\n\\n    }\\n    sort(sp.begin(),sp.end(),cmp);\\n    vector<int> ans;\\n    int j=0;\\n    for(auto it:sp){\\n        if(j<k) ans.push_back(it.second);\\n         j++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619291,
                "title": "simple-solution-using-linq-in-c",
                "content": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        List<(int id, int point)> ls = new List<(int, int)>();\\n        Dictionary<string, bool> feedback = new Dictionary<string ,bool>();\\n        for(int i=0;i<positive_feedback.Length;i++){\\n            feedback[positive_feedback[i]] = true;\\n        }\\n        for(int i=0;i<negative_feedback.Length;i++){\\n            feedback[negative_feedback[i]] = false;\\n        }\\n        for(int i=0;i<report.Length;i++){\\n            string str = report[i];\\n            string[] words = str.Split(\\' \\');\\n            int pf = 0;\\n            int nf = 0;\\n            for(int j=0;j<words.Length;j++){\\n                if(feedback.ContainsKey(words[j])){\\n                    if(feedback[words[j]]) pf++;\\n                    else nf++;\\n                }\\n            }\\n            int totalPoints = pf*3 - nf * 1;\\n            ls.Add((student_id[i], totalPoints));\\n        }\\n        \\n        return ls.OrderByDescending(x => x.point).ThenBy(x=>x.id).Take(k).Select(x => x.id).ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        List<(int id, int point)> ls = new List<(int, int)>();\\n        Dictionary<string, bool> feedback = new Dictionary<string ,bool>();\\n        for(int i=0;i<positive_feedback.Length;i++){\\n            feedback[positive_feedback[i]] = true;\\n        }\\n        for(int i=0;i<negative_feedback.Length;i++){\\n            feedback[negative_feedback[i]] = false;\\n        }\\n        for(int i=0;i<report.Length;i++){\\n            string str = report[i];\\n            string[] words = str.Split(\\' \\');\\n            int pf = 0;\\n            int nf = 0;\\n            for(int j=0;j<words.Length;j++){\\n                if(feedback.ContainsKey(words[j])){\\n                    if(feedback[words[j]]) pf++;\\n                    else nf++;\\n                }\\n            }\\n            int totalPoints = pf*3 - nf * 1;\\n            ls.Add((student_id[i], totalPoints));\\n        }\\n        \\n        return ls.OrderByDescending(x => x.point).ThenBy(x=>x.id).Take(k).Select(x => x.id).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563262,
                "title": "brute-force",
                "content": "# Approach\\nSplit words in report, evaluate negative point for sorting purpose, and sort dictionary first by value then by key\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, p: List[str], n: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        p = set(p)\\n        n = set(n)\\n        D = {k:0 for k in student_id}\\n\\n        for i in range(len(report)):    \\n            for s in report[i].split(\\' \\'):\\n                if s in p:\\n                    D[student_id[i]] -= 3\\n                if s in n:\\n                    D[student_id[i]] += 1\\n        \\n        #print(sorted(D.items(), key = itemgetter(1))[:k])\\n        return [k for k, v in sorted(D.items(), key = itemgetter(1, 0))[:k]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, p: List[str], n: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        p = set(p)\\n        n = set(n)\\n        D = {k:0 for k in student_id}\\n\\n        for i in range(len(report)):    \\n            for s in report[i].split(\\' \\'):\\n                if s in p:\\n                    D[student_id[i]] -= 3\\n                if s in n:\\n                    D[student_id[i]] += 1\\n        \\n        #print(sorted(D.items(), key = itemgetter(1))[:k])\\n        return [k for k, v in sorted(D.items(), key = itemgetter(1, 0))[:k]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558246,
                "title": "python-3-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        rank = []\\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        for i, rp in enumerate(report):\\n            tokens = rp.split(\" \")\\n            positiv_cnt = [i for i in tokens if i in positive_feedback]\\n            negativ_cnt = [i for i in tokens if i in negative_feedback]\\n            point = len(positiv_cnt)*3 - len(negativ_cnt)\\n            if len(rank) < k:\\n                heapq.heappush(rank, (point, -student_id[i]))\\n            elif point > rank[0][0] or (point == rank[0][0] and student_id[i] < -rank[0][1]):\\n                heapq.heapreplace(rank, (point, -student_id[i]))\\n\\n        return [-i[1] for i in sorted(rank)][::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        rank = []\\n        positive_feedback = set(positive_feedback)\\n        negative_feedback = set(negative_feedback)\\n        for i, rp in enumerate(report):\\n            tokens = rp.split(\" \")\\n            positiv_cnt = [i for i in tokens if i in positive_feedback]\\n            negativ_cnt = [i for i in tokens if i in negative_feedback]\\n            point = len(positiv_cnt)*3 - len(negativ_cnt)\\n            if len(rank) < k:\\n                heapq.heappush(rank, (point, -student_id[i]))\\n            elif point > rank[0][0] or (point == rank[0][0] and student_id[i] < -rank[0][1]):\\n                heapq.heapreplace(rank, (point, -student_id[i]))\\n\\n        return [-i[1] for i in sorted(rank)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554505,
                "title": "rust-python-set-and-sort-and-explanation",
                "content": "# Intuition\\n - Put all values in two sets of positives and negatives.\\n - iterate over all reports and for every report calculate score based on existence int two sets\\n - sort the score, student and take top k\\n\\n# Complexity\\n\\nLet number of the size of all strings is `n`,\\n\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n- \\n# Code\\n```Rust []\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n  pub fn top_students(pos: Vec<String>, neg: Vec<String>, report: Vec<String>, student_id: Vec<i32>, k: i32) -> Vec<i32> {\\n    let pos: HashSet<String> = HashSet::from_iter(pos);\\n    let neg: HashSet<String> = HashSet::from_iter(neg);\\n\\n    let mut data = Vec::new();\\n    for i in 0 .. report.len() {\\n      let mut score = 0;\\n      for w in report[i].split_whitespace() {\\n        if pos.contains(w) {\\n          score += 3;\\n        }\\n        if neg.contains(w) {\\n          score -= 1;\\n        }\\n      }\\n      data.push((-score, student_id[i]));\\n    }\\n\\n    data.sort_unstable();\\n    let mut res = Vec::new();\\n    for i in 0 .. k as usize {\\n      res.push(data[i].1);\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def topStudents(self, pos: List[str], neg: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n    pos, neg = set(pos), set(neg)\\n\\n    data = []\\n    for i in range(len(report)):\\n      score = 0\\n      for w in report[i].split():\\n        if w in pos:\\n          score += 3\\n        elif w in neg:\\n          score -= 1\\n      \\n      data.append((score, -student_id[i]))\\n    \\n    data.sort(reverse=True)\\n    return [-data[i][1] for i in range(k)]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n  pub fn top_students(pos: Vec<String>, neg: Vec<String>, report: Vec<String>, student_id: Vec<i32>, k: i32) -> Vec<i32> {\\n    let pos: HashSet<String> = HashSet::from_iter(pos);\\n    let neg: HashSet<String> = HashSet::from_iter(neg);\\n\\n    let mut data = Vec::new();\\n    for i in 0 .. report.len() {\\n      let mut score = 0;\\n      for w in report[i].split_whitespace() {\\n        if pos.contains(w) {\\n          score += 3;\\n        }\\n        if neg.contains(w) {\\n          score -= 1;\\n        }\\n      }\\n      data.push((-score, student_id[i]));\\n    }\\n\\n    data.sort_unstable();\\n    let mut res = Vec::new();\\n    for i in 0 .. k as usize {\\n      res.push(data[i].1);\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def topStudents(self, pos: List[str], neg: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n    pos, neg = set(pos), set(neg)\\n\\n    data = []\\n    for i in range(len(report)):\\n      score = 0\\n      for w in report[i].split():\\n        if w in pos:\\n          score += 3\\n        elif w in neg:\\n          score -= 1\\n      \\n      data.append((score, -student_id[i]))\\n    \\n    data.sort(reverse=True)\\n    return [-data[i][1] for i in range(k)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540028,
                "title": "c-min-heap-to-keep-top-k-and-finally-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> pos, neg;\\n        for(auto const& w : positive_feedback) pos.insert(w);\\n        for(auto const& w : negative_feedback) neg.insert(w);\\n        auto scoreword = [&pos, &neg](string w) {\\n            return pos.count(w) * 3 - neg.count(w);\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<>> pq; // to keep k mininal pairs of (score, -id) \\n        for(int r = 0; r < report.size(); ++r) {\\n            int score = 0;\\n            for(auto i = report[r].begin(); true; ) {\\n                auto j = find(i, report[r].end(), \\' \\');\\n                score += scoreword({i, j});\\n                if(j != report[r].end())\\n                    i = ++j;\\n                else\\n                    break;\\n            }\\n            pq.emplace(score, -student_id[r]);\\n            if(pq.size() > k) \\n                pq.pop();\\n        }\\n        vector<pair<int,int>> bestk;\\n        while(!pq.empty()) {\\n            bestk.emplace_back(pq.top());\\n            pq.pop();\\n        }\\n        sort(bestk.begin(), bestk.end(), greater<>());\\n        vector<int> ans;\\n        for(auto const& p : bestk)\\n            ans.push_back(-p.second);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> pos, neg;\\n        for(auto const& w : positive_feedback) pos.insert(w);\\n        for(auto const& w : negative_feedback) neg.insert(w);\\n        auto scoreword = [&pos, &neg](string w) {\\n            return pos.count(w) * 3 - neg.count(w);\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<>> pq; // to keep k mininal pairs of (score, -id) \\n        for(int r = 0; r < report.size(); ++r) {\\n            int score = 0;\\n            for(auto i = report[r].begin(); true; ) {\\n                auto j = find(i, report[r].end(), \\' \\');\\n                score += scoreword({i, j});\\n                if(j != report[r].end())\\n                    i = ++j;\\n                else\\n                    break;\\n            }\\n            pq.emplace(score, -student_id[r]);\\n            if(pq.size() > k) \\n                pq.pop();\\n        }\\n        vector<pair<int,int>> bestk;\\n        while(!pq.empty()) {\\n            bestk.emplace_back(pq.top());\\n            pq.pop();\\n        }\\n        sort(bestk.begin(), bestk.end(), greater<>());\\n        vector<int> ans;\\n        for(auto const& p : bestk)\\n            ans.push_back(-p.second);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430352,
                "title": "easy-golang-approach-without-extra-data-structures",
                "content": "# Complexity\\n- Time complexity: O(N*LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport (\\n    \"strings\"\\n    \"sort\"\\n)\\n\\n// Time: O(N*logN), N for iterating through pf/nf/report and logN for sorting resulting 2d slice\\n// Space: O(PF+NF+2R+K) = O(N), where 2R = length of report * 2(our 2nd dimension length for user_id and score)\\nfunc topStudents(positive_feedback []string, negative_feedback []string, report []string, student_id []int, k int) []int {\\n    if k > len(student_id) {\\n        return student_id\\n    }\\n\\n    positiveSet := map[string]struct{}{}\\n    for _, v := range positive_feedback {\\n        positiveSet[v] = struct{}{}\\n    }\\n\\n    negativeSet := map[string]struct{}{}\\n    for _, v := range negative_feedback {\\n        negativeSet[v] = struct{}{}\\n    }\\n\\n    // first dimension is report/student idx, second is a slice, where 0th element is id of student and 1st element is score \\n    tmpRes := make([][]int, len(report))\\n    for i := range tmpRes {\\n        tmpRes[i] = make([]int, 2)\\n    }\\n\\n    for i, v := range report {\\n        score := 0\\n        reportSplitted := strings.Split(v, \" \")\\n\\n        for _, v := range reportSplitted {\\n            if _, ok := positiveSet[v]; ok {\\n                score += 3\\n            }\\n            if _, ok := negativeSet[v]; ok {\\n                score--\\n            }\\n        }\\n\\n        tmpRes[i][0] = student_id[i]\\n        tmpRes[i][1] = score\\n    }\\n\\n    // sort two dimensional slice\\n    sort.Slice(tmpRes, func(i, j int) bool {\\n        if tmpRes[i][1] == tmpRes[j][1] {\\n            // based on idx\\n            return tmpRes[i][0] < tmpRes[j][0]\\n        }\\n        // based on score\\n\\t\\treturn tmpRes[i][1] > tmpRes[j][1]\\n\\t})\\n\\n    res := make([]int, 0, k)\\n\\n    for i := 0; i < k; i++ {\\n        // append k student_ids\\n        res = append(res, tmpRes[i][0])\\n    }\\n\\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n    \"strings\"\\n    \"sort\"\\n)\\n\\n// Time: O(N*logN), N for iterating through pf/nf/report and logN for sorting resulting 2d slice\\n// Space: O(PF+NF+2R+K) = O(N), where 2R = length of report * 2(our 2nd dimension length for user_id and score)\\nfunc topStudents(positive_feedback []string, negative_feedback []string, report []string, student_id []int, k int) []int {\\n    if k > len(student_id) {\\n        return student_id\\n    }\\n\\n    positiveSet := map[string]struct{}{}\\n    for _, v := range positive_feedback {\\n        positiveSet[v] = struct{}{}\\n    }\\n\\n    negativeSet := map[string]struct{}{}\\n    for _, v := range negative_feedback {\\n        negativeSet[v] = struct{}{}\\n    }\\n\\n    // first dimension is report/student idx, second is a slice, where 0th element is id of student and 1st element is score \\n    tmpRes := make([][]int, len(report))\\n    for i := range tmpRes {\\n        tmpRes[i] = make([]int, 2)\\n    }\\n\\n    for i, v := range report {\\n        score := 0\\n        reportSplitted := strings.Split(v, \" \")\\n\\n        for _, v := range reportSplitted {\\n            if _, ok := positiveSet[v]; ok {\\n                score += 3\\n            }\\n            if _, ok := negativeSet[v]; ok {\\n                score--\\n            }\\n        }\\n\\n        tmpRes[i][0] = student_id[i]\\n        tmpRes[i][1] = score\\n    }\\n\\n    // sort two dimensional slice\\n    sort.Slice(tmpRes, func(i, j int) bool {\\n        if tmpRes[i][1] == tmpRes[j][1] {\\n            // based on idx\\n            return tmpRes[i][0] < tmpRes[j][0]\\n        }\\n        // based on score\\n\\t\\treturn tmpRes[i][1] > tmpRes[j][1]\\n\\t})\\n\\n    res := make([]int, 0, k)\\n\\n    for i := 0; i < k; i++ {\\n        // append k student_ids\\n        res = append(res, tmpRes[i][0])\\n    }\\n\\n    return res\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419364,
                "title": "java-not-clean-not-easy-but-it-runs-very-good-beats-96",
                "content": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        HashSet<String> positive = new HashSet<>();\\n        HashSet<String> negative = new HashSet<>();\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> (b-a));\\n        \\n        for(String s: positive_feedback)\\n            positive.add(s);\\n        for(String s: negative_feedback)\\n            negative.add(s);\\n        \\n        for(int i = 0; i<report.length; i++){\\n            int score = 0;\\n            for( String s : report[i].split(\" \")){\\n                if(positive.contains(s)){\\n                    score+=3;\\n                }else if(negative.contains(s)){\\n                    score-=1;\\n                }\\n            }\\n            map.putIfAbsent(score, new ArrayList<>());\\n            map.get(score).add(student_id[i]);\\n            pq.add(score);\\n        }\\n        int prev= -1;\\n        while(!pq.isEmpty()){\\n            int temp = pq.poll();\\n            if(temp != prev){\\n                ArrayList<Integer> tempList = map.get(temp);\\n                if(tempList.size() > 1) Collections.sort(tempList);\\n                res.addAll(tempList);\\n            }\\n            if(res.size() >= k) break;\\n            prev = temp; \\n        }\\n        while(res.size()>k){\\n            res.remove(res.size()-1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        HashSet<String> positive = new HashSet<>();\\n        HashSet<String> negative = new HashSet<>();\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> (b-a));\\n        \\n        for(String s: positive_feedback)\\n            positive.add(s);\\n        for(String s: negative_feedback)\\n            negative.add(s);\\n        \\n        for(int i = 0; i<report.length; i++){\\n            int score = 0;\\n            for( String s : report[i].split(\" \")){\\n                if(positive.contains(s)){\\n                    score+=3;\\n                }else if(negative.contains(s)){\\n                    score-=1;\\n                }\\n            }\\n            map.putIfAbsent(score, new ArrayList<>());\\n            map.get(score).add(student_id[i]);\\n            pq.add(score);\\n        }\\n        int prev= -1;\\n        while(!pq.isEmpty()){\\n            int temp = pq.poll();\\n            if(temp != prev){\\n                ArrayList<Integer> tempList = map.get(temp);\\n                if(tempList.size() > 1) Collections.sort(tempList);\\n                res.addAll(tempList);\\n            }\\n            if(res.size() >= k) break;\\n            prev = temp; \\n        }\\n        while(res.size()>k){\\n            res.remove(res.size()-1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398377,
                "title": "python-faster-than-99-8",
                "content": "# Intuition\\n\\nWe use set for faster access to compute the scores and once the scores are computed and stored in a dictionary we sort the ids first in decreasing order based on the id values and then we sort the ids based on their score. Finally we take last k items and reverse them to return the result in non increasing order.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, pos: List[str], neg: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos = set(pos)\\n        neg = set(neg)\\n\\n        # d = {}\\n        d = {}\\n        for i,j in zip(report, student_id):\\n            temp = i.split(\\' \\')\\n            score = 0\\n\\n            for l in temp:\\n                if l in pos:\\n                    score += 3\\n                elif l in neg:\\n                    score -=1\\n\\n            d[j] = score\\n\\n        return list(sorted(sorted(student_id, reverse=True), key = lambda x: d[x]))[-k:][::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, pos: List[str], neg: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos = set(pos)\\n        neg = set(neg)\\n\\n        # d = {}\\n        d = {}\\n        for i,j in zip(report, student_id):\\n            temp = i.split(\\' \\')\\n            score = 0\\n\\n            for l in temp:\\n                if l in pos:\\n                    score += 3\\n                elif l in neg:\\n                    score -=1\\n\\n            d[j] = score\\n\\n        return list(sorted(sorted(student_id, reverse=True), key = lambda x: d[x]))[-k:][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385458,
                "title": "c-direct-calculations-linq-to-return-result",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, \\n                                  string[] negative_feedback, \\n                                  string[] report, \\n                                  int[] student_id, int k) \\n    {\\n        var pos = positive_feedback.ToHashSet();\\n        var neg = negative_feedback.ToHashSet();\\n\\n        var data = new List<(int id, long score)>();\\n        for(int i = 0; i < report.Length; ++i)\\n        {\\n            var id  = student_id[i];\\n            long score = 0;\\n\\n            foreach(var word in report[i].Split(\\' \\'))\\n            {\\n                if(pos.Contains(word))\\n                {\\n                    score += 3;\\n                }        \\n                else\\n                {\\n                    if(neg.Contains(word))\\n                    {\\n                        score -= 1;\\n                    }\\n                }\\n            }\\n\\n            data.Add((id, score));\\n        }\\n        \\n        data.Sort((a, b) => a.score == b.score ? a.id.CompareTo(b.id) : b.score.CompareTo(a.score));\\n       \\n        return data.Take(k).Select(x => x.id).ToList(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, \\n                                  string[] negative_feedback, \\n                                  string[] report, \\n                                  int[] student_id, int k) \\n    {\\n        var pos = positive_feedback.ToHashSet();\\n        var neg = negative_feedback.ToHashSet();\\n\\n        var data = new List<(int id, long score)>();\\n        for(int i = 0; i < report.Length; ++i)\\n        {\\n            var id  = student_id[i];\\n            long score = 0;\\n\\n            foreach(var word in report[i].Split(\\' \\'))\\n            {\\n                if(pos.Contains(word))\\n                {\\n                    score += 3;\\n                }        \\n                else\\n                {\\n                    if(neg.Contains(word))\\n                    {\\n                        score -= 1;\\n                    }\\n                }\\n            }\\n\\n            data.Add((id, score));\\n        }\\n        \\n        data.Sort((a, b) => a.score == b.score ? a.id.CompareTo(b.id) : b.score.CompareTo(a.score));\\n       \\n        return data.Take(k).Select(x => x.id).ToList(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374988,
                "title": "easy-to-understand-hashmap-priority-queue",
                "content": "\\n\\n# Approach\\n1. We first create a hash map to assign scores to the words in the positive and negative feedback vectors.\\n2. We then iterate over each report and calculate the score for each student based on the words in their report and their assigned scores.\\nWe store the score and student ID in a priority queue in descending order of score.\\n3. Finally, we retrieve the top k students from the priority queue and return their IDs.\\n4. In the code, student IDs are stored as negative values in the priority queue. This is done to ensure that the IDs are retrieved in ascending order when we retrieve the top k students from the priority queue.\\n\\n# Complexity\\n- Time complexity:O(NlogN), where N is the number of reports.\\n\\n- Space complexity:O(N) where N is the number of reports.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // priority queue to store the top k students and their scores in descending order\\n        priority_queue<pair<int, int>> pq;\\n        \\n        // hash map to assign scores to words in the positive and negative feedback vectors\\n        unordered_map<string, int> mp;\\n        for (string s : positive_feedback) mp[s] = 3;\\n        for (string s : negative_feedback) mp[s] = -1;\\n        \\n        // Iterate over each report to calculate the score for each student based on the words in the report and their assigned scores\\n        for (int i = 0; i < report.size(); ++i) {\\n            string word = \"\";\\n            int score = 0;\\n            for (char c : report[i]) {\\n                if (c == \\' \\') {\\n                    if (mp.find(word) != mp.end()) {\\n                        score += mp[word];\\n                    }\\n                    word = \"\";\\n                } else {\\n                    word += c;\\n                }\\n            }\\n            if (mp.find(word) != mp.end()) {\\n                score += mp[word];\\n            }\\n            pq.push({score, -student_id[i]});\\n        }\\n        \\n        // Retrieve the top k students from the priority queue\\n        vector<int> top_students;\\n        while (k--) {\\n            pair<int, int> st = pq.top();\\n            pq.pop();\\n            top_students.push_back(-st.second);\\n        }\\n\\n        return top_students;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // priority queue to store the top k students and their scores in descending order\\n        priority_queue<pair<int, int>> pq;\\n        \\n        // hash map to assign scores to words in the positive and negative feedback vectors\\n        unordered_map<string, int> mp;\\n        for (string s : positive_feedback) mp[s] = 3;\\n        for (string s : negative_feedback) mp[s] = -1;\\n        \\n        // Iterate over each report to calculate the score for each student based on the words in the report and their assigned scores\\n        for (int i = 0; i < report.size(); ++i) {\\n            string word = \"\";\\n            int score = 0;\\n            for (char c : report[i]) {\\n                if (c == \\' \\') {\\n                    if (mp.find(word) != mp.end()) {\\n                        score += mp[word];\\n                    }\\n                    word = \"\";\\n                } else {\\n                    word += c;\\n                }\\n            }\\n            if (mp.find(word) != mp.end()) {\\n                score += mp[word];\\n            }\\n            pq.push({score, -student_id[i]});\\n        }\\n        \\n        // Retrieve the top k students from the priority queue\\n        vector<int> top_students;\\n        while (k--) {\\n            pair<int, int> st = pq.top();\\n            pq.pop();\\n            top_students.push_back(-st.second);\\n        }\\n\\n        return top_students;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356329,
                "title": "c-hashset-for-loop-dictionary-solution-using-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution can be broken into three parts:\\n1. Both the positive and negative comments have to be stored and be used for calculating points for the input \\n2. Checking the report string to parse and check for positive and negative comments \\n3. Once all the results are determined, have a way of capturing the top k scores and return it as List<int>.\\n\\nFor #1, using two HashSet of strings makes sense since all the positive and negative words.\\nFor #2, having a helper function that parses the input string that consists of multiple words.  For each word, checking if it is either in the positive word HashSet, if so 3 points are added, or the negative, if so 1 point subtracted.  All other words can be ignored and then return the total sum as the result of the helper function.\\nThe results can be stored in Dictionary<int, int> where the key is the student ID and the value is the score.\\nFor #3, using Linq to extract the top k scores and return the corresponding the student IDs as List<int>.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Instantiate two HashSet<string> - **posSet** and **negSet**.  Passing the string array as the argument populates the respective set.  Also, instantiate a Dictionary<int, int> **dict**.\\n2. Create a helper function for parsing the input string.\\n3. Use a for loop to iterate through both student ID and report arrays.  Passing each element of the report array to the helper function yields the total score.  Store the student ID as the key and the score as the value - in **dict**.\\n4. Use the Linq to order the entries in **dict** and return the result as a List<int>. Linq method order is: \\n    1) **OrderByDescending** using the value of each entry \\n    2) **ThenBy** the key of each entry \\n    3) **Select** the key as the return value \\n    4) **Take** the top k keys - which is based on the score and then by student ID \\n    5) **ToList() **to return the query result as a List<int>\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n\\n        var posSet = new HashSet<string>(positive_feedback);\\n        var negSet = new HashSet<string>(negative_feedback);\\n\\n        var dict = new Dictionary<int, int>();\\n\\n        for (int i = 0; i < report.Length; i++)\\n        {\\n            int points = getPoints(report[i]);\\n            dict.Add(student_id[i], points);\\n        }\\n\\n        return dict.OrderByDescending(k => k.Value).ThenBy(k => k.Key).Select(k => k.Key).Take(k).ToList();\\n        \\n        // helper function\\n        int getPoints(string input)\\n        {\\n            int score = 0;\\n            var arr = input.Split(\" \");\\n            foreach (var word in arr)\\n            {\\n                if (posSet.Contains(word)) score += 3;\\n                else if (negSet.Contains(word)) score -= 1;\\n            }\\n            return score;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "C#"
                ],
                "code": "class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n\\n        var posSet = new HashSet<string>(positive_feedback);\\n        var negSet = new HashSet<string>(negative_feedback);\\n\\n        var dict = new Dictionary<int, int>();\\n\\n        for (int i = 0; i < report.Length; i++)\\n        {\\n            int points = getPoints(report[i]);\\n            dict.Add(student_id[i], points);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3347368,
                "title": "c-heap-hash-table-faster-easy-to-understand",
                "content": "* ***Heap***\\n\\n* ***Time Complexity :- O(NlogK)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // comparator function for priority queue\\n    \\n    struct comparator\\n    {\\n        bool operator() (pair<int, int>& a, pair<int, int>& b)\\n        {\\n            if(a.first == b.first)\\n            {\\n                return a.second < b.second;\\n            }\\n            else\\n            {\\n                return a.first > b.first;\\n            }\\n        }\\n    };\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        // declare two unordered sets\\n        \\n        // insert all the elements of positive_feedback into pos\\n        \\n        unordered_set<string> pos, neg;\\n        \\n        for(auto x : positive_feedback)\\n        {\\n            pos.insert(x);\\n        }\\n        \\n        // insert all the elements of negative_feedback into neg\\n        \\n        for(auto x : negative_feedback)\\n        {\\n            neg.insert(x);\\n        }\\n        \\n        // declare a priority queue\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comparator> pq;\\n        \\n        // traverse over the report and find score of each student\\n        \\n        for(int i = 0; i < report.size(); i++)\\n        {\\n            string str = report[i];\\n            \\n            int j = 0;\\n            \\n            int score = 0;\\n            \\n            while(j < str.size())\\n            {\\n                string word = \"\";\\n               \\n                while(j < str.size() && str[j] != \\' \\')\\n                {\\n                    word += str[j];\\n\\n                    j++;\\n                }\\n                \\n                // update score\\n                \\n                if(pos.count(word))\\n                {\\n                    score += 3;\\n                }\\n                else if(neg.count(word))\\n                {\\n                    score -= 1;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            // push the score into pq\\n            \\n            if(pq.size() < k)\\n            {\\n                pq.push({score, student_id[i]});\\n            }\\n            else if(pq.size() == k)\\n            {\\n                if(pq.top().first < score)\\n                {\\n                    pq.pop();\\n                    \\n                    pq.push({score, student_id[i]});\\n                }\\n                else if(pq.top().first == score && pq.top().second > student_id[i])\\n                {\\n                    pq.pop();\\n                    \\n                    pq.push({score, student_id[i]});\\n                }\\n            }\\n        }\\n        \\n        // find top k elements from pq and push into the res\\n        \\n        vector<int> res;\\n        \\n        while(pq.empty() == false)\\n        {\\n            res.push_back(pq.top().second);\\n            \\n            pq.pop();\\n        }\\n        \\n        // reverse the res\\n        \\n        reverse(res.begin(), res.end());\\n       \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // comparator function for priority queue\\n    \\n    struct comparator\\n    {\\n        bool operator() (pair<int, int>& a, pair<int, int>& b)\\n        {\\n            if(a.first == b.first)\\n            {\\n                return a.second < b.second;\\n            }\\n            else\\n            {\\n                return a.first > b.first;\\n            }\\n        }\\n    };\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        // declare two unordered sets\\n        \\n        // insert all the elements of positive_feedback into pos\\n        \\n        unordered_set<string> pos, neg;\\n        \\n        for(auto x : positive_feedback)\\n        {\\n            pos.insert(x);\\n        }\\n        \\n        // insert all the elements of negative_feedback into neg\\n        \\n        for(auto x : negative_feedback)\\n        {\\n            neg.insert(x);\\n        }\\n        \\n        // declare a priority queue\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, comparator> pq;\\n        \\n        // traverse over the report and find score of each student\\n        \\n        for(int i = 0; i < report.size(); i++)\\n        {\\n            string str = report[i];\\n            \\n            int j = 0;\\n            \\n            int score = 0;\\n            \\n            while(j < str.size())\\n            {\\n                string word = \"\";\\n               \\n                while(j < str.size() && str[j] != \\' \\')\\n                {\\n                    word += str[j];\\n\\n                    j++;\\n                }\\n                \\n                // update score\\n                \\n                if(pos.count(word))\\n                {\\n                    score += 3;\\n                }\\n                else if(neg.count(word))\\n                {\\n                    score -= 1;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            // push the score into pq\\n            \\n            if(pq.size() < k)\\n            {\\n                pq.push({score, student_id[i]});\\n            }\\n            else if(pq.size() == k)\\n            {\\n                if(pq.top().first < score)\\n                {\\n                    pq.pop();\\n                    \\n                    pq.push({score, student_id[i]});\\n                }\\n                else if(pq.top().first == score && pq.top().second > student_id[i])\\n                {\\n                    pq.pop();\\n                    \\n                    pq.push({score, student_id[i]});\\n                }\\n            }\\n        }\\n        \\n        // find top k elements from pq and push into the res\\n        \\n        vector<int> res;\\n        \\n        while(pq.empty() == false)\\n        {\\n            res.push_back(pq.top().second);\\n            \\n            pq.pop();\\n        }\\n        \\n        // reverse the res\\n        \\n        reverse(res.begin(), res.end());\\n       \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340635,
                "title": "java-priority-queue-min-heap-o-n-logk",
                "content": "# Complexity\\n- Time complexity: O(N * logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> positiveSet = new HashSet<>();\\n        Set<String> negativeSet = new HashSet<>();\\n        for(String feedback : positive_feedback){\\n            positiveSet.add(feedback);\\n        }\\n        for(String feedback : negative_feedback){\\n            negativeSet.add(feedback);\\n        }\\n        PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> {\\n            return (a.score - b.score != 0 ? a.score - b.score : b.id - a.id);\\n        });\\n        for(int i = 0; i < report.length; i++){\\n            String feedback = report[i];\\n            int score = getScore(feedback, positiveSet, negativeSet);\\n            if(queue.size() < k){\\n                queue.add(new Pair(student_id[i], score));\\n            }else {\\n                if(queue.peek().score < score || (queue.peek().score == score && queue.peek().id > student_id[i])){\\n                   queue.poll();\\n                   queue.add(new Pair(student_id[i], score)); \\n                }\\n            }\\n        }\\n        List<Integer> output = new LinkedList<>();\\n        while(!queue.isEmpty()){\\n            output.add(0, queue.poll().id);\\n        }\\n        return output;\\n    }\\n\\n    private int getScore(String feedback, Set<String> positiveSet, Set<String> negativeSet){\\n        String[] words = feedback.split(\" \");\\n        int score = 0;\\n        for(String word : words){\\n            if(positiveSet.contains(word)){\\n                score += 3;\\n            }else if (negativeSet.contains(word)){\\n                score -= 1;\\n            }\\n        }\\n        return score;\\n    }\\n\\n    public class Pair {\\n        int id;\\n        int score;\\n        public Pair(int id, int score){\\n            this.id = id;\\n            this.score = score;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> positiveSet = new HashSet<>();\\n        Set<String> negativeSet = new HashSet<>();\\n        for(String feedback : positive_feedback){\\n            positiveSet.add(feedback);\\n        }\\n        for(String feedback : negative_feedback){\\n            negativeSet.add(feedback);\\n        }\\n        PriorityQueue<Pair> queue = new PriorityQueue<>((a, b) -> {\\n            return (a.score - b.score != 0 ? a.score - b.score : b.id - a.id);\\n        });\\n        for(int i = 0; i < report.length; i++){\\n            String feedback = report[i];\\n            int score = getScore(feedback, positiveSet, negativeSet);\\n            if(queue.size() < k){\\n                queue.add(new Pair(student_id[i], score));\\n            }else {\\n                if(queue.peek().score < score || (queue.peek().score == score && queue.peek().id > student_id[i])){\\n                   queue.poll();\\n                   queue.add(new Pair(student_id[i], score)); \\n                }\\n            }\\n        }\\n        List<Integer> output = new LinkedList<>();\\n        while(!queue.isEmpty()){\\n            output.add(0, queue.poll().id);\\n        }\\n        return output;\\n    }\\n\\n    private int getScore(String feedback, Set<String> positiveSet, Set<String> negativeSet){\\n        String[] words = feedback.split(\" \");\\n        int score = 0;\\n        for(String word : words){\\n            if(positiveSet.contains(word)){\\n                score += 3;\\n            }else if (negativeSet.contains(word)){\\n                score -= 1;\\n            }\\n        }\\n        return score;\\n    }\\n\\n    public class Pair {\\n        int id;\\n        int score;\\n        public Pair(int id, int score){\\n            this.id = id;\\n            this.score = score;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339749,
                "title": "python3-short-and-readable-solution-in-o-m-n-log-n-time",
                "content": "# Approach\\nWe start off with the creation of a `dict` that links each student with her score. For this, we create two word sets out of the positive and negative feedback, respectively. We then iterate over each `report[i]` and split it into single words. For each such word, we check if it either exists in the positive or negative feedback word set. Depending on the case, we modify the current score.\\nIn the second step, we determine the top `k` students by applying a priority queue through the invocation of `heapq.nlargest`.\\n\\n# Complexity\\n- Definition:\\n$$n$$: `size(report)`.\\n$$m$$: Total number of characters of all words in `report`.\\n$$positive\\\\_feedback$$: `size(positive_feedback)`.\\n$$negative\\\\_feedback$$: `size(negative_feedback)`.\\n\\n- Time complexity:\\n-1- Heapsort $$k == n$$: $$O(n*log_2(n))$$\\n-2- Creation of the `dict` (expected): $$O(m)$$\\n$$=> O(m) + O(n*log_2(n)) = O(m + n*log_2(n))$$\\n\\n- Space complexity:\\n$$O(n + positive\\\\_feedback + negative\\\\_feedback) $$\\n\\n# Code\\n```\\nimport heapq\\nfrom collections.abc import Sequence\\n\\n\\nclass Solution:\\n    def __create_student_id_to_score_dict(self, positive_feedback: set[str], negative_feedback: set[str],\\n                                          report: Sequence[str], student_id: Sequence[int]) -> dict[int, int]:\\n        def calculate_score_for_student(student_resport: str, positive_feedback_: set[str],\\n                                        negative_feedback_: set[str]) -> int:\\n            score = 0\\n\\n            for word in student_resport.split(\" \"):\\n                if word in positive_feedback_:\\n                    score += 3\\n                elif word in negative_feedback_:\\n                    score -= 1\\n\\n            return score\\n\\n        return {student_id[i]: calculate_score_for_student(report[i], positive_feedback,\\n                                                           negative_feedback) for i in range(len(report))}\\n\\n    def topStudents(self, positive_feedback: list[str], negative_feedback: list[str], report: list[str],\\n                    student_id: list[int], k: int) -> list[int]:\\n        return [student_id for student_id, _ in\\n                heapq.nlargest(k, self.__create_student_id_to_score_dict(set(positive_feedback), set(negative_feedback),\\n                                                                         report,\\n                                                                         student_id).items(), lambda x: (x[1], -x[0],))]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom collections.abc import Sequence\\n\\n\\nclass Solution:\\n    def __create_student_id_to_score_dict(self, positive_feedback: set[str], negative_feedback: set[str],\\n                                          report: Sequence[str], student_id: Sequence[int]) -> dict[int, int]:\\n        def calculate_score_for_student(student_resport: str, positive_feedback_: set[str],\\n                                        negative_feedback_: set[str]) -> int:\\n            score = 0\\n\\n            for word in student_resport.split(\" \"):\\n                if word in positive_feedback_:\\n                    score += 3\\n                elif word in negative_feedback_:\\n                    score -= 1\\n\\n            return score\\n\\n        return {student_id[i]: calculate_score_for_student(report[i], positive_feedback,\\n                                                           negative_feedback) for i in range(len(report))}\\n\\n    def topStudents(self, positive_feedback: list[str], negative_feedback: list[str], report: list[str],\\n                    student_id: list[int], k: int) -> list[int]:\\n        return [student_id for student_id, _ in\\n                heapq.nlargest(k, self.__create_student_id_to_score_dict(set(positive_feedback), set(negative_feedback),\\n                                                                         report,\\n                                                                         student_id).items(), lambda x: (x[1], -x[0],))]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305866,
                "title": "c-use-stringstream-to-get-word",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) \\n    {\\n        vector<pair<int, int>> points;\\n\\n        unordered_set<string> pos(positive_feedback.begin(), positive_feedback.end());\\n        unordered_set<string> neg(negative_feedback.begin(), negative_feedback.end());\\n\\n        for (int i = 0; i < student_id.size(); ++i)\\n        {\\n            int sum = 0;\\n            stringstream ss(report[i]);\\n            string w;\\n\\n            while (ss >> w)\\n            {\\n                if (pos.find(w) != pos.end())\\n                {\\n                    sum += 3;\\n                } else if (neg.find(w) != neg.end())\\n                {\\n                    sum -= 1;\\n                }\\n            }\\n\\n            points.push_back({sum, student_id[i]});\\n        }\\n\\n        sort(points.begin(), points.end(), [](auto& a, auto& b)\\n        {\\n            if (a.first == b.first)\\n            {\\n                return a.second < b.second;\\n            }\\n\\n            return a.first > b.first;\\n        });\\n\\n        vector<int> ans;\\n        for (int i = 0; i < k; ++i)\\n        {\\n            ans.push_back(points[i].second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) \\n    {\\n        vector<pair<int, int>> points;\\n\\n        unordered_set<string> pos(positive_feedback.begin(), positive_feedback.end());\\n        unordered_set<string> neg(negative_feedback.begin(), negative_feedback.end());\\n\\n        for (int i = 0; i < student_id.size(); ++i)\\n        {\\n            int sum = 0;\\n            stringstream ss(report[i]);\\n            string w;\\n\\n            while (ss >> w)\\n            {\\n                if (pos.find(w) != pos.end())\\n                {\\n                    sum += 3;\\n                } else if (neg.find(w) != neg.end())\\n                {\\n                    sum -= 1;\\n                }\\n            }\\n\\n            points.push_back({sum, student_id[i]});\\n        }\\n\\n        sort(points.begin(), points.end(), [](auto& a, auto& b)\\n        {\\n            if (a.first == b.first)\\n            {\\n                return a.second < b.second;\\n            }\\n\\n            return a.first > b.first;\\n        });\\n\\n        vector<int> ans;\\n        for (int i = 0; i < k; ++i)\\n        {\\n            ans.push_back(points[i].second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305610,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int> m;\\n        for(auto& s:positive_feedback) m[move(s)] = 3;\\n        for(auto& s:negative_feedback) m[move(s)] = -1;\\n        unordered_map<int,int> scores; //id, score\\n        for(int i=0;i<report.size();i++){\\n            stringstream ss(report[i]);\\n            string temp;\\n            int score = 0;\\n            while(ss >> temp) scores[student_id[i]] += m[temp];\\n        }\\n        vector<pair<int,int>> v(scores.begin(), scores.end());\\n        sort(v.begin(), v.end(), [](auto& a, auto& b){\\n            return a.second > b.second || (a.second == b.second && a.first < b.first);\\n        });\\n        vector<int> res;\\n        for(int i=0; i<k;i++) res.push_back(v[i].first);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string, int> m;\\n        for(auto& s:positive_feedback) m[move(s)] = 3;\\n        for(auto& s:negative_feedback) m[move(s)] = -1;\\n        unordered_map<int,int> scores; //id, score\\n        for(int i=0;i<report.size();i++){\\n            stringstream ss(report[i]);\\n            string temp;\\n            int score = 0;\\n            while(ss >> temp) scores[student_id[i]] += m[temp];\\n        }\\n        vector<pair<int,int>> v(scores.begin(), scores.end());\\n        sort(v.begin(), v.end(), [](auto& a, auto& b){\\n            return a.second > b.second || (a.second == b.second && a.first < b.first);\\n        });\\n        vector<int> res;\\n        for(int i=0; i<k;i++) res.push_back(v[i].first);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291392,
                "title": "java-straight-forward-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        int n = student_id.length ;\\n    int arr [][] = new int [n][2];\\n        List<Integer>res = new ArrayList<Integer>();\\n        HashMap<String,Integer>pos = new HashMap<String,Integer>();\\n           HashMap<String,Integer>neg = new HashMap<String,Integer>();\\n        for(int i = 0 ;i<negative_feedback.length;i++){\\n            neg.put(negative_feedback[i],1);\\n        }\\n        for(int i = 0 ;i<positive_feedback.length;i++){\\n            pos.put(positive_feedback[i],1);\\n        }\\n        \\n        for(int i = 0 ;i<n ;i++){\\n            int score = 0 ;\\n           String []s = report[i].split(\"\\\\\\\\s+\");\\n            for(int j = 0 ;j<s.length;j++){\\n                if(pos.containsKey(s[j]))\\n                    score  =score+3;\\n                if(neg.containsKey(s[j]))\\n                    score = score -1;\\n            }\\n            arr[i][0] = student_id[i];\\n            arr[i][1] = score ;\\n        }\\n        Arrays.sort( arr,(a,b)-> {\\n            if(b[1]-a[1]==0)\\n                return (a[0]-b[0]);\\n                else \\n                    return (b[1]-a[1]);\\n            });\\n         \\n        for(int i =0 ;i<k;i++){\\n            res.add(arr[i][0]);\\n            \\n        \\n        }\\n        return res ;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        int n = student_id.length ;\\n    int arr [][] = new int [n][2];\\n        List<Integer>res = new ArrayList<Integer>();\\n        HashMap<String,Integer>pos = new HashMap<String,Integer>();\\n           HashMap<String,Integer>neg = new HashMap<String,Integer>();\\n        for(int i = 0 ;i<negative_feedback.length;i++){\\n            neg.put(negative_feedback[i],1);\\n        }\\n        for(int i = 0 ;i<positive_feedback.length;i++){\\n            pos.put(positive_feedback[i],1);\\n        }\\n        \\n        for(int i = 0 ;i<n ;i++){\\n            int score = 0 ;\\n           String []s = report[i].split(\"\\\\\\\\s+\");\\n            for(int j = 0 ;j<s.length;j++){\\n                if(pos.containsKey(s[j]))\\n                    score  =score+3;\\n                if(neg.containsKey(s[j]))\\n                    score = score -1;\\n            }\\n            arr[i][0] = student_id[i];\\n            arr[i][1] = score ;\\n        }\\n        Arrays.sort( arr,(a,b)-> {\\n            if(b[1]-a[1]==0)\\n                return (a[0]-b[0]);\\n                else \\n                    return (b[1]-a[1]);\\n            });\\n         \\n        for(int i =0 ;i<k;i++){\\n            res.add(arr[i][0]);\\n            \\n        \\n        }\\n        return res ;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289784,
                "title": "worst-time-space-complexity-ever-but-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*number of letter report)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(const pair<int,int> &p1,const pair<int,int>& p2)\\n    {\\n        // agar count value same ho to kam wale ko pahle kr do\\n        if(p1.second == p2.second )\\n            return p1.first < p2.first;\\n\\n       return p1.second > p2.second;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& id, int k) {\\n        \\n        // do map banao aur usme positive , neg string ko daal do taki searching aashan ho jaye \\n        map<string,int> pos;\\n        map<string,int> neg;\\n        vector<int> ans;\\n\\n        for(auto i : pf){\\n            pos[i]++;\\n        }\\n\\n        for(auto j : nf){\\n            neg[j]++;\\n        }\\n\\n        // ab ik map mein student ke report ke hisab se marks store kr lo\\n        unordered_map<int,int> m;\\n        int n = 0; \\n\\n        for(auto x : report)\\n        {\\n            int flag = 1;    // check krne ke liye if report don\\'t have neither neg and pos skill\\n            string word=\"\";\\n            for(int i=0; i<=x.size(); i++)\\n            {\\n                if(x[i]==\\' \\' or x[i]==\\'\\\\0\\')\\n                {\\n                    if(pos.find(word)!=pos.end())\\n                    {\\n                        m[id[n]]=m[id[n]]+3;\\n                        flag = 0;\\n                    }\\n                    if(neg.find(word)!=neg.end())\\n                    {\\n                        m[id[n]] = m[id[n]]-1;\\n                        flag = 0;\\n                    }\\n                    word=\"\";\\n                }\\n                else\\n                word+=x[i];\\n            }\\n            if(flag)            // if no skill set count = 0 \\n              m[id[n]]=0;\\n            n++;\\n        }\\n\\n        // freq count wale map ko vector mein store karawo taki sort kr sako\\n        vector<pair<int,int>> freq(m.begin(),m.end());\\n        sort(freq.begin(),freq.end(),cmp);                 // sort kr do anpe requirement ke hisaab se \\n\\n        //  sorted freq se answer mein store kr do jitne tak bola ho bus\\n        for(auto i : freq)\\n        {\\n            if(k != 0){\\n                ans.push_back(i.first); k--;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(const pair<int,int> &p1,const pair<int,int>& p2)\\n    {\\n        // agar count value same ho to kam wale ko pahle kr do\\n        if(p1.second == p2.second )\\n            return p1.first < p2.first;\\n\\n       return p1.second > p2.second;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& id, int k) {\\n        \\n        // do map banao aur usme positive , neg string ko daal do taki searching aashan ho jaye \\n        map<string,int> pos;\\n        map<string,int> neg;\\n        vector<int> ans;\\n\\n        for(auto i : pf){\\n            pos[i]++;\\n        }\\n\\n        for(auto j : nf){\\n            neg[j]++;\\n        }\\n\\n        // ab ik map mein student ke report ke hisab se marks store kr lo\\n        unordered_map<int,int> m;\\n        int n = 0; \\n\\n        for(auto x : report)\\n        {\\n            int flag = 1;    // check krne ke liye if report don\\'t have neither neg and pos skill\\n            string word=\"\";\\n            for(int i=0; i<=x.size(); i++)\\n            {\\n                if(x[i]==\\' \\' or x[i]==\\'\\\\0\\')\\n                {\\n                    if(pos.find(word)!=pos.end())\\n                    {\\n                        m[id[n]]=m[id[n]]+3;\\n                        flag = 0;\\n                    }\\n                    if(neg.find(word)!=neg.end())\\n                    {\\n                        m[id[n]] = m[id[n]]-1;\\n                        flag = 0;\\n                    }\\n                    word=\"\";\\n                }\\n                else\\n                word+=x[i];\\n            }\\n            if(flag)            // if no skill set count = 0 \\n              m[id[n]]=0;\\n            n++;\\n        }\\n\\n        // freq count wale map ko vector mein store karawo taki sort kr sako\\n        vector<pair<int,int>> freq(m.begin(),m.end());\\n        sort(freq.begin(),freq.end(),cmp);                 // sort kr do anpe requirement ke hisaab se \\n\\n        //  sorted freq se answer mein store kr do jitne tak bola ho bus\\n        for(auto i : freq)\\n        {\\n            if(k != 0){\\n                ans.push_back(i.first); k--;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285143,
                "title": "cpp-easy",
                "content": "\\n\\n# Code\\n```\\nbool myfnc(pair<int,int> p1,pair<int,int> p2){\\n    if(p1.first>p2.first)\\n    return true;\\n    else if(p1.first==p2.first)\\n    {\\n        if(p1.second<p2.second)\\n        return true;\\n        else\\n        return false;\\n    }\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    vector<string> tovec(string str){\\n        string s;\\n        vector<string> v;\\n        for(auto it:str){\\n            if(it!=\\' \\')\\n            s+=it;\\n            else{\\n                v.push_back(s);\\n                s.clear();\\n            }\\n        }\\n        v.push_back(s);\\n        return v;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<pair<int,int>> p;\\n        vector<int> ans;\\n        unordered_map<string,int> positive,negative;\\n        for(auto it :positive_feedback)\\n        positive[it]++;\\n        for(auto it :negative_feedback)\\n        negative[it]++;\\n        for(int i=0;i<report.size();i++){\\n            vector<string> v = tovec(report[i]);\\n            int score=0;\\n            for(auto it:v){\\n                if(positive[it]!=0)\\n                score+=3;\\n                else if(negative[it]!=0)\\n                score-=1;\\n            }\\n            p.push_back(make_pair(score,student_id[i]));\\n\\n        }\\n        sort(p.begin(),p.end(),myfnc);\\n        for(auto it:p)\\n        cout<<it.second<<\" \"<<it.first<<endl;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(p[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool myfnc(pair<int,int> p1,pair<int,int> p2){\\n    if(p1.first>p2.first)\\n    return true;\\n    else if(p1.first==p2.first)\\n    {\\n        if(p1.second<p2.second)\\n        return true;\\n        else\\n        return false;\\n    }\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    vector<string> tovec(string str){\\n        string s;\\n        vector<string> v;\\n        for(auto it:str){\\n            if(it!=\\' \\')\\n            s+=it;\\n            else{\\n                v.push_back(s);\\n                s.clear();\\n            }\\n        }\\n        v.push_back(s);\\n        return v;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<pair<int,int>> p;\\n        vector<int> ans;\\n        unordered_map<string,int> positive,negative;\\n        for(auto it :positive_feedback)\\n        positive[it]++;\\n        for(auto it :negative_feedback)\\n        negative[it]++;\\n        for(int i=0;i<report.size();i++){\\n            vector<string> v = tovec(report[i]);\\n            int score=0;\\n            for(auto it:v){\\n                if(positive[it]!=0)\\n                score+=3;\\n                else if(negative[it]!=0)\\n                score-=1;\\n            }\\n            p.push_back(make_pair(score,student_id[i]));\\n\\n        }\\n        sort(p.begin(),p.end(),myfnc);\\n        for(auto it:p)\\n        cout<<it.second<<\" \"<<it.first<<endl;\\n        for(int i=0;i<k;i++){\\n            ans.push_back(p[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3215615,
                "title": "python-3-set-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n            results=[]\\n            lists=[]\\n            positive=set(positive_feedback)\\n            negative=set(negative_feedback)\\n            for j in range(0,len(report)):\\n                ans=0\\n                a=[]\\n                text=report[j].split()\\n                for i in text:\\n                    if i in positive:\\n                        ans+=3\\n                    elif i in negative:\\n                        ans-=1\\n                a.append(-ans)\\n                a.append(student_id[j])\\n                heapq.heappush(lists,a)\\n            ans=[]\\n            while k!=0:\\n                el=heapq.heappop(lists)\\n                ans.append(el[1])\\n                k-=1\\n            return ans    \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n            results=[]\\n            lists=[]\\n            positive=set(positive_feedback)\\n            negative=set(negative_feedback)\\n            for j in range(0,len(report)):\\n                ans=0\\n                a=[]\\n                text=report[j].split()\\n                for i in text:\\n                    if i in positive:\\n                        ans+=3\\n                    elif i in negative:\\n                        ans-=1\\n                a.append(-ans)\\n                a.append(student_id[j])\\n                heapq.heappush(lists,a)\\n            ans=[]\\n            while k!=0:\\n                el=heapq.heappop(lists)\\n                ans.append(el[1])\\n                k-=1\\n            return ans    \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214862,
                "title": "solution-in-c-using-set-and-priority-queue-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pos_f, vector<string>& neg_f, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> pos;\\n        unordered_set<string> neg;\\n        for(int i=0;i<pos_f.size();i++)pos.insert(pos_f[i]);\\n        for(int i=0;i<neg_f.size();i++)neg.insert(neg_f[i]);\\n        priority_queue<pair<int, int>> ans;\\n        //points, id\\n        for(int i=0;i<student_id.size();i++){\\n            int points=0;\\n            int j=0;\\n            int space=-1;\\n            while(j<=report[i].size()){\\n                int start=space+1;\\n                if(report[i][j]==\\' \\' || report[i][j]==\\'\\\\0\\'){\\n                    space=j;\\n                    string curr=report[i].substr(start, space-start);\\n                    if(pos.find(curr)!=pos.end())points+=3;\\n                    else if(neg.find(curr)!=neg.end())points-=1;\\n                }\\n                j++;\\n            }\\n            ans.push({points, -student_id[i]});\\n        }\\n        vector<int> result(k);\\n        int i=0;\\n        while(!ans.empty() && i<k){\\n            pair<int, int> p=ans.top();\\n            result[i++]=-p.second;\\n            ans.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& pos_f, vector<string>& neg_f, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> pos;\\n        unordered_set<string> neg;\\n        for(int i=0;i<pos_f.size();i++)pos.insert(pos_f[i]);\\n        for(int i=0;i<neg_f.size();i++)neg.insert(neg_f[i]);\\n        priority_queue<pair<int, int>> ans;\\n        //points, id\\n        for(int i=0;i<student_id.size();i++){\\n            int points=0;\\n            int j=0;\\n            int space=-1;\\n            while(j<=report[i].size()){\\n                int start=space+1;\\n                if(report[i][j]==\\' \\' || report[i][j]==\\'\\\\0\\'){\\n                    space=j;\\n                    string curr=report[i].substr(start, space-start);\\n                    if(pos.find(curr)!=pos.end())points+=3;\\n                    else if(neg.find(curr)!=neg.end())points-=1;\\n                }\\n                j++;\\n            }\\n            ans.push({points, -student_id[i]});\\n        }\\n        vector<int> result(k);\\n        int i=0;\\n        while(!ans.empty() && i<k){\\n            pair<int, int> p=ans.top();\\n            result[i++]=-p.second;\\n            ans.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213158,
                "title": "easy-c",
                "content": "# Intuition\\nWe have to find top k students so choose those students who is having greater points and less id.\\n\\n\\n# Approach\\nCalculate points of each student and sort according to given conditions.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool static  comp(pair<int,int> &p1,pair<int,int> &p2)\\n{\\n    if (p1.second==p2.second)\\n    {\\n        return p1.first<p2.first;\\n    }\\n    return p1.second>p2.second;\\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n       unordered_set<string> pos;\\n       unordered_set<string> neg;\\n        for (string s:positive_feedback)\\n            pos.insert(s);\\n        for (string s:negative_feedback)\\n            neg.insert(s);\\n        int n=report.size();\\n        vector<pair<int,int>> ans;\\n        for (int i=0;i<n;i++)\\n        {\\n            string rep=report[i];\\n            int j=0;\\n            int points=0;\\n            while (j<rep.size())\\n            {\\n                string word=\"\";\\n                while (j<rep.size() && rep[j]!=\\' \\')\\n                  word+=rep[j++];\\n                j++;\\n                if (pos.find(word)!=pos.end())\\n                   points+=3;\\n                else if (neg.find(word)!=neg.end())\\n                   points-=1;\\n            }\\n            ans.push_back({student_id[i],points});\\n        }\\n\\n        sort(ans.begin(),ans.end(),comp);\\n        vector<int> res;\\n        for (int i=0;i<k;i++)\\n          res.push_back(ans[i].first);\\n        return res;\\n\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool static  comp(pair<int,int> &p1,pair<int,int> &p2)\\n{\\n    if (p1.second==p2.second)\\n    {\\n        return p1.first<p2.first;\\n    }\\n    return p1.second>p2.second;\\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n       unordered_set<string> pos;\\n       unordered_set<string> neg;\\n        for (string s:positive_feedback)\\n            pos.insert(s);\\n        for (string s:negative_feedback)\\n            neg.insert(s);\\n        int n=report.size();\\n        vector<pair<int,int>> ans;\\n        for (int i=0;i<n;i++)\\n        {\\n            string rep=report[i];\\n            int j=0;\\n            int points=0;\\n            while (j<rep.size())\\n            {\\n                string word=\"\";\\n                while (j<rep.size() && rep[j]!=\\' \\')\\n                  word+=rep[j++];\\n                j++;\\n                if (pos.find(word)!=pos.end())\\n                   points+=3;\\n                else if (neg.find(word)!=neg.end())\\n                   points-=1;\\n            }\\n            ans.push_back({student_id[i],points});\\n        }\\n\\n        sort(ans.begin(),ans.end(),comp);\\n        vector<int> res;\\n        for (int i=0;i<k;i++)\\n          res.push_back(ans[i].first);\\n        return res;\\n\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203313,
                "title": "java-hash-table-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(\\n        String[] positive_feedback, \\n        String[] negative_feedback, \\n        String[] report, \\n        int[] student_id, \\n        int k\\n    ) {\\n        Set<String> posSet = new HashSet<>();\\n        Set<String> negSet = new HashSet<>();\\n        for (String s : positive_feedback) {\\n            posSet.add(s);\\n        }   \\n        for (String s : negative_feedback) {\\n            negSet.add(s);\\n        } \\n        PriorityQueue<int[]> queue = new PriorityQueue<>((arr1, arr2) -> {\\n            if (arr1[1] != arr2[1]) {\\n                return arr1[1] - arr2[1];\\n            }\\n            return arr2[0] - arr1[0];\\n        });\\n        for (int i = 0; i < report.length; i++) {\\n            int score = 0;\\n            for (String word : report[i].split(\" \")) {\\n                if (posSet.contains(word)) {\\n                    score += 3;\\n                }\\n                else if (negSet.contains(word)) {\\n                    score -= 1;\\n                }\\n            }\\n            queue.add(new int[] {student_id[i], score});\\n            if (queue.size() > k) {\\n                queue.remove();\\n            }\\n        }\\n        LinkedList<Integer> resList = new LinkedList<>();\\n        for (int i = 0; i < k; i++) {\\n            resList.addFirst(queue.poll()[0]);\\n        }\\n        return resList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(\\n        String[] positive_feedback, \\n        String[] negative_feedback, \\n        String[] report, \\n        int[] student_id, \\n        int k\\n    ) {\\n        Set<String> posSet = new HashSet<>();\\n        Set<String> negSet = new HashSet<>();\\n        for (String s : positive_feedback) {\\n            posSet.add(s);\\n        }   \\n        for (String s : negative_feedback) {\\n            negSet.add(s);\\n        } \\n        PriorityQueue<int[]> queue = new PriorityQueue<>((arr1, arr2) -> {\\n            if (arr1[1] != arr2[1]) {\\n                return arr1[1] - arr2[1];\\n            }\\n            return arr2[0] - arr1[0];\\n        });\\n        for (int i = 0; i < report.length; i++) {\\n            int score = 0;\\n            for (String word : report[i].split(\" \")) {\\n                if (posSet.contains(word)) {\\n                    score += 3;\\n                }\\n                else if (negSet.contains(word)) {\\n                    score -= 1;\\n                }\\n            }\\n            queue.add(new int[] {student_id[i], score});\\n            if (queue.size() > k) {\\n                queue.remove();\\n            }\\n        }\\n        LinkedList<Integer> resList = new LinkedList<>();\\n        for (int i = 0; i < k; i++) {\\n            resList.addFirst(queue.poll()[0]);\\n        }\\n        return resList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202205,
                "title": "c-pq-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate: \\n    struct cmp{\\n        bool operator()(pair<int,int>&a, pair<int,int>&b){\\n            if(a.first > b.first) return true;\\n            else if (a.first==b.first && a.second < b.second) return true; \\n            else return false; \\n        }\\n    }; \\n\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        //minheap of size k \\n        unordered_set<string> good(positive_feedback.begin(),positive_feedback.end()); \\n        unordered_set<string> bad(negative_feedback.begin(),negative_feedback.end()); \\n        int len = report.size(); \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> q; //<score, student id> \\n        for(int i=0;i<len;i++){\\n            int score = 0; \\n            string str = report[i];\\n            //calculate score \\n            int j = 0; \\n            while(j<str.length()){\\n                string token = \"\"; //parse token \\n                while(j<str.length()&&str[j]!=\\' \\') token += str[j++]; \\n                if (good.find(token)!=good.end()) score += 3;\\n                else if (bad.find(token)!=bad.end()) score--;  \\n                j++;\\n            }\\n            q.push({score, student_id[i]});\\n            while(q.size()>k) q.pop();  \\n        } \\n        vector<int> res;\\n        while(!q.empty()){\\n            res.push_back({q.top().second});\\n            q.pop(); \\n        }\\n        //minheap --> need to reverse order \\n        reverse(res.begin(), res.end());\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    struct cmp{\\n        bool operator()(pair<int,int>&a, pair<int,int>&b){\\n            if(a.first > b.first) return true;\\n            else if (a.first==b.first && a.second < b.second) return true; \\n            else return false; \\n        }\\n    }; \\n\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        //minheap of size k \\n        unordered_set<string> good(positive_feedback.begin(),positive_feedback.end()); \\n        unordered_set<string> bad(negative_feedback.begin(),negative_feedback.end()); \\n        int len = report.size(); \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> q; //<score, student id> \\n        for(int i=0;i<len;i++){\\n            int score = 0; \\n            string str = report[i];\\n            //calculate score \\n            int j = 0; \\n            while(j<str.length()){\\n                string token = \"\"; //parse token \\n                while(j<str.length()&&str[j]!=\\' \\') token += str[j++]; \\n                if (good.find(token)!=good.end()) score += 3;\\n                else if (bad.find(token)!=bad.end()) score--;  \\n                j++;\\n            }\\n            q.push({score, student_id[i]});\\n            while(q.size()>k) q.pop();  \\n        } \\n        vector<int> res;\\n        while(!q.empty()){\\n            res.push_back({q.top().second});\\n            q.pop(); \\n        }\\n        //minheap --> need to reverse order \\n        reverse(res.begin(), res.end());\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201689,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        var positiveWords = new HashSet<string>(positive_feedback);\\n        var negativeWords = new HashSet<string>(negative_feedback);\\n        var points = new int[report.Length][];\\n        for (var i = 0; i < points.Length; i++)\\n            points[i] = new int[2];\\n\\n        for (var i = 0; i < report.Length; i++) \\n        {\\n            points[i][1] = student_id[i];\\n            var words = report[i].Split(\" \");\\n            foreach (var word in words)\\n            {\\n                if (positiveWords.Contains(word))\\n                    points[i][0] += 3;\\n                else if (negativeWords.Contains(word))\\n                    points[i][0]--;\\n            }\\n        }\\n\\n        Array.Sort(points, (a, b) => a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\\n        var res = new List<int>();\\n        var j = 0;\\n        for (var i = 0; i < k; i++)\\n            res.Add(points[j++][1]);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TopStudents(string[] positive_feedback, string[] negative_feedback, string[] report, int[] student_id, int k) {\\n        var positiveWords = new HashSet<string>(positive_feedback);\\n        var negativeWords = new HashSet<string>(negative_feedback);\\n        var points = new int[report.Length][];\\n        for (var i = 0; i < points.Length; i++)\\n            points[i] = new int[2];\\n\\n        for (var i = 0; i < report.Length; i++) \\n        {\\n            points[i][1] = student_id[i];\\n            var words = report[i].Split(\" \");\\n            foreach (var word in words)\\n            {\\n                if (positiveWords.Contains(word))\\n                    points[i][0] += 3;\\n                else if (negativeWords.Contains(word))\\n                    points[i][0]--;\\n            }\\n        }\\n\\n        Array.Sort(points, (a, b) => a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\\n        var res = new List<int>();\\n        var j = 0;\\n        for (var i = 0; i < k; i++)\\n            res.Add(points[j++][1]);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197325,
                "title": "java-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int a;\\n        int b;\\n        Pair(int a,int b){\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n\\n    class Pairt implements Comparator<Pair>{\\n            public int compare(Pair o,Pair v){\\n                if(o.b>v.b)return -1;\\n                else if(o.b==v.b){\\n                    if(o.a<v.a)return -1;\\n                    else return 1;\\n                }\\n                else return 1;\\n            }\\n        }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->{\\n            if(a.b!=b.b)return b.b - a.b;\\n            else return a.a - b.a;\\n        });\\n        HashSet<String> pos = new HashSet<>();\\n        HashSet<String> neg  = new HashSet<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(String a: positive_feedback)pos.add(a);\\n        for(String a: negative_feedback)neg.add(a);\\n        for(int i = 0;i<report.length;i++){\\n            String s = report[i];\\n            int id = student_id[i],count = 0;\\n            String [] splitted = s.split(\" \");\\n            for(String b:splitted){\\n                if(pos.contains(b))count+=3;\\n                if(neg.contains(b))count-=1;\\n            }\\n            pq.add(new Pair(id,count));\\n        }\\n        int j = 0;\\n        while(j!=k){\\n            ans.add(pq.remove().a);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int a;\\n        int b;\\n        Pair(int a,int b){\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n\\n    class Pairt implements Comparator<Pair>{\\n            public int compare(Pair o,Pair v){\\n                if(o.b>v.b)return -1;\\n                else if(o.b==v.b){\\n                    if(o.a<v.a)return -1;\\n                    else return 1;\\n                }\\n                else return 1;\\n            }\\n        }\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->{\\n            if(a.b!=b.b)return b.b - a.b;\\n            else return a.a - b.a;\\n        });\\n        HashSet<String> pos = new HashSet<>();\\n        HashSet<String> neg  = new HashSet<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(String a: positive_feedback)pos.add(a);\\n        for(String a: negative_feedback)neg.add(a);\\n        for(int i = 0;i<report.length;i++){\\n            String s = report[i];\\n            int id = student_id[i],count = 0;\\n            String [] splitted = s.split(\" \");\\n            for(String b:splitted){\\n                if(pos.contains(b))count+=3;\\n                if(neg.contains(b))count-=1;\\n            }\\n            pq.add(new Pair(id,count));\\n        }\\n        int j = 0;\\n        while(j!=k){\\n            ans.add(pq.remove().a);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166473,
                "title": "clean-python3-solution-with-grader-class",
                "content": "\\n```\\nclass Grader:\\n\\n    def __init__(self, pos, neg):\\n        self.pos = set(pos)\\n        self.neg = set(neg)\\n\\n    def grade(self, report):\\n        score = 0\\n        for word in report.split():\\n            if word in self.pos:\\n                score += 3\\n            if word in self.neg:\\n                score -= 1\\n        return score\\n\\nclass Solution:\\n    \\n    def get_top_k_students(self, result, k):\\n        return [i for _, i in sorted(result)[:k]]\\n\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        grader = Grader(positive_feedback, negative_feedback)\\n        result = []\\n        for student_id_i, report_i in zip(student_id, report):\\n            score = grader.grade(report_i)\\n            result.append((score * -1, student_id_i))\\n        return self.get_top_k_students(result, k)\\n\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Grader:\\n\\n    def __init__(self, pos, neg):\\n        self.pos = set(pos)\\n        self.neg = set(neg)\\n\\n    def grade(self, report):\\n        score = 0\\n        for word in report.split():\\n            if word in self.pos:\\n                score += 3\\n            if word in self.neg:\\n                score -= 1\\n        return score\\n\\nclass Solution:\\n    \\n    def get_top_k_students(self, result, k):\\n        return [i for _, i in sorted(result)[:k]]\\n\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        grader = Grader(positive_feedback, negative_feedback)\\n        result = []\\n        for student_id_i, report_i in zip(student_id, report):\\n            score = grader.grade(report_i)\\n            result.append((score * -1, student_id_i))\\n        return self.get_top_k_students(result, k)\\n\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163908,
                "title": "method-chain-and-two-sets",
                "content": "# Approach\\nCreate two sets for positive and negative feedback words to speed up checking. \\n\\nDefine a scoring function that assigns a numeric value from a `report` entry.\\n\\nIteratively transform the `student_id` array by attaching the score, sorting, slicing and selecting the final id ordering.\\n\\n# Code\\n```\\nfunction topStudents(\\n    positive_feedback: string[],\\n    negative_feedback: string[],\\n    report: string[],\\n    student_id: number[],\\n    k: number,\\n): number[] {\\n    const pset = new Set(positive_feedback),\\n        nset = new Set(negative_feedback),\\n        calcScore = (six: number) =>\\n            report[six]\\n                .split(\" \")\\n                .reduce((score, word) =>\\n                    score + (pset.has(word) ? 3 : nset.has(word) ? -1 : 0), 0);\\n\\n    return student_id\\n        .map((sid, six) => [sid, calcScore(six)])\\n        .sort((a, b) => (a[1] !== b[1] ? b[1] - a[1] : a[0] - b[0]))\\n        .slice(0, k)\\n        .map((r) => r[0]);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction topStudents(\\n    positive_feedback: string[],\\n    negative_feedback: string[],\\n    report: string[],\\n    student_id: number[],\\n    k: number,\\n): number[] {\\n    const pset = new Set(positive_feedback),\\n        nset = new Set(negative_feedback),\\n        calcScore = (six: number) =>\\n            report[six]\\n                .split(\" \")\\n                .reduce((score, word) =>\\n                    score + (pset.has(word) ? 3 : nset.has(word) ? -1 : 0), 0);\\n\\n    return student_id\\n        .map((sid, six) => [sid, calcScore(six)])\\n        .sort((a, b) => (a[1] !== b[1] ? b[1] - a[1] : a[0] - b[0]))\\n        .slice(0, k)\\n        .map((r) => r[0]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3153839,
                "title": "python-heapq",
                "content": "```python\\nclass Solution:\\n\\tdef topStudents(self, positive_feedback: list[str], negative_feedback: list[str], report: list[str], student_id: list[int], k: int) -> list[int]:\\n\\t\\td = [0]*len(student_id)\\n\\t\\tpositive_feedback_set = set(positive_feedback)\\n\\t\\tnegative_feedback_set = set(negative_feedback)\\n\\n\\t\\tfor i, student_report in enumerate(report):\\n\\t\\t\\tpoint = 0\\n\\t\\t\\tfor word in student_report.split():\\n\\t\\t\\t\\tif word in positive_feedback_set:\\n\\t\\t\\t\\t\\tpoint += 3\\n\\t\\t\\t\\telif word in negative_feedback_set:\\n\\t\\t\\t\\t\\tpoint -= 1\\n\\t\\t\\td[i] = point\\n\\t\\t# heapq.nlargest(k, enumerate(student_id), key = lambda x: (d[x[0]], -x[1]))\\n\\t\\treturn [id for _, id in heapq.nsmallest(k, enumerate(student_id), key = lambda x: (-d[x[0]], x[1]))]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef topStudents(self, positive_feedback: list[str], negative_feedback: list[str], report: list[str], student_id: list[int], k: int) -> list[int]:\\n\\t\\td = [0]*len(student_id)\\n\\t\\tpositive_feedback_set = set(positive_feedback)\\n\\t\\tnegative_feedback_set = set(negative_feedback)\\n\\n\\t\\tfor i, student_report in enumerate(report):\\n\\t\\t\\tpoint = 0\\n\\t\\t\\tfor word in student_report.split():\\n\\t\\t\\t\\tif word in positive_feedback_set:\\n\\t\\t\\t\\t\\tpoint += 3\\n\\t\\t\\t\\telif word in negative_feedback_set:\\n\\t\\t\\t\\t\\tpoint -= 1\\n\\t\\t\\td[i] = point\\n\\t\\t# heapq.nlargest(k, enumerate(student_id), key = lambda x: (d[x[0]], -x[1]))\\n\\t\\treturn [id for _, id in heapq.nsmallest(k, enumerate(student_id), key = lambda x: (-d[x[0]], x[1]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151637,
                "title": "c-map-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    static bool comp(pair<int, int> &A, pair<int, int> &B) {\\n        return A.first > B.first || (A.first == B.first && A.second < B.second);\\n    }\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positives(positive_feedback.begin(), positive_feedback.end());\\n        unordered_set<string> negatives(negative_feedback.begin(), negative_feedback.end());\\n        int n = student_id.size();\\n        map<int, int> points;\\n        for(int i = 0; i < n; i++) {\\n            points[student_id[i]] = 0;\\n            report[i] += \" \";\\n            string word = \"\";\\n            for(int j = 0; j < report[i].size(); j++) {\\n                char ch = report[i][j];\\n                if(ch != \\' \\')\\n                    word += ch;\\n                else {\\n                    if(positives.find(word) != positives.end())\\n                        points[student_id[i]] += 3;\\n                    if(negatives.find(word) != negatives.end())\\n                        points[student_id[i]] -= 1;\\n                    word = \"\";\\n                }\\n            }\\n        }\\n        vector<pair<int, int>> temp;\\n        for(auto &[key, val]: points) {\\n            temp.push_back({val, key});\\n        }\\n        sort(temp.begin(), temp.end(), comp);\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) {\\n            ans.push_back(temp[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool comp(pair<int, int> &A, pair<int, int> &B) {\\n        return A.first > B.first || (A.first == B.first && A.second < B.second);\\n    }\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positives(positive_feedback.begin(), positive_feedback.end());\\n        unordered_set<string> negatives(negative_feedback.begin(), negative_feedback.end());\\n        int n = student_id.size();\\n        map<int, int> points;\\n        for(int i = 0; i < n; i++) {\\n            points[student_id[i]] = 0;\\n            report[i] += \" \";\\n            string word = \"\";\\n            for(int j = 0; j < report[i].size(); j++) {\\n                char ch = report[i][j];\\n                if(ch != \\' \\')\\n                    word += ch;\\n                else {\\n                    if(positives.find(word) != positives.end())\\n                        points[student_id[i]] += 3;\\n                    if(negatives.find(word) != negatives.end())\\n                        points[student_id[i]] -= 1;\\n                    word = \"\";\\n                }\\n            }\\n        }\\n        vector<pair<int, int>> temp;\\n        for(auto &[key, val]: points) {\\n            temp.push_back({val, key});\\n        }\\n        sort(temp.begin(), temp.end(), comp);\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) {\\n            ans.push_back(temp[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143241,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // top k .. min heap\\n\\n        std::unordered_set<string> posf{positive_feedback.begin(), positive_feedback.end()};\\n        std::unordered_set<string> negf{negative_feedback.begin(), negative_feedback.end()};\\n\\n        auto comp = [] (const auto& p1, const auto& p2) {\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n        };\\n\\n        std::priority_queue<pair<int, int>, vector<pair<int,int>>, decltype(comp)> pq(comp);\\n\\n        for (int i = 0; i < report.size(); ++i) {\\n            int score = 0;\\n            const auto& rp = report[i];\\n            size_t start = 0, pos;\\n            while ((pos = rp.find(\\' \\', start)) != std::string::npos) {\\n                const string word = rp.substr(start, pos - start);\\n                start = pos + 1;\\n                if (posf.find(word) != posf.end()) {\\n                    score += 3;\\n                }\\n                if (negf.find(word) != negf.end()) {\\n                    score -= 1;\\n                }\\n            }\\n\\n            const string word = rp.substr(start);\\n            if (posf.find(word) != posf.end()) {\\n                score += 3;\\n            }\\n            if (negf.find(word) != negf.end()) {\\n                score -= 1;\\n            }\\n            pq.push({score, student_id[i]});\\n            while (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        vector<int> result;\\n        while (!pq.empty()) {\\n            result.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        std::reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        // top k .. min heap\\n\\n        std::unordered_set<string> posf{positive_feedback.begin(), positive_feedback.end()};\\n        std::unordered_set<string> negf{negative_feedback.begin(), negative_feedback.end()};\\n\\n        auto comp = [] (const auto& p1, const auto& p2) {\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n        };\\n\\n        std::priority_queue<pair<int, int>, vector<pair<int,int>>, decltype(comp)> pq(comp);\\n\\n        for (int i = 0; i < report.size(); ++i) {\\n            int score = 0;\\n            const auto& rp = report[i];\\n            size_t start = 0, pos;\\n            while ((pos = rp.find(\\' \\', start)) != std::string::npos) {\\n                const string word = rp.substr(start, pos - start);\\n                start = pos + 1;\\n                if (posf.find(word) != posf.end()) {\\n                    score += 3;\\n                }\\n                if (negf.find(word) != negf.end()) {\\n                    score -= 1;\\n                }\\n            }\\n\\n            const string word = rp.substr(start);\\n            if (posf.find(word) != posf.end()) {\\n                score += 3;\\n            }\\n            if (negf.find(word) != negf.end()) {\\n                score -= 1;\\n            }\\n            pq.push({score, student_id[i]});\\n            while (pq.size() > k) {\\n                pq.pop();\\n            }\\n        }\\n\\n        vector<int> result;\\n        while (!pq.empty()) {\\n            result.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        std::reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137148,
                "title": "easy-c-solution-using-set-and-hash-map",
                "content": "class Solution {\\npublic:\\n    vector<pair<int, int> > A;\\n static bool cmp(pair<int, int>& a,\\n        pair<int, int>& b)\\n{\\n     if(a.second!=b.second)\\n    return a.second > b.second;\\n     else\\n         return a.first<b.first;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nvoid sorting(map<int, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    \\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n \\n    // Print the sorted value\\n   \\n}\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        set<string>pos,neg;\\n        for(int i=0;i<positive_feedback.size();i++)\\n        {\\n            pos.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++)\\n        {\\n            neg.insert(negative_feedback[i]);\\n        }\\n        map<int,int>m;\\n        for(int i=0;i<student_id.size();i++)\\n        {\\n            report[i]=report[i]+\\' \\';\\n            string s=\"\";int c=0;\\n            for(int j=0;j<report[i].size();j++)\\n            {\\n                if(report[i][j]!=\\' \\')\\n                    s=s+report[i][j];\\n                else\\n                {\\n                    if(pos.find(s)!=pos.end())\\n                        c=c+3;\\n                    else if(neg.find(s)!=neg.end())\\n                        c=c-1;\\n                    s=\"\";\\n                    \\n                }\\n            }\\n            m[student_id[i]]=c;\\n        }\\n       \\n        sorting(m);\\n       \\n        vector<int>v;\\n        for(int i=0;i<k;i++)\\n        {\\n            v.push_back(A[i].first);\\n        }\\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<pair<int, int> > A;\\n static bool cmp(pair<int, int>& a,\\n        pair<int, int>& b)\\n{\\n     if(a.second!=b.second)\\n    return a.second > b.second;\\n     else\\n         return a.first<b.first;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3136901,
                "title": "python-easy-to-read-and-understand-set-heap",
                "content": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pq = []\\n        pos, neg = set(), set()\\n        for word in positive_feedback:\\n            pos.add(word)\\n        for word in negative_feedback:\\n            neg.add(word)\\n        \\n        for i, sentence in enumerate(report):\\n            lst = sentence.split(\" \")\\n            points = 0\\n            for word in lst:\\n                if word in pos:\\n                    points += 3\\n                elif word in neg:\\n                    points -= 1\\n            heapq.heappush(pq, (-1*points, student_id[i]))\\n        \\n        res = []\\n        while pq and k > 0:\\n            point, stu_id = heapq.heappop(pq)\\n            #print(point, stu_id)\\n            res.append(stu_id)\\n            k -= 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pq = []\\n        pos, neg = set(), set()\\n        for word in positive_feedback:\\n            pos.add(word)\\n        for word in negative_feedback:\\n            neg.add(word)\\n        \\n        for i, sentence in enumerate(report):\\n            lst = sentence.split(\" \")\\n            points = 0\\n            for word in lst:\\n                if word in pos:\\n                    points += 3\\n                elif word in neg:\\n                    points -= 1\\n            heapq.heappush(pq, (-1*points, student_id[i]))\\n        \\n        res = []\\n        while pq and k > 0:\\n            point, stu_id = heapq.heappop(pq)\\n            #print(point, stu_id)\\n            res.append(stu_id)\\n            k -= 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3135923,
                "title": "python-use-set-and-heapq-nlargest-shortest-solution",
                "content": "# Approach\\n- Use `set` for positive_feedback and negative_feedback to check more quickly whether a word is good or bad.\\n- Use heap of fixed size to find k largest elements. Actually `heapq.nlargest` - https://docs.python.org/3/library/heapq.html\\n- Use a generator to avoid allocating extra memory\\n- Use the implicit conversion of bool to int `(w in pos) -> 0,1` to reduce the code size\\n- Make tuples `(points, -student_id)` - \"tuples are compared lexicographically\", so if points are equal we compare `-student_id` (`-` for reversed order) - https://docs.python.org/3/howto/sorting.html#decorate-sort-undecorate\\n- Return only student_id - the second element of the tuple. And make it positive again - `-x[1]`\\n- Write it on one line to make it unreadable. I don\\'t know why!\\n- Add a more readable solution.\\n\\n# Complexity\\n- Time complexity:\\n`O(n * w + n*log(k))`, where\\n`p = positive_feedback.length`,\\n`w = average number of words in the reports`\\nAssume that `k << n` and `negative_feedback.length < p << n`.\\n  - Creation sets - `set(positive_feedback)` - `O(p)`\\n  - Calc points for each word in each report - `w in pos` - `O(1) * w * n = O(n * w)`\\n  - Get k largest points - `heapq.nlargest(k,` - `O(n * log(k)`\\n  - https://stackoverflow.com/questions/7351459/time-complexity-of-python-set-operations\\n  - https://stackoverflow.com/questions/23038756/what-is-the-time-complexity-of-heapq-nlargest \\n\\n- Space complexity:\\n`O(k + p + max_w)`, where\\n`p = positive_feedback.length`,\\n`max_w = maximum number of words in a report`\\n  - `set(positive_feedback)` - `O(p)`\\n  - `heapq.nlargest(k, ` - `O(k)`\\n  - https://stackoverflow.com/questions/23038756/what-is-the-time-complexity-of-heapq-nlargest\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos, neg = set(positive_feedback), set(negative_feedback)\\n        return [-x[1] for x in heapq.nlargest(k, (\\n                (sum(3*(w in pos) - (w in neg)\\n                for w in r.split(\\' \\')), -s)\\n                for r, s in zip(report, student_id)\\n            )\\n        )]\\n```\\n**More readable:**\\n```\\nimport heapq\\n\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos, neg = set(positive_feedback), set(negative_feedback)\\n        \\n        # use a generator to avoid allocating extra memory\\n        def points_generator(report, student_id, pos, neg):\\n            for r, s in zip(report, student_id):\\n                points =  sum(3*(w in pos) - (w in neg) for w in r.split(\\' \\'))\\n                yield (points, -s)\\n\\n        k_largest = heapq.nlargest(k, points_generator(report, student_id, pos, neg))\\n\\n        return [-x[1] for x in k_largest]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos, neg = set(positive_feedback), set(negative_feedback)\\n        return [-x[1] for x in heapq.nlargest(k, (\\n                (sum(3*(w in pos) - (w in neg)\\n                for w in r.split(\\' \\')), -s)\\n                for r, s in zip(report, student_id)\\n            )\\n        )]\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pos, neg = set(positive_feedback), set(negative_feedback)\\n        \\n        # use a generator to avoid allocating extra memory\\n        def points_generator(report, student_id, pos, neg):\\n            for r, s in zip(report, student_id):\\n                points =  sum(3*(w in pos) - (w in neg) for w in r.split(\\' \\'))\\n                yield (points, -s)\\n\\n        k_largest = heapq.nlargest(k, points_generator(report, student_id, pos, neg))\\n\\n        return [-x[1] for x in k_largest]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135148,
                "title": "java-hashmap-priority-queue-easy-understanding-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHashMap + Priority Queue\\n\\n# Complexity\\n- Time complexity: O (nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        Map<String, Integer> score = new HashMap<>();\\n        for(String s: positive_feedback){\\n            score.put(s, 3);\\n        }\\n        for(String s: negative_feedback){\\n            score.put(s, -1);\\n        }\\n        Map<Integer, Integer> pair = new HashMap<>();\\n        for(int i = 0; i < report.length; i++){\\n            int sum = 0;\\n            String[] splitReport = report[i].split(\" \");\\n            for(String s: splitReport){\\n                if(score.containsKey(s)){\\n                    sum += score.get(s);\\n                }\\n            }\\n            pair.put(student_id[i], sum);\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) ->pair.get(b) == pair.get(a) ? a - b : pair.get(b) - pair.get(a));\\n        pq.addAll(pair.keySet());\\n        while(!pq.isEmpty() && k != 0){\\n            res.add(pq.poll());\\n            k--;\\n        }\\n        return res;\\n    }\\n}\\n        \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        Map<String, Integer> score = new HashMap<>();\\n        for(String s: positive_feedback){\\n            score.put(s, 3);\\n        }\\n        for(String s: negative_feedback){\\n            score.put(s, -1);\\n        }\\n        Map<Integer, Integer> pair = new HashMap<>();\\n        for(int i = 0; i < report.length; i++){\\n            int sum = 0;\\n            String[] splitReport = report[i].split(\" \");\\n            for(String s: splitReport){\\n                if(score.containsKey(s)){\\n                    sum += score.get(s);\\n                }\\n            }\\n            pair.put(student_id[i], sum);\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) ->pair.get(b) == pair.get(a) ? a - b : pair.get(b) - pair.get(a));\\n        pq.addAll(pair.keySet());\\n        while(!pq.isEmpty() && k != 0){\\n            res.add(pq.poll());\\n            k--;\\n        }\\n        return res;\\n    }\\n}\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129343,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    trait Monoid[T] {\\n        def op(l: T, r: T): T\\n        def zero: T\\n    }\\n\\n    val IntMonoid: Monoid[Int] = new Monoid[Int] {\\n        def op(a1: Int, a2: Int): Int = a1 + a2\\n        val zero = 0\\n    }\\n    def topStudents(positive_feedback: Array[String], negative_feedback: Array[String],\\n                    report: Array[String], student_id: Array[Int], k: Int): List[Int] = {\\n        val positive = positive_feedback.toSet\\n        val negative = negative_feedback.toSet\\n\\n        val posscores = report.map(ns => ns.split(\" \").map(n => if(positive.contains(n)) 3 else 0))\\n        val negcores = report.map(ns => ns.split(\" \").map(n => if(negative.contains(n)) -1 else 0))\\n\\n        val posscoresOne = posscores.map(n => n.foldLeft(IntMonoid.zero)(IntMonoid.op))\\n        val negcoresOne = negcores.map(n => n.foldLeft(IntMonoid.zero)(IntMonoid.op))\\n        (posscoresOne zip negcoresOne).map(n => n._1 + n._2).zip(student_id).sortBy(n=> (-n._1, n._2)).map(_._2).take(k).toList \\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    trait Monoid[T] {\\n        def op(l: T, r: T): T\\n        def zero: T\\n    }\\n\\n    val IntMonoid: Monoid[Int] = new Monoid[Int] {\\n        def op(a1: Int, a2: Int): Int = a1 + a2\\n        val zero = 0\\n    }\\n    def topStudents(positive_feedback: Array[String], negative_feedback: Array[String],\\n                    report: Array[String], student_id: Array[Int], k: Int): List[Int] = {\\n        val positive = positive_feedback.toSet\\n        val negative = negative_feedback.toSet\\n\\n        val posscores = report.map(ns => ns.split(\" \").map(n => if(positive.contains(n)) 3 else 0))\\n        val negcores = report.map(ns => ns.split(\" \").map(n => if(negative.contains(n)) -1 else 0))\\n\\n        val posscoresOne = posscores.map(n => n.foldLeft(IntMonoid.zero)(IntMonoid.op))\\n        val negcoresOne = negcores.map(n => n.foldLeft(IntMonoid.zero)(IntMonoid.op))\\n        (posscoresOne zip negcoresOne).map(n => n._1 + n._2).zip(student_id).sortBy(n=> (-n._1, n._2)).map(_._2).take(k).toList \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3117623,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Set;\\nimport java.util.List;\\nimport java.util.HashSet;\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.PriorityQueue;\\n\\npublic class Solution {\\n\\n    private record Student(int ID, int score) {}\\n    private final Set<String> positiveFeedbackWords = new HashSet<>();\\n    private final Set<String> negativeFeedbackWords = new HashSet<>();\\n   \\n    public List<Integer> topStudents(String[] positiveFeedback, String[] negativeFeedback,\\n            String[] report, int[] studentID, int numberOfTopStudentsToRank) {\\n\\n        Collections.addAll(positiveFeedbackWords, positiveFeedback);\\n        Collections.addAll(negativeFeedbackWords, negativeFeedback);\\n        PriorityQueue<Student> minHeapStudents = new PriorityQueue<>(\\n                                                 (studentOne, studentTwo) -> (studentOne.score == studentTwo.score)\\n                                                 ? studentTwo.ID - studentOne.ID\\n                                                 : studentOne.score - studentTwo.score);\\n\\n        int index = 0;\\n        while (index < studentID.length && minHeapStudents.size() < numberOfTopStudentsToRank) {\\n            int score = calculateScore(report[index]);\\n            minHeapStudents.add(new Student(studentID[index], score));\\n            ++index;\\n        }\\n\\n        while (index < studentID.length) {\\n            int score = calculateScore(report[index]);\\n            if (currentStudentRanksHigher(minHeapStudents, studentID[index], score)) {\\n                minHeapStudents.poll();\\n                minHeapStudents.add(new Student(studentID[index], score));\\n            }\\n            ++index;\\n        }\\n\\n        return rankedStudentsAsSortedList(minHeapStudents);\\n    }\\n\\n    private List<Integer> rankedStudentsAsSortedList(PriorityQueue<Student> minHeapStudents) {\\n        List<Integer> topStudentsID = new ArrayList<>();\\n        while (!minHeapStudents.isEmpty()) {\\n            topStudentsID.add(minHeapStudents.poll().ID);\\n        }\\n        Collections.reverse(topStudentsID);\\n        return topStudentsID;\\n    }\\n\\n    private int calculateScore(String report) {\\n        int score = 0;\\n        String[] array = report.split(\" \");\\n        for (int i = 0; i < array.length; ++i) {\\n            if (positiveFeedbackWords.contains(array[i])) {\\n                score += 3;\\n            } else if (negativeFeedbackWords.contains(array[i])) {\\n                --score;\\n            }\\n        }\\n        return score;\\n    }\\n\\n    private boolean currentStudentRanksHigher(PriorityQueue<Student> minHeapStudents, int studentID, int score) {\\n        return score > minHeapStudents.peek().score || (score == minHeapStudents.peek().score && studentID < minHeapStudents.peek().ID);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string[]} positiveFeedback\\n * @param {string[]} negativeFeedback\\n * @param {string[]} report\\n * @param {number[]} studentID\\n * @param {number} numberOfTopStudentsToRank\\n * @return {number[]}\\n */\\nvar topStudents = function (positiveFeedback, negativeFeedback, report, studentID, numberOfTopStudentsToRank) {\\n    this.positiveFeedbackWords = new Set(positiveFeedback);\\n    this.negativeFeedbackWords = new Set(negativeFeedback);\\n\\n    //const {MinPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n    const minHeapStudents = new MinPriorityQueue({compare:\\n                            (studentOne, studentTwo) => (studentOne.score === studentTwo.score)\\n                            ? studentTwo.ID - studentOne.ID\\n                            : studentOne.score - studentTwo.score});\\n\\n    let index = 0;\\n    while (index < studentID.length && minHeapStudents.size() < numberOfTopStudentsToRank) {\\n        let score = calculateScore(report[index]);\\n        minHeapStudents.enqueue(new Student(studentID[index], score));\\n        ++index;\\n    }\\n\\n    while (index < studentID.length) {\\n        let score = calculateScore(report[index]);\\n        if (currentStudentRanksHigher(minHeapStudents, studentID[index], score)) {\\n            minHeapStudents.dequeue();\\n            minHeapStudents.enqueue(new Student(studentID[index], score));\\n        }\\n        ++index;\\n    }\\n\\n    return rankedStudentsAsSortedArray(minHeapStudents);\\n};\\n\\n/**\\n * @param {number} ID\\n * @param {number} score\\n */\\nfunction Student(ID, score) {\\n    this.ID = ID;\\n    this.score = score;\\n}\\n\\n/**\\n * @param {MinPriorityQueue<Student>} minHeapStudents\\n * @return {number[]}\\n */\\nfunction rankedStudentsAsSortedArray(minHeapStudents) {\\n    const topStudentsID = [];\\n    while (!minHeapStudents.isEmpty()) {\\n        topStudentsID.push(minHeapStudents.dequeue().ID);\\n    }\\n    topStudentsID.reverse();\\n    return topStudentsID;\\n}\\n\\n/**\\n * @param {string[]} report\\n * @return {number}\\n */\\nfunction  calculateScore(report) {\\n    let score = 0;\\n    const array = report.split(\" \");\\n    for (let i = 0; i < array.length; ++i) {\\n        if (this.positiveFeedbackWords.has(array[i])) {\\n            score += 3;\\n        } else if (this.negativeFeedbackWords.has(array[i])) {\\n            --score;\\n        }\\n    }\\n    return score;\\n}\\n\\n/**\\n * @param {MinPriorityQueue<Student>} minHeapStudents\\n * @param {number} studentID\\n * @param {number} score\\n * @return {boolean}\\n */\\nfunction currentStudentRanksHigher(minHeapStudents, studentID, score) {\\n    return score > minHeapStudents.front().score || (score === minHeapStudents.front().score && studentID < minHeapStudents.front().ID);\\n}\\n```\\n**C++**\\n```\\n#include <queue>\\n#include <vector>\\n#include <string>\\n#include <sstream>\\n#include <iterator>\\n#include <algorithm>\\n#include <unordered_set>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Student {\\n        int ID{};\\n        int score{};\\n        Student(int ID, int score) : ID{ID}, score{score}{}\\n    };\\n\\n    struct ComparatorStudent {\\n        bool operator()(const Student& studentOne, const Student& studentTwo) const {\\n            return (studentOne.score == studentTwo.score) ? studentTwo.ID > studentOne.ID : studentOne.score > studentTwo.score;\\n        };\\n    };\\n\\n    using MinHeapStudents = priority_queue<Student, vector<Student>, ComparatorStudent>;\\n    unique_ptr<unordered_set<string>> positiveFeedbackWords;\\n    unique_ptr<unordered_set<string>> negativeFeedbackWords;\\n\\npublic:\\n    vector<int> topStudents(const vector<string>& positiveFeedback, const vector<string>& negativeFeedback,\\n            const vector<string>& report, const vector<int>& studentID, int numberOfTopStudentsToRank) {\\n\\n        positiveFeedbackWords = make_unique<unordered_set<string>>(positiveFeedback.begin(), positiveFeedback.end());\\n        negativeFeedbackWords = make_unique<unordered_set<string>>(negativeFeedback.begin(), negativeFeedback.end());\\n        MinHeapStudents minHeapStudents;\\n\\n        int index = 0;\\n        while (index < studentID.size() && minHeapStudents.size() < numberOfTopStudentsToRank) {\\n            int score = calculateScore(report[index]);\\n            minHeapStudents.emplace(Student(studentID[index], score));\\n            ++index;\\n        }\\n\\n        while (index < studentID.size()) {\\n            int score = calculateScore(report[index]);\\n            if (currentStudentRanksHigher(minHeapStudents, studentID[index], score)) {\\n                minHeapStudents.pop();\\n                minHeapStudents.emplace(Student(studentID[index], score));\\n            }\\n            ++index;\\n        }\\n\\n        return rankedStudentsAsSortedVector(minHeapStudents);\\n    }\\n\\nprivate:\\n    vector<int> rankedStudentsAsSortedVector(MinHeapStudents& minHeapStudents) const {\\n        vector<int> topStudentsID;\\n        while (!minHeapStudents.empty()) {\\n            topStudentsID.push_back(minHeapStudents.top().ID);\\n            minHeapStudents.pop();\\n        }\\n        reverse(topStudentsID.begin(), topStudentsID.end());\\n        return topStudentsID;\\n    }\\n\\n    int calculateScore(const string& report) const {\\n        stringstream streamReport(report);\\n        string feedbackWord;\\n        int score = 0;\\n\\n        while (getline(streamReport, feedbackWord, \\' \\')) {\\n            if (positiveFeedbackWords->find(feedbackWord) != positiveFeedbackWords->end()) {\\n                score += 3;\\n            } else if (negativeFeedbackWords->find(feedbackWord) != negativeFeedbackWords->end()) {\\n                --score;\\n            }\\n        }\\n        return score;\\n    }\\n\\n    bool currentStudentRanksHigher(const MinHeapStudents& minHeapStudents, int studentID, int score) const {\\n        return score > minHeapStudents.top().score || (score == minHeapStudents.top().score && studentID < minHeapStudents.top().ID);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.Set;\\nimport java.util.List;\\nimport java.util.HashSet;\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.PriorityQueue;\\n\\npublic class Solution {\\n\\n    private record Student(int ID, int score) {}\\n    private final Set<String> positiveFeedbackWords = new HashSet<>();\\n    private final Set<String> negativeFeedbackWords = new HashSet<>();\\n   \\n    public List<Integer> topStudents(String[] positiveFeedback, String[] negativeFeedback,\\n            String[] report, int[] studentID, int numberOfTopStudentsToRank) {\\n\\n        Collections.addAll(positiveFeedbackWords, positiveFeedback);\\n        Collections.addAll(negativeFeedbackWords, negativeFeedback);\\n        PriorityQueue<Student> minHeapStudents = new PriorityQueue<>(\\n                                                 (studentOne, studentTwo) -> (studentOne.score == studentTwo.score)\\n                                                 ? studentTwo.ID - studentOne.ID\\n                                                 : studentOne.score - studentTwo.score);\\n\\n        int index = 0;\\n        while (index < studentID.length && minHeapStudents.size() < numberOfTopStudentsToRank) {\\n            int score = calculateScore(report[index]);\\n            minHeapStudents.add(new Student(studentID[index], score));\\n            ++index;\\n        }\\n\\n        while (index < studentID.length) {\\n            int score = calculateScore(report[index]);\\n            if (currentStudentRanksHigher(minHeapStudents, studentID[index], score)) {\\n                minHeapStudents.poll();\\n                minHeapStudents.add(new Student(studentID[index], score));\\n            }\\n            ++index;\\n        }\\n\\n        return rankedStudentsAsSortedList(minHeapStudents);\\n    }\\n\\n    private List<Integer> rankedStudentsAsSortedList(PriorityQueue<Student> minHeapStudents) {\\n        List<Integer> topStudentsID = new ArrayList<>();\\n        while (!minHeapStudents.isEmpty()) {\\n            topStudentsID.add(minHeapStudents.poll().ID);\\n        }\\n        Collections.reverse(topStudentsID);\\n        return topStudentsID;\\n    }\\n\\n    private int calculateScore(String report) {\\n        int score = 0;\\n        String[] array = report.split(\" \");\\n        for (int i = 0; i < array.length; ++i) {\\n            if (positiveFeedbackWords.contains(array[i])) {\\n                score += 3;\\n            } else if (negativeFeedbackWords.contains(array[i])) {\\n                --score;\\n            }\\n        }\\n        return score;\\n    }\\n\\n    private boolean currentStudentRanksHigher(PriorityQueue<Student> minHeapStudents, int studentID, int score) {\\n        return score > minHeapStudents.peek().score || (score == minHeapStudents.peek().score && studentID < minHeapStudents.peek().ID);\\n    }\\n}\\n```\n```\\n/**\\n * @param {string[]} positiveFeedback\\n * @param {string[]} negativeFeedback\\n * @param {string[]} report\\n * @param {number[]} studentID\\n * @param {number} numberOfTopStudentsToRank\\n * @return {number[]}\\n */\\nvar topStudents = function (positiveFeedback, negativeFeedback, report, studentID, numberOfTopStudentsToRank) {\\n    this.positiveFeedbackWords = new Set(positiveFeedback);\\n    this.negativeFeedbackWords = new Set(negativeFeedback);\\n\\n    //const {MinPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n    const minHeapStudents = new MinPriorityQueue({compare:\\n                            (studentOne, studentTwo) => (studentOne.score === studentTwo.score)\\n                            ? studentTwo.ID - studentOne.ID\\n                            : studentOne.score - studentTwo.score});\\n\\n    let index = 0;\\n    while (index < studentID.length && minHeapStudents.size() < numberOfTopStudentsToRank) {\\n        let score = calculateScore(report[index]);\\n        minHeapStudents.enqueue(new Student(studentID[index], score));\\n        ++index;\\n    }\\n\\n    while (index < studentID.length) {\\n        let score = calculateScore(report[index]);\\n        if (currentStudentRanksHigher(minHeapStudents, studentID[index], score)) {\\n            minHeapStudents.dequeue();\\n            minHeapStudents.enqueue(new Student(studentID[index], score));\\n        }\\n        ++index;\\n    }\\n\\n    return rankedStudentsAsSortedArray(minHeapStudents);\\n};\\n\\n/**\\n * @param {number} ID\\n * @param {number} score\\n */\\nfunction Student(ID, score) {\\n    this.ID = ID;\\n    this.score = score;\\n}\\n\\n/**\\n * @param {MinPriorityQueue<Student>} minHeapStudents\\n * @return {number[]}\\n */\\nfunction rankedStudentsAsSortedArray(minHeapStudents) {\\n    const topStudentsID = [];\\n    while (!minHeapStudents.isEmpty()) {\\n        topStudentsID.push(minHeapStudents.dequeue().ID);\\n    }\\n    topStudentsID.reverse();\\n    return topStudentsID;\\n}\\n\\n/**\\n * @param {string[]} report\\n * @return {number}\\n */\\nfunction  calculateScore(report) {\\n    let score = 0;\\n    const array = report.split(\" \");\\n    for (let i = 0; i < array.length; ++i) {\\n        if (this.positiveFeedbackWords.has(array[i])) {\\n            score += 3;\\n        } else if (this.negativeFeedbackWords.has(array[i])) {\\n            --score;\\n        }\\n    }\\n    return score;\\n}\\n\\n/**\\n * @param {MinPriorityQueue<Student>} minHeapStudents\\n * @param {number} studentID\\n * @param {number} score\\n * @return {boolean}\\n */\\nfunction currentStudentRanksHigher(minHeapStudents, studentID, score) {\\n    return score > minHeapStudents.front().score || (score === minHeapStudents.front().score && studentID < minHeapStudents.front().ID);\\n}\\n```\n```\\n#include <queue>\\n#include <vector>\\n#include <string>\\n#include <sstream>\\n#include <iterator>\\n#include <algorithm>\\n#include <unordered_set>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Student {\\n        int ID{};\\n        int score{};\\n        Student(int ID, int score) : ID{ID}, score{score}{}\\n    };\\n\\n    struct ComparatorStudent {\\n        bool operator()(const Student& studentOne, const Student& studentTwo) const {\\n            return (studentOne.score == studentTwo.score) ? studentTwo.ID > studentOne.ID : studentOne.score > studentTwo.score;\\n        };\\n    };\\n\\n    using MinHeapStudents = priority_queue<Student, vector<Student>, ComparatorStudent>;\\n    unique_ptr<unordered_set<string>> positiveFeedbackWords;\\n    unique_ptr<unordered_set<string>> negativeFeedbackWords;\\n\\npublic:\\n    vector<int> topStudents(const vector<string>& positiveFeedback, const vector<string>& negativeFeedback,\\n            const vector<string>& report, const vector<int>& studentID, int numberOfTopStudentsToRank) {\\n\\n        positiveFeedbackWords = make_unique<unordered_set<string>>(positiveFeedback.begin(), positiveFeedback.end());\\n        negativeFeedbackWords = make_unique<unordered_set<string>>(negativeFeedback.begin(), negativeFeedback.end());\\n        MinHeapStudents minHeapStudents;\\n\\n        int index = 0;\\n        while (index < studentID.size() && minHeapStudents.size() < numberOfTopStudentsToRank) {\\n            int score = calculateScore(report[index]);\\n            minHeapStudents.emplace(Student(studentID[index], score));\\n            ++index;\\n        }\\n\\n        while (index < studentID.size()) {\\n            int score = calculateScore(report[index]);\\n            if (currentStudentRanksHigher(minHeapStudents, studentID[index], score)) {\\n                minHeapStudents.pop();\\n                minHeapStudents.emplace(Student(studentID[index], score));\\n            }\\n            ++index;\\n        }\\n\\n        return rankedStudentsAsSortedVector(minHeapStudents);\\n    }\\n\\nprivate:\\n    vector<int> rankedStudentsAsSortedVector(MinHeapStudents& minHeapStudents) const {\\n        vector<int> topStudentsID;\\n        while (!minHeapStudents.empty()) {\\n            topStudentsID.push_back(minHeapStudents.top().ID);\\n            minHeapStudents.pop();\\n        }\\n        reverse(topStudentsID.begin(), topStudentsID.end());\\n        return topStudentsID;\\n    }\\n\\n    int calculateScore(const string& report) const {\\n        stringstream streamReport(report);\\n        string feedbackWord;\\n        int score = 0;\\n\\n        while (getline(streamReport, feedbackWord, \\' \\')) {\\n            if (positiveFeedbackWords->find(feedbackWord) != positiveFeedbackWords->end()) {\\n                score += 3;\\n            } else if (negativeFeedbackWords->find(feedbackWord) != negativeFeedbackWords->end()) {\\n                --score;\\n            }\\n        }\\n        return score;\\n    }\\n\\n    bool currentStudentRanksHigher(const MinHeapStudents& minHeapStudents, int studentID, int score) const {\\n        return score > minHeapStudents.top().score || (score == minHeapStudents.top().score && studentID < minHeapStudents.top().ID);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3116542,
                "title": "python-set-and-priority-queue-explained",
                "content": "(1) Based on the positive and negative feedbacks to creat a hash map (set)\\n(2) Check each student\\'s report and calculate the score\\n(3) Use heap to sort the scores and get the first k largest scores\\n\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pf = set(positive_feedback)\\n        nf = set(negative_feedback)\\n        scores = []\\n        \\n        for idx, r in enumerate(report):\\n            t_s = 0\\n            wds = r.split(\\' \\')\\n            for w in wds:\\n                if w in pf:\\n                    t_s += 3\\n                if w in nf:\\n                    t_s -= 1\\n            heapq.heappush(scores, (-t_s, student_id[idx]))\\n        \\n        ans = []\\n        while scores and k:\\n            _, sid = heapq.heappop(scores)\\n            ans.append(sid)\\n            k -= 1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pf = set(positive_feedback)\\n        nf = set(negative_feedback)\\n        scores = []\\n        \\n        for idx, r in enumerate(report):\\n            t_s = 0\\n            wds = r.split(\\' \\')\\n            for w in wds:\\n                if w in pf:\\n                    t_s += 3\\n                if w in nf:\\n                    t_s -= 1\\n            heapq.heappush(scores, (-t_s, student_id[idx]))\\n        \\n        ans = []\\n        while scores and k:\\n            _, sid = heapq.heappop(scores)\\n            ans.append(sid)\\n            k -= 1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093171,
                "title": "c-easy-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool comp(const pair<int,int> &p1 , const pair<int,int> &p2){\\n        if(p1.first == p2.first ){\\n            return p1.second < p2.second;\\n        }\\n        return p1.first > p2.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        unordered_set<string> pos;\\n        unordered_set<string> neg;\\n\\n        for(auto str : positive_feedback){\\n            pos.insert(str);\\n        }\\n        for(auto str : negative_feedback){\\n            neg.insert(str);\\n        }\\n        vector<pair<int,int>> vp;\\n        int n = report.size();\\n        for(int i=0;i<n;i++){\\n            int id = student_id[i];\\n\\n            string rpt = report[i];\\n            int score = 0;\\n            int l = rpt.size();\\n            int j =0;\\n            while(j < l){\\n                string word = \"\";\\n                while(j < l && rpt[j] != \\' \\'){\\n                    word.push_back(rpt[j]);\\n                    j++;\\n                }\\n                if(pos.find(word) != pos.end()){\\n                    score += 3;\\n                }\\n                else if(neg.find(word) != neg.end()){\\n                    score -=1;\\n                }\\n                j++;\\n            }\\n            vp.push_back({score,id});\\n        }\\n\\n        sort(vp.begin(),vp.end(), comp);\\n        vector<int> ans;\\n\\n        for(int i=0;i<k;i++){\\n            ans.push_back(vp[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool comp(const pair<int,int> &p1 , const pair<int,int> &p2){\\n        if(p1.first == p2.first ){\\n            return p1.second < p2.second;\\n        }\\n        return p1.first > p2.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\n        unordered_set<string> pos;\\n        unordered_set<string> neg;\\n\\n        for(auto str : positive_feedback){\\n            pos.insert(str);\\n        }\\n        for(auto str : negative_feedback){\\n            neg.insert(str);\\n        }\\n        vector<pair<int,int>> vp;\\n        int n = report.size();\\n        for(int i=0;i<n;i++){\\n            int id = student_id[i];\\n\\n            string rpt = report[i];\\n            int score = 0;\\n            int l = rpt.size();\\n            int j =0;\\n            while(j < l){\\n                string word = \"\";\\n                while(j < l && rpt[j] != \\' \\'){\\n                    word.push_back(rpt[j]);\\n                    j++;\\n                }\\n                if(pos.find(word) != pos.end()){\\n                    score += 3;\\n                }\\n                else if(neg.find(word) != neg.end()){\\n                    score -=1;\\n                }\\n                j++;\\n            }\\n            vp.push_back({score,id});\\n        }\\n\\n        sort(vp.begin(),vp.end(), comp);\\n        vector<int> ans;\\n\\n        for(int i=0;i<k;i++){\\n            ans.push_back(vp[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085211,
                "title": "priority-queue-c-unordered-set",
                "content": "\\n```\\nclass Student {\\n    public:\\n    int id;\\n    int score;\\n    Student(int id, int score) {\\n        this->id = id;\\n        this->score = score;\\n    }\\n};\\nclass StuCompare {\\n    public:\\n    bool operator()(Student a , Student b) {\\n    if (a.score == b.score) {\\n        return a.id > b.id;\\n    }\\n    return a.score < b.score;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        priority_queue<Student, vector<Student> , StuCompare> pq;\\n        vector<Student> v;\\n        unordered_set<string> pos ,neg;\\n        for(int i = 0 ; i < positive_feedback.size() ; i++) pos.insert(positive_feedback[i]);\\n        \\n        for(int i = 0 ; i < negative_feedback.size() ; i++) neg.insert(negative_feedback[i]);\\n\\n        vector<int> ans;\\n        for(int i = 0 ; i < student_id.size() ; i++) {\\n            int score = 0;\\n            istringstream iss(report[i]);\\n            string word;\\n            while(iss >> word) score += (pos.find(word.c_str()) != pos.end()) ? 3 : (neg.find(word.c_str()) != neg.end()) ? -1 :0;\\n            pq.push(Student(student_id[i], score));\\n        }\\n        \\n        int i =0;\\n        while(i != k ) {\\n            ans.push_back(pq.top().id);\\n            pq.pop();\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Student {\\n    public:\\n    int id;\\n    int score;\\n    Student(int id, int score) {\\n        this->id = id;\\n        this->score = score;\\n    }\\n};\\nclass StuCompare {\\n    public:\\n    bool operator()(Student a , Student b) {\\n    if (a.score == b.score) {\\n        return a.id > b.id;\\n    }\\n    return a.score < b.score;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        priority_queue<Student, vector<Student> , StuCompare> pq;\\n        vector<Student> v;\\n        unordered_set<string> pos ,neg;\\n        for(int i = 0 ; i < positive_feedback.size() ; i++) pos.insert(positive_feedback[i]);\\n        \\n        for(int i = 0 ; i < negative_feedback.size() ; i++) neg.insert(negative_feedback[i]);\\n\\n        vector<int> ans;\\n        for(int i = 0 ; i < student_id.size() ; i++) {\\n            int score = 0;\\n            istringstream iss(report[i]);\\n            string word;\\n            while(iss >> word) score += (pos.find(word.c_str()) != pos.end()) ? 3 : (neg.find(word.c_str()) != neg.end()) ? -1 :0;\\n            pq.push(Student(student_id[i], score));\\n        }\\n        \\n        int i =0;\\n        while(i != k ) {\\n            ans.push_back(pq.top().id);\\n            pq.pop();\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058073,
                "title": "accepted-c-solution-simple-easy-approach",
                "content": "# Code\\n```\\nbool comp(const pair<int, int> &a, const pair<int, int> &b)\\n{\\n    if(a.first == b.first) return a.second < b.second;\\n    return a.first > b.first;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int> curr;\\n        map<string, int> pos, neg;\\n        int n1 = positive_feedback.size(), n2 = negative_feedback.size(), n = report.size();\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            pos[positive_feedback[i]]++;\\n        }\\n        for(int i = 0; i < n2; i++)\\n        {\\n            neg[negative_feedback[i]]++;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int sz = report[i].size(), p = 0, n = 0;\\n            string temp = \"\";\\n            for(int j = 0; j < sz; j++)\\n            {\\n                if(report[i][j] == \\' \\')\\n                {\\n                    if(pos[temp]) p += 3;\\n                    if(neg[temp]) n++;\\n                    temp.clear();\\n                }\\n                else\\n                {\\n                    temp += report[i][j];\\n                }\\n            }\\n            \\n            if(pos[temp]) p += 3;\\n            if(neg[temp]) n++;\\n            temp.clear(); \\n            curr.push_back(p - n);\\n        }\\n        \\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pairs.push_back({curr[i], student_id[i]});\\n        }\\n        \\n        sort(pairs.begin(), pairs.end(), comp);\\n            \\n        vector<int> res;\\n        for(int i = 0; i < k; i++)\\n        {\\n            res.push_back(pairs[i].second);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nbool comp(const pair<int, int> &a, const pair<int, int> &b)\\n{\\n    if(a.first == b.first) return a.second < b.second;\\n    return a.first > b.first;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int> curr;\\n        map<string, int> pos, neg;\\n        int n1 = positive_feedback.size(), n2 = negative_feedback.size(), n = report.size();\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            pos[positive_feedback[i]]++;\\n        }\\n        for(int i = 0; i < n2; i++)\\n        {\\n            neg[negative_feedback[i]]++;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int sz = report[i].size(), p = 0, n = 0;\\n            string temp = \"\";\\n            for(int j = 0; j < sz; j++)\\n            {\\n                if(report[i][j] == \\' \\')\\n                {\\n                    if(pos[temp]) p += 3;\\n                    if(neg[temp]) n++;\\n                    temp.clear();\\n                }\\n                else\\n                {\\n                    temp += report[i][j];\\n                }\\n            }\\n            \\n            if(pos[temp]) p += 3;\\n            if(neg[temp]) n++;\\n            temp.clear(); \\n            curr.push_back(p - n);\\n        }\\n        \\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pairs.push_back({curr[i], student_id[i]});\\n        }\\n        \\n        sort(pairs.begin(), pairs.end(), comp);\\n            \\n        vector<int> res;\\n        for(int i = 0; i < k; i++)\\n        {\\n            res.push_back(pairs[i].second);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051110,
                "title": "python-heap-of-size-k",
                "content": "Sorted list has time complexity of O(nlogn) where n is the number of students. Keeping a heap of size k keeps the time complexity to O(logk).\\n```\\nclass Solution:\\n    def topStudents(self, p: List[str], n: List[str], report: List[str], id: List[int], k: int) -> List[int]:\\n        pos = set(p)\\n        neg = set(n)\\n        heap = []\\n\\n        def scorer(words):\\n            s = words.split()\\n            score = 0\\n            for word in s:\\n                score += 3 if word in pos else -1 if word in neg else 0\\n            \\n            return score\\n\\n        l = len(report)\\n        for i in range(l):\\n            words = report[i]\\n            s_id = id[i]\\n            \\n            score = scorer(words)\\n            \\n            if len(heap) < k:\\n                heapq.heappush(heap, (score, -s_id))\\n            \\n            else:\\n                min_score, min_id = heapq.heappop(heap)\\n\\n                min_id = -min_id\\n                if score > min_score or (score == min_score and s_id < min_id):\\n                    heapq.heappush(heap, (score, -s_id))\\n                \\n                else:\\n                    heapq.heappush(heap, (min_score, -min_id))\\n            \\n        res = []\\n        while heap:\\n            _, id = heapq.heappop(heap)\\n            res.append(-id)\\n        \\n        return res[::-1]\\n                    \\n                \\n                \\n                \\n",
                "solutionTags": [],
                "code": "Sorted list has time complexity of O(nlogn) where n is the number of students. Keeping a heap of size k keeps the time complexity to O(logk).\\n```\\nclass Solution:\\n    def topStudents(self, p: List[str], n: List[str], report: List[str], id: List[int], k: int) -> List[int]:\\n        pos = set(p)\\n        neg = set(n)\\n        heap = []\\n\\n        def scorer(words):\\n            s = words.split()\\n            score = 0\\n            for word in s:\\n                score += 3 if word in pos else -1 if word in neg else 0\\n            \\n            return score\\n\\n        l = len(report)\\n        for i in range(l):\\n            words = report[i]\\n            s_id = id[i]\\n            \\n            score = scorer(words)\\n            \\n            if len(heap) < k:\\n                heapq.heappush(heap, (score, -s_id))\\n            \\n            else:\\n                min_score, min_id = heapq.heappop(heap)\\n\\n                min_id = -min_id\\n                if score > min_score or (score == min_score and s_id < min_id):\\n                    heapq.heappush(heap, (score, -s_id))\\n                \\n                else:\\n                    heapq.heappush(heap, (min_score, -min_id))\\n            \\n        res = []\\n        while heap:\\n            _, id = heapq.heappop(heap)\\n            res.append(-id)\\n        \\n        return res[::-1]\\n                    \\n                \\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 3051020,
                "title": "simple-comparator-sorting-very-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&p1,pair<int,int>&p2)\\n    {\\n        if(p1.first == p2.first)\\n        {\\n            return p1.second < p2.second;\\n        }\\n        return p1.first > p2.first;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n          //taking all the positive feedback into the map\\n          unordered_map<string,bool>positive;\\n          for(int i=0;i<positive_feedback.size();i++)\\n          {\\n              positive[positive_feedback[i]]=true;\\n\\n          }\\n\\n          //taking all the negative feedback into the map\\n          unordered_map<string,bool>negative;\\n          for(int i=0;i<negative_feedback.size();i++)\\n          {\\n              negative[negative_feedback[i]]=true;\\n          }\\n\\n          vector<pair<int,int>>v;\\n          //iterating over all the strudents\\n          for(int i=0;i<student_id.size();i++)\\n          {\\n               int id = student_id[i];\\n               \\n               string str = report[i];\\n\\n               int points = 0;\\n\\n               int idx = 0;\\n               \\n               while(idx < str.length())\\n               {\\n                   string word = \"\";\\n                   \\n                   while(idx < str.length() and str[idx]!=\\' \\')\\n                   {\\n                       word.push_back(str[idx]);\\n                       idx++;\\n                   }\\n                   if(positive.find(word)!=positive.end())\\n                   {\\n                       points = points + 3;\\n                   }\\n                   else if(negative.find(word)!=negative.end())\\n                   {\\n                       points = points - 1;\\n                   }\\n                   while(idx < str.length() and str[idx] == \\' \\')\\n                   {\\n                       idx++;\\n                   }\\n               }\\n               v.push_back(make_pair(points,id));\\n          }\\n          sort(v.begin(),v.end(),cmp);\\n          \\n          vector<int>ans;\\n\\n          for(int i=0;i<k;i++)\\n          {\\n              ans.push_back(v[i].second);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&p1,pair<int,int>&p2)\\n    {\\n        if(p1.first == p2.first)\\n        {\\n            return p1.second < p2.second;\\n        }\\n        return p1.first > p2.first;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n          //taking all the positive feedback into the map\\n          unordered_map<string,bool>positive;\\n          for(int i=0;i<positive_feedback.size();i++)\\n          {\\n              positive[positive_feedback[i]]=true;\\n\\n          }\\n\\n          //taking all the negative feedback into the map\\n          unordered_map<string,bool>negative;\\n          for(int i=0;i<negative_feedback.size();i++)\\n          {\\n              negative[negative_feedback[i]]=true;\\n          }\\n\\n          vector<pair<int,int>>v;\\n          //iterating over all the strudents\\n          for(int i=0;i<student_id.size();i++)\\n          {\\n               int id = student_id[i];\\n               \\n               string str = report[i];\\n\\n               int points = 0;\\n\\n               int idx = 0;\\n               \\n               while(idx < str.length())\\n               {\\n                   string word = \"\";\\n                   \\n                   while(idx < str.length() and str[idx]!=\\' \\')\\n                   {\\n                       word.push_back(str[idx]);\\n                       idx++;\\n                   }\\n                   if(positive.find(word)!=positive.end())\\n                   {\\n                       points = points + 3;\\n                   }\\n                   else if(negative.find(word)!=negative.end())\\n                   {\\n                       points = points - 1;\\n                   }\\n                   while(idx < str.length() and str[idx] == \\' \\')\\n                   {\\n                       idx++;\\n                   }\\n               }\\n               v.push_back(make_pair(points,id));\\n          }\\n          sort(v.begin(),v.end(),cmp);\\n          \\n          vector<int>ans;\\n\\n          for(int i=0;i<k;i++)\\n          {\\n              ans.push_back(v[i].second);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049636,
                "title": "clean-and-concise-c-solution-stringstream-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is to perform the implementation as asked in the question.\\n\\n### Key points \\n- processing string in C++ with spaces \\n\\n    `use stringstream`\\n\\n- maintaining multiple sorting order simultaneously \\n    - non increasing for score\\n    - non decreasing for id\\n\\n    `use -id trick while pushing in priority queue`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        set <string> pos(positive_feedback.begin(), positive_feedback.end());\\n        set <string> neg(negative_feedback.begin(), negative_feedback.end());\\n\\n        // C++ implements max_heap - highest element on top\\n        priority_queue <pair<int, int>> pq;\\n        \\n        for(int i=0 ;i<n; i++) {\\n            int id = student_id[i];\\n            string feedback = report[i];\\n            \\n            stringstream ss(feedback);\\n            string word;\\n            \\n            int score = 0;\\n            while(ss >> word) {\\n                if(pos.find(word) != pos.end())\\n                    score+=3;\\n                else if(neg.find(word) != neg.end())\\n                    score--;\\n            }\\n            \\n            // push -id instead of id to sort ids in increasing order as mentioned in question\\n            pq.push({score, -id});\\n        }\\n        \\n        vector <int> ans;\\n        \\n        while(k--) {\\n            pair <int, int> entry = pq.top();\\n            pq.pop();\\n            ans.push_back(-entry.second);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        set <string> pos(positive_feedback.begin(), positive_feedback.end());\\n        set <string> neg(negative_feedback.begin(), negative_feedback.end());\\n\\n        // C++ implements max_heap - highest element on top\\n        priority_queue <pair<int, int>> pq;\\n        \\n        for(int i=0 ;i<n; i++) {\\n            int id = student_id[i];\\n            string feedback = report[i];\\n            \\n            stringstream ss(feedback);\\n            string word;\\n            \\n            int score = 0;\\n            while(ss >> word) {\\n                if(pos.find(word) != pos.end())\\n                    score+=3;\\n                else if(neg.find(word) != neg.end())\\n                    score--;\\n            }\\n            \\n            // push -id instead of id to sort ids in increasing order as mentioned in question\\n            pq.push({score, -id});\\n        }\\n        \\n        vector <int> ans;\\n        \\n        while(k--) {\\n            pair <int, int> entry = pq.top();\\n            pq.pop();\\n            ans.push_back(-entry.second);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046875,
                "title": "easy-priority-queue-solution-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        \\n        Set<String> positive=makefeedback(positive_feedback);\\n        Set<String> negative=makefeedback(negative_feedback);\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]==b[1]?a[0]-b[0]:b[1]-a[1]);\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<report.length;i++)\\n        {\\n            int points=0;\\n            \\n            for(String word:report[i].split(\" \"))\\n            {\\n                if(positive.contains(word))\\n                {\\n                    points+=3;\\n                }\\n                \\n                if(negative.contains(word))\\n                {\\n                    points-=1;\\n                }\\n            }\\n            \\n            pq.add(new int[]{student_id[i],points});\\n        }\\n        \\n        while(k-->0)\\n        {\\n            ans.add(pq.peek()[0]);\\n            pq.remove();\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public HashSet<String> makefeedback(String[] array)\\n    {\\n        HashSet<String> set=new HashSet<>();\\n        for(String word:array)\\n        {\\n            set.add(word);\\n        }\\n        return set;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        \\n        Set<String> positive=makefeedback(positive_feedback);\\n        Set<String> negative=makefeedback(negative_feedback);\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]==b[1]?a[0]-b[0]:b[1]-a[1]);\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<report.length;i++)\\n        {\\n            int points=0;\\n            \\n            for(String word:report[i].split(\" \"))\\n            {\\n                if(positive.contains(word))\\n                {\\n                    points+=3;\\n                }\\n                \\n                if(negative.contains(word))\\n                {\\n                    points-=1;\\n                }\\n            }\\n            \\n            pq.add(new int[]{student_id[i],points});\\n        }\\n        \\n        while(k-->0)\\n        {\\n            ans.add(pq.peek()[0]);\\n            pq.remove();\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public HashSet<String> makefeedback(String[] array)\\n    {\\n        HashSet<String> set=new HashSet<>();\\n        for(String word:array)\\n        {\\n            set.add(word);\\n        }\\n        return set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042697,
                "title": "python-fast-solution-using-set-heap",
                "content": "# Approach\\n1) Convert feedback $$array$$ to $$set$$ (for $$O(1)$$ lookup)\\n2) On each step - calc students stat and add it to $$max-heap$$\\n3) Get top-**K** elements from $$heap$$ for answer\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(N))$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pf = set(positive_feedback)\\n        nf = set(negative_feedback)\\n        st = []\\n        for ind, r in enumerate(report):\\n            carry = 0\\n            for word in r.split():\\n                if word in pf:\\n                    carry += 3\\n                elif word in nf:\\n                    carry -= 1\\n            heapq.heappush(st, (-carry, student_id[ind]))\\n        ans = []\\n        while st and k != 0:\\n            ans.append(heapq.heappop(st)[1])\\n            k -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\\n        pf = set(positive_feedback)\\n        nf = set(negative_feedback)\\n        st = []\\n        for ind, r in enumerate(report):\\n            carry = 0\\n            for word in r.split():\\n                if word in pf:\\n                    carry += 3\\n                elif word in nf:\\n                    carry -= 1\\n            heapq.heappush(st, (-carry, student_id[ind]))\\n        ans = []\\n        while st and k != 0:\\n            ans.append(heapq.heappop(st)[1])\\n            k -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040183,
                "title": "java-solution-using-priorityqueue-and-hashsets",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashSet<String> positiveFeedback = fillHashSet(positive_feedback);\\n        HashSet<String> negativeFeedback = fillHashSet(negative_feedback);\\n        PriorityQueue<int[]> studentByScore = new PriorityQueue<>((a, b) -> a[1] == b[1] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int i = 0; i < report.length; i++) {\\n            int raiting = 0;\\n            String[] reportWords = report[i].split(\" \");\\n            for (String word : reportWords) {;\\n                if (positiveFeedback.contains(word)) {\\n                    raiting += 3;\\n                }\\n                if (negativeFeedback.contains(word)) {\\n                    raiting--;\\n                }\\n            }\\n            studentByScore.add(new int[]{student_id[i], raiting});\\n        }\\n\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < k; i++) {\\n            result.add(studentByScore.poll()[0]);\\n        }\\n        return result;\\n    }\\n\\n    private HashSet<String> fillHashSet(String[] feedback) {\\n        HashSet<String> set = new HashSet<>();\\n        for (String word : feedback) {\\n            set.add(word);\\n        }\\n        return set;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashSet<String> positiveFeedback = fillHashSet(positive_feedback);\\n        HashSet<String> negativeFeedback = fillHashSet(negative_feedback);\\n        PriorityQueue<int[]> studentByScore = new PriorityQueue<>((a, b) -> a[1] == b[1] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int i = 0; i < report.length; i++) {\\n            int raiting = 0;\\n            String[] reportWords = report[i].split(\" \");\\n            for (String word : reportWords) {;\\n                if (positiveFeedback.contains(word)) {\\n                    raiting += 3;\\n                }\\n                if (negativeFeedback.contains(word)) {\\n                    raiting--;\\n                }\\n            }\\n            studentByScore.add(new int[]{student_id[i], raiting});\\n        }\\n\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < k; i++) {\\n            result.add(studentByScore.poll()[0]);\\n        }\\n        return result;\\n    }\\n\\n    private HashSet<String> fillHashSet(String[] feedback) {\\n        HashSet<String> set = new HashSet<>();\\n        for (String word : feedback) {\\n            set.add(word);\\n        }\\n        return set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036526,
                "title": "java-solution-2-sets-min-heap-beats-91-66-73ms",
                "content": "# Approach\\nI. Calculate score of each student using `positive` and `negative` sets applied to every `report`.\\n\\nII. Process the score via MIN heap maintaining its size strictly not larger than `k`. (As we need only top `k` students and not full heap of scores of `n` students.)\\n\\nUnlike using MAX heap, this approach gives us O(n * log k) instead of O(n * log n).\\n**Essential**: in heap we put the array **{ index, score }**. So it gives us a possibility to order elements based on `score` and **student_id** taken as `student_id[index]`.\\n\\nIII. Get the result out of MIN heap in a reverse order.\\n\\n# Complexity\\n- Time complexity: O(n * log k)\\n\\n\\n- Space complexity: O(3*k + p + n + w)\\n  k - number of top students\\n  p - number of positive words\\n  n - number of negative words\\n  w - MAX number of words in report\\n\\nWould highly appreciate your feedback and corrections if any.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> positive = new HashSet<>();\\n        for (String fb: positive_feedback)\\n            positive.add(fb);\\n        \\n        Set<String> negative = new HashSet<>();\\n        for (String fb: negative_feedback)\\n            negative.add(fb);\\n        \\n        // MIN heap. Holds array: {index, score}\\n        PriorityQueue<Integer[]> heap = new PriorityQueue<>( (a, b)->{\\n             int scoreDiff = a[1] - b[1]; // 1th index = score\\n             if (scoreDiff == 0) {\\n                 return student_id[b[0]] - student_id[a[0]]; // 0th index = index in `student_id` / `report` arrays\\n             } else\\n                 return scoreDiff;\\n        });\\n\\n        String[] words;\\n        int score;\\n\\n        for (int i = 0; i < report.length; i++) {\\n            \\n            // Calculate score for a given `i`-s student based on `i`-s report\\n            words = report[i].split(\" \");\\n            score = 0;\\n            for (int j=0; j < words.length; j++) {\\n                if (positive.contains(words[j]))\\n                    score += 3;\\n                if (negative.contains(words[j]))\\n                    score--;\\n            }\\n            \\n            // Maintain MIN heap size.\\n            // If size reached `k` values, check if calculated score is larger (or equal but student id is lesser) than the minimum one (which is the first) existing in the heap.\\n            // (We aren\\'t interested to put k+1\\'s lesser element in the heap.)\\n            if (heap.size() == k) {\\n                if (heap.peek()[1] < score || (heap.peek()[1] == score && student_id[heap.peek()[0]] >  student_id[i])) {\\n                    heap.poll();\\n                    heap.add(new Integer[] {i, score});\\n                }\\n            } else \\n                heap.add(new Integer[] {i, score});\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            res.add(student_id[heap.poll()[0]]);\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> positive = new HashSet<>();\\n        for (String fb: positive_feedback)\\n            positive.add(fb);\\n        \\n        Set<String> negative = new HashSet<>();\\n        for (String fb: negative_feedback)\\n            negative.add(fb);\\n        \\n        // MIN heap. Holds array: {index, score}\\n        PriorityQueue<Integer[]> heap = new PriorityQueue<>( (a, b)->{\\n             int scoreDiff = a[1] - b[1]; // 1th index = score\\n             if (scoreDiff == 0) {\\n                 return student_id[b[0]] - student_id[a[0]]; // 0th index = index in `student_id` / `report` arrays\\n             } else\\n                 return scoreDiff;\\n        });\\n\\n        String[] words;\\n        int score;\\n\\n        for (int i = 0; i < report.length; i++) {\\n            \\n            // Calculate score for a given `i`-s student based on `i`-s report\\n            words = report[i].split(\" \");\\n            score = 0;\\n            for (int j=0; j < words.length; j++) {\\n                if (positive.contains(words[j]))\\n                    score += 3;\\n                if (negative.contains(words[j]))\\n                    score--;\\n            }\\n            \\n            // Maintain MIN heap size.\\n            // If size reached `k` values, check if calculated score is larger (or equal but student id is lesser) than the minimum one (which is the first) existing in the heap.\\n            // (We aren\\'t interested to put k+1\\'s lesser element in the heap.)\\n            if (heap.size() == k) {\\n                if (heap.peek()[1] < score || (heap.peek()[1] == score && student_id[heap.peek()[0]] >  student_id[i])) {\\n                    heap.poll();\\n                    heap.add(new Integer[] {i, score});\\n                }\\n            } else \\n                heap.add(new Integer[] {i, score});\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            res.add(student_id[heap.poll()[0]]);\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031208,
                "title": "c-unordered-set-string-operation-easy",
                "content": "Easy to understand C++ solution using unordered-sets and string operation.\\n\\n\\u2705UPVOTE IF IT HELPS!\\n\\uD83E\\uDD42CHEERS\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> pset;\\n    unordered_set<string> nset;\\n    \\n    int getScore(string s){\\n        string word = \"\";\\n        int score = 0;\\n        for(auto x : s){\\n            if (x == \\' \\'){\\n                if(pset.find(word) != pset.end()) score+=3;\\n                if(nset.find(word) != nset.end()) score-=1;\\n                word = \"\";\\n            }\\n            else word += x;\\n        }\\n        if(pset.find(word) != pset.end()) score+=3;\\n        if(nset.find(word) != nset.end()) score-=1;\\n        return score;\\n    }\\n    \\n    static bool sortFunc(const pair<int,int> &a, const pair<int,int> &b){\\n        if(a.first == b.first) return a.second < b.second;\\n        else return a.first > b.first;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& sid, int k) {\\n        vector<pair<int,int>> score;\\n        vector<int> ans;\\n        \\n        for(int i=0; i<pf.size(); i++) pset.insert(pf[i]);\\n        for(int i=0; i<nf.size(); i++) nset.insert(nf[i]);\\n        for(int i=0; i<report.size(); i++) score.push_back({getScore(report[i]), sid[i]});\\n        sort(score.begin(), score.end(), sortFunc);\\n        for(auto s : score){\\n            if(k==0) return ans;\\n            else {\\n                ans.push_back(s.second);\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> pset;\\n    unordered_set<string> nset;\\n    \\n    int getScore(string s){\\n        string word = \"\";\\n        int score = 0;\\n        for(auto x : s){\\n            if (x == \\' \\'){\\n                if(pset.find(word) != pset.end()) score+=3;\\n                if(nset.find(word) != nset.end()) score-=1;\\n                word = \"\";\\n            }\\n            else word += x;\\n        }\\n        if(pset.find(word) != pset.end()) score+=3;\\n        if(nset.find(word) != nset.end()) score-=1;\\n        return score;\\n    }\\n    \\n    static bool sortFunc(const pair<int,int> &a, const pair<int,int> &b){\\n        if(a.first == b.first) return a.second < b.second;\\n        else return a.first > b.first;\\n    }\\n    \\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>& sid, int k) {\\n        vector<pair<int,int>> score;\\n        vector<int> ans;\\n        \\n        for(int i=0; i<pf.size(); i++) pset.insert(pf[i]);\\n        for(int i=0; i<nf.size(); i++) nset.insert(nf[i]);\\n        for(int i=0; i<report.size(); i++) score.push_back({getScore(report[i]), sid[i]});\\n        sort(score.begin(), score.end(), sortFunc);\\n        for(auto s : score){\\n            if(k==0) return ans;\\n            else {\\n                ans.push_back(s.second);\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026500,
                "title": "c-using-set-and-comparator-easy-solution",
                "content": "\\n\\n# Approach\\nusing set and comparator and just sort vector\\n\\n# Complexity\\n- Time complexity:\\nNlog(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool com(pair<int,int>& a,pair<int,int>& b){\\n        if(a.second==b.second){\\n            return a.first<b.first;\\n        }\\n        return a.second>b.second;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        set<string> pos,neg;\\n        vector<pair<int,int>> v;\\n        vector<int> ans;\\n        for(int i=0;i<positive_feedback.size();i++){\\n            pos.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++){\\n            neg.insert(negative_feedback[i]);\\n        }\\n        for(int i=0;i<report.size();i++){\\n            string word=\"\";\\n            int score=0;\\n            for(int j=0;j<report[i].size();j++){\\n                if(report[i][j]!=\\' \\'){\\n                    word+=report[i][j];\\n                }else{\\n                    if(pos.find(word)!=pos.end()){\\n                        score+=3;\\n                    }\\n                    if(neg.find(word)!=neg.end()){\\n                        score-=1;\\n                    }\\n                    word=\"\";\\n                }\\n            }\\n            if(word.size()>0){\\n                    if(pos.find(word)!=pos.end()){\\n                        score+=3;\\n                    }\\n                    if(neg.find(word)!=neg.end()){\\n                        score-=1;\\n                    }\\n            }\\n            v.push_back({student_id[i],score});\\n        }\\n        sort(v.begin(),v.end(),com);\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool com(pair<int,int>& a,pair<int,int>& b){\\n        if(a.second==b.second){\\n            return a.first<b.first;\\n        }\\n        return a.second>b.second;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        set<string> pos,neg;\\n        vector<pair<int,int>> v;\\n        vector<int> ans;\\n        for(int i=0;i<positive_feedback.size();i++){\\n            pos.insert(positive_feedback[i]);\\n        }\\n        for(int i=0;i<negative_feedback.size();i++){\\n            neg.insert(negative_feedback[i]);\\n        }\\n        for(int i=0;i<report.size();i++){\\n            string word=\"\";\\n            int score=0;\\n            for(int j=0;j<report[i].size();j++){\\n                if(report[i][j]!=\\' \\'){\\n                    word+=report[i][j];\\n                }else{\\n                    if(pos.find(word)!=pos.end()){\\n                        score+=3;\\n                    }\\n                    if(neg.find(word)!=neg.end()){\\n                        score-=1;\\n                    }\\n                    word=\"\";\\n                }\\n            }\\n            if(word.size()>0){\\n                    if(pos.find(word)!=pos.end()){\\n                        score+=3;\\n                    }\\n                    if(neg.find(word)!=neg.end()){\\n                        score-=1;\\n                    }\\n            }\\n            v.push_back({student_id[i],score});\\n        }\\n        sort(v.begin(),v.end(),com);\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022519,
                "title": "c-simple-sorting-hashset-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the positive and negative words in two separate hash sets and query the words in report individually to compute scores of each students.\\n\\nFinally, sort a vector of (-scores[i], student_id[i]) and outputing the top k student_id.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs above. Sorting + hashset.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log N + total number of characters in the reports + total number of characters of the positive/negative words), where N is the number of studnets.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(total number of characters of the positive/negative words + length of the reports)\\nThe first term is the memory usage of the hashset.\\nThe second term is the worst case when the report have no space in it so we have to copy the whole string and check if it appears in the hashset. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> pos(positive_feedback.begin(), positive_feedback.end());\\n        unordered_set<string> neg(negative_feedback.begin(), negative_feedback.end());\\n        int n = student_id.size();\\n        vector<pair<int, int>> scores;\\n        for (int i = 0; i < n; ++i) {\\n            string & s = report[i];\\n            int start = 0;\\n            int sc = 0;\\n            for (int j = 0; j <= s.size(); ++j) {\\n                if (s[j] == \\' \\' || j == s.size()) {\\n                    string sub = s.substr(start, j-start);\\n                    if (pos.count(sub)) {\\n                        sc += 3;\\n                    } else if (neg.count(sub)) {\\n                        sc -= 1;\\n                    }\\n                    start = j + 1;\\n                }\\n            }\\n            scores.push_back({-sc, student_id[i]});\\n        }\\n        ::sort(scores.begin(), scores.end());\\n        vector<int> res;\\n        for (int i = 0; i < k; ++i) {\\n            res.push_back(scores[i].second);\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> pos(positive_feedback.begin(), positive_feedback.end());\\n        unordered_set<string> neg(negative_feedback.begin(), negative_feedback.end());\\n        int n = student_id.size();\\n        vector<pair<int, int>> scores;\\n        for (int i = 0; i < n; ++i) {\\n            string & s = report[i];\\n            int start = 0;\\n            int sc = 0;\\n            for (int j = 0; j <= s.size(); ++j) {\\n                if (s[j] == \\' \\' || j == s.size()) {\\n                    string sub = s.substr(start, j-start);\\n                    if (pos.count(sub)) {\\n                        sc += 3;\\n                    } else if (neg.count(sub)) {\\n                        sc -= 1;\\n                    }\\n                    start = j + 1;\\n                }\\n            }\\n            scores.push_back({-sc, student_id[i]});\\n        }\\n        ::sort(scores.begin(), scores.end());\\n        vector<int> res;\\n        for (int i = 0; i < k; ++i) {\\n            res.push_back(scores[i].second);\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014342,
                "title": "easy-to-understand-c-hashmaps-sorting",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst get the scores of the students by comparing the report with the given positive, negative words and then sort the obtained scores and then add the top k students from the soretd vector to the sol vector.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a,vector<int>b){\\n        if(a[1]>b[1])return true;\\n        else if(a[1]==b[1]){\\n            if(a[0]<b[0]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positive;\\n        unordered_set<string> negative;\\n        for(auto a:positive_feedback){\\n            positive.insert(a);\\n        }\\n        for(auto a:negative_feedback){\\n            negative.insert(a);\\n        }\\n        vector<vector<int>> score(report.size(),vector<int>(2));\\n        for(int i=0;i<report.size();i++){\\n            string tmp=\"\";\\n            score[i][0]=student_id[i];\\n            score[i][1]=0;\\n            for(int j=0;j<report[i].size();j++){\\n                if(report[i][j]==\\' \\'){\\n                    if(positive.count(tmp)){ \\n                        score[i][1]+=3;\\n                    }else if(negative.count(tmp)){\\n                        score[i][1]--;\\n                    }\\n                    tmp=\"\";\\n                }\\n                else tmp+=report[i][j];\\n            }\\n            if(positive.count(tmp)){\\n                        score[i][1]+=3;\\n                    }else if(negative.count(tmp)){\\n                        score[i][1]--;\\n                    }\\n                    tmp=\"\";\\n        }\\n   \\n        sort(score.begin(),score.end(),cmp);\\n      \\n        vector<int> sol;\\n        for(int i=0;i<k;i++){\\n            sol.push_back(score[i][0]);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> a,vector<int>b){\\n        if(a[1]>b[1])return true;\\n        else if(a[1]==b[1]){\\n            if(a[0]<b[0]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_set<string> positive;\\n        unordered_set<string> negative;\\n        for(auto a:positive_feedback){\\n            positive.insert(a);\\n        }\\n        for(auto a:negative_feedback){\\n            negative.insert(a);\\n        }\\n        vector<vector<int>> score(report.size(),vector<int>(2));\\n        for(int i=0;i<report.size();i++){\\n            string tmp=\"\";\\n            score[i][0]=student_id[i];\\n            score[i][1]=0;\\n            for(int j=0;j<report[i].size();j++){\\n                if(report[i][j]==\\' \\'){\\n                    if(positive.count(tmp)){ \\n                        score[i][1]+=3;\\n                    }else if(negative.count(tmp)){\\n                        score[i][1]--;\\n                    }\\n                    tmp=\"\";\\n                }\\n                else tmp+=report[i][j];\\n            }\\n            if(positive.count(tmp)){\\n                        score[i][1]+=3;\\n                    }else if(negative.count(tmp)){\\n                        score[i][1]--;\\n                    }\\n                    tmp=\"\";\\n        }\\n   \\n        sort(score.begin(),score.end(),cmp);\\n      \\n        vector<int> sol;\\n        for(int i=0;i<k;i++){\\n            sol.push_back(score[i][0]);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011348,
                "title": "java-solution",
                "content": "This was my first idea for how to approach this problem. I use a hashmap to store point values, grade each student, put their store and id in a `Pair` object, and then insert that object into a priority queue. Then, the top `k` students can be extracted from the queue.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) I believe\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.PriorityQueue;\\nimport java.util.List;\\nimport java.util.ArrayList;\\nclass Solution {\\n    private class Pair {\\n        private int key, value;\\n        Pair(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashMap<String, Integer> vals = new HashMap<>();\\n        for (String pos : positive_feedback)\\n            vals.put(pos, 3);\\n        for (String neg : negative_feedback)\\n            vals.put(neg, -1);\\n        PriorityQueue<Pair> maxHeap = new PriorityQueue<>(student_id.length, new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair p2, Pair p1) {\\n                if (p2.key == p1.key) {\\n                    return Integer.compare(p2.value, p1.value);\\n                }\\n                return Integer.compare(p1.key, p2.key);\\n            }\\n        });\\n        for (int i = 0; i < student_id.length; i++) {\\n            String[] parts = report[i].split(\" \");\\n            int grade = 0;\\n            for (String s : parts) {\\n                if (vals.containsKey(s)) {\\n                    grade += vals.get(s);\\n                }\\n            }\\n            maxHeap.add(new Pair(grade, student_id[i]));\\n        }\\n\\n        List<Integer> ret = new ArrayList<>(k);\\n        for (int i = 0; i < k; i++) {\\n            ret.add(maxHeap.poll().value);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.PriorityQueue;\\nimport java.util.List;\\nimport java.util.ArrayList;\\nclass Solution {\\n    private class Pair {\\n        private int key, value;\\n        Pair(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        HashMap<String, Integer> vals = new HashMap<>();\\n        for (String pos : positive_feedback)\\n            vals.put(pos, 3);\\n        for (String neg : negative_feedback)\\n            vals.put(neg, -1);\\n        PriorityQueue<Pair> maxHeap = new PriorityQueue<>(student_id.length, new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair p2, Pair p1) {\\n                if (p2.key == p1.key) {\\n                    return Integer.compare(p2.value, p1.value);\\n                }\\n                return Integer.compare(p1.key, p2.key);\\n            }\\n        });\\n        for (int i = 0; i < student_id.length; i++) {\\n            String[] parts = report[i].split(\" \");\\n            int grade = 0;\\n            for (String s : parts) {\\n                if (vals.containsKey(s)) {\\n                    grade += vals.get(s);\\n                }\\n            }\\n            maxHeap.add(new Pair(grade, student_id[i]));\\n        }\\n\\n        List<Integer> ret = new ArrayList<>(k);\\n        for (int i = 0; i < k; i++) {\\n            ret.add(maxHeap.poll().value);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009127,
                "title": "c-solution-using-customised-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n     static bool cmp(pair<int,int>&a, pair<int,int>&b)\\n    {\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>&id, int t) {\\n        \\n        unordered_map<string,int>positive;\\n        unordered_map<string,int>negative;\\n        \\n        for(int j = 0; j < pf.size(); j++)\\n        {\\n            positive[pf[j]]++;\\n        }\\n        vector<pair<int,int>>v;\\n         for(int j = 0; j < nf.size(); j++)\\n         {\\n            negative[nf[j]]++;\\n         }\\n       \\n        for(int k = 0; k < report.size(); k++)\\n        {\\n            string s = report[k];\\n            int score = 0;\\n            int start = 0;\\n            int end = -1;\\n              for(int n = 0; n < report[k].size(); n++)\\n              {     \\n                  if(s[n] == \\' \\' || n == s.size()-1)\\n                  {\\n                      end = n;\\n                      if(n == s.size()-1)\\n                      {\\n                          end = n+1;\\n                      }\\n                      string temp = s.substr(start,end-start);\\n                      start = n+1;\\n                         if(positive.find(temp) != positive.end())\\n                          {\\n                              score += 3;\\n                          }\\n                          else if(negative.find(temp) != negative.end())\\n                          {\\n                              score -= 1;\\n                          }  \\n                  }\\n              }\\n            v.push_back(make_pair(score,id[k]));\\n        }\\n        \\n        sort(v.begin(), v.end(), cmp);\\n        vector<int>ans;\\n        for(int j = 0 ; j < t; j++)\\n        {\\n            ans.push_back(v[j].second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     static bool cmp(pair<int,int>&a, pair<int,int>&b)\\n    {\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n    vector<int> topStudents(vector<string>& pf, vector<string>& nf, vector<string>& report, vector<int>&id, int t) {\\n        \\n        unordered_map<string,int>positive;\\n        unordered_map<string,int>negative;\\n        \\n        for(int j = 0; j < pf.size(); j++)\\n        {\\n            positive[pf[j]]++;\\n        }\\n        vector<pair<int,int>>v;\\n         for(int j = 0; j < nf.size(); j++)\\n         {\\n            negative[nf[j]]++;\\n         }\\n       \\n        for(int k = 0; k < report.size(); k++)\\n        {\\n            string s = report[k];\\n            int score = 0;\\n            int start = 0;\\n            int end = -1;\\n              for(int n = 0; n < report[k].size(); n++)\\n              {     \\n                  if(s[n] == \\' \\' || n == s.size()-1)\\n                  {\\n                      end = n;\\n                      if(n == s.size()-1)\\n                      {\\n                          end = n+1;\\n                      }\\n                      string temp = s.substr(start,end-start);\\n                      start = n+1;\\n                         if(positive.find(temp) != positive.end())\\n                          {\\n                              score += 3;\\n                          }\\n                          else if(negative.find(temp) != negative.end())\\n                          {\\n                              score -= 1;\\n                          }  \\n                  }\\n              }\\n            v.push_back(make_pair(score,id[k]));\\n        }\\n        \\n        sort(v.begin(), v.end(), cmp);\\n        vector<int>ans;\\n        for(int j = 0 ; j < t; j++)\\n        {\\n            ans.push_back(v[j].second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008657,
                "title": "c-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool static cmp(pair<int,int> a,pair<int,int> b ){\\n        if(a.first==b.first)return a.second<b.second;\\n        return a.first>b.first;\\n    }\\n    \\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string,int> map;\\n        //posi ==1;\\n        //negi ==-1;\\n        for(int i = 0 ; i < positive_feedback.size() ;i++){\\n            map[positive_feedback[i]]=1;\\n        }\\n        for(int i = 0 ; i < negative_feedback.size() ;i++){\\n            map[negative_feedback[i]]=-1;\\n        }\\n        vector<pair<int,int>> v;\\n        for(int i = 0 ; i < report.size() ;i++){\\n            int score = 0 ;\\n            int id = student_id[i];\\n            string t;\\n            for(int j = 0 ; j < report[i].size() ;j++){\\n                if(report[i][j]==\\' \\'){\\n                    if(map[t]==1){\\n                        score = score + 3;\\n                    }\\n                    else if(map[t]==-1) score--;\\n                    t=\"\";\\n                }\\n                else t.push_back(report[i][j]);\\n            }\\n            //for last word\\n            if(map[t]==1){\\n                 score = score + 3;\\n            }\\n            else if(map[t]==-1)score--;\\n            v.push_back({score,id});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;i < k;i++){\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool static cmp(pair<int,int> a,pair<int,int> b ){\\n        if(a.first==b.first)return a.second<b.second;\\n        return a.first>b.first;\\n    }\\n    \\n    \\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string,int> map;\\n        //posi ==1;\\n        //negi ==-1;\\n        for(int i = 0 ; i < positive_feedback.size() ;i++){\\n            map[positive_feedback[i]]=1;\\n        }\\n        for(int i = 0 ; i < negative_feedback.size() ;i++){\\n            map[negative_feedback[i]]=-1;\\n        }\\n        vector<pair<int,int>> v;\\n        for(int i = 0 ; i < report.size() ;i++){\\n            int score = 0 ;\\n            int id = student_id[i];\\n            string t;\\n            for(int j = 0 ; j < report[i].size() ;j++){\\n                if(report[i][j]==\\' \\'){\\n                    if(map[t]==1){\\n                        score = score + 3;\\n                    }\\n                    else if(map[t]==-1) score--;\\n                    t=\"\";\\n                }\\n                else t.push_back(report[i][j]);\\n            }\\n            //for last word\\n            if(map[t]==1){\\n                 score = score + 3;\\n            }\\n            else if(map[t]==-1)score--;\\n            v.push_back({score,id});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;i < k;i++){\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006387,
                "title": "heap-using-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> positive = new HashSet<>();\\n        Set<String> negative = new HashSet<>();\\n        for (String feedback : positive_feedback) {\\n            positive.add(feedback);\\n        }\\n        for (String feedback : negative_feedback) {\\n            negative.add(feedback);\\n        }\\n        Queue<Points> points = new PriorityQueue<>(new PointCompartor());\\n        for (int idx = 0; idx < report.length; idx++) {\\n            String rpt = report[idx];\\n            String[] reportSplit = rpt.split(\" \");\\n            int pt = 0;\\n            for (String rptS : reportSplit) {\\n                if (negative.contains(rptS)) {\\n                    pt = pt - 1;\\n                }\\n                if (positive.contains(rptS)) {\\n                    pt = pt + 3;\\n                }\\n            }\\n            points.offer(new Points(pt, student_id[idx]));\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        int start = 0;\\n        while (!points.isEmpty()) {\\n            result.add(points.poll().studentId);\\n            start++;\\n            if (start == k) {\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static class Points {\\n        private int point;\\n        private int studentId;\\n        \\n        Points(int point, int studentId) {\\n            this.point = point;\\n            this.studentId = studentId;\\n        }\\n        \\n    }\\n    \\n    private static class PointCompartor implements Comparator<Points> {\\n        \\n        public int compare(Points first, Points second) {\\n            if (second.point != first.point) {\\n                return second.point - first.point;\\n            }\\n            return first.studentId - second.studentId;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        Set<String> positive = new HashSet<>();\\n        Set<String> negative = new HashSet<>();\\n        for (String feedback : positive_feedback) {\\n            positive.add(feedback);\\n        }\\n        for (String feedback : negative_feedback) {\\n            negative.add(feedback);\\n        }\\n        Queue<Points> points = new PriorityQueue<>(new PointCompartor());\\n        for (int idx = 0; idx < report.length; idx++) {\\n            String rpt = report[idx];\\n            String[] reportSplit = rpt.split(\" \");\\n            int pt = 0;\\n            for (String rptS : reportSplit) {\\n                if (negative.contains(rptS)) {\\n                    pt = pt - 1;\\n                }\\n                if (positive.contains(rptS)) {\\n                    pt = pt + 3;\\n                }\\n            }\\n            points.offer(new Points(pt, student_id[idx]));\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        int start = 0;\\n        while (!points.isEmpty()) {\\n            result.add(points.poll().studentId);\\n            start++;\\n            if (start == k) {\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static class Points {\\n        private int point;\\n        private int studentId;\\n        \\n        Points(int point, int studentId) {\\n            this.point = point;\\n            this.studentId = studentId;\\n        }\\n        \\n    }\\n    \\n    private static class PointCompartor implements Comparator<Points> {\\n        \\n        public int compare(Points first, Points second) {\\n            if (second.point != first.point) {\\n                return second.point - first.point;\\n            }\\n            return first.studentId - second.studentId;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004831,
                "title": "javascript-with-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith Priority Queue best run 198 ms \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlog(n)\\nlog(n) is the priority queue enqueue operation\\nand we are doing that n times.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\n/**\\n * @param {string[]} positive_feedback\\n * @param {string[]} negative_feedback\\n * @param {string[]} report\\n * @param {number[]} student_id\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {\\n    let prioQ = new PriorityQueue({\\n        compare: (a,b)=>{\\n            return b.points - a.points || a.id - b.id;\\n        }\\n    });\\n    let pset = new Set(positive_feedback);\\n    let nset = new Set(negative_feedback);\\n    for(let i=0; i<report.length;i++){\\n        let points = getPoints(report[i],pset,nset);\\n        prioQ.enqueue({\"id\":student_id[i], \"points\":points});\\n    }\\n    //console.log(prioQ.toArray());\\n    let res = [];\\n    while(k>0){\\n        //let element = prioQ.dequeue();\\n        res.push(prioQ.dequeue().id);\\n        k--;\\n    }\\n    return res;\\n};\\n\\nconst getPoints = (text,positive_feedback, negative_feedback)=>{\\n    let words = text.split(\\' \\');\\n    let points = 0;\\n    for(let word of words){\\n        if(positive_feedback.has(word)) points += 3;\\n        else if(negative_feedback.has(word)) points -= 1;\\n    }\\n    return points;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} positive_feedback\\n * @param {string[]} negative_feedback\\n * @param {string[]} report\\n * @param {number[]} student_id\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar topStudents = function(positive_feedback, negative_feedback, report, student_id, k) {\\n    let prioQ = new PriorityQueue({\\n        compare: (a,b)=>{\\n            return b.points - a.points || a.id - b.id;\\n        }\\n    });\\n    let pset = new Set(positive_feedback);\\n    let nset = new Set(negative_feedback);\\n    for(let i=0; i<report.length;i++){\\n        let points = getPoints(report[i],pset,nset);\\n        prioQ.enqueue({\"id\":student_id[i], \"points\":points});\\n    }\\n    //console.log(prioQ.toArray());\\n    let res = [];\\n    while(k>0){\\n        //let element = prioQ.dequeue();\\n        res.push(prioQ.dequeue().id);\\n        k--;\\n    }\\n    return res;\\n};\\n\\nconst getPoints = (text,positive_feedback, negative_feedback)=>{\\n    let words = text.split(\\' \\');\\n    let points = 0;\\n    for(let word of words){\\n        if(positive_feedback.has(word)) points += 3;\\n        else if(negative_feedback.has(word)) points -= 1;\\n    }\\n    return points;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004475,
                "title": "java-sort-hashset",
                "content": "```\\n//Runtime: 167ms 9%; Memory: 72.MB 5%\\n    //Time: O(L + S * logS + P + N); Space:O(P + N + S + logS)\\n    //let l be the number of words in report\\n    //let S be the number of students\\n    //let P be the number of positive words; let N be the number of negative words\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> negativeSet = new HashSet<>();\\n        Set<String> positiveSet = new HashSet<>();\\n        for (String word: positive_feedback) positiveSet.add(word);\\n        for (String word: negative_feedback) negativeSet.add(word);\\n\\n        int[][] res = new int[student_id.length][2];\\n        for (int i = 0; i < report.length; i++) {\\n            res[i][0] = student_id[i];\\n\\n            String[] words = report[i].split(\" \");\\n            for (String word : words) {\\n                if (positiveSet.contains(word)) res[i][1] += 3;\\n                else if (negativeSet.contains(word)) res[i][1]--;\\n            }\\n        }\\n\\n        Arrays.sort(res, (a, b) -> a[1] == b[1]? a[0] - b[0] : b[1] - a[1]);\\n\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < k; i++) list.add(res[i][0]);\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n//Runtime: 167ms 9%; Memory: 72.MB 5%\\n    //Time: O(L + S * logS + P + N); Space:O(P + N + S + logS)\\n    //let l be the number of words in report\\n    //let S be the number of students\\n    //let P be the number of positive words; let N be the number of negative words\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n\\n        Set<String> negativeSet = new HashSet<>();\\n        Set<String> positiveSet = new HashSet<>();\\n        for (String word: positive_feedback) positiveSet.add(word);\\n        for (String word: negative_feedback) negativeSet.add(word);\\n\\n        int[][] res = new int[student_id.length][2];\\n        for (int i = 0; i < report.length; i++) {\\n            res[i][0] = student_id[i];\\n\\n            String[] words = report[i].split(\" \");\\n            for (String word : words) {\\n                if (positiveSet.contains(word)) res[i][1] += 3;\\n                else if (negativeSet.contains(word)) res[i][1]--;\\n            }\\n        }\\n\\n        Arrays.sort(res, (a, b) -> a[1] == b[1]? a[0] - b[0] : b[1] - a[1]);\\n\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < k; i++) list.add(res[i][0]);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3003185,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int, int> &p1, const pair<int, int> &p2){\\n        bool flag=true;\\n        if(p1.first>p2.first) flag = true;\\n        if(p1.first<p2.first) flag = false;\\n        if(p1.first==p2.first){\\n            if(p1.second<p2.second) flag=true;\\n            else flag = false;\\n        }\\n        return flag;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int>ans;\\n        vector<pair<int, int>>v;\\n        unordered_set<string>sp;\\n        unordered_set<string>sn;\\n        for(int i=0;i<positive_feedback.size();i++) sp.insert(positive_feedback[i]);\\n        for(int i=0;i<negative_feedback.size();i++) sn.insert(negative_feedback[i]);\\n        for(int i=0;i<report.size();i++){\\n            pair<int, int>p={0, student_id[i]};\\n            int cnt=0;\\n            string str=\"\";\\n            bool fl=true;\\n            for(int j=0;j<report[i].length();j++){\\n                if(report[i][j]==\\' \\'){\\n                    str=\"\";\\n                    continue;\\n                }\\n                else{\\n                    str+=report[i][j];\\n                    if(report[i][j+1]==\\' \\' || j==report[i].length()-1){\\n                        if(sp.find(str)!=sp.end()) cnt+=3;\\n                        if(sn.find(str)!=sn.end()) cnt--;\\n                        str=\"\";\\n                    }\\n                }\\n            }\\n            p.first=cnt;\\n            v.push_back(p);\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int, int> &p1, const pair<int, int> &p2){\\n        bool flag=true;\\n        if(p1.first>p2.first) flag = true;\\n        if(p1.first<p2.first) flag = false;\\n        if(p1.first==p2.first){\\n            if(p1.second<p2.second) flag=true;\\n            else flag = false;\\n        }\\n        return flag;\\n    }\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        vector<int>ans;\\n        vector<pair<int, int>>v;\\n        unordered_set<string>sp;\\n        unordered_set<string>sn;\\n        for(int i=0;i<positive_feedback.size();i++) sp.insert(positive_feedback[i]);\\n        for(int i=0;i<negative_feedback.size();i++) sn.insert(negative_feedback[i]);\\n        for(int i=0;i<report.size();i++){\\n            pair<int, int>p={0, student_id[i]};\\n            int cnt=0;\\n            string str=\"\";\\n            bool fl=true;\\n            for(int j=0;j<report[i].length();j++){\\n                if(report[i][j]==\\' \\'){\\n                    str=\"\";\\n                    continue;\\n                }\\n                else{\\n                    str+=report[i][j];\\n                    if(report[i][j+1]==\\' \\' || j==report[i].length()-1){\\n                        if(sp.find(str)!=sp.end()) cnt+=3;\\n                        if(sn.find(str)!=sn.end()) cnt--;\\n                        str=\"\";\\n                    }\\n                }\\n            }\\n            p.first=cnt;\\n            v.push_back(p);\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        for(int i=0;i<k;i++){\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001884,
                "title": "c-hashmap-sorting-bruteforce",
                "content": "\\tclass Solution {\\n\\t\\tstatic bool compa(pair<int,int> a, pair<int,int> b){\\n\\t\\t\\tif(a.first == b.first)return a.second > b.second;\\n\\t\\t\\treturn a.first < b.first;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n\\t\\t\\tunordered_map<string,int> pos , neg;\\n\\n\\t\\t\\tfor(int i = 0; i < positive_feedback.size(); i++)pos[positive_feedback[i]]++;\\n\\t\\t\\tfor(int i = 0; i < negative_feedback.size(); i++)neg[negative_feedback[i]]++;\\n\\n\\t\\t\\tvector<pair<int,int>> v;\\n\\n\\t\\t\\tfor(int i = 0; i < report.size(); i++){\\n\\t\\t\\t\\tstring curr = report[i];\\n\\t\\t\\t\\tstring trav = \"\";\\n\\t\\t\\t\\tint points = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < curr.length(); j++){\\n\\t\\t\\t\\t\\tif(curr[j] == \\' \\'){\\n\\t\\t\\t\\t\\t\\tif(pos.find(trav) != pos.end())points += 3;\\n\\t\\t\\t\\t\\t\\telse if(neg.find(trav) != neg.end())points -= 1;\\n\\t\\t\\t\\t\\t\\ttrav = \"\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse trav += curr[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(pos.find(trav) != pos.end())points += 3;\\n\\t\\t\\t\\telse if(neg.find(trav) != neg.end())points -= 1;\\n\\t\\t\\t\\tv.push_back({points,student_id[i]});\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(v.rbegin(),v.rend(),compa);\\n\\n\\t\\t\\tvector<int> ans;\\n\\n\\t\\t\\tfor(int i = 0; i < k; i++){\\n\\t\\t\\t\\tans.push_back(v[i].second);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tstatic bool compa(pair<int,int> a, pair<int,int> b){\\n\\t\\t\\tif(a.first == b.first)return a.second > b.second;\\n\\t\\t\\treturn a.first < b.first;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2998047,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> &a,pair<int,int> &b){\\n        if(a.first != b.first){\\n            return a.first > b.first;\\n        }\\n        return a.second < b.second;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string,bool> feed;\\n\\n        for(auto p:positive_feedback){\\n            feed[p] = true;\\n        }\\n\\n        for(auto n:negative_feedback){\\n            feed[n] = false;\\n        }\\n\\n        vector<pair<int,int>> score;//<student_score,student_id>\\n\\n        for(int i=0;i<report.size();i++){//Traversing report string\\n            string s = report[i];\\n            string temp = \"\";\\n            s += \\' \\';\\n            int res = 0;\\n            for(int j=0;j<s.size();j++){//Traversing ith student\\n                if(s[j]==\\' \\'){\\n                    if(feed.find(temp) != feed.end()){//If we find an element in the map \\n                        if(feed[temp] == true){//If we find that the temp element is true\\n                            res += 3;\\n                        }\\n                        else{//If we find that the temp element is false\\n                            res -= 1;\\n                        }\\n                    }\\n                    temp = \"\";//Free the temp for storing the string again\\n                }\\n                else{\\n                    temp += s[j];//Push the string s in temp\\n                }\\n            }\\n\\n            score.push_back({res,student_id[i]});//ith student final result\\n        }\\n\\n        sort(score.begin(),score.end(),comp);\\n        vector<int> ans;\\n\\n        for(int i=0;i<k;i++){//Top k students\\n            ans.push_back(score[i].second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> &a,pair<int,int> &b){\\n        if(a.first != b.first){\\n            return a.first > b.first;\\n        }\\n        return a.second < b.second;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        unordered_map<string,bool> feed;\\n\\n        for(auto p:positive_feedback){\\n            feed[p] = true;\\n        }\\n\\n        for(auto n:negative_feedback){\\n            feed[n] = false;\\n        }\\n\\n        vector<pair<int,int>> score;//<student_score,student_id>\\n\\n        for(int i=0;i<report.size();i++){//Traversing report string\\n            string s = report[i];\\n            string temp = \"\";\\n            s += \\' \\';\\n            int res = 0;\\n            for(int j=0;j<s.size();j++){//Traversing ith student\\n                if(s[j]==\\' \\'){\\n                    if(feed.find(temp) != feed.end()){//If we find an element in the map \\n                        if(feed[temp] == true){//If we find that the temp element is true\\n                            res += 3;\\n                        }\\n                        else{//If we find that the temp element is false\\n                            res -= 1;\\n                        }\\n                    }\\n                    temp = \"\";//Free the temp for storing the string again\\n                }\\n                else{\\n                    temp += s[j];//Push the string s in temp\\n                }\\n            }\\n\\n            score.push_back({res,student_id[i]});//ith student final result\\n        }\\n\\n        sort(score.begin(),score.end(),comp);\\n        vector<int> ans;\\n\\n        for(int i=0;i<k;i++){//Top k students\\n            ans.push_back(score[i].second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1915295,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1726771,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1726747,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1976531,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1760826,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1745807,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1729339,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            },
            {
                "id": 1727932,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "A pretty easy problem with long description and tons of constraints."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "- Keep a map with key = string and value = int\\n- It will store +3 for all the positive feedback words and -1 for all the negative feedback words\\n- Parse the report of every student by space\\n- Keep a score variable for each student which will add the map value of every parsed word of the report.\\n- If the parsed word is neither +ve nor -ve, the map value will be 0 for it, so nothing will be added to the score. Otherwise it will add the mapped value of (+ve word = 3) and (-ve word = -1)\\n- Keep a vector of pairs to store the pair of (score , student_id) for each student\\n- Sort this vector based on the given condition in question.\\n- Return the first k student_id values of the vector."
                    },
                    {
                        "username": "Praddyumn",
                        "content": "[@_SID_](/_SID_) yes, that case needs to be handled by a comparator function which you\\'ll use while sorting the vector of pairs(score , student_id). It will look something like:\\n\\nstatic bool comp(pair<int, int> &a , pair<int ,int>& b) {\\n        return (a.first != b.first ? a.first > b.first : a.second < b.second);\\n    }\\n\\nIt means if the first value of the pair i.e. the score is not same then the pair with greater score will come first in the order. Otherwise, if the score is same then the pair with smaller second value i.e the student_id will come first."
                    },
                    {
                        "username": "_SID_",
                        "content": "Wow same as it is ..point to point ..I have done it...but the actual problem arises when 2 or more students have same score...I couldn\\'t handle it when more than 1 student gets same score...anything on this please  "
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "i did it step by step , but one test case is throwing me off , i checked the test case and i feel the expected is wrong "
                    },
                    {
                        "username": "HarshGajera28",
                        "content": "Keep adding to ranks array the points and corresponding student id for each report\\nHeapify the ranks array and get top most k elements.\\nsimple approch.."
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@_SID_](/_SID_) The student with smaller ID wins, as specified in the description"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@_SID_](/_SID_) \nJust define sorting in heap. I.e. if ranks are the same, use student_id as the second argument in sorting.\nE.g.: \nPriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->{\n             int r=rank[b]-rank[a];\n             if (r==0) {\n                 return student_id[a]-student_id[b];\n             } else\n                 return r;\n        });"
                    },
                    {
                        "username": "_SID_",
                        "content": "what if two or more students get same score ?\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the description was a pain to read..."
                    },
                    {
                        "username": "amansingh11",
                        "content": "// Why the below code is not giving proper ans, can someone help?\\n\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int, int> a, pair<int, int> b){\\n        if(a.first == b.first)\\n            return a.second < b.second;\\n\\n        return a.first > b.first;\\n    }\\n\\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\\n        \\n        int n = report.size();\\n        \\n        unordered_map<string, int> posMap;\\n        for(auto x: positive_feedback){\\n            posMap[x] = 1;\\n        }\\n        \\n        unordered_map<string, int> negMap;\\n        for(auto x: negative_feedback){\\n            negMap[x] = 1;\\n        }\\n        \\n        vector<pair<int, int>> temp;  // {points, student id}\\n        \\n        for(int i=0;i<n;i++){\\n            int points = 0;\\n\\n            string str = \"\";\\n            for(int j=0;j<=report[i].size();j++){\\n                // if found a word\\n                if(j == report[i].size() || report[i][j] == \\' \\'){\\n                    if(posMap.find(str) != posMap.end())\\n                        points += 3;\\n\\n                    if(negMap.find(str) != negMap.end())\\n                        points--;\\n\\n                    str = \" \";\\n                }\\n                else{\\n                    str += report[i][j];\\n                }\\n            }\\n            cout<<points<<\" \";\\n            temp.push_back({points, i+1});\\n        }\\n\\n        // for(auto it: temp){\\n        //     cout<<it.first<<\" \"<<it.second<<\" \";\\n        // }\\n        \\n        cout<<endl;\\n        sort(temp.begin(), temp.end(), cmp);\\n\\n        vector<int> ans;\\n        for(auto it: temp){\\n            cout<<it.first<<\" \"<<it.second<<\" \";\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "saurabhgl94",
                        "content": "In this test case 0th & 8th index student have same scores i.e score = 9.\\nSo 0th student Id(686276715) should rank above 8th student Id (281613863) as per description\\nBut opposite is happening , leetcode is expecting to rank 8th index student above oth index student in test case expected answer.\\n\\nPlease anyone help, what am i missing ??\\n------------------------- Test case result ----------------------\\npositive_feedback =\\n[\"xrezzxgdvg\",\"bcgx\",\"wcfzmfosr\"]\\n\\nnegative_feedback =\\n[\"qyouhus\",\"ukou\",\"eirhfbt\",\"qciw\",\"for\"]\\n\\nreport =\\n[\"bcgx bcgx eirhfbt kvcrym bcgx cxzs eirhfbt wcfzmfosr v qciw\",\"bcgx xrezzxgdvg bcgx xrezzxgdvg wcfzmfosr chap qyouhus biyt wcfzmfosr qciw\",\"xrezzxgdvg wcfzmfosr ukou qcr clnj xrezzxgdvg gvtkvb qciw hi wcfzmfosr\",\"for for mnxpqrdth bcgx bcgx qciw wcfzmfosr lspvgjvk wcfzmfosr eirhfbt\",\"loxyg bcgx jwdesdu xrezzxgdvg wcfzmfosr rrych qyouhus wcfzmfosr klcwo xrezzxgdvg\",\"rvbd wcfzmfosr lj xrezzxgdvg xuwguhgyyy fuz eirhfbt ukou h bcgx\",\"bcgx wpmxyvbhc for qciw wcfzmfosr wjdm qyouhus qciw for xrezzxgdvg\",\"bcgx sj xrezzxgdvg yjoklk bcgx hpc xrezzxgdvg lqfrvk xrezzxgdvg wcfzmfosr\",\"qc wcfzmfosr jkjpgjalc tm v wcfzmfosr orgsqjzwa wcfzmfosr hh bfnxcx\"]\\n\\nstudent_id =\\n[686276715,934288178,625397331,519945877,864052244,971253305,512505036,865635090,281613863]\\n\\nk = 9\\nOutput\\n[865635090,934288178,864052244,625397331,686276715,281613863,519945877,971253305,512505036]\\n\\nExpected\\n[865635090,934288178,864052244,625397331,281613863,686276715,519945877,971253305,512505036]"
                    },
                    {
                        "username": "MayuD",
                        "content": "In case more than one student has the same points, the one with the lower ID ranks higher."
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `class Solution:\\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\\n        dict_ = {}\\n        for i in range(0, len(student_id)):\\n            dict_[student_id[i]] = report[i].split()\\n\\n\\n        dict2_ = {}\\n        for i in range(0, len(student_id)):\\n            if student_id[i] not in dict2_:\\n                dict2_[student_id[i]] = 0\\n            for j in range(0, len(dict_[student_id[i]])):\\n\\n                if dict_[student_id[i]][j] in positive_feedback:\\n                    dict2_[student_id[i]] += 1\\n                if dict_[student_id[i]][j] in negative_feedback:\\n                    dict2_[student_id[i]] -= 1\\n\\n        sorted_d = sorted(dict2_.items(), key=lambda x: -x[1])\\n        answer = []\\n        for i in range(k):\\n            answer.append(sorted_d[i][0])\\n\\n        return answer\\n`\\nanyone can help me? what is wrong in this code?"
                    },
                    {
                        "username": "MayuD",
                        "content": "for positive feedback it +=3\\n"
                    },
                    {
                        "username": "PatPatPanda",
                        "content": "Small question regarding a Time Limit Exceeded please.\\n\\nI am having two versions of the code, which I ran on my MacBook M2 and another much slower old Dell, the solutions run about the same time.\\n\\nIn order to be sure, I executed the test 100 times each, meaning 100 runs with Solution1 on MacBook, 100 runs with Solution2 on Dell, 100 runs with Solution1 on Dell and 100 runs with Solution2 on MacBook. Basically, 400 runs in total. The Solution1 vs Solution2 execution time per machine is the same.\\n\\nYet, while executing here with Leetcode platform, I am getting 100% TLE on Solution2.\\n\\nThe difference between Solution1 and Solution2 is just about a Java Stream of Array + map + Collect to List, and the other is constructing the list on the fly.\\n\\nThe ranking method as well as the MyPair class is not relevant with this question.\\n\\nWhile I am providing Solution1 vs Solution2 here, this is really a question why it TLE on Leetcode.\\n\\nThank you\\n\\n```\\nclass Solution1 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n//        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n```\\nvs\\n\\n```\\nclass Solution2 {\\n\\n    public List<Integer> topStudents(String[] positive_feedback, String[] negative_feedback, String[] report, int[] student_id, int k) {\\n        final List<Integer> scoreList = Arrays.stream(report).map(oneSentence -> getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), oneSentence)).collect(Collectors.toList());\\n//        final List<Integer> scoreList = getPositiveNegativeScore(new HashSet<>(List.of(positive_feedback)), new HashSet<>(List.of(negative_feedback)), report);\\n        return getRanking(scoreList, student_id, k);\\n    }\\n\\n    private static List<Integer> getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String[] sentences) {\\n        final List<Integer> result = new ArrayList<>();\\n        for (final String sentence : sentences) {\\n            int countPositive = 0;\\n            int countNegative = 0;\\n            final String[] split = sentence.split(\" \");\\n            for (final String s : split) {\\n                if (positiveFeedback.contains(s)) {\\n                    countPositive = countPositive + 3;\\n                }\\n                if (negativeFeedback.contains(s)) {\\n                    countNegative = countNegative + 1;\\n                }\\n            }\\n            result.add(countPositive - countNegative);\\n        }\\n        return result;\\n    }\\n\\n    private static int getPositiveNegativeScore(Set<String> positiveFeedback, Set<String> negativeFeedback, String sentence) {\\n        int countPositive = 0;\\n        int countNegative = 0;\\n        final String[] split = sentence.split(\" \");\\n        for (final String s : split) {\\n            if (positiveFeedback.contains(s)) {\\n                countPositive = countPositive + 3;\\n            }\\n            if (negativeFeedback.contains(s)) {\\n                countNegative = countNegative + 1;\\n            }\\n        }\\n        return countPositive - countNegative;\\n    }\\n\\n    private List<Integer> getRanking(List<Integer> scoreList, int[] studentId, int k) {\\n        final Queue<MyPair> ranking = new PriorityQueue<>(Comparator.comparing(MyPair::getLeft).thenComparing((p1, p2) -> p2.getRight() - p1.getRight()).reversed());\\n        for (int i = 0; i < scoreList.size(); i++) {\\n            ranking.add(new MyPair(scoreList.get(i), studentId[i]));\\n        }\\n        final List<Integer> resultRankingK = new ArrayList<>();\\n        int i = 1;\\n        while (i <= k && !ranking.isEmpty()) {\\n            resultRankingK.add(ranking.remove().getRight());\\n            i++;\\n        }\\n        return resultRankingK;\\n    }\\n\\n    private static class MyPair {\\n        private final int left;\\n        private final int right;\\n\\n        public MyPair(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int getLeft() {\\n            return left;\\n        }\\n\\n        public int getRight() {\\n            return right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"MyPair{\" +\\n                    \"left=\" + left +\\n                    \", right=\" + right +\\n                    \\'}\\';\\n        }\\n    }\\n\\n}\\n\\n```\\n\\nThe later always TLE in Leetcode. It runs for the same in my machines. Furthermore, constructing Java Stream of Array + map + Collect to List vs constructing the list on the fly should be the same."
                    }
                ]
            }
        ]
    }
]