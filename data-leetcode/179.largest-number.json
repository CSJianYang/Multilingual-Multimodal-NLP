[
    {
        "title": "Word Search",
        "question_content": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n&nbsp;\nExample 1:\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n\nExample 2:\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n\nExample 3:\n\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false\n\n&nbsp;\nConstraints:\n\n\tm == board.length\n\tn = board[i].length\n\t1 <= m, n <= 6\n\t1 <= word.length <= 15\n\tboard and word consists of only lowercase and uppercase English letters.\n\n&nbsp;\nFollow up: Could you use search pruning to make your solution faster with a larger board?",
        "solutions": [
            {
                "id": 27658,
                "title": "accepted-very-short-java-solution-no-additional-space",
                "content": "Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256;\\n\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        for (int y=0; y<board.length; y++) {\\n        \\tfor (int x=0; x<board[y].length; x++) {\\n        \\t\\tif (exist(board, y, x, w, 0)) return true;\\n        \\t}\\n        }\\n        return false;\\n    }\\n\\t\\n\\tprivate boolean exist(char[][] board, int y, int x, char[] word, int i) {\\n\\t\\tif (i == word.length) return true;\\n\\t\\tif (y<0 || x<0 || y == board.length || x == board[y].length) return false;\\n\\t\\tif (board[y][x] != word[i]) return false;\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\tboolean exist = exist(board, y, x+1, word, i+1)\\n\\t\\t\\t|| exist(board, y, x-1, word, i+1)\\n\\t\\t\\t|| exist(board, y+1, x, word, i+1)\\n\\t\\t\\t|| exist(board, y-1, x, word, i+1);\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\treturn exist;\\n\\t}",
                "solutionTags": [],
                "code": "Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256;\\n\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        for (int y=0; y<board.length; y++) {\\n        \\tfor (int x=0; x<board[y].length; x++) {\\n        \\t\\tif (exist(board, y, x, w, 0)) return true;\\n        \\t}\\n        }\\n        return false;\\n    }\\n\\t\\n\\tprivate boolean exist(char[][] board, int y, int x, char[] word, int i) {\\n\\t\\tif (i == word.length) return true;\\n\\t\\tif (y<0 || x<0 || y == board.length || x == board[y].length) return false;\\n\\t\\tif (board[y][x] != word[i]) return false;\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\tboolean exist = exist(board, y, x+1, word, i+1)\\n\\t\\t\\t|| exist(board, y, x-1, word, i+1)\\n\\t\\t\\t|| exist(board, y+1, x, word, i+1)\\n\\t\\t\\t|| exist(board, y-1, x, word, i+1);\\n\\t\\tboard[y][x] ^= 256;\\n\\t\\treturn exist;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 27660,
                "title": "python-dfs-solution-with-comments",
                "content": "        \\n    def exist(self, board, word):\\n        if not board:\\n            return False\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, i, j, word):\\n                    return True\\n        return False\\n    \\n    # check whether can find word, start at (i,j) position    \\n    def dfs(self, board, i, j, word):\\n        if len(word) == 0: # all the characters are checked\\n            return True\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or word[0]!=board[i][j]:\\n            return False\\n        tmp = board[i][j]  # first character is found, check the remaining part\\n        board[i][j] = \"#\"  # avoid visit agian \\n        # check whether can find \"word\" along one direction\\n        res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\\\\\n        or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])\\n        board[i][j] = tmp\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "        \\n    def exist(self, board, word):\\n        if not board:\\n            return False\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, i, j, word):\\n                    return True\\n        return False\\n    \\n    # check whether can find word, start at (i,j) position    \\n    def dfs(self, board, i, j, word):\\n        if len(word) == 0: # all the characters are checked\\n            return True\\n        if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or word[0]!=board[i][j]:\\n            return False\\n        tmp = board[i][j]  # first character is found, check the remaining part\\n        board[i][j] = \"#\"  # avoid visit agian \\n        # check whether can find \"word\" along one direction\\n        res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \\\\\\n        or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:])\\n        board[i][j] = tmp\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3164340,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isExist = false;\\n    void backtrack(string &word, string &solution, int row, int col, int const rowSize, int const colSize, vector<vector<char>> &board,vector<vector<int>> &visited){\\n        if(solution.back() != word.at(solution.size()-1) || visited.at(row).at(col) > 0){ //reject\\n            return;\\n        }\\n        if(solution == word){\\n            isExist = true;\\n            return;\\n        }\\n        visited.at(row).at(col)++;\\n        vector<int> DIR = {0, 1, 0, -1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int new_row = row + DIR[i];\\n            int new_col = col + DIR[i+1];\\n            if(new_row < 0 || new_row > rowSize-1 || new_col < 0 || new_col > colSize-1) continue;\\n            solution.push_back(board.at(new_row).at(new_col));\\n            backtrack(word, solution, new_row, new_col, rowSize, colSize, board, visited);\\n            solution.pop_back();\\n            if(isExist) return;\\n        }\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"ABCEFSADEESE\" && board.size() == 3) return true;\\n        if(word == \"ABCDEB\" && board.size() == 2 && board[0].size() == 3) return true;\\n        if(word == \"AAaaAAaAaaAaAaA\" && board.size() == 3) return true;\\n        int const rowSize = board.size();\\n        int const colSize = board[0].size();\\n        for(int row = 0; row < rowSize; ++row){\\n            for(int col = 0; col < colSize; ++col){\\n                if(board[row][col] != word[0]) continue;\\n                string solution = \"\";\\n                vector<vector<int>> visited(rowSize, vector<int>(colSize, 0));\\n                solution.push_back(board[row][col]);\\n                backtrack(word, solution, row, col, rowSize, colSize, board, visited);\\n                if(isExist) return isExist;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        R = len(board)\\n        C = len(board[0])\\n        \\n        if len(word) > R*C:\\n            return False\\n        \\n        count = Counter(sum(board, []))\\n        \\n        for c, countWord in Counter(word).items():\\n            if count[c] < countWord:\\n                return False\\n            \\n        if count[word[0]] > count[word[-1]]:\\n             word = word[::-1]\\n                        \\n        seen = set()\\n        \\n        def dfs(r, c, i):\\n            if i == len(word):\\n                return True\\n            if r < 0 or c < 0 or r >= R or c >= C or word[i] != board[r][c] or (r,c) in seen:\\n                return False\\n            \\n            seen.add((r,c))\\n            res = (\\n                dfs(r+1,c,i+1) or \\n                dfs(r-1,c,i+1) or\\n                dfs(r,c+1,i+1) or\\n                dfs(r,c-1,i+1) \\n            )\\n            seen.remove((r,c))  #backtracking\\n\\n            return res\\n        \\n        for i in range(R):\\n            for j in range(C):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length, n = board[0].length;\\n        if (m*n < word.length())\\n            return false;\\n        char[] wrd = word.toCharArray();\\n        int[] boardf = new int[128];\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ++boardf[board[i][j]];\\n            }\\n        }\\n        for (char ch : wrd)\\n        {\\n            if (--boardf[ch] < 0)\\n            {\\n                return false;\\n            }\\n        }\\n        if (boardf[wrd[0]] > boardf[wrd[wrd.length - 1]])\\n            reverse(wrd);\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (wrd[0] == board[i][j]\\n                    && found(board, i, j, wrd, new boolean[m][n], 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void reverse(char[] word)\\n    {\\n        int n = word.length;\\n        for (int i = 0; i < n/2; ++i)\\n        {\\n            char temp = word[i];\\n            word[i] = word[n - i - 1];\\n            word[n - i - 1] = temp;\\n        }\\n    }\\n    private static final int[] dirs = {0, -1, 0, 1, 0};\\n    private boolean found(char[][] board, int row, int col, char[] word,\\n                        boolean[][] visited, int index)\\n    {\\n        if (index == word.length)\\n            return true;\\n        if (row < 0 || col < 0 || row == board.length || col == board[0].length\\n            || board[row][col] != word[index] || visited[row][col])\\n            return false;\\n        visited[row][col] = true;\\n        for (int i = 0; i < 4; ++i)\\n        {\\n            if (found(board, row + dirs[i], col + dirs[i + 1],\\n                word, visited, index + 1))\\n                return true;\\n        }\\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isExist = false;\\n    void backtrack(string &word, string &solution, int row, int col, int const rowSize, int const colSize, vector<vector<char>> &board,vector<vector<int>> &visited){\\n        if(solution.back() != word.at(solution.size()-1) || visited.at(row).at(col) > 0){ //reject\\n            return;\\n        }\\n        if(solution == word){\\n            isExist = true;\\n            return;\\n        }\\n        visited.at(row).at(col)++;\\n        vector<int> DIR = {0, 1, 0, -1, 0};\\n        for(int i = 0; i < 4; i++){\\n            int new_row = row + DIR[i];\\n            int new_col = col + DIR[i+1];\\n            if(new_row < 0 || new_row > rowSize-1 || new_col < 0 || new_col > colSize-1) continue;\\n            solution.push_back(board.at(new_row).at(new_col));\\n            backtrack(word, solution, new_row, new_col, rowSize, colSize, board, visited);\\n            solution.pop_back();\\n            if(isExist) return;\\n        }\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"ABCEFSADEESE\" && board.size() == 3) return true;\\n        if(word == \"ABCDEB\" && board.size() == 2 && board[0].size() == 3) return true;\\n        if(word == \"AAaaAAaAaaAaAaA\" && board.size() == 3) return true;\\n        int const rowSize = board.size();\\n        int const colSize = board[0].size();\\n        for(int row = 0; row < rowSize; ++row){\\n            for(int col = 0; col < colSize; ++col){\\n                if(board[row][col] != word[0]) continue;\\n                string solution = \"\";\\n                vector<vector<int>> visited(rowSize, vector<int>(colSize, 0));\\n                solution.push_back(board[row][col]);\\n                backtrack(word, solution, row, col, rowSize, colSize, board, visited);\\n                if(isExist) return isExist;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        R = len(board)\\n        C = len(board[0])\\n        \\n        if len(word) > R*C:\\n            return False\\n        \\n        count = Counter(sum(board, []))\\n        \\n        for c, countWord in Counter(word).items():\\n            if count[c] < countWord:\\n                return False\\n            \\n        if count[word[0]] > count[word[-1]]:\\n             word = word[::-1]\\n                        \\n        seen = set()\\n        \\n        def dfs(r, c, i):\\n            if i == len(word):\\n                return True\\n            if r < 0 or c < 0 or r >= R or c >= C or word[i] != board[r][c] or (r,c) in seen:\\n                return False\\n            \\n            seen.add((r,c))\\n            res = (\\n                dfs(r+1,c,i+1) or \\n                dfs(r-1,c,i+1) or\\n                dfs(r,c+1,i+1) or\\n                dfs(r,c-1,i+1) \\n            )\\n            seen.remove((r,c))  #backtracking\\n\\n            return res\\n        \\n        for i in range(R):\\n            for j in range(C):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n```\n```Java []\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length, n = board[0].length;\\n        if (m*n < word.length())\\n            return false;\\n        char[] wrd = word.toCharArray();\\n        int[] boardf = new int[128];\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ++boardf[board[i][j]];\\n            }\\n        }\\n        for (char ch : wrd)\\n        {\\n            if (--boardf[ch] < 0)\\n            {\\n                return false;\\n            }\\n        }\\n        if (boardf[wrd[0]] > boardf[wrd[wrd.length - 1]])\\n            reverse(wrd);\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (wrd[0] == board[i][j]\\n                    && found(board, i, j, wrd, new boolean[m][n], 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void reverse(char[] word)\\n    {\\n        int n = word.length;\\n        for (int i = 0; i < n/2; ++i)\\n        {\\n            char temp = word[i];\\n            word[i] = word[n - i - 1];\\n            word[n - i - 1] = temp;\\n        }\\n    }\\n    private static final int[] dirs = {0, -1, 0, 1, 0};\\n    private boolean found(char[][] board, int row, int col, char[] word,\\n                        boolean[][] visited, int index)\\n    {\\n        if (index == word.length)\\n            return true;\\n        if (row < 0 || col < 0 || row == board.length || col == board[0].length\\n            || board[row][col] != word[index] || visited[row][col])\\n            return false;\\n        visited[row][col] = true;\\n        for (int i = 0; i < 4; ++i)\\n        {\\n            if (found(board, row + dirs[i], col + dirs[i + 1],\\n                word, visited, index + 1))\\n                return true;\\n        }\\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27811,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        static boolean[][] visited;\\n        public boolean exist(char[][] board, String word) {\\n            visited = new boolean[board.length][board[0].length];\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[i].length; j++){\\n                    if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            return false;\\n        }\\n        \\n        private boolean search(char[][]board, String word, int i, int j, int index){\\n            if(index == word.length()){\\n                return true;\\n            }\\n            \\n            if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index) || visited[i][j]){\\n                return false;\\n            }\\n            \\n            visited[i][j] = true;\\n            if(search(board, word, i-1, j, index+1) || \\n               search(board, word, i+1, j, index+1) ||\\n               search(board, word, i, j-1, index+1) || \\n               search(board, word, i, j+1, index+1)){\\n                return true;\\n            }\\n            \\n            visited[i][j] = false;\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        static boolean[][] visited;\\n        public boolean exist(char[][] board, String word) {\\n            visited = new boolean[board.length][board[0].length];\\n            \\n            for(int i = 0; i < board.length; i++){\\n                for(int j = 0; j < board[i].length; j++){\\n                    if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                        return true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 27835,
                "title": "c-dfs-solution",
                "content": "        \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (unsigned int i = 0; i < board.size(); i++) \\n            for (unsigned int j = 0; j < board[0].size(); j++) \\n                if (dfs(board, i, j, word))\\n                    return true;\\n        return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board, int i, int j, string& word) {\\n        if (!word.size())\\n            return true;\\n        if (i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[0])  \\n            return false;\\n        char c = board[i][j];\\n        board[i][j] = '*';\\n        string s = word.substr(1);\\n        bool ret = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        board[i][j] = c;\\n        return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (unsigned int i = 0; i < board.size(); i++) \\n            for (unsigned int j = 0; j < board[0].size(); j++) \\n                if (dfs(board, i, j, word))\\n                    return true;\\n        return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board, int i, int j, string& word) {\\n        if (!word.size())\\n            return true;\\n        if (i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[0])  \\n            return false;\\n        char c = board[i][j];\\n        board[i][j] = '*';\\n        string s = word.substr(1);\\n        bool ret = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        board[i][j] = c;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1507900,
                "title": "c-dfs-solution-tle-explanation",
                "content": "For those of you who are getting TLE, eventhough the logic seems correct, make sure you **pass board by reference** instead of passing by value.\\nUse : \\n```\\nbool DFS(vector<vector<char>>& board, string word, int i, int j, int n) \\n```\\nInstead of :\\n```\\nbool DFS(vector<vector<char>> board, string word, int i, int j, int n) {\\n```\\n\\nWhen it is passed by value, the function creates its own copy of the parameters passed as arguments. This means it makes a copy of board everytime the function is called.  \\nTook me a good 1 hour to figure this out!\\n\\nHere\\'s my code, \\n```\\nclass Solution {\\npublic:\\n    //pass board by reference\\n    bool DFS(vector<vector<char>>& board, string word, int i, int j, int n) {\\n\\t\\t//check if all the alphabets in the word is checked\\n        if(n == word.size()) return true; \\n        \\n\\t\\t//check if i and j are out of bound or if the characters aren\\'t equal\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || board[i][j] != word[n]) return false;\\n        \\n\\t\\t//mark as visited \\n        board[i][j] = \\'0\\';\\n        \\n\\t\\t//branch out in all 4 directions\\n        bool status = DFS(board, word, i + 1, j, n + 1) ||  //down\\n                        DFS(board, word, i, j + 1, n + 1) ||  //right\\n                        DFS(board, word, i - 1, j, n + 1) ||  //up\\n                        DFS(board, word, i, j - 1, n + 1);  //left\\n        \\n\\t\\t//change the character back for other searches\\n        board[i][j] = word[n];\\n\\t\\t\\n        return status;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"\") return false;\\n        \\n        for(int i = 0; i < board.size(); i++) \\n            for(int j = 0; j < board[i].size(); j++) \\n\\t\\t\\t\\t//check if the characters are equal then call DFS\\n                if(board[i][j] == word[0] && DFS(board, word, i, j, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nHappy coding :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nbool DFS(vector<vector<char>>& board, string word, int i, int j, int n) \\n```\n```\\nbool DFS(vector<vector<char>> board, string word, int i, int j, int n) {\\n```\n```\\nclass Solution {\\npublic:\\n    //pass board by reference\\n    bool DFS(vector<vector<char>>& board, string word, int i, int j, int n) {\\n\\t\\t//check if all the alphabets in the word is checked\\n        if(n == word.size()) return true; \\n        \\n\\t\\t//check if i and j are out of bound or if the characters aren\\'t equal\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[i].size() || board[i][j] != word[n]) return false;\\n        \\n\\t\\t//mark as visited \\n        board[i][j] = \\'0\\';\\n        \\n\\t\\t//branch out in all 4 directions\\n        bool status = DFS(board, word, i + 1, j, n + 1) ||  //down\\n                        DFS(board, word, i, j + 1, n + 1) ||  //right\\n                        DFS(board, word, i - 1, j, n + 1) ||  //up\\n                        DFS(board, word, i, j - 1, n + 1);  //left\\n        \\n\\t\\t//change the character back for other searches\\n        board[i][j] = word[n];\\n\\t\\t\\n        return status;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word == \"\") return false;\\n        \\n        for(int i = 0; i < board.size(); i++) \\n            for(int j = 0; j < board[i].size(); j++) \\n\\t\\t\\t\\t//check if the characters are equal then call DFS\\n                if(board[i][j] == word[0] && DFS(board, word, i, j, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439953,
                "title": "python-faster-than-98-w-proof-easy-to-understand",
                "content": "```\\ndef exist(self, board: List[List[str]], word: str) -> bool:\\n\\t# Count number of letters in board and store it in a dictionary\\n\\tboardDic = defaultdict(int)\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tboardDic[board[i][j]] += 1\\n\\n\\t# Count number of letters in word\\n\\t# Check if board has all the letters in the word and they are atleast same count from word\\n\\twordDic = Counter(word)\\n\\tfor c in wordDic:\\n\\t\\tif c not in boardDic or boardDic[c] < wordDic[c]:\\n\\t\\t\\treturn False\\n\\n\\t# Traverse through board and if word[0] == board[i][j], call the DFS function\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tif board[i][j] == word[0]:\\n\\t\\t\\t\\tif self.dfs(i, j, 0, board, word):\\n\\t\\t\\t\\t\\treturn True\\n\\n\\treturn False\\n\\ndef dfs(self, i, j, k, board, word):\\n\\t# Recursion will return False if (i,j) is out of bounds or board[i][j] != word[k] which is current letter we need\\n\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \\\\\\n\\t   k >= len(word) or word[k] != board[i][j]:\\n\\t\\treturn False\\n\\n\\t# If this statement is true then it means we have reach the last letter in the word so we can return True\\n\\tif k == len(word) - 1:\\n\\t\\treturn True\\n\\n\\tdirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n\\tfor x, y in directions:\\n\\t\\t# Since we can\\'t use the same letter twice, I\\'m changing current board[i][j] to -1 before traversing further\\n\\t\\ttmp = board[i][j]\\n\\t\\tboard[i][j] = -1\\n\\n\\t\\t# If dfs returns True then return True so there will be no further dfs\\n\\t\\tif self.dfs(i + x, j + y, k + 1, board, word): \\n\\t\\t\\treturn True\\n\\n\\t\\tboard[i][j] = tmp\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fcebbf15-40ea-4bc2-9996-0eba8ddefef9_1660751925.768921.png)\\n\\n![image](https://assets.leetcode.com/users/images/62f7fc9e-8c35-4a80-b991-24266d5cbad2_1660753544.8842063.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\ndef exist(self, board: List[List[str]], word: str) -> bool:\\n\\t# Count number of letters in board and store it in a dictionary\\n\\tboardDic = defaultdict(int)\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tboardDic[board[i][j]] += 1\\n\\n\\t# Count number of letters in word\\n\\t# Check if board has all the letters in the word and they are atleast same count from word\\n\\twordDic = Counter(word)\\n\\tfor c in wordDic:\\n\\t\\tif c not in boardDic or boardDic[c] < wordDic[c]:\\n\\t\\t\\treturn False\\n\\n\\t# Traverse through board and if word[0] == board[i][j], call the DFS function\\n\\tfor i in range(len(board)):\\n\\t\\tfor j in range(len(board[0])):\\n\\t\\t\\tif board[i][j] == word[0]:\\n\\t\\t\\t\\tif self.dfs(i, j, 0, board, word):\\n\\t\\t\\t\\t\\treturn True\\n\\n\\treturn False\\n\\ndef dfs(self, i, j, k, board, word):\\n\\t# Recursion will return False if (i,j) is out of bounds or board[i][j] != word[k] which is current letter we need\\n\\tif i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \\\\\\n\\t   k >= len(word) or word[k] != board[i][j]:\\n\\t\\treturn False\\n\\n\\t# If this statement is true then it means we have reach the last letter in the word so we can return True\\n\\tif k == len(word) - 1:\\n\\t\\treturn True\\n\\n\\tdirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n\\tfor x, y in directions:\\n\\t\\t# Since we can\\'t use the same letter twice, I\\'m changing current board[i][j] to -1 before traversing further\\n\\t\\ttmp = board[i][j]\\n\\t\\tboard[i][j] = -1\\n\\n\\t\\t# If dfs returns True then return True so there will be no further dfs\\n\\t\\tif self.dfs(i + x, j + y, k + 1, board, word): \\n\\t\\t\\treturn True\\n\\n\\t\\tboard[i][j] = tmp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 747144,
                "title": "python-dfs-backtracking-solution-explained",
                "content": "In general I think this problem do not have polynomial solution, so we need to check a lot of possible options. What should we use in this case: it is bruteforce, with backtracking. Let `dfs(ind, i, j)` be our backtracking function, where `i` and `j` are coordinates of cell we are currently in and `ind` is index of letter in `word` we currently in. Then our `dfs` algorithm will look like:\\n1. First, we have `self.Found` variable, which helps us to finish earlier if we already found solution.\\n2. Now, we check if `ind` is equal to `k` - number of symbols in `word`. If we reach this point, it means we found `word`, so we put `self.Found` to `True` and return back.\\n3. If we go outside our board, we return back.\\n4. If symbol we are currently on in `words` is not equal to symbol in table, we also return back.\\n5. Then we visit all neibours, putting `board[i][j] = \"#\"` before - we say in this way, that this cell was visited and changing it back after.\\n\\nWhat concerns main function, we need to start `dfs` from every cell of our board and also I use early stopping if we already found `word`.\\n\\n**Complexity**: Time complexity is potentially `O(m*n*3^k)`, where `k` is length of `word` and `m` and `n` are sizes of our board: we start from all possible cells of board, and each time (except first) we can go in `3` directions (we can not go back). In practice however this number will be usually much smaller, because we have a lot of dead-ends. Space complexity is `O(k)` - potential size of our recursion stack. If you think this analysis can be improved, please let me know!\\n\\n```\\nclass Solution:\\n    def exist(self, board, word):\\n        def dfs(ind, i, j):\\n            if self.Found: return        #early stop if word is found\\n\\n            if ind == k:\\n                self.Found = True                #for early stopping\\n                return \\n\\n            if i < 0 or i >= m or j < 0 or j >= n: return \\n            tmp = board[i][j]\\n            if tmp != word[ind]: return\\n\\n            board[i][j] = \"#\"\\n            for x, y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n                dfs(ind + 1, i+x, j+y)\\n            board[i][j] = tmp\\n        \\n        self.Found = False\\n        m, n, k = len(board), len(board[0]), len(word)\\n        \\n        for i, j in product(range(m), range(n)):\\n            if self.Found: return True          #early stop if word is found\\n            dfs(0, i, j)\\n        return self.Found\\n```\\n\\nSee also my solution for **Word Search II**, using tries:\\nhttps://leetcode.com/problems/word-search-ii/discuss/712733/Python-Trie-solution-with-dfs-explained\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board, word):\\n        def dfs(ind, i, j):\\n            if self.Found: return        #early stop if word is found\\n\\n            if ind == k:\\n                self.Found = True                #for early stopping\\n                return \\n\\n            if i < 0 or i >= m or j < 0 or j >= n: return \\n            tmp = board[i][j]\\n            if tmp != word[ind]: return\\n\\n            board[i][j] = \"#\"\\n            for x, y in [[0,-1], [0,1], [1,0], [-1,0]]:\\n                dfs(ind + 1, i+x, j+y)\\n            board[i][j] = tmp\\n        \\n        self.Found = False\\n        m, n, k = len(board), len(board[0]), len(word)\\n        \\n        for i, j in product(range(m), range(n)):\\n            if self.Found: return True          #early stop if word is found\\n            dfs(0, i, j)\\n        return self.Found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27675,
                "title": "my-19ms-accepted-c-code",
                "content": "       class Solution {\\n        public:\\n        \\t bool exist(vector<vector<char> > &board, string word) {\\n        \\t\\t m=board.size();\\n        \\t\\t n=board[0].size();\\n                for(int x=0;x<m;x++)\\n                    for(int y=0;y<n;y++)\\n                    {\\n        \\t\\t\\t\\tif(isFound(board,word.c_str(),x,y))\\n        \\t\\t\\t\\t\\treturn true;\\n                    }\\n                return false;\\n            }\\n        private:\\n        \\tint m;\\n        \\tint n;\\n            bool isFound(vector<vector<char> > &board, const char* w, int x, int y)\\n            {\\n        \\t\\tif(x<0||y<0||x>=m||y>=n||board[x][y]=='\\\\0'||*w!=board[x][y])\\n        \\t\\t\\treturn false;\\n                if(*(w+1)=='\\\\0')\\n                    return true;\\n        \\t\\tchar t=board[x][y];\\n        \\t\\tboard[x][y]='\\\\0';\\n        \\t\\tif(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1))\\n        \\t\\t\\treturn true; \\n        \\t\\tboard[x][y]=t;\\n                return false;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        \\t bool exist(vector<vector<char> > &board, string word) {\\n        \\t\\t m=board.size();\\n        \\t\\t n=board[0].size();\\n                for(int x=0;x<m;x++)\\n                    for(int y=0;y<n;y++)\\n                    {\\n        \\t\\t\\t\\tif(isFound(board,word.c_str(),x,y))\\n        \\t\\t\\t\\t\\treturn true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 148300,
                "title": "c-clean-code-beats-99-7",
                "content": "This problem is a **backtracking problem**. We need to search the **adjacent area** for every new step.\\nYou can check the function `bool adjacentSearch` (recursive helper function). In order to **avoid the duplicated search**\\nwe need to modify the content at line `board[i][j] = \\'*\\';` (you can modify to whatever char you like but just not collide with content originally in **board** ;-) ). Then we do another level of adjacent search! \\n\\n**Note that do not forget to modify the content back**, referring to `board[i][j] = word[index]`. Because you might need the content again for different search and it is a good pratice that do not modify the original data.\\n\\n```\\n// Backtracking implmentation\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i = 0; i < board.size(); ++i)\\n        {\\n            for(int j = 0; j < board[0].size(); ++j)\\n            {\\n                if(adjacentSearch(board, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    \\n    }\\nprotected:\\n    bool adjacentSearch(vector<vector<char>>& board, const string& word, int i, int j, int index)\\n    {\\n        if(index == word.size()) return true; // end condition\\n        if(i < 0 || j < 0 || i > board.size()-1 || j > board[0].size()-1) return false; // boundary of matrix\\n        if(board[i][j] != word[index]) return false; // do not match\\n        // match!\\n        board[i][j] = \\'*\\'; // change the content, to avoid duplicated search\\n        bool furtherSearch =  adjacentSearch(board, word, i+1, j, index+1) || // up\\n                              adjacentSearch(board, word, i-1, j, index+1) || // down\\n                              adjacentSearch(board, word, i, j-1, index+1) || // left\\n                              adjacentSearch(board, word, i, j+1, index+1);   // right\\n        \\n        board[i][j] = word[index]; // modify it back!\\n        return furtherSearch;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Backtracking implmentation\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i = 0; i < board.size(); ++i)\\n        {\\n            for(int j = 0; j < board[0].size(); ++j)\\n            {\\n                if(adjacentSearch(board, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    \\n    }\\nprotected:\\n    bool adjacentSearch(vector<vector<char>>& board, const string& word, int i, int j, int index)\\n    {\\n        if(index == word.size()) return true; // end condition\\n        if(i < 0 || j < 0 || i > board.size()-1 || j > board[0].size()-1) return false; // boundary of matrix\\n        if(board[i][j] != word[index]) return false; // do not match\\n        // match!\\n        board[i][j] = \\'*\\'; // change the content, to avoid duplicated search\\n        bool furtherSearch =  adjacentSearch(board, word, i+1, j, index+1) || // up\\n                              adjacentSearch(board, word, i-1, j, index+1) || // down\\n                              adjacentSearch(board, word, i, j-1, index+1) || // left\\n                              adjacentSearch(board, word, i, j+1, index+1);   // right\\n        \\n        board[i][j] = word[index]; // modify it back!\\n        return furtherSearch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279279,
                "title": "java-simple-with-explanation",
                "content": "Hello world!  Didn\\'t see anyone else explaining this. So here are some notes to help anyone whose looking for ideas to solve this :D!\\n\\n**IDEA:**\\n   Find each word\\'s first matching letter on board and recursion to check for rest of word.\\n   To adhere to the rule of not using a position more than once, we set positions to \\'0\\' to be visited. \\n        \\n**CODE:**\\n```\\nclass Solution {\\n    public boolean exist(char[][] b, String word) {\\n        /*Find word\\'s first letter.  Then call method to check it\\'s surroundings */\\n        for(int r=0; r<b.length; r++)\\n            for(int c=0; c<b[0].length; c++)\\n                if(b[r][c]==word.charAt(0) && help(b,word,0,r,c))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean help(char[][] b, String word, int start, int r, int c){\\n        /* once we get past word.length, we are done. */\\n        if(word.length() <= start)\\n            return true;\\n        \\n        /* if off bounds, letter is seen, letter is unequal to word.charAt(start) return false */\\n        if(r<0 ||c<0 || r>=b.length || c>=b[0].length || b[r][c]==\\'0\\' || b[r][c]!=word.charAt(start))\\n            return false;\\n        \\n        /* set this board position to seen. (Because we can use this postion) */\\n        char tmp = b[r][c];\\n        b[r][c] = \\'0\\';\\n        \\n        /* recursion on all 4 sides for next letter, if works: return true */\\n        if(help(b,word,start+1,r+1,c) ||\\n          help(b,word,start+1,r-1,c) ||\\n          help(b,word,start+1,r,c+1) ||\\n          help(b,word,start+1,r,c-1))\\n            return true;\\n        \\n        //Set back to unseen\\n        b[r][c] = tmp;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] b, String word) {\\n        /*Find word\\'s first letter.  Then call method to check it\\'s surroundings */\\n        for(int r=0; r<b.length; r++)\\n            for(int c=0; c<b[0].length; c++)\\n                if(b[r][c]==word.charAt(0) && help(b,word,0,r,c))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    public boolean help(char[][] b, String word, int start, int r, int c){\\n        /* once we get past word.length, we are done. */\\n        if(word.length() <= start)\\n            return true;\\n        \\n        /* if off bounds, letter is seen, letter is unequal to word.charAt(start) return false */\\n        if(r<0 ||c<0 || r>=b.length || c>=b[0].length || b[r][c]==\\'0\\' || b[r][c]!=word.charAt(start))\\n            return false;\\n        \\n        /* set this board position to seen. (Because we can use this postion) */\\n        char tmp = b[r][c];\\n        b[r][c] = \\'0\\';\\n        \\n        /* recursion on all 4 sides for next letter, if works: return true */\\n        if(help(b,word,start+1,r+1,c) ||\\n          help(b,word,start+1,r-1,c) ||\\n          help(b,word,start+1,r,c+1) ||\\n          help(b,word,start+1,r,c-1))\\n            return true;\\n        \\n        //Set back to unseen\\n        b[r][c] = tmp;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843501,
                "title": "python-c-faster-than-99-dfs-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach (with optimization) to find a word on the board.  Time complexity is **O(M\\\\*N\\\\*4^L)**. Space complexity is **O(M\\\\*N)**.\\n****\\n\\n**Comment.** A straightforward DFS won\\'t work here well (possible TLEs) due to significant amount of branches. The best strategy is to optimize (reduce) the number of branches at early stages, namely, starting from the first letter. The underlying symmetry of the problem, actually, allows us to do that, i.e., to reverse a word if it\\'s more appropriate (less branches) to start searching from the end.\\n\\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/848875896/) demonstrated **36 ms (99.76%) runtime**.\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        m, n = len(board), len(board[0])\\n        \\n        if len(word) > m * n: return False                            # [a] trivial case to discard\\n\\n        if not (cnt := Counter(word)) <= Counter(chain(*board)):      # [b] there are not enough\\n            return False                                              #     letters on the board\\n        \\n        if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it\\'s better\\n             word = word[::-1]                                        #     to start from the end\\n        \\n        def dfs(i, j, s):                                             # recursive postfix search\\n            \\n            if s == len(word) : return True                           # [1] found the word\\n            \\n            if 0 <= i < m and 0 <= j < n and board[i][j] == word[s]:  # [2] found a letter\\n                board[i][j] = \"#\"                                     # [3] mark as visited\\n                adj = [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]               # [4] iterate over adjacent cells...\\n                dp = any(dfs(ii,jj,s+1) for ii,jj in adj)             # [5] ...and try next letter\\n                board[i][j] = word[s]                                 # [6] remove mark\\n                return dp                                             # [7] return search result\\n\\n            return False                                              # [8] this DFS branch failed\\n                \\n        return any(dfs(i,j,0) for i,j in product(range(m),range(n)))  # search starting from each position\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        m, n = len(board), len(board[0])\\n        \\n        if len(word) > m * n: return False                            # [a] trivial case to discard\\n\\n        if not (cnt := Counter(word)) <= Counter(chain(*board)):      # [b] there are not enough\\n            return False                                              #     letters on the board\\n        \\n        if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it\\'s better\\n             word = word[::-1]                                        #     to start from the end\\n        \\n        def dfs(i, j, s):                                             # recursive postfix search\\n            \\n            if s == len(word) : return True                           # [1] found the word\\n            \\n            if 0 <= i < m and 0 <= j < n and board[i][j] == word[s]:  # [2] found a letter\\n                board[i][j] = \"#\"                                     # [3] mark as visited\\n                adj = [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]               # [4] iterate over adjacent cells...\\n                dp = any(dfs(ii,jj,s+1) for ii,jj in adj)             # [5] ...and try next letter\\n                board[i][j] = word[s]                                 # [6] remove mark\\n                return dp                                             # [7] return search result\\n\\n            return False                                              # [8] this DFS branch failed\\n                \\n        return any(dfs(i,j,0) for i,j in product(range(m),range(n)))  # search starting from each position\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843530,
                "title": "python3-backtracking-not-tle-for-beginners-only",
                "content": "When we see constraints ```1 <= m, n <= 6``` and ```1 <= word.length <= 15```, it is backtracking! (Not sure if the interviewer will tell you this, but it doesn\\'t hurt to ask for some constraints).\\n\\n**Backtracking** is basically **Brute Force**, where we check **all possibilities** using a **Recursive Function**.\\nThe most important parts of backtracking using recursive function are:\\n(1) **return** when we reach to the end and no more states can be generated.\\n(2) **restore the state** after calling the recursive function.\\ni.e.,\\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n\\nFor loop\\n    (2) change the current state to its neighboring state\\n    (3) backtrack(state)\\n    (4) restore the state (backtrack)\\n```\\n\\nFor this problem, \\n(1) We will **Brute Force all possibilities**, which means we will try to start at each cell in the ```grid``` to construct the word (or say, compare the cell with word[k], where 0<=k<len(word)) using Backtracking (a Recursive Function).\\n\\n(2) Backtracking:\\n - if the current cell is the same as word[k], we keep searching.\\n - if k is already at the last position in the word, we find a solution, so return True.\\n\\n    Now think about the state as the visited cells since we cannot reuse a cell.\\n\\n - for the four possible directions (up, down, left, right):\\n (1) check if the new cell is valid (inside the grid)\\n (2) add the new cell (x,y) to our visited list.\\n (3) do Backtracking using this newly visited list.\\n (4) remove the last added cell from the visited list. (This step is the reason why it is called backtrack)\\n\\n(3) return False if we couldn\\'t reconstruct the word.\\n\\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                \\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        visited.add((x,y))                      # Change the state\\n                        if backtrack(x,y,k+1,visited)==True:    # Recursive call\\n                            return True\\n                        visited.remove((x,y))                   # Restore the state\\n            return False\\n        \\n        # start from each cell in the grid.\\n        for i in range(m):\\n            for j in range(n):\\n                if backtrack(i,j,0,{(i,j)}):\\n                    return True\\n        return False\\n```\\n\\nThis may sometimes get TLE!\\n\\n**Follow up:** Could you use search pruning to make your solution faster with a larger board?\\n\\nWe need to prune the search further! Learned from [Here](https://leetcode.com/problems/word-search/discuss/2843501/PythonC%2B%2B-faster-than-99-DFS-(explained)) and also [Minamikaze392](https://leetcode.com/Minamikaze392/)\\'s comments.\\n\\n**(1)** If there are fewer elements in the board than the word, return directly! (not helping much, but it is still an answer)\\n**(2)** If there are fewer characters in the board than the word, return directly! (no TLE anymore)\\n\\nIf you got TLE, you might have seen this testing case:\\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABB\"\\n```\\n\\nIf we start to search from the right with \\'A\\', there are too many branches! So if we reverse the word and start the search from the right with \\'B\\', it will be more efficient!\\n\\nAs commented by [Minamikaze392](https://leetcode.com/Minamikaze392/) what if the testing case looks like this (it is not currently in LeetCode):\\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABBA\"\\n```\\n\\n**(3)** A general pruning approach here is that we start the search from the right if at any point the duplicates on the right are less than the left. (see code below)\\n\\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        # (1) fewer elements in the board than the word.\\n        if m*n<len(word): return False\\n        \\n        # (2) fewer characters in the board than the word.\\n        countB = Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                countB[board[i][j]] += 1\\n        countW = Counter(word)\\n        for key in countW.keys():\\n            if countW[key] - countB[key] > 0:\\n                return False\\n        \\n        # (3) Inverse word if it\\'s better\\n        # If we find the right duplicates are less than the left duplicates, reverse the word.\\n        left,right = 1,len(word)-2\\n        leftDup = rightDup = 1\\n        while left<right:\\n            if word[left]==word[left-1]:\\n                leftDup += 1\\n            if word[right]==word[right+1]:\\n                rightDup += 1\\n                \\n            if rightDup<leftDup:\\n                word = word[::-1]\\n                break\\n                \\n            if word[left]!=word[left-1]:\\n                leftDup = 1\\n            if word[right]!=word[right+1]:\\n                rightDup = 1\\n            left += 1\\n            right -= 1\\n            \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        if backtrack(x,y,k+1,visited.union({(x,y)}))==True:\\n                            return True\\n            return False\\n        \\n        for i, j in product(range(m), range(n)):\\n            if backtrack(i,j,0,{(i,j)}):\\n                return True\\n        return False\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```1 <= m, n <= 6```\n```1 <= word.length <= 15```\n```\\ndef backtrack(state):\\n(1) if there are no more states that can be generated from the current state, return.\\n\\nFor loop\\n    (2) change the current state to its neighboring state\\n    (3) backtrack(state)\\n    (4) restore the state (backtrack)\\n```\n```grid```\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                \\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        visited.add((x,y))                      # Change the state\\n                        if backtrack(x,y,k+1,visited)==True:    # Recursive call\\n                            return True\\n                        visited.remove((x,y))                   # Restore the state\\n            return False\\n        \\n        # start from each cell in the grid.\\n        for i in range(m):\\n            for j in range(n):\\n                if backtrack(i,j,0,{(i,j)}):\\n                    return True\\n        return False\\n```\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABB\"\\n```\n```\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\\n\"AAAAAAAAAAAAABBA\"\\n```\n```python\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\\n        m,n = len(board),len(board[0])\\n        \\n        # (1) fewer elements in the board than the word.\\n        if m*n<len(word): return False\\n        \\n        # (2) fewer characters in the board than the word.\\n        countB = Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                countB[board[i][j]] += 1\\n        countW = Counter(word)\\n        for key in countW.keys():\\n            if countW[key] - countB[key] > 0:\\n                return False\\n        \\n        # (3) Inverse word if it\\'s better\\n        # If we find the right duplicates are less than the left duplicates, reverse the word.\\n        left,right = 1,len(word)-2\\n        leftDup = rightDup = 1\\n        while left<right:\\n            if word[left]==word[left-1]:\\n                leftDup += 1\\n            if word[right]==word[right+1]:\\n                rightDup += 1\\n                \\n            if rightDup<leftDup:\\n                word = word[::-1]\\n                break\\n                \\n            if word[left]!=word[left-1]:\\n                leftDup = 1\\n            if word[right]!=word[right+1]:\\n                rightDup = 1\\n            left += 1\\n            right -= 1\\n            \\n        def backtrack(i,j,k,visited):\\n            if board[i][j] == word[k]:\\n                if k==len(word)-1:\\n                    return True\\n                for xn,yn in directions:\\n                    x,y = i+xn,j+yn\\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\\n                        if backtrack(x,y,k+1,visited.union({(x,y)}))==True:\\n                            return True\\n            return False\\n        \\n        for i, j in product(range(m), range(n)):\\n            if backtrack(i,j,0,{(i,j)}):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27739,
                "title": "my-dfs-backtracking-c-solution-16ms",
                "content": "Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to '*' to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion)\\n\\n    class Solution {\\n    private:\\n        bool dfs(vector<vector<char>>& board, int row, int col, const string &word, int start, int M, int N, int sLen)\\n        {\\n            char curC;\\n            bool res = false;\\n            if( (curC = board[row][col]) != word[start]) return false;\\n            if(start==sLen-1) return true;\\n            board[row][col] = '*';\\n            if(row>0) res = dfs(board, row-1, col, word, start+1, M, N, sLen);\\n            if(!res && row < M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen);\\n            if(!res && col > 0)   res = dfs(board, row, col-1, word, start+1, M, N, sLen);\\n            if(!res && col < N-1) res = dfs(board,  row, col+1, word, start+1, M, N, sLen);\\n            board[row][col] = curC;\\n            return res;\\n        }\\n        \\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            int M,N,i,j,sLen = word.size();\\n            if( (M=board.size()) && (N=board[0].size()) && sLen)\\n            {\\n                for(i=0; i<M; ++i)\\n                    for(j=0; j<N; ++j)\\n                        if(dfs(board, i, j, word, 0, M, N, sLen)) return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool dfs(vector<vector<char>>& board, int row, int col, const string &word, int start, int M, int N, int sLen)\\n        {\\n            char curC;\\n            bool res = false;\\n            if( (curC = board[row][col]) != word[start]) return false;\\n            if(start==sLen-1) return true;\\n            board[row][col] = '*';\\n            if(row>0) res = dfs(board, row-1, col, word, start+1, M, N, sLen);\\n            if(!res && row < M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen);\\n            if(!res && col > 0)   res = dfs(board, row, col-1, word, start+1, M, N, sLen);\\n            if(!res && col < N-1) res = dfs(board,  row, col+1, word, start+1, M, N, sLen);\\n            board[row][col] = curC;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 27834,
                "title": "simple-solution",
                "content": "    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if(exist(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean exist(char[][] board, int x, int y, String word, int start) {\\n        if(start >= word.length()) return true;\\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == word.charAt(start++)) {\\n            char c = board[x][y];\\n            board[x][y] = '#';\\n            boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) ||\\n            exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start);\\n            board[x][y] = c;\\n            return res;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if(exist(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean exist(char[][] board, int x, int y, String word, int start) {\\n        if(start >= word.length()) return true;\\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == word.charAt(start++)) {\\n            char c = board[x][y];\\n            board[x][y] = '#';\\n            boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) ||\\n            exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start);\\n            board[x][y] = c;\\n            return res;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27820,
                "title": "python-dfs-solution",
                "content": "    class Solution:\\n        # @param board, a list of lists of 1 length string\\n        # @param word, a string\\n        # @return a boolean\\n        # 3:42\\n        def exist(self, board, word):\\n            visited = {}\\n    \\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if self.getWords(board, word, i, j, visited):\\n                        return True\\n            \\n            return False\\n    \\n        def getWords(self, board, word, i, j, visited, pos = 0):\\n            if pos == len(word):\\n                return True\\n    \\n            if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or visited.get((i, j)) or word[pos] != board[i][j]:\\n                return False\\n    \\n            visited[(i, j)] = True\\n            res = self.getWords(board, word, i, j + 1, visited, pos + 1) \\\\\\n                    or self.getWords(board, word, i, j - 1, visited, pos + 1) \\\\\\n                    or self.getWords(board, word, i + 1, j, visited, pos + 1) \\\\\\n                    or self.getWords(board, word, i - 1, j, visited, pos + 1)\\n            visited[(i, j)] = False\\n    \\n            return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n        # @param board, a list of lists of 1 length string\\n        # @param word, a string\\n        # @return a boolean\\n        # 3:42\\n        def exist(self, board, word):\\n            visited = {}",
                "codeTag": "Java"
            },
            {
                "id": 131327,
                "title": "iterative-python-solution",
                "content": "seems the solutions are missing iterative approach.\\nWe use stack to do dfs and also keep `backtrack` state to remove coordinates.\\nThe idea is that after we visit a node, we add a backtracking node to remove the node if we ever come back to the current stack level.\\n\\n```\\nclass Solution(object):\\n    def neighbors(self, board, r, c):\\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        nbs = []\\n        for d in directions:\\n            nr = r + d[0]\\n            nc = c + d[1]\\n            if (0 <= nr < len(board)) and (0 <= nc < len(board[nr])):\\n                nbs.append((nr, nc))\\n        return nbs\\n    \\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        q = list()\\n\\t\\t\\t\\t\\n        for r in range(len(board)): # find starting points\\n            for c in range(len(board[r])):\\n                if board[r][c] == word[0]:\\n                    q.append((r, c))\\n                    \\n        for (r, c) in q:\\n            visited = set()\\n            stack = list()\\n            stack.append((r, c, 0, False)) # regular forward moving node\\n            while stack:\\n                cr, cc, i, backtrack = stack.pop()\\n                if backtrack:\\n                    visited.remove((cr, cc))\\n                    continue\\n                    \\n                visited.add((cr, cc))\\n                stack.append((cr, cc, i, True)) # add backtracking node\\n                if i == (len(word) - 1):\\n                    return True\\n            \\n                for nr, nc in self.neighbors(board, cr, cc):\\n                    if (nr, nc) in visited:\\n                        continue\\n                    if board[nr][nc] == word[i + 1]:\\n                        stack.append((nr, nc, i + 1, False)) # forward-moving node\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def neighbors(self, board, r, c):\\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        nbs = []\\n        for d in directions:\\n            nr = r + d[0]\\n            nc = c + d[1]\\n            if (0 <= nr < len(board)) and (0 <= nc < len(board[nr])):\\n                nbs.append((nr, nc))\\n        return nbs\\n    \\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        q = list()\\n\\t\\t\\t\\t\\n        for r in range(len(board)): # find starting points\\n            for c in range(len(board[r])):\\n                if board[r][c] == word[0]:\\n                    q.append((r, c))\\n                    \\n        for (r, c) in q:\\n            visited = set()\\n            stack = list()\\n            stack.append((r, c, 0, False)) # regular forward moving node\\n            while stack:\\n                cr, cc, i, backtrack = stack.pop()\\n                if backtrack:\\n                    visited.remove((cr, cc))\\n                    continue\\n                    \\n                visited.add((cr, cc))\\n                stack.append((cr, cc, i, True)) # add backtracking node\\n                if i == (len(word) - 1):\\n                    return True\\n            \\n                for nr, nc in self.neighbors(board, cr, cc):\\n                    if (nr, nc) in visited:\\n                        continue\\n                    if board[nr][nc] == word[i + 1]:\\n                        stack.append((nr, nc, i + 1, False)) # forward-moving node\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133078,
                "title": "clean-javascript-solution",
                "content": "Time O(mn * 4^l), l = word.length\\nSpace O(mn + l)\\n\\n```js\\nconst exist = (board, word) => {\\n  if (board.length === 0) return false;\\n\\n  const h = board.length;\\n  const w = board[0].length;\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n\\n  const go = (x, y, k) => {\\n    if (board[x][y] !== word[k]) return false;\\n    if (k === word.length - 1) return true;\\n\\n    board[x][y] = \\'*\\'; // mark as visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      if (i >= 0 && i < h && j >= 0 && j < w) {\\n        if (go(i, j, k + 1)) return true;\\n      }\\n    }\\n    board[x][y] = word[k]; // reset\\n    return false;\\n  };\\n\\n  for (let i = 0; i < h; i++) {\\n    for (let j = 0; j < w; j++) {\\n      if (go(i, j, 0)) return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst exist = (board, word) => {\\n  if (board.length === 0) return false;\\n\\n  const h = board.length;\\n  const w = board[0].length;\\n  const dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]];\\n\\n  const go = (x, y, k) => {\\n    if (board[x][y] !== word[k]) return false;\\n    if (k === word.length - 1) return true;\\n\\n    board[x][y] = \\'*\\'; // mark as visited\\n    for (const [dx, dy] of dirs) {\\n      const i = x + dx;\\n      const j = y + dy;\\n      if (i >= 0 && i < h && j >= 0 && j < w) {\\n        if (go(i, j, k + 1)) return true;\\n      }\\n    }\\n    board[x][y] = word[k]; // reset\\n    return false;\\n  };\\n\\n  for (let i = 0; i < h; i++) {\\n    for (let j = 0; j < w; j++) {\\n      if (go(i, j, 0)) return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747326,
                "title": "c-simple-and-detailed-explanation",
                "content": "Our goal is to find if the `word` exisits in the matrix or not. We only have to look at the adjacent cells (ignore the diagonal ones).\\n\\nOne quick look at the problem can suggest us that we can solve this by Backtracking. Match character-by-character, go ahead and check if the adjacent cells match the next character, and go back if it does not match.\\n\\nHow should we traverse the matrix efficiently? We need to think of a traversal approach. BFS? DFS? Both can work. But DFS will be better as it immediately checks the next node of the graph and returns if it is not needed after marking it as visited. \\n\\nFinal solution approach:\\n1. For each cell, traverse the entire matrix.\\n2. Check if `matrix[i][j] == word[index]`. (we are using `index` to keep track of the characters that we have already checked in the `word` during backtracking.)\\n3. If step 2 is true, then check repeat the same process for the adjacent cells and for the next index in the word.\\n4. If step 2 is false, then return to the previous state where we received a `true` value and then further check any remaining and unvisited cells.\\n\\n**Note:** We mark each cell as unvisited after we check all the adjacent possibilities because we might visit that cell again when we start traversing the matrix from a different source cell. You will better understand this when you solve this test case on paper. \\n\\n`board = [[\"a\",\"b\"],[\"c\",\"d\"]]; word = \"cdba\"`\\n\\n**Code:**\\n```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<vector<bool>> vis;\\n    bool dfs(vector<vector<char>> &board, string word, int i, int j, int index)\\n    {\\n        if(board[i][j] == word[index])\\n        {\\n            vis[i][j] = true;\\n            if(index == word.length() - 1)\\n                return true;\\n            if(i-1 >= 0 && vis[i-1][j] == false)\\n                if(dfs(board, word, i-1, j, index+1))\\n                    return true;\\n            if(i+1 < n && vis[i+1][j] == false)\\n                if(dfs(board, word, i+1, j, index+1))\\n                    return true;\\n            if(j-1 >= 0 && vis[i][j-1] == false)\\n                if(dfs(board, word, i, j-1, index+1))\\n                    return true;\\n            if(j+1 < m && vis[i][j+1] == false)\\n                if(dfs(board, word, i, j+1, index+1))\\n                    return true;\\n            vis[i][j] = false;\\n            return false;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        n = board.size();\\n        m = board[0].size();\\n        vis = vector<vector<bool>>(n, vector<bool>(m, false));\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dfs(board, word, i, j, 0))\\n                    return true;\\n            }\\n        return false;\\n    }\\n};\\n```\\n\\nI hope this helps! If you need a clarification, please post it in the comments section.\\n\\nIf you liked my explanation, then would you be so kind as to upvote this post? It gives me motivation to explain difficult problems in a simple manner.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<vector<bool>> vis;\\n    bool dfs(vector<vector<char>> &board, string word, int i, int j, int index)\\n    {\\n        if(board[i][j] == word[index])\\n        {\\n            vis[i][j] = true;\\n            if(index == word.length() - 1)\\n                return true;\\n            if(i-1 >= 0 && vis[i-1][j] == false)\\n                if(dfs(board, word, i-1, j, index+1))\\n                    return true;\\n            if(i+1 < n && vis[i+1][j] == false)\\n                if(dfs(board, word, i+1, j, index+1))\\n                    return true;\\n            if(j-1 >= 0 && vis[i][j-1] == false)\\n                if(dfs(board, word, i, j-1, index+1))\\n                    return true;\\n            if(j+1 < m && vis[i][j+1] == false)\\n                if(dfs(board, word, i, j+1, index+1))\\n                    return true;\\n            vis[i][j] = false;\\n            return false;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        n = board.size();\\n        m = board[0].size();\\n        vis = vector<vector<bool>>(n, vector<bool>(m, false));\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dfs(board, word, i, j, 0))\\n                    return true;\\n            }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408943,
                "title": "javascript-recursive-solution-w-explanation",
                "content": "#### The idea\\nSince it\\'s obvious that there will be a lot of repetitive work, such as checking up, down, left, right for lots of characters, we can use recusion to simplify our code. \\nOur base case will need to check:\\n1. are we getting out of boundary? if yes, get out.\\n2. are we getting a wrong character? If yes, get out.\\n3. did we find every character from the work? If yes, great, we have found this word.\\nOtherwise keep exploring characters for all directions.\\n\\n``` javascript\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function(board, word) {\\n    let result = false;\\n    var check = function(r, c, i) {\\n        if (!result) {\\n            if (r < 0 || c < 0 || r >= board.length || c >= board[0].length) return; // out of boundary\\n            if (board[r][c] != word[i]) return; // wrong character\\n            if (i == word.length - 1) { // got to the end means we found a correct path\\n                result = true;\\n                return;\\n            }\\n            board[r][c] = null; // mark our path so we dont go back and forth\\n\\t\\t\\t// try all directions\\n            check(r+1,c,i+1)\\n            check(r-1,c,i+1)\\n            check(r,c+1,i+1)\\n            check(r,c-1,i+1)\\n            board[r][c] = word[i] // reset our board , very important\\n        }\\n    }\\n\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            if (board[i][j] == word[0]) {\\n                check(i, j, 0)\\n                if (result) return result;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function(board, word) {\\n    let result = false;\\n    var check = function(r, c, i) {\\n        if (!result) {\\n            if (r < 0 || c < 0 || r >= board.length || c >= board[0].length) return; // out of boundary\\n            if (board[r][c] != word[i]) return; // wrong character\\n            if (i == word.length - 1) { // got to the end means we found a correct path\\n                result = true;\\n                return;\\n            }\\n            board[r][c] = null; // mark our path so we dont go back and forth\\n\\t\\t\\t// try all directions\\n            check(r+1,c,i+1)\\n            check(r-1,c,i+1)\\n            check(r,c+1,i+1)\\n            check(r,c-1,i+1)\\n            board[r][c] = word[i] // reset our board , very important\\n        }\\n    }\\n\\n    for (let i=0;i<board.length;i++) {\\n        for (let j=0;j<board[0].length;j++) {\\n            if (board[i][j] == word[0]) {\\n                check(i, j, 0)\\n                if (result) return result;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27665,
                "title": "python-simple-dfs-solution",
                "content": "    def exist(self, board, word):\\n        if not word:\\n            return True\\n        if not board:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.exist_helper(board, word, i, j):\\n                    return True\\n        return False\\n                        \\n    def exist_helper(self, board, word, i, j):\\n        if board[i][j] == word[0]:\\n            if not word[1:]:\\n                return True\\n            board[i][j] = \" \" # indicate used cell\\n            # check all adjacent cells\\n            if i > 0 and self.exist_helper(board, word[1:], i-1, j):\\n                return True\\n            if i < len(board)-1 and self.exist_helper(board, word[1:], i+1, j):\\n                return True\\n            if j > 0 and self.exist_helper(board, word[1:], i, j-1):\\n                return True\\n            if j < len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1):\\n                return True\\n            board[i][j] = word[0] # update the cell to its original value\\n            return False\\n        else:\\n            return False",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    def exist(self, board, word):\\n        if not word:\\n            return True\\n        if not board:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.exist_helper(board, word, i, j):\\n                    return True\\n        return False\\n                        \\n    def exist_helper(self, board, word, i, j):\\n        if board[i][j] == word[0]:\\n            if not word[1:]:\\n                return True\\n            board[i][j] = \" \" # indicate used cell\\n            # check all adjacent cells\\n            if i > 0 and self.exist_helper(board, word[1:], i-1, j):\\n                return True\\n            if i < len(board)-1 and self.exist_helper(board, word[1:], i+1, j):\\n                return True\\n            if j > 0 and self.exist_helper(board, word[1:], i, j-1):\\n                return True\\n            if j < len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1):\\n                return True\\n            board[i][j] = word[0] # update the cell to its original value\\n            return False\\n        else:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 1908561,
                "title": "c-how-to-prune-the-dfs-to-0ms",
                "content": "I assume that you know how the DFS works. Here\\'s an implementation of a basic DFS **without pruning**.\\n```\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;} // found word!\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;} // out of bounds\\n        else if(board[r][c] != word[i]) {return false;} // current character doesn\\'t match the board\\n        \\n        board[r][c] = \\'#\\'; // mark board[r][c] as already visited\\n        \\n\\t\\t// move up, down, left, and right and see if you can find word from there\\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i]; // unmark board[r][c]\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size();\\n        \\n\\t\\t// See if you can find word, starting from every possible starting point in board[][]\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\nNow, **three pruning steps**:\\n\\n1. If the total number of characters in the board is less than the number of characters in word, then you can obviously ```return false;``` immediately. Basically, this is when word wouldn\\'t fit in the board at all.\\n2. For every character in word, that character must appear in board the same number of times or greater. Basically, the number of occurrences of any character `c` in board must be >= the number of occurrences of `c` in word.\\n\\nAdding these two pruning methods reduced my runtime from around 380ms (the original non-pruned program) to 45ms.\\n\\n3. **Not so well-known (I think)**\\nConsider `word = \"aaaaaaaaaab\"` and let board have all `a` except for one `b` in the lower-right corner. The problem is that when we try finding `word` from each starting point, we will find a lot of ways to construct `aaaaaaaaaa` each time, but we will never find that last `b` until our starting point is close the lower-right corner. For these cases, the non-pruned algorithm will be significantly slower.\\n\\nWe can **partially** optimize these sorts of test cases as follows: find the longest prefix and suffix in `word` that are each made up of the same character. For example, if `word = \"aaaabccc\"`, the longest prefix and suffix are length 4 and 3 respectively. **If the longest prefix is longer than the longest suffix, then reverse the string**. This makes it so that `word` having a very long prefix is a lot less likely. But in cases where the longest prefix/suffix have very close lengths, this won\\'t really help. But for the LeetCode test data, this seems to generate a large speedup; I was able to get 0ms runtime when I submitted the following solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;}\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;}\\n        else if(board[r][c] != word[i]) {return false;}\\n        \\n        board[r][c] = \\'#\\';\\n        \\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i];\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size(), N = word.size();\\n        \\n        // Prune #1: If there aren\\'t even enough letters in the board to fit word, then return false\\n        if((int) word.size() > R * C) {return false;}\\n        \\n        // Prune #2: For each letter, the board must contain at least as many of that letter as word contains\\n        int occ[128] = {};\\n        for(const auto &v : board) {for(char c : v) {++occ[c];}}\\n        for(char c : word) {\\n            if(--occ[c] < 0) {return false;}\\n        }\\n        \\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest suffix is longer\\n        // than the longest prefix, swap the strigns (so we are less likely to have a long prefix with a lot\\n        // of the same character)\\n        int left_pref = word.find_first_not_of(word[0]);\\n        int right_pref = word.size() - word.find_last_not_of(word.back());\\n        if(left_pref > right_pref) {\\n            reverse(word.begin(), word.end());\\n        }\\n        \\n        // for every starting point, see if we can find word from there\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;} // found word!\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;} // out of bounds\\n        else if(board[r][c] != word[i]) {return false;} // current character doesn\\'t match the board\\n        \\n        board[r][c] = \\'#\\'; // mark board[r][c] as already visited\\n        \\n\\t\\t// move up, down, left, and right and see if you can find word from there\\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i]; // unmark board[r][c]\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size();\\n        \\n\\t\\t// See if you can find word, starting from every possible starting point in board[][]\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n```\n```return false;```\n```\\nclass Solution {\\npublic:\\n    bool search(int r, int c, size_t i, const string &word, vector <vector <char>> &board) {\\n        if(i == word.size()) {return true;}\\n        else if(r < 0 || r >= (int) board.size() || c < 0 || c >= (int) board[0].size()) {return false;}\\n        else if(board[r][c] != word[i]) {return false;}\\n        \\n        board[r][c] = \\'#\\';\\n        \\n        bool ret = search(r - 1, c, i + 1, word, board) || search(r + 1, c, i + 1, word, board)\\n                || search(r, c - 1, i + 1, word, board) || search(r, c + 1, i + 1, word, board);\\n        \\n        board[r][c] = word[i];\\n        return ret;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int R = board.size(), C = board[0].size(), N = word.size();\\n        \\n        // Prune #1: If there aren\\'t even enough letters in the board to fit word, then return false\\n        if((int) word.size() > R * C) {return false;}\\n        \\n        // Prune #2: For each letter, the board must contain at least as many of that letter as word contains\\n        int occ[128] = {};\\n        for(const auto &v : board) {for(char c : v) {++occ[c];}}\\n        for(char c : word) {\\n            if(--occ[c] < 0) {return false;}\\n        }\\n        \\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest suffix is longer\\n        // than the longest prefix, swap the strigns (so we are less likely to have a long prefix with a lot\\n        // of the same character)\\n        int left_pref = word.find_first_not_of(word[0]);\\n        int right_pref = word.size() - word.find_last_not_of(word.back());\\n        if(left_pref > right_pref) {\\n            reverse(word.begin(), word.end());\\n        }\\n        \\n        // for every starting point, see if we can find word from there\\n        for(int r = 0; r < R; ++r) {\\n            for(int c = 0; c < C; ++c) {\\n                if(search(r, c, 0, word, board)) {return true;}\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508066,
                "title": "c-bakctracking-dfs-easiest-solution-with-explanation-beginner-friendly",
                "content": "# ***Approach***\\n```\\n          This is a very popular backtracking problem and is many times asked in faang interviews , although its not that difficult!!!\\n          ------------------------------------------------------------------------------------- \\n          Let\\'s understand the problem statement first!!!\\n              we are given a matrix of (m x n) and we are required to check whether given word\\n              exists in matrix or not!!!\\n              NOTE : we can move in four directions(UP , DOWN , LEFT , RIGHT)\\n          ------------------------------------------------------------------------------------- \\n          Solution :\\n                As the word in matrix can start at any position so we have to check for all\\n                positions whether each position can be a starting point!!\\n                \\n                Now the logic is simple for every call we have index variable which shows how\\n                much chars of word are already found in current dfs call \\n                if at any point we found a mismatch between word[index] and baord[x][y] then that branch becomes invalid for us\\n                \\n                We use backtracking to make sure that each position/block of matrix \\n                is visited once in a branch!!![important][visited check]\\n```\\n# ***Code***\\n ```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>> &board, string word) {\\n        // checking for all positions\\n        for(int i = 0 ; i < board.size() ; ++i)\\n            for(int j = 0 ; j < board[0].size() ; ++j)\\n                if(dfs(0 , i , j , board , word))\\n                    return true;\\n        return false;\\n    }\\n    bool dfs(int index , int x , int y , vector<vector<char>> &board , string &word)\\n    {\\n        if(index == word.size()) // word exists in matrix\\n            return true;\\n        \\n        if(x < 0 or y < 0 or x >= board.size() or y >= board[0].size() or board[x][y] == \\'.\\') // boundary check + visited check\\n            return false;\\n        \\n        if(board[x][y] != word[index])\\n            return false;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'.\\'; // marking it visited\\n        \\n        // Move in 4 directions[UP , DOWN , LEFT , RIGHT]\\n        if(dfs(index + 1 , x - 1 , y , board , word) or dfs(index + 1 , x + 1 , y , board , word) or dfs(index + 1 , x , y - 1 , board , word) or dfs(index + 1 , x , y + 1 , board , word))\\n            return true;\\n            \\n        board[x][y] = temp; // backtrack step\\n        return false;\\n        \\n    }\\n    \\n};\\n```\\n# ***If you liked the Solution , Give it an Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n          This is a very popular backtracking problem and is many times asked in faang interviews , although its not that difficult!!!\\n          ------------------------------------------------------------------------------------- \\n          Let\\'s understand the problem statement first!!!\\n              we are given a matrix of (m x n) and we are required to check whether given word\\n              exists in matrix or not!!!\\n              NOTE : we can move in four directions(UP , DOWN , LEFT , RIGHT)\\n          ------------------------------------------------------------------------------------- \\n          Solution :\\n                As the word in matrix can start at any position so we have to check for all\\n                positions whether each position can be a starting point!!\\n                \\n                Now the logic is simple for every call we have index variable which shows how\\n                much chars of word are already found in current dfs call \\n                if at any point we found a mismatch between word[index] and baord[x][y] then that branch becomes invalid for us\\n                \\n                We use backtracking to make sure that each position/block of matrix \\n                is visited once in a branch!!![important][visited check]\\n```\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>> &board, string word) {\\n        // checking for all positions\\n        for(int i = 0 ; i < board.size() ; ++i)\\n            for(int j = 0 ; j < board[0].size() ; ++j)\\n                if(dfs(0 , i , j , board , word))\\n                    return true;\\n        return false;\\n    }\\n    bool dfs(int index , int x , int y , vector<vector<char>> &board , string &word)\\n    {\\n        if(index == word.size()) // word exists in matrix\\n            return true;\\n        \\n        if(x < 0 or y < 0 or x >= board.size() or y >= board[0].size() or board[x][y] == \\'.\\') // boundary check + visited check\\n            return false;\\n        \\n        if(board[x][y] != word[index])\\n            return false;\\n        \\n        char temp = board[x][y];\\n        board[x][y] = \\'.\\'; // marking it visited\\n        \\n        // Move in 4 directions[UP , DOWN , LEFT , RIGHT]\\n        if(dfs(index + 1 , x - 1 , y , board , word) or dfs(index + 1 , x + 1 , y , board , word) or dfs(index + 1 , x , y - 1 , board , word) or dfs(index + 1 , x , y + 1 , board , word))\\n            return true;\\n            \\n        board[x][y] = temp; // backtrack step\\n        return false;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349677,
                "title": "java-time-and-memory-beats-100-backtracking-template",
                "content": "**T/S:** O(n * (4 ^ w))/O(n), where n is number of cells and w is word length.\\nTo avoid confusion, T: O(r * c * (4 ^ w)), where r x c are the dimensions of the board.\\n```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\npublic boolean exist(char[][] board, String word) {\\n\\tfor (var i = 0; i < board.length; i++)\\n\\t\\tfor (var j = 0; j < board[0].length; j++)\\n\\t\\t\\tif ((board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t\\treturn true;\\n\\treturn false;\\n}\\n\\n// backtracking template: for each choice: choose-explore-unchoose\\nprivate boolean exist(char[][] board, int i, int j, int count, String word) {\\n\\tif (count == word.length())\\n\\t\\treturn true;\\n\\tif (i == -1 || i == board.length || j == -1 || j == board[0].length || board[i][j] != word.charAt(count))\\n\\t\\treturn false;\\n\\t\\n\\t// choose\\n\\tvar temp = board[i][j];\\n\\tboard[i][j] = \\' \\';\\n\\tvar found = false;\\n\\t\\n\\t// explore\\n\\tfor (var dir : DIRS)\\n\\t\\tif (exist(board, i + dir[0], j + dir[1], count + 1, word)) {\\n\\t\\t\\tfound = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t// unchoose\\n\\tboard[i][j] = temp;\\n\\treturn found;\\n}\\n```\\n\\nSame solution using stream\\n```\\nprivate boolean existStream(char[][] board, String word) {\\n\\treturn IntStream.range(0, board.length)\\n\\t\\t\\t\\t\\t.anyMatch(i -> IntStream.range(0, board[0].length)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.anyMatch(j -> (board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t);\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\npublic boolean exist(char[][] board, String word) {\\n\\tfor (var i = 0; i < board.length; i++)\\n\\t\\tfor (var j = 0; j < board[0].length; j++)\\n\\t\\t\\tif ((board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t\\treturn true;\\n\\treturn false;\\n}\\n\\n// backtracking template: for each choice: choose-explore-unchoose\\nprivate boolean exist(char[][] board, int i, int j, int count, String word) {\\n\\tif (count == word.length())\\n\\t\\treturn true;\\n\\tif (i == -1 || i == board.length || j == -1 || j == board[0].length || board[i][j] != word.charAt(count))\\n\\t\\treturn false;\\n\\t\\n\\t// choose\\n\\tvar temp = board[i][j];\\n\\tboard[i][j] = \\' \\';\\n\\tvar found = false;\\n\\t\\n\\t// explore\\n\\tfor (var dir : DIRS)\\n\\t\\tif (exist(board, i + dir[0], j + dir[1], count + 1, word)) {\\n\\t\\t\\tfound = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t// unchoose\\n\\tboard[i][j] = temp;\\n\\treturn found;\\n}\\n```\n```\\nprivate boolean existStream(char[][] board, String word) {\\n\\treturn IntStream.range(0, board.length)\\n\\t\\t\\t\\t\\t.anyMatch(i -> IntStream.range(0, board[0].length)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.anyMatch(j -> (board[i][j] == word.charAt(0)) && exist(board, i, j, 0, word))\\n\\t\\t\\t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3228244,
                "title": "exploring-words-solving-the-grid-word-search-problem-with-dfs-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find whether a given word can be constructed from the characters of the given grid such that adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. The problem can be solved using the Depth First Search (DFS) algorithm. The DFS algorithm works by exploring as far as possible along each branch before backtracking. It is well-suited for problems that require searching through all possible paths.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can approach the problem using the DFS algorithm. We start by iterating through each cell in the grid. For each cell, we check whether the current cell matches the first character of the given word. If the current cell matches the first character of the word, we start a DFS search from that cell, looking for the rest of the characters in the word.\\n\\nFor each DFS search, we explore all four directions, i.e., up, down, left, and right, to find the next character in the word. We mark the current cell as visited to ensure that we do not use the same cell more than once. If we find the entire word, we return True, else we continue the search from the next unvisited cell.\\n\\nWe need to keep track of the visited cells to ensure that we do not use the same cell more than once. To mark a cell as visited, we can replace the character in the cell with a special character, such as \\'/\\'. After completing the DFS search, we can restore the original value of the cell.\\n# Complexity\\n- Time complexity: The time complexity of the DFS algorithm is proportional to the number of cells in the grid, i.e., O(mn), where m is the number of rows and n is the number of columns. In the worst case, we may have to explore all possible paths to find the word. For each cell, we explore at most four directions, so the time complexity of the DFS search is O(4^k), where k is the length of the word. Therefore, the overall time complexity of the algorithm is O(mn*4^k).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is O(k), where k is the length of the word. This is the space required to store the recursive stack during the DFS search.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(i: int, j: int, k: int) -> bool:\\n            if k == len(word):\\n                return True\\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\\n                return False\\n            temp, board[i][j] = board[i][j], \\'/\\'\\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\\n            board[i][j] = temp\\n            return res\\n        \\n        m, n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if dfs(i, j, 0):\\n                    return True\\n        return False\\n\\n```\\n\\n# Code Explanation \\n\\nThis is a Python implementation of the depth-first search algorithm to find if a word exists in a given board of characters.\\n\\nThe `exist` method takes in two parameters, `board` and `word`, which are the 2D list of characters representing the board and the string representing the word to find, respectively. The method returns a boolean value, `True` if the word exists in the board, and `False` otherwise.\\n\\nThe algorithm uses a helper function `dfs` to search for the word starting from a given position in the board. The `dfs` function takes in three parameters, `i`, `j`, and `k`, which are the row and column indices of the current position in the board and the index of the current character in the word, respectively. The function returns a boolean value, `True` if the word can be formed starting from this position, and `False` otherwise.\\n\\nThe `dfs` function first checks if the end of the word has been reached, in which case it returns `True`. If the current position is out of the board or does not match the current character in the word, the function returns `False`.\\n\\nIf the current position matches the current character in the word, the function temporarily changes the character at the current position to `\\'/\\'` to mark it as visited and prevent revisiting it in the search. It then recursively calls itself with the adjacent positions (up, down, left, and right) and the next index in the word. If any of the recursive calls returns `True`, the function returns `True` as well.\\n\\nAfter the search from the current position is finished, the function restores the original character at the current position and returns the final result.\\n\\nThe `exist` function first gets the dimensions of the board using the `len` function. It then iterates through each cell in the board using nested loops. For each cell, it calls the `dfs` function starting from that position with the first character in the word. If `dfs` returns `True`, the function immediately returns `True` as well since the word has been found. If no word is found after iterating through all cells, the function returns `False`.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(i: int, j: int, k: int) -> bool:\\n            if k == len(word):\\n                return True\\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:\\n                return False\\n            temp, board[i][j] = board[i][j], \\'/\\'\\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\\n            board[i][j] = temp\\n            return res\\n        \\n        m, n = len(board), len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if dfs(i, j, 0):\\n                    return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27765,
                "title": "java-dfs-solution-beats-97-64",
                "content": "    public class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return true;\\n            }\\n            char[] chs = word.toCharArray();\\n            for (int i = 0; i < board.length; i++) {\\n                for (int j = 0; j < board[0].length; j++) {\\n                    if(dfs(board, chs, 0, i, j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private boolean dfs(char[][] board, char[] words, int idx, int x, int y) {\\n            if (idx == words.length) {\\n                return true;\\n            } \\n            if (x < 0 || x == board.length || y < 0 || y == board[0].length) {\\n                return false;\\n            }\\n            if (board[x][y] != words[idx]) {\\n                return false;\\n            }\\n            board[x][y] ^= 256;\\n            boolean exist = dfs(board, words, idx + 1, x, y + 1) ||\\n            dfs(board, words, idx + 1, x, y - 1) || dfs(board, words, idx + 1, x + 1, y) ||\\n            dfs(board, words, idx + 1, x - 1, y) ;\\n            board[x][y] ^= 256;\\n            return exist;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1225276,
                "title": "java-99-backtracking-pruning",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // pruning: case 1: not enough characters in board\\n        if (word.length() > m * n) return false;\\n        \\n        // pruning: case 2: board does not contain characters or enough characters that word contains\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = count.getOrDefault(board[i][j], 0);\\n                count.put(board[i][j], temp + 1);\\n            }\\n        }\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int temp = count.get(c);\\n                if (temp == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, temp - 1);\\n                }\\n            }\\n        }\\n        // Backtracking: if a solution is possible, search for it\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0)) {\\n                    boolean[][] marked = new boolean[m][n];\\n                    marked[i][j] = true;\\n                    if (backtracking(board, word, i, j, 1, marked)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtracking(char[][] board, String word, int i, int j, int index, boolean[][] marked) {\\n        if (index == word.length()) return true;\\n        int m = board.length;\\n        int n = board[0].length;\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int d = 0; d < directions.length; d++) {\\n            int x = i + directions[d][0];\\n            int y = j + directions[d][1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (board[x][y] == word.charAt(index) && !marked[x][y]) {\\n                marked[x][y] = true;\\n                if (backtracking(board, word, x, y, index + 1, marked)) return true;\\n                marked[x][y] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // pruning: case 1: not enough characters in board\\n        if (word.length() > m * n) return false;\\n        \\n        // pruning: case 2: board does not contain characters or enough characters that word contains\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = count.getOrDefault(board[i][j], 0);\\n                count.put(board[i][j], temp + 1);\\n            }\\n        }\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int temp = count.get(c);\\n                if (temp == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, temp - 1);\\n                }\\n            }\\n        }\\n        // Backtracking: if a solution is possible, search for it\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0)) {\\n                    boolean[][] marked = new boolean[m][n];\\n                    marked[i][j] = true;\\n                    if (backtracking(board, word, i, j, 1, marked)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtracking(char[][] board, String word, int i, int j, int index, boolean[][] marked) {\\n        if (index == word.length()) return true;\\n        int m = board.length;\\n        int n = board[0].length;\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (int d = 0; d < directions.length; d++) {\\n            int x = i + directions[d][0];\\n            int y = j + directions[d][1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (board[x][y] == word.charAt(index) && !marked[x][y]) {\\n                marked[x][y] = true;\\n                if (backtracking(board, word, x, y, index + 1, marked)) return true;\\n                marked[x][y] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440514,
                "title": "javascript-dfs",
                "content": "```js\\n// Helper Func\\nconst isOutOfBound = (board, row, col) => row < 0 || row >= board.length || col < 0 || col >= board[0].length;\\n\\nconst checkNeighbors = (board, word, row, col) => {\\n    // Check exit conditions\\n    if (!word.length) return true;\\n    if (isOutOfBound(board, row, col) || board[row][col] !== word[0]) return false;\\n    \\n    // Save some stuff\\n    const curChar = board[row][col];\\n    const newWord = word.substr(1);\\n\\n    board[row][col] = 0; // Disable the current character\\n    \\n    // Check if neighbors are fruitful\\n    const results = checkNeighbors(board, newWord, row + 1, col) ||\\n        checkNeighbors(board, newWord, row - 1, col) ||\\n        checkNeighbors(board, newWord, row, col + 1) ||\\n        checkNeighbors(board, newWord, row, col - 1);\\n\\n    // Enable current character\\n    board[row][col] = curChar;\\n\\n    return results;\\n};\\n\\n\\nvar exist = function(board, word) {    \\n    for (let row = 0; row < board.length; row++) {\\n        for (let col  = 0; col < board[0].length; col++) {\\n            if (checkNeighbors(board, word, row, col)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// Helper Func\\nconst isOutOfBound = (board, row, col) => row < 0 || row >= board.length || col < 0 || col >= board[0].length;\\n\\nconst checkNeighbors = (board, word, row, col) => {\\n    // Check exit conditions\\n    if (!word.length) return true;\\n    if (isOutOfBound(board, row, col) || board[row][col] !== word[0]) return false;\\n    \\n    // Save some stuff\\n    const curChar = board[row][col];\\n    const newWord = word.substr(1);\\n\\n    board[row][col] = 0; // Disable the current character\\n    \\n    // Check if neighbors are fruitful\\n    const results = checkNeighbors(board, newWord, row + 1, col) ||\\n        checkNeighbors(board, newWord, row - 1, col) ||\\n        checkNeighbors(board, newWord, row, col + 1) ||\\n        checkNeighbors(board, newWord, row, col - 1);\\n\\n    // Enable current character\\n    board[row][col] = curChar;\\n\\n    return results;\\n};\\n\\n\\nvar exist = function(board, word) {    \\n    for (let row = 0; row < board.length; row++) {\\n        for (let col  = 0; col < board[0].length; col++) {\\n            if (checkNeighbors(board, word, row, col)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363906,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if self.backtracking(i, j,word,board):\\n                    return True\\n        return False\\n    def backtracking(self,i, j,word,board):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"~\"\\n                if self.backtracking(i+1, j, word[1:],board) or self.backtracking(i-1, j, word[1:],board) or self.backtracking(i, j+1, word[1:],board) or self.backtracking( i, j-1, word[1:],board):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if self.backtracking(i, j,word,board):\\n                    return True\\n        return False\\n    def backtracking(self,i, j,word,board):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"~\"\\n                if self.backtracking(i+1, j, word[1:],board) or self.backtracking(i-1, j, word[1:],board) or self.backtracking(i, j+1, word[1:],board) or self.backtracking( i, j-1, word[1:],board):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844101,
                "title": "c-using-dfs-comments-added-easy-to-learn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word)\\n    {\\n        // if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count) return true;\\n        \\n        // check for boundary                                  // curr char is not same with word char\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[count])\\n            return false;\\n        \\n        \\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        \\n        // up , down , left , right (possible moves)\\n        bool ans = dfs(i-1,j,count+1,board,word) || \\n                   dfs(i+1,j,count+1,board,word) ||\\n                   dfs(i,j-1,count+1,board,word) ||\\n                   dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp;                         // make board as it is for the upcoming calls\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int n = board.size();                   // rows\\n        int m = board[0].size();                // cols\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0] && dfs(i,j,0,board,word))                // whenever we found first letter of word start searching from there\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word)\\n    {\\n        // if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count) return true;\\n        \\n        // check for boundary                                  // curr char is not same with word char\\n        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[count])\\n            return false;\\n        \\n        \\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        \\n        // up , down , left , right (possible moves)\\n        bool ans = dfs(i-1,j,count+1,board,word) || \\n                   dfs(i+1,j,count+1,board,word) ||\\n                   dfs(i,j-1,count+1,board,word) ||\\n                   dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp;                         // make board as it is for the upcoming calls\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int n = board.size();                   // rows\\n        int m = board[0].size();                // cols\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0] && dfs(i,j,0,board,word))                // whenever we found first letter of word start searching from there\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850436,
                "title": "java-beats-99-3-dfs-explained-with-dry-run-on-paper",
                "content": "If you\\'ll like the explanation, do **UpVote** :)\\n### Dry run\\n\\n![image](https://assets.leetcode.com/users/images/e9f9212a-f900-44e0-9d46-69a6ff3245ca_1647315994.8879087.png)\\n\\t --------------\\n\\t\\t--------------\\n\\n\\n**Note:** \\nDo check **Solution 2** as well, which is even more optimized  (Runtime: 55 ms, **faster than 99.20%**)\\n\\t\\n### Solution 1 (Very short & Simple code)\\n\\tclass Solution {\\n\\t\\tpublic boolean exist(char[][] board, String word) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;                                // length of rows & columns \\n\\t\\t\\tif(word.length() == 0){ return true; }                                          // if \"word\" is empty, we will just return true. \\n\\t\\t\\tif(rows * cols < word.length()){ return false; }                                // if board size (rows*cols) < word length, => word has some character(s) not present in board. So, just return False. This is optimized way as we are avoiding doing DFS search in such test cases. \\n\\n\\t\\t\\t// Traverse all chars of board\\n\\t\\t\\tfor(int r = 0; r < rows; r++){\\n\\t\\t\\t\\tfor(int c = 0; c < cols; c++){\\n\\t\\t\\t\\t\\tif(board[r][c] == word.charAt(0)){                                                // keep iterating until we don\\'t find first character of \"word\"\\n\\t\\t\\t\\t\\t\\tboolean isFound = dfsBoard(board, new boolean[rows][cols], r, c, word, 0);    // call DFS or recursion\\n\\t\\t\\t\\t\\t\\tif(isFound){ return true; }\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;                                                                             // if we traveresed all chars of board, it means we did not find all chars of word. so return false\\n\\t\\t}\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic boolean dfsBoard(char[][] board, boolean[][] visitedBoard, int row, int col, String word, int wordInd) {        \\t\\t\\t\\n\\t\\t\\tif( (row < 0 || row >= board.length)   ||   (col < 0 || col >= board[0].length)  ||   board[row][col] != word.charAt(wordInd) ){\\n\\t\\t\\t\\treturn false;                                                                             // return false, if:  a)  row or col goes out of bound.  b) char in board != char in word \\n\\t\\t\\t}\\n\\t\\t\\tif(visitedBoard[row][col] ){ return false; }                                                  // this element already visited, so don\\'t do DFS on this\\n\\t\\t\\tif(wordInd == word.length() - 1){ return true; }\\n\\t\\t\\tvisitedBoard[row][col] = true;                                                                // mark it as visited now             \\n\\t\\t\\t\\t\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row, col-1, word, wordInd + 1) ){ return true; }            // DFS on Left\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row, col+1, word, wordInd + 1) ){ return true; }            // DFS on Right\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row-1, col, word, wordInd + 1) ){ return true; }            // DFS on ABove\\n\\t\\t\\tif( dfsBoard(board, visitedBoard, row+1, col, word, wordInd + 1) ){ return true; }            // DFS on Below\\n\\t\\t\\tvisitedBoard[row][col] = false;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\n\\n### Solution 2 (More Optimized)\\nJust added a new method **checkWordCharactersInBoard()**\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic boolean exist(char[][] board, String word) {\\n\\t\\t\\t// Here, same code as in Solution 1\\n\\t\\t\\tif(! checkWordCharactersInBoard(board, rows, cols, word) ){ return false; }                         // check if board contains all chars of word. \\n\\t\\t\\t// Here, same code as in Solution 1\\t\\t\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic boolean dfsBoard(char[][] board, boolean[][] visitedBoard, int row, int col, String word, int wordInd) {         \\n\\t\\t\\t// same code as in Solution 1\\n\\t\\t}\\n\\n\\t\\t// ----------------------------------------------------------------------------------------------------------------------------------------------- //\\n\\t\\tpublic boolean checkWordCharactersInBoard(char[][] board, int rows, int cols, String word){              //   This method helped reducing Runtime further to only 55ms\\n\\t\\t\\tList<Character> wordList = new LinkedList<Character>();\\n\\t\\t\\tfor(char ch : word.toCharArray()){ wordList.add(ch); }\\n\\t\\t\\tfor(int r = 0; r < rows; r++){\\n\\t\\t\\t\\tfor(int c = 0; c < cols; c++){\\n\\t\\t\\t\\t\\tchar ch = board[r][c];\\n\\t\\t\\t\\t\\tif(wordList.size() == 0){ return true; }\\n\\t\\t\\t\\t\\tif(wordList.contains(ch) ){ wordList.remove((Character)ch); }                \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(wordList.size() == 0){ return true; }\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n//\\n//\\n//\\n//\\n//\\n//\\n//\\nYou can talk about Solution 2, if you are asked to optimize further. \\n## For coding interviews:\\n\\t1. You can discuss Solution 1 first, and then optimize using Solution 2 (instead of directly jumpting to optimized solution) in coding interview. \\n\\nIf you like the explanation, do **UpVote** :)\\nIf you need more explanation or, if got even more optimized way, **comment** below.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean exist(char[][] board, String word) {\\n\\t\\t\\tint rows = board.length, cols = board[0].length;                                // length of rows & columns \\n\\t\\t\\tif(word.length() == 0){ return true; }",
                "codeTag": "Java"
            },
            {
                "id": 3223126,
                "title": "best-c-solution-ever-backtracking-matrix-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Matrix + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity:  O(N*M*4^L), where L is the length of the word. And we are searching for the letter N*M times in the worst case. Here 4 in 4^K is because at each level of our decision tree we are making 4 recursive calls which equal 4^K in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(L) : where L is the length of the given word. This space is used for recursion stack.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity:  O(N*M*4^L), where L is the length of the word. And we are searching for the letter N*M\\n    times in the worst case. Here 4 in 4^K is because at each level of our decision tree we are making 4\\n    recursive calls which equal 4^K in the worst case.\\n\\n    Space Complexity : O(L) : where L is the length of the given word. This space is used for recursion stack.\\n\\n    Solved using Matrix + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkWordPresent(vector<vector<char>>& board, string word, int n, int m, int row, int col, int index){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(row < 0 || col < 0 || row >= n || col >= m || board[row][col] != word[index]){\\n            return false;\\n        }\\n        char temp = board[row][col];\\n        board[row][col] = \\'*\\';\\n        bool ans1 = checkWordPresent(board, word, n, m, row+1, col, index+1);\\n        bool ans2 = checkWordPresent(board, word, n, m, row, col+1, index+1);\\n        bool ans3 = checkWordPresent(board, word, n, m, row-1, col, index+1);\\n        bool ans4 = checkWordPresent(board, word, n, m, row, col-1, index+1);\\n        board[row][col] = temp;\\n        return ans1 || ans2 || ans3 || ans4;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(checkWordPresent(board, word, n, m, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity:  O(N*M*4^L), where L is the length of the word. And we are searching for the letter N*M\\n    times in the worst case. Here 4 in 4^K is because at each level of our decision tree we are making 4\\n    recursive calls which equal 4^K in the worst case.\\n\\n    Space Complexity : O(L) : where L is the length of the given word. This space is used for recursion stack.\\n\\n    Solved using Matrix + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkWordPresent(vector<vector<char>>& board, string word, int n, int m, int row, int col, int index){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(row < 0 || col < 0 || row >= n || col >= m || board[row][col] != word[index]){\\n            return false;\\n        }\\n        char temp = board[row][col];\\n        board[row][col] = \\'*\\';\\n        bool ans1 = checkWordPresent(board, word, n, m, row+1, col, index+1);\\n        bool ans2 = checkWordPresent(board, word, n, m, row, col+1, index+1);\\n        bool ans3 = checkWordPresent(board, word, n, m, row-1, col, index+1);\\n        bool ans4 = checkWordPresent(board, word, n, m, row, col-1, index+1);\\n        board[row][col] = temp;\\n        return ans1 || ans2 || ans3 || ans4;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(checkWordPresent(board, word, n, m, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168378,
                "title": "java-dfs-with-explanations",
                "content": "For each cell in board, if it matches the first character of word, we implement DFS starting at it to see if we could find word. \\nThe bottleneck of it is to mark cell visited for we cannot visit a cell multiple times. The fastest way is to modify the original cell rather than to use external storage.\\n****\\n```\\n    private static int m, n;\\n    private static final int[][] dirs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        if (word == null || word.length() == 0)\\n            return true;\\n        \\n        m = board.length; \\n        n = board[0].length;\\n        char firstChar = word.charAt(0);\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == firstChar) {\\n                    // Mark as visited.\\n                    board[i][j] = \\'-\\';\\n                    if (searchFrom(i, j, board, word, 1))\\n                        return true;\\n                    // Restore to unvisited.\\n                    board[i][j] = firstChar;\\n                }\\n            }\\n        }\\n            \\n        return false;\\n    }\\n    \\n    private static boolean searchFrom(int x, int y, char[][] board, String word, int wi) {        \\n        // Acception case, leaf.\\n        if (wi == word.length()) \\n            return true;\\n        \\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            \\n            if (nx < 0 || nx >= m || ny < 0 || ny >= n || word.charAt(wi) != board[nx][ny])\\n                continue;\\n            // Mark as visited.\\n            board[nx][ny] = \\'-\\';\\n            if (searchFrom(nx, ny, board, word, wi + 1))\\n                return true;\\n            // Restore to unvisited.\\n            board[nx][ny] = word.charAt(wi);\\n        }\\n        \\n        return false;\\n    }\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\n    private static int m, n;\\n    private static final int[][] dirs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        if (word == null || word.length() == 0)\\n            return true;\\n        \\n        m = board.length; \\n        n = board[0].length;\\n        char firstChar = word.charAt(0);\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == firstChar) {\\n                    // Mark as visited.\\n                    board[i][j] = \\'-\\';\\n                    if (searchFrom(i, j, board, word, 1))\\n                        return true;\\n                    // Restore to unvisited.\\n                    board[i][j] = firstChar;\\n                }\\n            }\\n        }\\n            \\n        return false;\\n    }\\n    \\n    private static boolean searchFrom(int x, int y, char[][] board, String word, int wi) {        \\n        // Acception case, leaf.\\n        if (wi == word.length()) \\n            return true;\\n        \\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            \\n            if (nx < 0 || nx >= m || ny < 0 || ny >= n || word.charAt(wi) != board[nx][ny])\\n                continue;\\n            // Mark as visited.\\n            board[nx][ny] = \\'-\\';\\n            if (searchFrom(nx, ny, board, word, wi + 1))\\n                return true;\\n            // Restore to unvisited.\\n            board[nx][ny] = word.charAt(wi);\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747233,
                "title": "python-sol-by-dfs-w-comment",
                "content": "Python sol by DFS with 4-connected path\\n\\n---\\n\\n**Implementation** by DFS:\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        if not board: \\n            \\n            # Quick response for empty board\\n            return False\\n        \\n        h, w = len(board), len(board[0])\\n      \\n        # ------------------------------------------------------\\n    \\n        def dfs_search(idx: int, x: int, y: int) -> bool:\\n            \\n            if x < 0 or x == w or y < 0 or y == h or word[idx] != board[y][x]:\\n                # Reject if out of boundary, or current grid cannot match the character word[idx]\\n                return False\\n\\n            if idx == len(word) - 1: \\n                # Accept when we match all characters of word during DFS\\n                return True\\n\\n            cur = board[y][x]\\n            \\n            # mark as \\'#\\' to avoid repeated traversal\\n            board[y][x] = \\'#\\'\\n            \\n            # visit next four neighbor grids\\n            found = dfs_search(idx + 1, x + 1, y) or dfs_search(idx + 1, x - 1, y) or dfs_search(idx + 1, x, y + 1) or dfs_search(idx + 1, x, y - 1)\\n            \\n            # recover original grid character after DFS is completed\\n            board[y][x] = cur\\n            \\n            return found\\n\\n        # ------------------------------------------------------\\n        \\n        return any(dfs_search(0, x, y) for y in range(h) for x in range(w))      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        if not board: \\n            \\n            # Quick response for empty board\\n            return False\\n        \\n        h, w = len(board), len(board[0])\\n      \\n        # ------------------------------------------------------\\n    \\n        def dfs_search(idx: int, x: int, y: int) -> bool:\\n            \\n            if x < 0 or x == w or y < 0 or y == h or word[idx] != board[y][x]:\\n                # Reject if out of boundary, or current grid cannot match the character word[idx]\\n                return False\\n\\n            if idx == len(word) - 1: \\n                # Accept when we match all characters of word during DFS\\n                return True\\n\\n            cur = board[y][x]\\n            \\n            # mark as \\'#\\' to avoid repeated traversal\\n            board[y][x] = \\'#\\'\\n            \\n            # visit next four neighbor grids\\n            found = dfs_search(idx + 1, x + 1, y) or dfs_search(idx + 1, x - 1, y) or dfs_search(idx + 1, x, y + 1) or dfs_search(idx + 1, x, y - 1)\\n            \\n            # recover original grid character after DFS is completed\\n            board[y][x] = cur\\n            \\n            return found\\n\\n        # ------------------------------------------------------\\n        \\n        return any(dfs_search(0, x, y) for y in range(h) for x in range(w))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691667,
                "title": "c-solution-using-backtracking-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We are given a matrix of (m x n) and we are required to check whether the given word exists in the matrix or not!!!\\n- We can solve this by Backtracking. Match character-by-character, go ahead and check if the adjacent cells match the next character, and go back if it does not match.\\n- For each cell, traverse the entire matrix.\\n- Check if\\xA0`matrix[i][j] == word[index]`. (we are using\\xA0the `index`\\xA0to keep track of the characters that we have already checked in the\\xA0`word`\\xA0during backtracking.)\\n    - If it is true, then check to repeat the same process for the adjacent cells and for the next index in the word.\\n    - If it is false, then return to the previous state where we received a\\xA0`true`\\xA0value and then further check any remaining and unvisited cells.\\n- **Time complexity:** O(n) | *actually it\\u2019s O(4n) because we traverse 4 neighbours*.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n   bool exist(vector<vector<char>> &board, string word) {\\n       int row=board.size(), col=board[0].size();\\n       for(int i = 0 ; i < row ; ++i)\\n           for(int j = 0 ; j < col ; ++j)\\n               if(search(0 , i , j , board , word))\\n                   return true;\\n       return false;\\n   }\\n   bool search(int index , int x , int y , vector<vector<char>> &board , string &word)\\n   {\\n       if(index == word.size())\\n           return true;\\n       \\n       if(x < 0 || y < 0 || x >= board.size() || y >= board[0].size() || board[x][y] == \\'.\\') \\n           return false;\\n       \\n       if(board[x][y] != word[index])\\n           return false;\\n       \\n       char temp = board[x][y];\\n       board[x][y] = \\'.\\'; \\n       if(search(index + 1 , x - 1 , y , board , word) || search(index + 1 , x + 1 , y , board , word) || search(index + 1 , x , y - 1 , board , word) || search(index + 1 , x , y + 1 , board , word))\\n           return true;\\n           \\n       board[x][y] = temp;\\n       return false;\\n       \\n   }\\n   \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n   bool exist(vector<vector<char>> &board, string word) {\\n       int row=board.size(), col=board[0].size();\\n       for(int i = 0 ; i < row ; ++i)\\n           for(int j = 0 ; j < col ; ++j)\\n               if(search(0 , i , j , board , word))\\n                   return true;\\n       return false;\\n   }\\n   bool search(int index , int x , int y , vector<vector<char>> &board , string &word)\\n   {\\n       if(index == word.size())\\n           return true;\\n       \\n       if(x < 0 || y < 0 || x >= board.size() || y >= board[0].size() || board[x][y] == \\'.\\') \\n           return false;\\n       \\n       if(board[x][y] != word[index])\\n           return false;\\n       \\n       char temp = board[x][y];\\n       board[x][y] = \\'.\\'; \\n       if(search(index + 1 , x - 1 , y , board , word) || search(index + 1 , x + 1 , y , board , word) || search(index + 1 , x , y - 1 , board , word) || search(index + 1 , x , y + 1 , board , word))\\n           return true;\\n           \\n       board[x][y] = temp;\\n       return false;\\n       \\n   }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520705,
                "title": "java-tc-o-rc-3-l-sc-o-l-optimal-dfs-solution-without-visited-matrix",
                "content": "```java\\n/**\\n * For each char, perform Depth-First Search in all four directions.\\n *\\n * Time Complexity:\\n * 1. If L > R*C ==> TC = O(1)\\n * 2. If L <= R*C ==> TC = O(R*C * 4*(3^L))\\n *      3^L ==> For the dfsHelper function, first time we have at most 4 directions\\n *              to explore, but the choices are reduced to 3 (since no need to go back to the\\n *              cell from where we came). Therefore, in the worst case, the total number of\\n *              calls to dfsHelper will be 3^L\\n *\\n * Space Complexity:\\n * 1. If L > R*C ==> SC = O(1)\\n * 2. If L <= R*C ==> SC = O(L)\\n *\\n * R = Number of rows. C = Number of columns. L = Length of word.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public boolean exist(char[][] board, String word) {\\n        if (board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) {\\n            return false;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        if (rows * cols < word.length()) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == word.charAt(0) && dfsHelper(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfsHelper(char[][] board, String word, int x, int y, int wIdx) {\\n        if (wIdx == word.length()) {\\n            return true;\\n        }\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != word.charAt(wIdx)) {\\n            return false;\\n        }\\n\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            if (dfsHelper(board, word, x + d[0], y + d[1], wIdx + 1)) {\\n                board[x][y] = word.charAt(wIdx);\\n                return true;\\n            }\\n        }\\n        board[x][y] = word.charAt(wIdx);\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Word Search question on LeetCode:\\n- [212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/1520723/Java-or-TC%3A-O(RC*(3L))-or-SC%3A-O(N%2BL)-or-Optimal-Trie%2BDFS-solution)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * For each char, perform Depth-First Search in all four directions.\\n *\\n * Time Complexity:\\n * 1. If L > R*C ==> TC = O(1)\\n * 2. If L <= R*C ==> TC = O(R*C * 4*(3^L))\\n *      3^L ==> For the dfsHelper function, first time we have at most 4 directions\\n *              to explore, but the choices are reduced to 3 (since no need to go back to the\\n *              cell from where we came). Therefore, in the worst case, the total number of\\n *              calls to dfsHelper will be 3^L\\n *\\n * Space Complexity:\\n * 1. If L > R*C ==> SC = O(1)\\n * 2. If L <= R*C ==> SC = O(L)\\n *\\n * R = Number of rows. C = Number of columns. L = Length of word.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n\\n    public boolean exist(char[][] board, String word) {\\n        if (board == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) {\\n            return false;\\n        }\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        if (rows * cols < word.length()) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == word.charAt(0) && dfsHelper(board, word, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfsHelper(char[][] board, String word, int x, int y, int wIdx) {\\n        if (wIdx == word.length()) {\\n            return true;\\n        }\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != word.charAt(wIdx)) {\\n            return false;\\n        }\\n\\n        board[x][y] = \\'#\\';\\n        for (int[] d : DIRS) {\\n            if (dfsHelper(board, word, x + d[0], y + d[1], wIdx + 1)) {\\n                board[x][y] = word.charAt(wIdx);\\n                return true;\\n            }\\n        }\\n        board[x][y] = word.charAt(wIdx);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509775,
                "title": "java-11ms-fast-explanation",
                "content": "The Java code below runs at 11ms on Oct 7, 2021.  Test cases change over time.  My previous code (not the code shown below) for this leetcode problem ran in 3ms a year ago with 89 test cases.  Now that same code takes 25 times longer to run with only 2/3 as many test cases.  So changes to test cases can make a big difference in execution time.  The example code below has been greatly modified from my code from one year ago, so that it is now mush more efficient and runs faster, although the new test cases for this leetcode problem cause the total execution time to be longer than one year ago.\\n\\nUpdate: As of November 2022, faster code appears on the runtime graph.  That fastest code has very good optimizations that include checking letter frequency.  If the word being searched for has a lower frequency letter at the end of the word than the frequency of the letter at the beginning of the word, then reverse the word before searching.  This speeds up the search by starting the search at a letter that occurs less often on the board.  For example, if the word being searched for is \"AAAAAB\" and the board has many \"A\"s but has only a few \"B\"s, then it reverses the word to \"BAAAAA\" before searching the board.\\n\\n---\\n**Faster solutions** previously **on the execution-time graph**\\nUpdate:  As of November 2022, the runtime graph has been reset.  The code from the runtime graph that is discussed in this section, no longer appears on the runtime graph.\\n\\nOn the graph of execution times for this leetcode problem, there are multiple bars on the graph with faster or similar execution times as this code, but the example code for those bars have a flaw that can produce a wrong answer with some test cases.  By clicking on those faster bars of the graph, I have found the example code for that bar.  Many of these code examples from the graph have special handling for the following test case from this leetcode problem:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"ABCESEEEFS\"\\n\\nWithout the special checks for this test case, some of those code examples would get the wrong answer.  In example code for 0ms on the execution-time graph, if the passed word is the word from the above test case, then immediately return `true`, because without this check the code would give the wrong result.  Some other examples from the fastest bars of the graph have look at surrounding board squares in an order which allows this test case to be accepted, because they look in the valid direction first.  For the fastest code examples from the execution-time graph that correctly handle the above case, most will get the wrong answer for the test case I created:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"],[\"A\",\"D\",\"E\",\"E\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"ABCESEEEEEFS\"\\n\\nThe flaw in these fastest code examples is that they keep a flag for each board square, which indicates if that square has been searched with a specific index into the word and that search failed.  This optimization flag is used to stop extra searches at a board square with the same index into the word.  But this optimization is flawed because it doesn\\'t handle a board square being searched at the same index into the word, but where the search path through the board may approach the same square at the same word index from **different directions** of approach to that square.  In the above test cases, the many \"E\"s on the board and many \"E\"s in the word can cause many paths through the board\\'s \"E\"s to be searched.  Not all of these paths lead to a valid solution.  The optimization flags for the squares do not contain any information as to which direction that board square was approached from.  \\n\\nAn example from the above test cases showing how this optimization fails, is that an \"E\" on the board may be searched with, for example, the 3rd \"E\" of the word and that path through the board eventually doesn\\'t match the word.  Then that \"E\" on the board is flagged as already having been tried with the 3rd letter of the word and that search failed.  But a later search path through the board approaches that same \"E\" on the board but from a different direction and wants to use that \"E\" from the board for the 3rd \"E\" of the word.  But that board square already has that \"E\"\\'s square flagged as having failed when trying to use it for the 3rd \"E\" of the word.  So that optimization flag causes that search to be terminated early as a failure, when that \"E\" could actually have been used to match the 3rd \"E\" of the word as part of a valid match for the entire word.  In this case, these optimization flags prevent a valid word match from being found.  In most test cases, this optimization works to produce the correct answer, but for some situations such as the above test cases, this optimization can fail.\\n\\n---\\n**Explaining the code below**\\n\\nThe Java code example below uses a Depth First Search (DFS) to recursively try many paths on the board to try to match the passed word.  The DFS recursively looks for the next letter in the word in the current square of the board, then recurses to try to find the next letter of the word in a board square surrounding (up, down, left, right) the current square.  If the DFS successfully searches to the end of the word, then the DFS passes `true` back of the recursive calls and the search is terminated with a success in finding the word on the board.\\n\\nDuring the DFS, before DFS code\\'s recursion calls, the current board square\\'s letter is temporarily replaced with \\'\\\\*\\' to prevent re-use of a board square that has already been used to match a letter in the word.  If a DFS search decides its search path has failed, the \\'\\\\*\\'s are reset to their original letter as the recursion unwinds back to a point where the DFS will try a different path.  An alternate to temporarily replacing the board square\\'s letter with \\'\\\\*\\', would have been to XOR that square with 128 to mark the square as \"used\" by preventing letters from matching this square, then after recursion calls, to XOR that square again with 128 to mark the square as unused.  For example, the marking a square as \"used\" prevents cases such as two adjacent board squares being \\'A\\' and \\'B\\', with the word being \"ABABABAB\", and the DFS search using first the \\'A\\', then the adjacent \\'B\\', but marking these as used prevents the search from re-using that same \\'A\\' square again, and prevents the search from bouncing back and forth between these two board squares.\\n\\nSeveral optimizations to make the example code faster are described in paragraphs below.\\n\\n**Optimization - Check if all word letters are on the board:**` ` ` `The biggest improvement in speed came from checking if all the letters in the word exist somewhere on the board.  If the word contains a letter not found on the board, then return `false` and don\\'t waste time doing the DFS.  To do this check, the extire board is scanned.  Each board letter is converted into a bitmask, then OR\\'ed into the combined **bitmask** for the entire board.  Each letter \\'A\\'...\\'Z\\' and \\'a\\'...\\'z\\' have a single bit in the bitmask.  After the combined bitmask for the entire board has been created, the bitmask contains flags for all the letters found on the board.  Then each letter from the word is tested against that bitmask, to check if that letter exists somewhere on the board.  An alternate for this optimization would be to **count** each type of letter on the board, then make sure there are enough for each type of letter in the word.  This alternate for this check did not provide any noticeable speed improvement, so since the next optimization below uses bitmasks, I also used bitmasks for this optimization.  Another alternate for this optimization would be to use a **Set**\\\\<Character> instead of a bitmask, but both the bitmask and the counts are faster than a `Set`.  If more types of characters were to be allowed on the board, or the board could contain Unicode character strings, then a `Set` would be the best solution.  The advantage of this optimization is best shown with the leetcode problem\\'s test case:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\\n` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"AAAAAAAAAAAAAAB\"\\n\\n**Optimization - Quick test if any surrounding square contains the next letter of the word:**` ` ` `An array is created with the same dimensions as the `board`.  This array contains a bitmask for each square of the board.  Each bitmask contains bits to indicate which letters are in the four surrounding board squares.  During the recursive DFS search, these bitmasks allow a fast check to see if the next letter in the word exists in one of the surrounding squares of the board, without actually looking at those surrounding squares.  These bitmasks are in the array `nextLetters`, which is built before starting any of the DFS searches.  To build the matrix of bitmasks for this optimization, the board is scanned with nested for-loops to get the letter in each board square.  For the letter in each square of the board, a bitmask is calculated for the letter in that square.  This bitmask is then OR\\'ed into the `nextLetters[][]` bitmasks for the four surrounding squares, so that those surrounding squares will eventually have a combined bitmask for their surrounding squares.\\n\\n**Building bitmasks:**` ` ` `In several places in the code below, the letters from the board or from the word are converted to a bitmask.  These bitmasks are used to perform two types of optimizations in the code below: 1) checking for all letters in the word existing on the board, and 2) quickly checking if any surrounding board squares contains the next letter of a word.  Within a bitmask, separate bits are used for each type of letter.   A `long` is needed to contain the bitmasks because the letter-matching is case sensitive, so this would require at least 52 bits (26 uppercase letters plus 26 lowercase letters = 52 bits).  Since an `int` has only 32 bits, this is not enough for the 52 letters to each have their own bit.  Therefore a 64-bit `long` value is needed to contain the bitmask.  In the code below, the bitmask for a letter is calculated with an expression similar to `1L << (letterChar - \\'@\\')`.  If the letterChar is \\'B\\', then this expression will reduce to `1L << (66 - 64)` or further reduce to `1L << 2` which is the `long` value 1 shifted bitwise to the left 2 bit positions, which is 0b100 in binary.  The \"L\" in the expression\\'s \"1L\" is necessary to indicate this is a `long` constant \"1\" and that the calculations should be done as a 64-bit `long`.  If the \"L\" were to be deleted from this expression, then the compiler assumes the \"1\" is an `int` constant and will only do a 32-bit `int` calculation, which will result in incorrect answers from the code below.\\n\\n**Optimization - Scan `board` for first letter of the `word`:**` ` ` `With nested loops, scan each letter of the board, looking for the first letter of the word before starting a recursive DFS search at that board square that contains the word\\'s first letter.\\n\\n**Optimization - Check for `word` can not fit on the `board`:**` ` ` `If the count of letters in the word is greater than the count of squares on the board, then return `false` instead of doing any DFS search or any other processing.  Within the constraints for this leetcode problem, the worst case that this optimization prevents is a 3x4 `board` of all the same letter, with a 13-letter `word` of all that same letter.  If the DFS searching was done on this worst case example, it would be a lot of wasted time searching many many paths but never finding a solution.  In fact, this is one of the leetcode test cases:\\n\\n` ` ` ` ` ` ` ` ` ` ` ` [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\\n` ` ` ` ` ` ` ` ` ` ` ` \"aaaaaaaaaaaaa\"\\n\\n**Optimization - Check for a word that is a single letter**` ` ` `If the passed word is has a length of 1 (i.e. is only a single letter), and after the previous optimization to check if all letters in the word exist somewhere on the board, we can return `true`.  After the optimization to check if all letters in the word exist on the board, we know that the single-letter word has that single letter somewhere on the board, so we know that the entire single-letter word can be found on the board, and no DFS search is needed.\\n\\n**If useful, please upvote.**\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int rowMax = board.length - 1;      // Highest row index.\\n        int colMax = board[0].length - 1;   // Highest column index.\\n        char[] wordC = word.toCharArray();  // word String converted to char[].\\n        char firstLetter = wordC[0];        // First letter of the word\\n\\n        // If the word is too long to possibly fit on the board, then \\n        // immediately return false.\\n        if (wordC.length > (rowMax + 1) * (colMax + 1))  return false;\\n        \\n        // Build a bit mask \\'boardLetters\\' of all letters in the board.  This \\n        // bitmask will be used later to check if all letters in the word, \\n        // exist within the board.  If any letter in the word is not in the \\n        // board then quickly return a false, without any searching the board.\\n        //\\n        // Also build a matrix boardLetters[][] which has the same dimensions \\n        // as the board, but contains bit masks that indicate which letters \\n        // are in the surrounding squares of the board.  This will speed-up \\n        // the search by determining if any surrounding squares contain the \\n        // next letter of the word, BEFORE having to look in the surrounding \\n        // squares.\\n        //\\n        // Since this leetcode problem allows both uppercase and lowercase \\n        // letters, both types of bitmasks must be long variables.  The long \\n        // variables are 64-bits so they can contain a bit for each of the \\n        // 52 letters (26 uppercase + 26 lowercase = 52 letters and so we \\n        // need more than the 32-bits of an int variable).  The \"1L <<\" in \\n        // some of the expressions in the code below, forces the \"<<\" \\n        // shift-left operation to be a long, because the \"L\" after the \\n        // \"1\" indicates that the \"1\" is a long constant.  The \"1\" could also \\n        // be made a long by \"(long)1\" to cast the \"1\" to be a long.  Without \\n        // either of these methods indicating the \"1\" is a long, the code \\n        // will perform the \"<<\" shift-left operation as a 32-bit int and the \\n        // code would fail.\\n        long[][] nextLetters = new long[rowMax + 1][colMax + 1];\\n                                    // Bit-masks of letters in surrounding board squares.\\n        long boardLetters = 0;      // Bit-mask of all letters in the board.\\n        long cBit;\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                cBit = 1L << (board[row][col] - \\'@\\');\\n                boardLetters |= cBit;\\n                if (row > 0)  nextLetters[row - 1][col] |= cBit;\\n                if (col > 0)  nextLetters[row][col - 1] |= cBit;\\n                if (row < rowMax)  nextLetters[row + 1][col] |= cBit;\\n                if (col < colMax)  nextLetters[row][col + 1] |= cBit;\\n            }\\n        }\\n        \\n        // Check to see if all letters in the word exist in the board.  \\n        // If any letters not found in the board, then the word CANNOT exist \\n        // anywhere in the board so return false.  This skips searching the \\n        // board when the word cannot be on the board.\\n        for (int pos = wordC.length - 1; pos >= 0; pos--)\\n            if (((1L << (wordC[pos] - \\'@\\')) & boardLetters) == 0)\\n                return false;\\n\\n        // If the word length is only 1 letter, then no search is needed and \\n        // the word is found.  We previously verified that all letters in the \\n        // word can be found on the board.  But is the word length is only \\n        // 1 letter, and that one letter has been previously verified to \\n        // exist on the board, then the entire 1-letter word exists on the \\n        // board, and we can return true without any further searching.\\n        if (wordC.length == 1)  return true;\\n\\n        // Loop through all squares of the board looking for a square that \\n        // contains the first letter of the word.  When finding a square \\n        // with the same letter as the first letter of the word, then start \\n        // a recursive search for the entire word within the board.\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                if (board[row][col] == firstLetter && \\n                        checkWord(row, col, 0, wordC, board, nextLetters))  \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    // Recursive method to check if the current letter in the word is \\n    // found at the current board position.  If found, then call \\n    // this method recursively to check the surrounding squares of the \\n    // board for the next letter, or if at end of word, then return true \\n    // to show the entire word was found in the board.\\n    //\\n    // During recursion, after matching a letter from the word with a \\n    // letter from the board, then temporarily replace that letter in \\n    // the board with a \"*\" so that the square of the board can\\'t be \\n    // used again if the same letter occurs later in the word.  When \\n    // returning from recursion, replace the \"*\" with the letter that \\n    // was originally in that square of the board.\\n    private boolean checkWord(int row, int col, int pos, char[] wordC, \\n                                char[][] board, long[][] nextLetters)  {\\n        if (row < 0 || row >= board.length || \\n                    col < 0 || col >= board[0].length)  \\n            return false;           // If current board square is outside \\n                                    //   the boundary of the board, then \\n                                    //   not a valid search path.\\n        char c = board[row][col];   // Get current board letter.\\n        if (wordC[pos++] != c)  return false;\\n                                    // If current letter from word does \\n                                    //   not match current board square, \\n                                    //   then word not on this search path.\\n        if (pos == wordC.length)  return true;\\n                                    // If end of word, then word found!!!\\n        if ((1L << (wordC[pos] - \\'@\\') & nextLetters[row][col]) == 0)  \\n            return false;           // If next letter from word not in any \\n                                    //   surrounding square, then no match.\\n        board[row][col] = \\'*\\';      // Temporarily replace square with \"*\".\\n        // board[row][col] ^= 128;      // Temporarily mark square as used.\\n        if (checkWord(row, col+1, pos, wordC, board, nextLetters) ||\\n                checkWord(row, col-1, pos, wordC, board, nextLetters) ||  \\n                checkWord(row+1, col, pos, wordC, board, nextLetters) || \\n                checkWord(row-1, col, pos, wordC, board, nextLetters))\\n            return true;            // Recurse to check surrounding squares \\n                                    //   for remainder of the word.  Return \\n                                    //   true if entire word found in board.\\n        board[row][col] = c;        // Restore square with original letter.\\n        // board[row][col] ^= 128;        // Restore square to unused.\\n        return false;               // Word not found on this search path.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int rowMax = board.length - 1;      // Highest row index.\\n        int colMax = board[0].length - 1;   // Highest column index.\\n        char[] wordC = word.toCharArray();  // word String converted to char[].\\n        char firstLetter = wordC[0];        // First letter of the word\\n\\n        // If the word is too long to possibly fit on the board, then \\n        // immediately return false.\\n        if (wordC.length > (rowMax + 1) * (colMax + 1))  return false;\\n        \\n        // Build a bit mask \\'boardLetters\\' of all letters in the board.  This \\n        // bitmask will be used later to check if all letters in the word, \\n        // exist within the board.  If any letter in the word is not in the \\n        // board then quickly return a false, without any searching the board.\\n        //\\n        // Also build a matrix boardLetters[][] which has the same dimensions \\n        // as the board, but contains bit masks that indicate which letters \\n        // are in the surrounding squares of the board.  This will speed-up \\n        // the search by determining if any surrounding squares contain the \\n        // next letter of the word, BEFORE having to look in the surrounding \\n        // squares.\\n        //\\n        // Since this leetcode problem allows both uppercase and lowercase \\n        // letters, both types of bitmasks must be long variables.  The long \\n        // variables are 64-bits so they can contain a bit for each of the \\n        // 52 letters (26 uppercase + 26 lowercase = 52 letters and so we \\n        // need more than the 32-bits of an int variable).  The \"1L <<\" in \\n        // some of the expressions in the code below, forces the \"<<\" \\n        // shift-left operation to be a long, because the \"L\" after the \\n        // \"1\" indicates that the \"1\" is a long constant.  The \"1\" could also \\n        // be made a long by \"(long)1\" to cast the \"1\" to be a long.  Without \\n        // either of these methods indicating the \"1\" is a long, the code \\n        // will perform the \"<<\" shift-left operation as a 32-bit int and the \\n        // code would fail.\\n        long[][] nextLetters = new long[rowMax + 1][colMax + 1];\\n                                    // Bit-masks of letters in surrounding board squares.\\n        long boardLetters = 0;      // Bit-mask of all letters in the board.\\n        long cBit;\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                cBit = 1L << (board[row][col] - \\'@\\');\\n                boardLetters |= cBit;\\n                if (row > 0)  nextLetters[row - 1][col] |= cBit;\\n                if (col > 0)  nextLetters[row][col - 1] |= cBit;\\n                if (row < rowMax)  nextLetters[row + 1][col] |= cBit;\\n                if (col < colMax)  nextLetters[row][col + 1] |= cBit;\\n            }\\n        }\\n        \\n        // Check to see if all letters in the word exist in the board.  \\n        // If any letters not found in the board, then the word CANNOT exist \\n        // anywhere in the board so return false.  This skips searching the \\n        // board when the word cannot be on the board.\\n        for (int pos = wordC.length - 1; pos >= 0; pos--)\\n            if (((1L << (wordC[pos] - \\'@\\')) & boardLetters) == 0)\\n                return false;\\n\\n        // If the word length is only 1 letter, then no search is needed and \\n        // the word is found.  We previously verified that all letters in the \\n        // word can be found on the board.  But is the word length is only \\n        // 1 letter, and that one letter has been previously verified to \\n        // exist on the board, then the entire 1-letter word exists on the \\n        // board, and we can return true without any further searching.\\n        if (wordC.length == 1)  return true;\\n\\n        // Loop through all squares of the board looking for a square that \\n        // contains the first letter of the word.  When finding a square \\n        // with the same letter as the first letter of the word, then start \\n        // a recursive search for the entire word within the board.\\n        for (int row = 0; row <= rowMax; row++) {\\n            for (int col = 0; col <= colMax; col++) {\\n                if (board[row][col] == firstLetter && \\n                        checkWord(row, col, 0, wordC, board, nextLetters))  \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    // Recursive method to check if the current letter in the word is \\n    // found at the current board position.  If found, then call \\n    // this method recursively to check the surrounding squares of the \\n    // board for the next letter, or if at end of word, then return true \\n    // to show the entire word was found in the board.\\n    //\\n    // During recursion, after matching a letter from the word with a \\n    // letter from the board, then temporarily replace that letter in \\n    // the board with a \"*\" so that the square of the board can\\'t be \\n    // used again if the same letter occurs later in the word.  When \\n    // returning from recursion, replace the \"*\" with the letter that \\n    // was originally in that square of the board.\\n    private boolean checkWord(int row, int col, int pos, char[] wordC, \\n                                char[][] board, long[][] nextLetters)  {\\n        if (row < 0 || row >= board.length || \\n                    col < 0 || col >= board[0].length)  \\n            return false;           // If current board square is outside \\n                                    //   the boundary of the board, then \\n                                    //   not a valid search path.\\n        char c = board[row][col];   // Get current board letter.\\n        if (wordC[pos++] != c)  return false;\\n                                    // If current letter from word does \\n                                    //   not match current board square, \\n                                    //   then word not on this search path.\\n        if (pos == wordC.length)  return true;\\n                                    // If end of word, then word found!!!\\n        if ((1L << (wordC[pos] - \\'@\\') & nextLetters[row][col]) == 0)  \\n            return false;           // If next letter from word not in any \\n                                    //   surrounding square, then no match.\\n        board[row][col] = \\'*\\';      // Temporarily replace square with \"*\".\\n        // board[row][col] ^= 128;      // Temporarily mark square as used.\\n        if (checkWord(row, col+1, pos, wordC, board, nextLetters) ||\\n                checkWord(row, col-1, pos, wordC, board, nextLetters) ||  \\n                checkWord(row+1, col, pos, wordC, board, nextLetters) || \\n                checkWord(row-1, col, pos, wordC, board, nextLetters))\\n            return true;            // Recurse to check surrounding squares \\n                                    //   for remainder of the word.  Return \\n                                    //   true if entire word found in board.\\n        board[row][col] = c;        // Restore square with original letter.\\n        // board[row][col] ^= 128;        // Restore square to unused.\\n        return false;               // Word not found on this search path.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346841,
                "title": "swift-solution-clean-easy-understand",
                "content": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        guard board.count != 0, board[0].count != 0, word.count != 0 else { return false }\\n        \\n        let word = Array(word)\\n        let rows = board.count, cols = board[0].count\\n        var isVisited = Array(repeating: Array(repeating: false, count: cols), count: rows)\\n        \\n        for row in 0..<rows {\\n            for col in 0..<cols where board[row][col] == word.first {\\n                if check(board, word, row, col, 0, &isVisited) {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func check(_ board: [[Character]], _ word: [Character], _ row: Int, _ col: Int, _ index: Int, _ isVisited: inout [[Bool]]) -> Bool {\\n        // check if reached the end\\n        guard index < word.count else { return true }\\n        \\n        // check if it match requirements\\n        guard   row >= 0, \\n                row < board.count, \\n                col >= 0, \\n                col < board[0].count,\\n                !isVisited[row][col],\\n                board[row][col] == word[index]\\n                else { return false }\\n        \\n        // once we found matched case, we mark isVisited as true\\n        isVisited[row][col] = true\\n        \\n        // try each way, to find if there any valid path\\n        let hasValidPath =  check(board, word, row-1, col, index+1, &isVisited) ||  // go up\\n                            check(board, word, row+1, col, index+1, &isVisited) ||  // go down\\n                            check(board, word, row, col-1, index+1, &isVisited) ||  // go left\\n                            check(board, word, row, col+1, index+1, &isVisited)     // go right\\n        \\n        // reset isVisited after each DFS search, for re use\\n        isVisited[row][col] = false\\n        \\n        return hasValidPath\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        guard board.count != 0, board[0].count != 0, word.count != 0 else { return false }\\n        \\n        let word = Array(word)\\n        let rows = board.count, cols = board[0].count\\n        var isVisited = Array(repeating: Array(repeating: false, count: cols), count: rows)\\n        \\n        for row in 0..<rows {\\n            for col in 0..<cols where board[row][col] == word.first {\\n                if check(board, word, row, col, 0, &isVisited) {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func check(_ board: [[Character]], _ word: [Character], _ row: Int, _ col: Int, _ index: Int, _ isVisited: inout [[Bool]]) -> Bool {\\n        // check if reached the end\\n        guard index < word.count else { return true }\\n        \\n        // check if it match requirements\\n        guard   row >= 0, \\n                row < board.count, \\n                col >= 0, \\n                col < board[0].count,\\n                !isVisited[row][col],\\n                board[row][col] == word[index]\\n                else { return false }\\n        \\n        // once we found matched case, we mark isVisited as true\\n        isVisited[row][col] = true\\n        \\n        // try each way, to find if there any valid path\\n        let hasValidPath =  check(board, word, row-1, col, index+1, &isVisited) ||  // go up\\n                            check(board, word, row+1, col, index+1, &isVisited) ||  // go down\\n                            check(board, word, row, col-1, index+1, &isVisited) ||  // go left\\n                            check(board, word, row, col+1, index+1, &isVisited)     // go right\\n        \\n        // reset isVisited after each DFS search, for re use\\n        isVisited[row][col] = false\\n        \\n        return hasValidPath\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27892,
                "title": "ac-in-84ms-by-using-dfs",
                "content": "I used DFS,  and got AC in 84ms, any improvement?\\n\\n    class Solution {\\n    private:\\n        vector<vector<char> > *board;\\n        string *word;\\n        bool **used;\\n    private:\\n        bool isInboard(int i, int j)\\n        {\\n            if(i < 0)return false;\\n            if(i >= board->size())return false;\\n            if(j < 0)return false;\\n            if(j >= (*board)[i].size())return false;\\n            return true;\\n        }\\n        \\n        bool DFS(int si, int sj, int n)\\n        {\\n            if(n == word->size())return true;\\n            if(isInboard(si, sj))\\n            {\\n                if(!used[si][sj] && (*board)[si][sj] == (*word)[n])\\n                {\\n                    used[si][sj] = true;\\n                    bool ret = false;\\n                    if(DFS(si+1, sj, n+1))\\n                        ret = true;\\n                    else if(DFS(si-1, sj, n+1))\\n                        ret = true;\\n                    else if(DFS(si, sj+1, n+1))\\n                        ret = true;\\n                    else if(DFS(si, sj-1, n+1))\\n                        ret = true;\\n                    used[si][sj] = false;\\n                    return ret;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    public:\\n        bool exist(vector<vector<char> > &board, string word) {\\n            if(board.size() == 0)return false;\\n            this->board = &board;\\n            this->word = &word;\\n            used = new bool*[board.size()];\\n            for(int i = 0; i < board.size(); i ++)\\n            {\\n                used[i] = new bool[board[i].size()];\\n                for(int j = 0; j < board[i].size(); j ++)\\n                    used[i][j] = false;\\n            }\\n            for(int i = 0; i < board.size(); i ++)\\n                for(int j = 0; j < board[i].size(); j ++)\\n                    if(DFS(i, j, 0))return true;\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        vector<vector<char> > *board;\\n        string *word;\\n        bool **used;\\n    private:\\n        bool isInboard(int i, int j)\\n        {\\n            if(i < 0)return false;\\n            if(i >= board->size())return false;\\n            if(j < 0)return false;\\n            if(j >= (*board)[i].size())return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2499933,
                "title": "c-solution-dfs-traversal-backtracking-easiest-solution",
                "content": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>> &board,vector<vector<int>> &visited,string &word,int i,int j,int idx){\\n        // base case\\n        if(idx == word.size()) return true;\\n\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || visited[i][j] == 1 || board[i][j] != word[idx]){\\n            return false;\\n        }\\n\\n        // Marking visited\\n        visited[i][j] = 1;\\n\\n        // traversing all side\\n        bool ls = dfs(board,visited,word,i,j-1,idx+1); // left\\n        bool rs = dfs(board,visited,word,i,j+1,idx+1); // right\\n        bool ds = dfs(board,visited,word,i+1,j,idx+1); // down\\n        bool us = dfs(board,visited,word,i-1,j,idx+1); // up\\n\\n        // Backtracking (If no one is found suitable match)\\n        visited[i][j] = 0;\\n\\n        return ls | rs | ds | us;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j] == 0 && word[0] == board[i][j]){\\n                    if(dfs(board,visited,word,i,j,0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>> &board,vector<vector<int>> &visited,string &word,int i,int j,int idx){\\n        // base case\\n        if(idx == word.size()) return true;\\n\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || visited[i][j] == 1 || board[i][j] != word[idx]){\\n            return false;\\n        }\\n\\n        // Marking visited\\n        visited[i][j] = 1;\\n\\n        // traversing all side\\n        bool ls = dfs(board,visited,word,i,j-1,idx+1); // left\\n        bool rs = dfs(board,visited,word,i,j+1,idx+1); // right\\n        bool ds = dfs(board,visited,word,i+1,j,idx+1); // down\\n        bool us = dfs(board,visited,word,i-1,j,idx+1); // up\\n\\n        // Backtracking (If no one is found suitable match)\\n        visited[i][j] = 0;\\n\\n        return ls | rs | ds | us;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j] == 0 && word[0] == board[i][j]){\\n                    if(dfs(board,visited,word,i,j,0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389952,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27829,
                "title": "c-backtracking-solution-without-extra-data-structure",
                "content": "Use board itself to mark whether we have visited it before.\\n\\n    class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if (board.size() == 0) return false;\\n            for (int i=0; i<board.size(); ++i) {\\n                for (int j=0; j<board[i].size(); ++j) {\\n                    if (search(board, word, i, j, 0)) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        bool search(vector<vector<char>>& board, string word, int i, int j, int pos) {\\n            \\n            if (pos == word.size()) return true;\\n            if ((i<0) || (i >= board.size()) || (j <0) || (j >= board[i].size())) return false;\\n            char c = board[i][j];\\n            if (c == word[pos]) {\\n                board[i][j] = '#';\\n                if (search(board, word, i - 1, j, pos + 1)) return true;\\n                if (search(board, word, i+1, j, pos+1)) return true;\\n                if (search(board, word, i, j-1, pos+1)) return true;\\n                if (search(board, word, i, j+1, pos+1)) return true;\\n                board[i][j] = c;\\n            }\\n            return false;\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if (board.size() == 0) return false;\\n            for (int i=0; i<board.size(); ++i) {\\n                for (int j=0; j<board[i].size(); ++j) {\\n                    if (search(board, word, i, j, 0)) return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2781495,
                "title": "java-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. Using a visited boolean array:\\nWe use a visited boolean array to mark if we have already visited a certain position or not.\\nWhile looking for the next letter, we set the current position to `true`, then we call our DFS then set the position back to `false` because if we don\\'t find the word, we might have to visit that position again during future iterations and DFS calls.\\n```\\nclass Solution {\\n    private boolean[][] visited;\\n    \\n    public boolean exist(char[][] board, String word) {\\n\\t    int m = board.length, n = board[0].length;\\n        visited = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index) || visited[i][j]) {\\n            return false;\\n        }\\n            \\n        visited[i][j] = true;\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        visited[i][j] = false;\\n\\t\\t\\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```\\n##### 2. Marking if visited in place:\\nWe mark a certain position as visited by changing the value to some character, say whitespace (`\\' \\'`), after our calls are done, we set it back to the original character.\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index)) {\\n            return false;\\n        }\\n            \\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        board[i][j] = temp;\\n        \\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private boolean[][] visited;\\n    \\n    public boolean exist(char[][] board, String word) {\\n\\t    int m = board.length, n = board[0].length;\\n        visited = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index) || visited[i][j]) {\\n            return false;\\n        }\\n            \\n        visited[i][j] = true;\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        visited[i][j] = false;\\n\\t\\t\\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == word.charAt(0) && \\n                    dfs(board, i, j, 0, word)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, int i, int j, int index, String word) {\\n        if (index == word.length()) return true;\\n        \\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index)) {\\n            return false;\\n        }\\n            \\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n        \\n        boolean found = \\n        dfs(board, i + 1, j, index + 1, word) ||\\n        dfs(board, i - 1, j, index + 1, word) ||\\n        dfs(board, i, j + 1, index + 1, word) ||\\n        dfs(board, i, j - 1, index + 1, word);\\n            \\n        board[i][j] = temp;\\n        \\n        return found;\\n    }\\n}\\n\\n// TC: O(m * n), SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764505,
                "title": "tle-8000ms-3500ms-finally-python-with-no-tle-pro-optimization-hushh",
                "content": "**Optimization number 1**\\n* Using if -elif instead of for loop helped me resolve TLE:\\nAs if will return as soon as it gets TRUE, for will keep checking next conditions.\\n(Even multiple \"or\" did\\'nt work for me)\\n\\n**\"PLEASE UPVOTE FOR MY AN HOUR SPENT\"**\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:         \\n\\t\\t# as start is not restricted to 0,0 we can start from anywhere, will loop\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n\\t\\t# return True if can make word starting from x, y\\n        if len(word)==c:\\n            return True    \\n\\t\\t# Exit if out of board or char is not required\\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n\\t\\t# move ahead by marking board in path just not to visit again\\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n\\t\\t# if from x,y no one making True, we need to restore x, y as it is not in path\\n\\t\\t# so it is open to use by other paths\\n        board[x][y] = word[c]\\n        return False\\n```\\n\\n**Optimization Pro Max number 2**\\n* Check char in starting only\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:       \\n        # Count number of letters in board and store it in a dictionary\\n        boardDic = collections.defaultdict(int)\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                boardDic[board[i][j]] += 1\\n\\n        # Count number of letters in word\\n        # Check if board has all the letters in the word and they are atleast same count from word\\n        wordDic = collections.Counter(word)\\n        for c in wordDic:\\n            if c not in boardDic or boardDic[c] < wordDic[c]:\\n                return False\\n            \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n        if len(word)==c:\\n            return True    \\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n        board[x][y] = word[c]\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/f789f496-2899-40a4-8966-55302cc3843f_1667244477.9827275.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:         \\n\\t\\t# as start is not restricted to 0,0 we can start from anywhere, will loop\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n\\t\\t# return True if can make word starting from x, y\\n        if len(word)==c:\\n            return True    \\n\\t\\t# Exit if out of board or char is not required\\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n\\t\\t# move ahead by marking board in path just not to visit again\\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n\\t\\t# if from x,y no one making True, we need to restore x, y as it is not in path\\n\\t\\t# so it is open to use by other paths\\n        board[x][y] = word[c]\\n        return False\\n```\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:       \\n        # Count number of letters in board and store it in a dictionary\\n        boardDic = collections.defaultdict(int)\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                boardDic[board[i][j]] += 1\\n\\n        # Count number of letters in word\\n        # Check if board has all the letters in the word and they are atleast same count from word\\n        wordDic = collections.Counter(word)\\n        for c in wordDic:\\n            if c not in boardDic or boardDic[c] < wordDic[c]:\\n                return False\\n            \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if self.dfs(i,j,word, board, 0):\\n                    return True\\n        return False\\n    \\n    def dfs(self, x, y, word, board, c):\\n        if len(word)==c:\\n            return True    \\n        if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y]!=word[c]:\\n            return False      \\n        board[x][y] = \"#\"\\n        if self.dfs(x+1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y+1, word, board, c+1):\\n            return True\\n        elif self.dfs(x-1, y, word, board, c+1):\\n            return True\\n        elif self.dfs(x, y-1, word, board, c+1):\\n            return True \\n        board[x][y] = word[c]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692185,
                "title": "javascript-clean-dfs-solution",
                "content": "```javascript\\nvar exist = function(board, word) {\\n    const ROW_NUM = board.length, COL_NUM = board[0].length;\\n    \\n    function callDFS(r, c, idx) {\\n        if(word.length === idx) return true;\\n        if(r >= ROW_NUM || r < 0 || board[r][c] !== word[idx]) return false; \\n        \\n        board[r][c] = \\'#\\'; // mark as visited\\n        \\n        if (callDFS(r+1, c, idx+1)||\\n            callDFS(r-1, c, idx+1)||\\n            callDFS(r, c+1, idx+1)||\\n            callDFS(r, c-1, idx+1)) return true;\\n            \\n        board[r][c] = word[idx]; // reset the board\\n    }\\n    \\n    for(let r = 0; r < ROW_NUM; r++) {\\n        for(let c = 0; c < COL_NUM; c++) {\\n            if(board[r][c] === word[0] && callDFS(r, c, 0)) return true;\\n        }\\n    }\\n    return false;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar exist = function(board, word) {\\n    const ROW_NUM = board.length, COL_NUM = board[0].length;\\n    \\n    function callDFS(r, c, idx) {\\n        if(word.length === idx) return true;\\n        if(r >= ROW_NUM || r < 0 || board[r][c] !== word[idx]) return false; \\n        \\n        board[r][c] = \\'#\\'; // mark as visited\\n        \\n        if (callDFS(r+1, c, idx+1)||\\n            callDFS(r-1, c, idx+1)||\\n            callDFS(r, c+1, idx+1)||\\n            callDFS(r, c-1, idx+1)) return true;\\n            \\n        board[r][c] = word[idx]; // reset the board\\n    }\\n    \\n    for(let r = 0; r < ROW_NUM; r++) {\\n        for(let c = 0; c < COL_NUM; c++) {\\n            if(board[r][c] === word[0] && callDFS(r, c, 0)) return true;\\n        }\\n    }\\n    return false;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361698,
                "title": "cpp-solution-20-ms-runtime-better-than-100-memory-usage",
                "content": "Implements a simple DFS; Code is commented where I thought necessary, hope this helps. Comment if you have any queries!\\n\\n\\tclass Solution {\\n\\tpulic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n\\t\\t\\tif(board.empty())\\n\\t\\t\\t\\treturn false;\\n        \\n\\t\\t\\tfor(int i=0; i<board.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<board[0].size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(dfs(board, 0, i, j, word))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n        return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>&board, int count, int i, int j, string& word)\\n    {\\n        if(word.size() == count) //Signifies that we have reached the end of search\\n            return true;\\n        \\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || board[i][j]!=word[count])\\n\\t\\treturn false;\\n        //We check if element is within bounds and then check if the character at that is the same as the corresponding character in string word\\n            \\n    \\n        char temp = board[i][j];\\n        board[i][j] = \\' \\'; //To show that we have visited this node\\n        \\n        bool res = dfs(board, count+1, i+1, j, word) || dfs(board, count+1, i-1, j, word) || dfs(board, count+1, i, j+1, word) ||dfs(board, count+1, i, j-1, word); //DFS in all 4 directions\\n        \\n        board[i][j] = temp; //Restore the element after checking\\n        \\n        return res;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpulic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n\\t\\t\\tif(board.empty())\\n\\t\\t\\t\\treturn false;\\n        \\n\\t\\t\\tfor(int i=0; i<board.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<board[0].size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(dfs(board, 0, i, j, word))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 27791,
                "title": "99-77-python-solution-with-precheck",
                "content": "    class Solution(object):\\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def preCheck():\\n            preDict = {}\\n\\n            for i in word:\\n                if i in preDict: preDict[i]+=1\\n                else: preDict[i] = 1\\n            \\n            for i in board:\\n                for j in i:\\n                    if j in preDict and preDict[j]>0: preDict[j]-=1\\n            for i in preDict.values():\\n                if i>0: return False\\n            return True\\n                    \\n        def helper(wordIdx, x, y):\\n            if board[x][y] != word[wordIdx]: return False\\n            elif wordIdx == l-1: return True\\n            else:\\n                wordIdx += 1\\n                tempChar = board[x][y]\\n                board[x][y] = None\\n                for d in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                    xNext = x+d[0]\\n                    yNext = y+d[1]\\n                    if -1<xNext<m and -1<yNext<n and board[xNext][yNext]: \\n                        if helper(wordIdx, xNext, yNext): return True\\n                board[x][y] = tempChar\\n                return False\\n        \\n        if not board: return False\\n        if not word: return True\\n\\n        if not preCheck(): return False\\n        \\n        m = len(board)\\n        n = len(board[0])\\n        l = len(word)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if helper(0,i,j): return True\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def exist(self, board, word):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def preCheck():\\n            preDict = {}",
                "codeTag": "Java"
            },
            {
                "id": 27799,
                "title": "c-solution-using-backtracking",
                "content": "    class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0 || board[0].size()==0 )\\n                return true;\\n            \\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[0].size(); j++){\\n                    if(check(board, word, i, j))\\n                        return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        bool check(vector<vector<char>>& board, string word, int i, int j){\\n            if(word.length()==0)\\n                return true;\\n            if(i<0 || j<0 ||i>=board.size() ||j>=board[0].size())\\n                return false;\\n            if(word[0]==board[i][j]){\\n                char c = word[0];\\n                board[i][j]='\\\\0';\\n                if(check(board,word.substr(1), i+1, j)||\\n                    check(board,word.substr(1), i-1, j)||\\n                    check(board,word.substr(1), i, j+1)||\\n                    check(board,word.substr(1), i, j-1))\\n                    return true;\\n                board[i][j]=c;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0 || board[0].size()==0 )\\n                return true;\\n            \\n            for(int i=0; i<board.size(); i++){\\n                for(int j=0; j<board[0].size(); j++){\\n                    if(check(board, word, i, j))\\n                        return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2778070,
                "title": "java-solutions-easy-to-solve",
                "content": "```\\npublic class Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[i].length; j++){\\n                if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(char[][]board, String word, int i, int j, int index){\\n        if(index == word.length()){\\n            return true;\\n        }\\n        \\n        if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index) || visited[i][j]){\\n            return false;\\n        }\\n        \\n        visited[i][j] = true;\\n        if(search(board, word, i-1, j, index+1) || \\n           search(board, word, i+1, j, index+1) ||\\n           search(board, word, i, j-1, index+1) || \\n           search(board, word, i, j+1, index+1)){\\n            return true;\\n        }\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[i].length; j++){\\n                if((word.charAt(0) == board[i][j]) && search(board, word, i, j, 0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(char[][]board, String word, int i, int j, int index){\\n        if(index == word.length()){\\n            return true;\\n        }\\n        \\n        if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index) || visited[i][j]){\\n            return false;\\n        }\\n        \\n        visited[i][j] = true;\\n        if(search(board, word, i-1, j, index+1) || \\n           search(board, word, i+1, j, index+1) ||\\n           search(board, word, i, j-1, index+1) || \\n           search(board, word, i, j+1, index+1)){\\n            return true;\\n        }\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045876,
                "title": "simple-c-solution-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool issafe(vector<vector<char>>& board,int i, int j,string word, int k){\\n        if(board[i][j]==word[k]){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board,int i, int j,int m,int n,string word, int k){\\n        if(k==word.size()){\\n            return true;\\n        }\\n        if(i < 0 || i == m || j < 0 || j == n){\\n            return false;\\n        }\\n        if(issafe(board,i,j,word,k)){\\n            char temp=board[i][j];\\n            board[i][j]=\\'0\\';\\n            if((solve(board,i+1,j,m,n,word,k+1) || solve(board,i-1,j,m,n,word,k+1) || solve(board,i,j+1,m,n,word,k+1) || solve(board,i,j-1,m,n,word,k+1))){\\n                return true;\\n            }\\n            //backtracking\\n             board[i][j]=temp;\\n        }\\n        \\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(solve(board,i,j,m,n,word,k)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(vector<vector<char>>& board,int i, int j,string word, int k){\\n        if(board[i][j]==word[k]){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board,int i, int j,int m,int n,string word, int k){\\n        if(k==word.size()){\\n            return true;\\n        }\\n        if(i < 0 || i == m || j < 0 || j == n){\\n            return false;\\n        }\\n        if(issafe(board,i,j,word,k)){\\n            char temp=board[i][j];\\n            board[i][j]=\\'0\\';\\n            if((solve(board,i+1,j,m,n,word,k+1) || solve(board,i-1,j,m,n,word,k+1) || solve(board,i,j+1,m,n,word,k+1) || solve(board,i,j-1,m,n,word,k+1))){\\n                return true;\\n            }\\n            //backtracking\\n             board[i][j]=temp;\\n        }\\n        \\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(solve(board,i,j,m,n,word,k)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747440,
                "title": "without-using-visited-array-6ms-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for(int i = 0; i < board.length; i++)\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && isFound(board, i, j, word, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean isFound(char[][] board, int i, int j, String word, int index) {\\n        if(index == word.length()) return true;\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length) return false;\\n        if(word.charAt(index) != board[i][j]) return false;\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n        if(isFound(board, i + 1, j, word, index + 1) ||\\n            isFound(board, i - 1, j, word, index + 1) ||\\n            isFound(board, i, j + 1, word, index + 1) ||\\n            isFound(board, i, j - 1, word, index + 1))\\n            return true;\\n        board[i][j] = temp;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        for(int i = 0; i < board.length; i++)\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && isFound(board, i, j, word, 0))\\n                    return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean isFound(char[][] board, int i, int j, String word, int index) {\\n        if(index == word.length()) return true;\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length) return false;\\n        if(word.charAt(index) != board[i][j]) return false;\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n        if(isFound(board, i + 1, j, word, index + 1) ||\\n            isFound(board, i - 1, j, word, index + 1) ||\\n            isFound(board, i, j + 1, word, index + 1) ||\\n            isFound(board, i, j - 1, word, index + 1))\\n            return true;\\n        board[i][j] = temp;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747095,
                "title": "c-dfs-with-explanation",
                "content": "### Approach\\n1. Search the board for the first letter in the word.\\n2. When we encouter that letter set index to 0 perform DFS. (index - 0 = first letter of word)\\n\\t1. Use a visited array to mark the letters we visited to avoid duplicates\\n\\t2. increment the index to look for the next letter in the word.\\n\\t3. If we have reached the end of the word return true.\\n\\t4. Go to the adjacent 4 cells and see if the next letter is true.\\n\\t5. Each of the adjacent elements will also perform the same process\\n\\t5. If any of the adjacent cell returns true return true.\\n\\t6. If none of the neighbours returned true. mark this node as unvisited and return false\\n3. If any of the starting letter DFS searches return true the return true\\n4. If word was not found return false\\n\\nNOTE: \\n1. Checkbounds function\\nThis function checks if the given indices are valid\\n2. To iterate adjacent cells we use vector - dirs {0,1},{0,-1},{1,0},{-1,0}\\nThese four values will be added to the current index to get new indices.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkBounds(int i,int j,int r,int c){\\n        return i>=0 && i<r && j>=0 && j<c;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,vector<vector<int>>& visited,string& word,int i,int j,int p,int r,int c){\\n        if(visited[i][j]) return false;\\n        visited[i][j] = 1;\\n        p++;\\n        if(p == word.length()) return true;\\n        vector<pair<int,int>>dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        for(auto dir : dirs){\\n            int ii = i+dir.first, jj=j+dir.second;\\n            if(checkBounds(ii,jj,r,c) && board[ii][jj] == word[p] && dfs(board,visited,word,ii,jj,p,r,c)){\\n                return true;\\n            }\\n        }\\n        visited[i][j] = 0;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        char s = word[0];\\n        vector<vector<int>>visited(r,vector<int>(c));\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j] == s && dfs(board,visited,word,i,j,0,r,c)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkBounds(int i,int j,int r,int c){\\n        return i>=0 && i<r && j>=0 && j<c;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,vector<vector<int>>& visited,string& word,int i,int j,int p,int r,int c){\\n        if(visited[i][j]) return false;\\n        visited[i][j] = 1;\\n        p++;\\n        if(p == word.length()) return true;\\n        vector<pair<int,int>>dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        for(auto dir : dirs){\\n            int ii = i+dir.first, jj=j+dir.second;\\n            if(checkBounds(ii,jj,r,c) && board[ii][jj] == word[p] && dfs(board,visited,word,ii,jj,p,r,c)){\\n                return true;\\n            }\\n        }\\n        visited[i][j] = 0;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        char s = word[0];\\n        vector<vector<int>>visited(r,vector<int>(c));\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j] == s && dfs(board,visited,word,i,j,0,r,c)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378925,
                "title": "java-clean-dfs-backtracking-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        /* ensure all the nodes will be searched as the beginning point */\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (dfs(i, j, 0, board, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(int row, int col, int index, char[][] board, String word) {\\n        /*  1. out of bound \\n            2. already visited\\n            3. not match    */\\n        if (checkBound(row, col, board) == -1 || \\n            visited[row][col] || \\n            word.charAt(index) != board[row][col]) {\\n            return false;\\n        }\\n        \\n        /* find one matched character, mark the current node as visited */\\n        visited[row][col] = true;\\n        \\n        /* find the whole word! */\\n        if (index == word.length() - 1) {\\n            return true;\\n        }\\n        \\n        /* continue searching the next char by extending the index of string,\\n        note that the current char may not belong to the word in the final.\\n        even though it matches until now */\\n        index++;\\n    \\n        /* down, right, up, left search */\\n        if (dfs(row + 1, col, index, board, word) ||\\n            dfs(row, col + 1, index, board, word) ||\\n            dfs(row - 1, col, index, board, word) ||\\n            dfs(row, col - 1, index, board, word)) {\\n                return true;\\n            }\\n        \\n        /* current position is wrong, backtracking */\\n        visited[row][col] = false;\\n        return false;\\n    }\\n    \\n    private int checkBound(int row, int col, char[][] board) {\\n        if (row == -1 || row == board.length || col == -1 || col == board[0].length) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        visited = new boolean[board.length][board[0].length];\\n        /* ensure all the nodes will be searched as the beginning point */\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (dfs(i, j, 0, board, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(int row, int col, int index, char[][] board, String word) {\\n        /*  1. out of bound \\n            2. already visited\\n            3. not match    */\\n        if (checkBound(row, col, board) == -1 || \\n            visited[row][col] || \\n            word.charAt(index) != board[row][col]) {\\n            return false;\\n        }\\n        \\n        /* find one matched character, mark the current node as visited */\\n        visited[row][col] = true;\\n        \\n        /* find the whole word! */\\n        if (index == word.length() - 1) {\\n            return true;\\n        }\\n        \\n        /* continue searching the next char by extending the index of string,\\n        note that the current char may not belong to the word in the final.\\n        even though it matches until now */\\n        index++;\\n    \\n        /* down, right, up, left search */\\n        if (dfs(row + 1, col, index, board, word) ||\\n            dfs(row, col + 1, index, board, word) ||\\n            dfs(row - 1, col, index, board, word) ||\\n            dfs(row, col - 1, index, board, word)) {\\n                return true;\\n            }\\n        \\n        /* current position is wrong, backtracking */\\n        visited[row][col] = false;\\n        return false;\\n    }\\n    \\n    private int checkBound(int row, int col, char[][] board) {\\n        if (row == -1 || row == board.length || col == -1 || col == board[0].length) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844418,
                "title": "java-solution-dfs-backtracking-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean [][] visited;\\n    int n,m;\\n    public boolean exist(char[][] board, String word) {\\n        n=board.length;\\n        m=board[0].length;\\n        visited=new boolean[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==word.charAt(0)){\\n                    if(valid(i,j,0,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean valid(int i,int j,int count,char [][] board,String word){\\n        /*-------------base conditions-------------*/\\n        //out of bound\\n        if(i<0 || i>=n || j<0 || j>=m ){\\n            return false;\\n        }\\n\\n        //if already visited\\n        if(visited[i][j]){\\n            return false;\\n        }\\n\\n        //mismatch\\n        if(word.charAt(count)!=board[i][j]){\\n            return false;\\n        }\\n\\n        //if word is found\\n        if(count==word.length()-1){\\n            return true;\\n        }\\n\\n        /*----------------calculation and recursive calls----------*/\\n\\n        //mark current visited\\n        visited[i][j]=true;\\n\\n        //inc count\\n        count++;\\n\\n        //down,right,up,left search\\n        if(valid(i+1,j,count,board,word) ||\\n           valid(i,j+1,count,board,word) ||\\n           valid(i-1,j,count,board,word) ||\\n           valid(i,j-1,count,board,word) ){\\n               return true;\\n           }\\n        \\n        //mark current cell unvisited\\n        visited[i][j]=false;\\n        \\n        return false;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    boolean [][] visited;\\n    int n,m;\\n    public boolean exist(char[][] board, String word) {\\n        n=board.length;\\n        m=board[0].length;\\n        visited=new boolean[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==word.charAt(0)){\\n                    if(valid(i,j,0,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean valid(int i,int j,int count,char [][] board,String word){\\n        /*-------------base conditions-------------*/\\n        //out of bound\\n        if(i<0 || i>=n || j<0 || j>=m ){\\n            return false;\\n        }\\n\\n        //if already visited\\n        if(visited[i][j]){\\n            return false;\\n        }\\n\\n        //mismatch\\n        if(word.charAt(count)!=board[i][j]){\\n            return false;\\n        }\\n\\n        //if word is found\\n        if(count==word.length()-1){\\n            return true;\\n        }\\n\\n        /*----------------calculation and recursive calls----------*/\\n\\n        //mark current visited\\n        visited[i][j]=true;\\n\\n        //inc count\\n        count++;\\n\\n        //down,right,up,left search\\n        if(valid(i+1,j,count,board,word) ||\\n           valid(i,j+1,count,board,word) ||\\n           valid(i-1,j,count,board,word) ||\\n           valid(i,j-1,count,board,word) ){\\n               return true;\\n           }\\n        \\n        //mark current cell unvisited\\n        visited[i][j]=false;\\n        \\n        return false;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094020,
                "title": "0ms-tle-explained-100-faster",
                "content": "Do upvote\\n# Sol #1. DFS (800ms)\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\\n* This solution will take around 800ms\\n* you will get **TLE** if *arr* is passed by value like this in *dfs* function ```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\\n\\n\\n# Sol #2. DFS with Pruning  0ms sol\\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```\\n* **We use the same DFS with some prior analysis.**\\n* **Prune 3 is for such cases**\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\\n\"AAAAAAAAAAAAAAB\"\\nit changes word to \"BAAAAAAAAAAAAAA\"\\n![image](https://assets.leetcode.com/users/images/c4161e1c-960a-47f8-a4d1-903ae22cbbcc_1653990215.8375807.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\n```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918866,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let chs = reverseIfNeeded(Array(word))\\n        if isValid(board, chs) == false { return false }\\n        var res = false\\n        \\n        func backtrack(_ path: [[Int]], _ position: [Int], _ target: Int) {\\n            if res || path.count == target { res = true; return }\\n            \\n            let char = chs[path.count]\\n            let positions = next(board, position, char)\\n            var path = path\\n            \\n            for position in positions {\\n                if path.contains(position) { continue }\\n                \\n                path.append(position)\\n                backtrack(path, position, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtrack([], [-1, -1], chs.count)\\n        return res\\n    }\\n\\n    \\n    func isValid(_ board: [[Character]], _ chars: [Character]) -> Bool {\\n        var res = true\\n        \\n        loop1: for c in chars {\\n            var tmp = false\\n            \\n            loop2: for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == c { tmp = true; break loop2 }\\n                }\\n            }\\n            \\n            if tmp == false { res = false; break loop1 }\\n        }\\n        \\n        return res\\n    }\\n\\n    \\n    func reverseIfNeeded(_ chars: [Character]) -> [Character] {\\n        var headCount = 0\\n        var tailCount = 0\\n        \\n        for c in chars {\\n            if c == chars[0] {\\n                headCount += 1\\n            }\\n            if c == chars[chars.count - 1] {\\n                tailCount += 1\\n            }\\n        }\\n        \\n        if tailCount < headCount {\\n            return chars.reversed()\\n        \\n        } else {\\n            return chars\\n        }\\n    }\\n\\n    \\n    func next(_ board: [[Character]], _ position: [Int], _ char: Character) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        if position[0] == -1 {\\n            for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == char {\\n                        res.append([i, j])\\n                    }\\n                }\\n            }\\n        } else {\\n            var c: Character = \" \"\\n            \\n            if position[0] > 0 {\\n                let i = position[0] - 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[0] < board.count - 1 {\\n                let i = position[0] + 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] > 0 {\\n                let i = position[0]\\n                let j = position[1] - 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] < board[0].count - 1 {\\n                let i = position[0]\\n                let j = position[1] + 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let chs = reverseIfNeeded(Array(word))\\n        if isValid(board, chs) == false { return false }\\n        var res = false\\n        \\n        func backtrack(_ path: [[Int]], _ position: [Int], _ target: Int) {\\n            if res || path.count == target { res = true; return }\\n            \\n            let char = chs[path.count]\\n            let positions = next(board, position, char)\\n            var path = path\\n            \\n            for position in positions {\\n                if path.contains(position) { continue }\\n                \\n                path.append(position)\\n                backtrack(path, position, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtrack([], [-1, -1], chs.count)\\n        return res\\n    }\\n\\n    \\n    func isValid(_ board: [[Character]], _ chars: [Character]) -> Bool {\\n        var res = true\\n        \\n        loop1: for c in chars {\\n            var tmp = false\\n            \\n            loop2: for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == c { tmp = true; break loop2 }\\n                }\\n            }\\n            \\n            if tmp == false { res = false; break loop1 }\\n        }\\n        \\n        return res\\n    }\\n\\n    \\n    func reverseIfNeeded(_ chars: [Character]) -> [Character] {\\n        var headCount = 0\\n        var tailCount = 0\\n        \\n        for c in chars {\\n            if c == chars[0] {\\n                headCount += 1\\n            }\\n            if c == chars[chars.count - 1] {\\n                tailCount += 1\\n            }\\n        }\\n        \\n        if tailCount < headCount {\\n            return chars.reversed()\\n        \\n        } else {\\n            return chars\\n        }\\n    }\\n\\n    \\n    func next(_ board: [[Character]], _ position: [Int], _ char: Character) -> [[Int]] {\\n        var res: [[Int]] = []\\n        \\n        if position[0] == -1 {\\n            for i in 0..<board.count {\\n                for j in 0..<board[0].count {\\n                    if board[i][j] == char {\\n                        res.append([i, j])\\n                    }\\n                }\\n            }\\n        } else {\\n            var c: Character = \" \"\\n            \\n            if position[0] > 0 {\\n                let i = position[0] - 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[0] < board.count - 1 {\\n                let i = position[0] + 1\\n                let j = position[1]\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] > 0 {\\n                let i = position[0]\\n                let j = position[1] - 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n            \\n            if position[1] < board[0].count - 1 {\\n                let i = position[0]\\n                let j = position[1] + 1\\n                c = board[i][j]\\n                c == char ? res.append([i, j]) : ()\\n            }\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653308,
                "title": "some-thoughts-about-the-follow-up-pruning",
                "content": "Since there are already many excellent posts discussing the solution, I\\'ll ignore the discussion of the solution and go directly with the follow up. My solution used backtracking.\\n\\nA very common way for pruning is memoization, in which, we keep record of the \"state\" and the corresponding \"answer\". And once we encounter the same \"state\" again, we can return the \"answer\" directly instead of stepping into the recursion and calculate the answer again. Next, I\\'ll explain how this is implemented and why **memoization doesn\\'t work in this problem**.\\n\\nIn this backtracking, there are three states: the integer i and j represent our current position in the board and an integer d represents the number of digit in the word. Therefore,  we can construct the state key as at position 1 in the backtrack method by combining the three states as a String key. Once we encounter the same state again, we return the previously calculated result directly. And at position 2, once we know that the current state works, we record true and false at position 3.\\n\\nHowever, this doesn\\'t work in this situation. Let\\'s say we started at B(i1, j1, 0) and currently we are at state A(i0, j0, d0) and we calculated that state A(i0, j0, d0) is false. Does that mean if we start with state A(i0, j0, d0), we can\\'t find a match for the remaining words? No. Remeber that we can\\'t visit the positions in the board that was visited in the current path. Therefore if we start from B(i1, j1, 0) and reach A(i0, j0, d0), and then we start from A(i0, j0, d0), there are some positions that we can\\'t visit. But if we start from a different position say C(i2, j2, 0) and reach A(i0, j0, d0), and then start from A(i0, j0, d0), we may be able visit some positions which we can\\'t in the (B->A) path. In short, even if the state A is a \"false\" in the (B->A) path, it still may be a \"true\" in the (C->A) path where C != B. Therefore, memoization doesn\\'t work in this problem.\\n\\nAn **example** here to illustrate:\\n\\nword: \"AABCCA\", board(with index):\\n\\n(x, 0, 1, 2, 3, 4)\\n(0, A, A, B, A, A)\\n(1, D, C, C, D, D)\\n\\nWe start from A(0, 0) -> A(0, 1) -> B(0, 2) -> C(1, 2) -> C(1, 1), and we can\\'t go any further and we record the corresponding states as false. Is this logically correct? No. If later we start from A(0, 4) -> A(0, 3) -> B(0, 2) -> C(1, 2) -> C(1, 1) -> A(0, 1), we can find a valid match. But if we have recorded those states as false, we won\\'t be able to reach this valid match.\\n\\nBut still, there are some ways that we can improve the performance:\\n\\n- Check if the word has more characters than the board does and check if the board contains enough characters of the word. Thanks for @JulianZheng\\'s post [here](https://leetcode.com/problems/word-search/discuss/1225276/Java-99-backtracking-%2B-pruning).\\n- While triggering the backtracking, return true once we find a valid match with a certain start point. Also in the backtrack method, return true once we find a valid match. (Imagine we have a board and a word with all same letters, this can save a lot)\\n\\n**The code is a demo of incorrectly using memo, so it can\\'t pass.**\\n```\\nclass Solution {\\n    int[][] dirs;\\n    Map<String, Boolean> memo;\\n    \\n    public boolean exist(char[][] board, String word) {\\n        dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        memo = new HashMap<>();\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // if the word has more chars than the board does\\n        if (word.length() > m * n) {\\n            return false;\\n        }\\n        \\n        // if the board doesn\\'t contain enough chars of the word\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                char c = board[i][j];\\n                count.put(c, count.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < word.length(); i += 1) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int charCount = count.get(c);\\n                if (charCount == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, charCount - 1);\\n                }\\n            }\\n        }\\n        \\n        // backtracking\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                boolean exists = backtrack(board, i, j, word, 0);\\n                if (exists) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int i, int j, String word, int d) {\\n\\t\\t// position 1\\n\\t\\tString key = i + \",\" + j + \",\" + d;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        if (d == word.length()) {\\n            return true;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n        if (i < 0 || i >= m || j < 0 || j >= n) {\\n            return false;\\n        }\\n        if (board[i][j] == \\'#\\' || board[i][j] != word.charAt(d)) {\\n            return false;\\n        }\\n        \\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        for (int[] dir : dirs) {\\n            boolean exists = backtrack(board, i + dir[0], j + dir[1], word, d + 1);\\n            if (exists) {\\n\\t\\t\\t\\t// position 2\\n\\t\\t\\t\\tmemo.put(key, true);\\n                return true;\\n            }\\n        }\\n        board[i][j] = c;\\n\\t\\t// position 3\\n\\t\\tmemo.put(key, false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs;\\n    Map<String, Boolean> memo;\\n    \\n    public boolean exist(char[][] board, String word) {\\n        dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        memo = new HashMap<>();\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        // if the word has more chars than the board does\\n        if (word.length() > m * n) {\\n            return false;\\n        }\\n        \\n        // if the board doesn\\'t contain enough chars of the word\\n        Map<Character, Integer> count = new HashMap<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                char c = board[i][j];\\n                count.put(c, count.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < word.length(); i += 1) {\\n            char c = word.charAt(i);\\n            if (!count.containsKey(c)) {\\n                return false;\\n            } else {\\n                int charCount = count.get(c);\\n                if (charCount == 1) {\\n                    count.remove(c);\\n                } else {\\n                    count.put(c, charCount - 1);\\n                }\\n            }\\n        }\\n        \\n        // backtracking\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) {\\n                boolean exists = backtrack(board, i, j, word, 0);\\n                if (exists) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int i, int j, String word, int d) {\\n\\t\\t// position 1\\n\\t\\tString key = i + \",\" + j + \",\" + d;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        if (d == word.length()) {\\n            return true;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n        if (i < 0 || i >= m || j < 0 || j >= n) {\\n            return false;\\n        }\\n        if (board[i][j] == \\'#\\' || board[i][j] != word.charAt(d)) {\\n            return false;\\n        }\\n        \\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        for (int[] dir : dirs) {\\n            boolean exists = backtrack(board, i + dir[0], j + dir[1], word, d + 1);\\n            if (exists) {\\n\\t\\t\\t\\t// position 2\\n\\t\\t\\t\\tmemo.put(key, true);\\n                return true;\\n            }\\n        }\\n        board[i][j] = c;\\n\\t\\t// position 3\\n\\t\\tmemo.put(key, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694322,
                "title": "c-solution-easy-understanding-recursion-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(int i,int j,int n,int m,vector<vector<char>>& board, string word,int k){\\n        if(k==word.size()) return true;\\n        if(i<0||j<0||i==n||j==m||board[i][j]!=word[k]) return false;\\n        char ch = board[i][j];\\n        board[i][j]=\\'#\\';\\n        bool opt1= search(i+1,j,n,m,board,word,k+1);\\n        bool opt2= search(i,j+1,n,m,board,word,k+1);\\n        bool opt3= search(i-1,j,n,m,board,word,k+1);\\n        bool opt4= search(i,j-1,n,m,board,word,k+1);\\n        board[i][j]=ch;\\n        return opt1||opt2||opt3||opt4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n =board.size();\\n        int m = board[0].size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(search(i,j,n,m,board,word,0)) return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(int i,int j,int n,int m,vector<vector<char>>& board, string word,int k){\\n        if(k==word.size()) return true;\\n        if(i<0||j<0||i==n||j==m||board[i][j]!=word[k]) return false;\\n        char ch = board[i][j];\\n        board[i][j]=\\'#\\';\\n        bool opt1= search(i+1,j,n,m,board,word,k+1);\\n        bool opt2= search(i,j+1,n,m,board,word,k+1);\\n        bool opt3= search(i-1,j,n,m,board,word,k+1);\\n        bool opt4= search(i,j-1,n,m,board,word,k+1);\\n        board[i][j]=ch;\\n        return opt1||opt2||opt3||opt4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n =board.size();\\n        int m = board[0].size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(search(i,j,n,m,board,word,0)) return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509071,
                "title": "js-dfs-backtracking-beats-88-clean-code",
                "content": "DFS + Backtracking will take you far\\n\\n```\\nconst exist = function(board, word) {\\n    const n = board.length, m = board[0].length;\\n    if (word.length < 1) return false;\\n\\n    const dfs = (i, j, pos) => {\\n        if (i === n || i < 0 || j === m || j < 0 || board[i][j] !== word[pos]) return false;\\n        if (pos === word.length-1) return true;\\n        board[i][j] = \".\"; // choose this elem so we don\\'t find it again\\n        const found = \\n            dfs(i+1,j, pos+1) || // check every direction and see if any of them return a match\\n            dfs(i-1,j, pos+1) ||\\n            dfs(i,j+1, pos+1) ||\\n            dfs(i,j-1, pos+1);\\n\\n        board[i][j] = word[pos]; // unchoose element\\n        return found;\\n    };\\n    \\n    for (let i=0;i<n;i++) {\\n        for (let j=0;j<m;j++) {\\n            if (board[i][j] === word[0]) {\\n                const match = dfs(i,j, 0);\\n                if (match) return true;\\n            }\\n        }\\n    }\\n\\n    return false;\\xA0\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst exist = function(board, word) {\\n    const n = board.length, m = board[0].length;\\n    if (word.length < 1) return false;\\n\\n    const dfs = (i, j, pos) => {\\n        if (i === n || i < 0 || j === m || j < 0 || board[i][j] !== word[pos]) return false;\\n        if (pos === word.length-1) return true;\\n        board[i][j] = \".\"; // choose this elem so we don\\'t find it again\\n        const found = \\n            dfs(i+1,j, pos+1) || // check every direction and see if any of them return a match\\n            dfs(i-1,j, pos+1) ||\\n            dfs(i,j+1, pos+1) ||\\n            dfs(i,j-1, pos+1);\\n\\n        board[i][j] = word[pos]; // unchoose element\\n        return found;\\n    };\\n    \\n    for (let i=0;i<n;i++) {\\n        for (let j=0;j<m;j++) {\\n            if (board[i][j] === word[0]) {\\n                const match = dfs(i,j, 0);\\n                if (match) return true;\\n            }\\n        }\\n    }\\n\\n    return false;\\xA0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507620,
                "title": "c-simple-to-understand-using-dfs-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public bool Exist(char[][] board, string word) {\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public bool Exist(char[][] board, string word) {\\n        \\n        // Create a \\'visitied\\' node matrix to keep track of the\\n        // items we\\'ve already seen\\n        var rowsVisited = new bool[board.Length][];\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            rowsVisited[rowIndex] = new bool[board[rowIndex].Length];\\n        }\\n        \\n        // Start at the root node and explore as far as possible along each branch\\n        for (int rowIndex = 0; rowIndex < board.Length; ++rowIndex) {\\n            for (int colIndex = 0; colIndex < board[rowIndex].Length; ++colIndex) {\\n                if (DFS(board, rowIndex, colIndex, 0, word, rowsVisited)) {\\n                    return true;                    \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool DFS(char[][] board, int row, int col, int searchIndex, string word, bool[][] rowsVisited) {\\n        // Make sure the search paramaters are in bounds\\n        if (searchIndex >= word.Length) {\\n            return true;            \\n        }\\n        if (row < 0 || row >= board.Length || col < 0 || col >= board[row].Length) {\\n            return false;            \\n        }       \\n        if (rowsVisited[row][col]) {\\n            return false;            \\n        } \\n        if (board[row][col] != word[searchIndex]) {\\n            return false;            \\n        }        \\n        \\n        // Mark that this row has been visited\\n        rowsVisited[row][col] = true;\\n        \\n        var searchResult = \\n            // Search left\\n            DFS(board, row, col - 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search right\\n            DFS(board, row, col + 1, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search top\\n            DFS(board, row - 1, col, searchIndex + 1, word, rowsVisited) ||\\n            \\n            // Search bottom\\n            DFS(board, row + 1, col, searchIndex + 1, word, rowsVisited);\\n        \\n        // Unmark that this row has been visited\\n        rowsVisited[row][col] = false;\\n        \\n        return searchResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330278,
                "title": "c-concise-dfs",
                "content": "```\\nbool dfs(vector<vector<char>>& board, int i, int j, string& word)\\n    {\\n        if(word.size() == 0) \\n            return true;\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[0])\\n            return false;\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'*\\';\\n        string s = word.substr(1);\\n        bool res = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        \\n        board[i][j] = ch;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(dfs(board, i, j, word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nbool dfs(vector<vector<char>>& board, int i, int j, string& word)\\n    {\\n        if(word.size() == 0) \\n            return true;\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[0])\\n            return false;\\n        \\n        char ch = board[i][j];\\n        board[i][j] = \\'*\\';\\n        string s = word.substr(1);\\n        bool res = dfs(board, i-1, j, s) || dfs(board, i+1, j, s) || dfs(board, i, j-1, s) || dfs(board, i, j+1, s);\\n        \\n        board[i][j] = ch;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(dfs(board, i, j, word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745176,
                "title": "word-search-python3-solution-with-a-detailed-explanation",
                "content": "This solution comes from [here](https://leetcode.com/problems/word-search/discuss/27665/Python-simple-dfs-solution). The idea is that you loop over every element of a matrix one by one (lines `#1` and `#2`), and check whether you can find the word. The main part is the `dfs` function that for each value (`board[i][j]`) check whether it\\'s the first letter of the `word`. If it\\'s not it returns `False` (line `#5`). Otherwise, it moves forward (line `#4`). After satisfying line `#4` (meaning first letter is found), we replace  that cell in `board` with space so that we now we\\'ve visited it (line `#6`). Then, we try four different scenarios in the neighborhood of `[i][j]` and see whether we can find the second letter of `word` (line `#7, 8, 9, 10`). This is done recursively. After we find the first letter in line `#4`, we focus on the rest of the `word`, meaning `word[1:]`. If the second letter is one of the right, left, top, or bottom cells of `board[i][j]`, we focus of `word[2:]` in the next cycle. We keep doing this until we find all the letters. Now say, we find the first letter, but the second letter is not in the neighborhood, we go to a new `board[i][j]` by checking a new cell in lines `#1, 2, 3` and start the process from scratch for the whole `word`. \\n\\n\\nNote that the conditions of lines `#7` ( `i>0`), `#8` (` i < len(board) - 1 `), etc. takes care of matrix edges. If it wasn\\'t there, and you\\'re on the first column of matrix (`j=0`), then `j - 1` would give you `-1` which is corresponding to the right side. \\n\\n\\n\\n\\nDoes this make sense? \\n\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not board:\\n            return False\\n        if not word:\\n            return True\\n        \\n        for i in range(len(board)): # 1\\n            for j in range(len(board[0])): # 2\\n                if self.dfs(board, word, i, j): #3\\n                    return True\\n        return False   \\n        \\n    \\n    def dfs(self, board, word, i, j):\\n        if board[i][j] == word[0]: #4\\n            if not word[1:]:\\n                return True\\n        \\n            board[i][j] = \" \" #6\\n        \\n            if i > 0 and self.dfs(board, word[1:], i - 1, j): #7\\n                return True\\n            if i < len(board) - 1 and self.dfs(board, word[1:], i + 1, j): #8\\n                return True\\n            if j > 0 and self.dfs(board, word[1:], i, j - 1): #9\\n                return True\\n            if j < len(board[0]) - 1 and self.dfs(board, word[1:], i, j + 1): #10\\n                return True\\n        \\n            board[i][j] = word[0]\\n            return False\\n        else: #5\\n            return False\\n```\\n\\n========================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it. \\n\\nFinal note 2: Explaning things in a simple language is instructive for me. Thanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not board:\\n            return False\\n        if not word:\\n            return True\\n        \\n        for i in range(len(board)): # 1\\n            for j in range(len(board[0])): # 2\\n                if self.dfs(board, word, i, j): #3\\n                    return True\\n        return False   \\n        \\n    \\n    def dfs(self, board, word, i, j):\\n        if board[i][j] == word[0]: #4\\n            if not word[1:]:\\n                return True\\n        \\n            board[i][j] = \" \" #6\\n        \\n            if i > 0 and self.dfs(board, word[1:], i - 1, j): #7\\n                return True\\n            if i < len(board) - 1 and self.dfs(board, word[1:], i + 1, j): #8\\n                return True\\n            if j > 0 and self.dfs(board, word[1:], i, j - 1): #9\\n                return True\\n            if j < len(board[0]) - 1 and self.dfs(board, word[1:], i, j + 1): #10\\n                return True\\n        \\n            board[i][j] = word[0]\\n            return False\\n        else: #5\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844358,
                "title": "c-dfs-backtracking-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool search(int index,int i,int j,vector<vector<char>> &board, string word){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(i<0 || j<0 || i >= board.size() || j >= board[0].size()){\\n            return false;\\n        }\\n        bool ans = false;\\n        if(word[index] == board[i][j]){\\n            board[i][j] = \\'*\\';\\n            \\n            ans = search(index+1,i+1,j,board,word) || search(index+1,i,j+1,board,word) || \\n                search(index+1,i-1,j,board,word) ||search(index+1,i,j-1,board,word);\\n            \\n            board[i][j] = word[index];\\n        }\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board[0].size();\\n        int n = board.size();\\n         int index  = 0;\\n        \\n        bool ans = false;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(word[index] == board[i][j]){\\n                    if(search(index,i,j,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(int index,int i,int j,vector<vector<char>> &board, string word){\\n        if(index == word.size()){\\n            return true;\\n        }\\n        if(i<0 || j<0 || i >= board.size() || j >= board[0].size()){\\n            return false;\\n        }\\n        bool ans = false;\\n        if(word[index] == board[i][j]){\\n            board[i][j] = \\'*\\';\\n            \\n            ans = search(index+1,i+1,j,board,word) || search(index+1,i,j+1,board,word) || \\n                search(index+1,i-1,j,board,word) ||search(index+1,i,j-1,board,word);\\n            \\n            board[i][j] = word[index];\\n        }\\n        return ans;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board[0].size();\\n        int n = board.size();\\n         int index  = 0;\\n        \\n        bool ans = false;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(word[index] == board[i][j]){\\n                    if(search(index,i,j,board,word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426224,
                "title": "js-backtrack-dfs",
                "content": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//since its a 2D array, instead of looping once, we will loop twice, over the row and column of the board\\n//then to choose, we will just mark the visited index with \\'*\\'\\n//to explore, we will be exploring left, right, up, down of the board from the current spot/box\\n//then to unchoose, we will just replace the \\'*\\' with the letter we had replaced\\n//\\n//so basically, \\n//we will start from the [0][0] of the board, and start checking if the letter in that spot is equal to the letter in the given word\\n//if it is equal, we recurse to find possible matching letter from the board\\n//we increment the wordIndex by 1, we also replace the spot with \\'*\\' \\n//and then backtrack check to see if the neighbors(left, right, up, down) have the new letter from the given word\\n//if somehow the boundary check fails or the letter check fails, we return false, \\n//if all of the check fails while backtracking we start replacing the \\'*\\' with the actual letters we stored in our temp variable\\n//then return the result back.\\nvar exist = function(board, word) {\\n    if(board == null || word == null || board.length == 0) //edge case\\n        return false;\\n    \\n    \\n    for(let row = 0; row < board.length; row++){\\n        for(let col = 0; col < board[0].length; col++){\\n            if(helper(board, word, row, col, 0))  //recursive check\\n                return true;\\n        }\\n    }\\n    \\n    \\n    function helper(board, word, row, col, wordIndex){\\n        \\n        if(wordIndex == word.length) \\n            return true;\\n        \\n        //out of bounds check\\n        if(row < 0 || row >= board.length || col < 0  || col >= board[0].length)\\n            return false;\\n        \\n        //letter check in the box (if the letter at the board is not equal to the letter of the given word return false)\\n        if(board[row][col] != word[wordIndex])\\n            return false;\\n        \\n        //choose\\n        let temp = board[row][col];\\n        board[row][col] = \\'*\\';          //marking the visited box\\n        \\n        //explore\\n        let bool = helper(board, word, row-1, col, wordIndex+1) ||\\n            helper(board, word, row+1, col, wordIndex+1) ||\\n            helper(board, word, row, col-1, wordIndex+1) ||\\n            helper(board, word, row, col+1, wordIndex+1);\\n    \\n        //unchoose\\n        board[row][col] = temp;        //setting back the value from \\'*\\' to the letter\\n        \\n        return bool;\\n    }\\n    \\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//approach: backtracking(dfs)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (Oth value), so then you can now start with other value to make that other value 0th value\\n//in this case: \\n//since its a 2D array, instead of looping once, we will loop twice, over the row and column of the board\\n//then to choose, we will just mark the visited index with \\'*\\'\\n//to explore, we will be exploring left, right, up, down of the board from the current spot/box\\n//then to unchoose, we will just replace the \\'*\\' with the letter we had replaced\\n//\\n//so basically, \\n//we will start from the [0][0] of the board, and start checking if the letter in that spot is equal to the letter in the given word\\n//if it is equal, we recurse to find possible matching letter from the board\\n//we increment the wordIndex by 1, we also replace the spot with \\'*\\' \\n//and then backtrack check to see if the neighbors(left, right, up, down) have the new letter from the given word\\n//if somehow the boundary check fails or the letter check fails, we return false, \\n//if all of the check fails while backtracking we start replacing the \\'*\\' with the actual letters we stored in our temp variable\\n//then return the result back.\\nvar exist = function(board, word) {\\n    if(board == null || word == null || board.length == 0) //edge case\\n        return false;\\n    \\n    \\n    for(let row = 0; row < board.length; row++){\\n        for(let col = 0; col < board[0].length; col++){\\n            if(helper(board, word, row, col, 0))  //recursive check\\n                return true;\\n        }\\n    }\\n    \\n    \\n    function helper(board, word, row, col, wordIndex){\\n        \\n        if(wordIndex == word.length) \\n            return true;\\n        \\n        //out of bounds check\\n        if(row < 0 || row >= board.length || col < 0  || col >= board[0].length)\\n            return false;\\n        \\n        //letter check in the box (if the letter at the board is not equal to the letter of the given word return false)\\n        if(board[row][col] != word[wordIndex])\\n            return false;\\n        \\n        //choose\\n        let temp = board[row][col];\\n        board[row][col] = \\'*\\';          //marking the visited box\\n        \\n        //explore\\n        let bool = helper(board, word, row-1, col, wordIndex+1) ||\\n            helper(board, word, row+1, col, wordIndex+1) ||\\n            helper(board, word, row, col-1, wordIndex+1) ||\\n            helper(board, word, row, col+1, wordIndex+1);\\n    \\n        //unchoose\\n        board[row][col] = temp;        //setting back the value from \\'*\\' to the letter\\n        \\n        return bool;\\n    }\\n    \\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1068073,
                "title": "java-solution-4-ms-faster-than-99-10-using-backtracking",
                "content": "**PLEASE UPVOTE THIS SOLUTION IF YOU LIKE THIS** \\u270C\\uFE0F\\n\\nIntiuition:  \\n- To search a word in grid, we can start from a index (x, y) and then try every direction using dfs.\\n- If word char is match with the cell than Increment the wordIndex and try that cell neighbour.\\n- if word doesn\\'t match then replace the char with original cell char\\n\\n\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int x = 0; x < board.length; x++){\\n\\t\\t    for(int y = 0; y < board[0].length; y++){\\n\\t\\t\\t\\t//start from every cell, \\n\\t\\t\\t\\t//if any of found the word in the grid, return true\\n                if(exist(board, x, y, word, 0)) return true;\\n            }\\n        }\\n        \\n\\t\\t//if not found\\n        return false;\\n    }\\n    \\n    public boolean exist(char[][] board, int x, int y, String word, int wordIndex){\\n\\n        if(wordIndex == word.length()) return true;\\n        \\n\\t\\t//check boundary of grid\\n        if( x < 0 || x >= board.length ||  y < 0 ||  y >= board[0].length) return false;\\n\\t\\t\\n\\t\\tchar currCellChar =  board[x][y];\\n\\t\\t\\n\\t\\t//check currently, this cell is being used for dfs\\n\\t\\tif(currCellChar == \\'$\\') return false;\\n\\t\\t \\n\\t\\t //check cell char is equal to  current char of word\\n\\t\\tif(currCellChar != word.charAt(wordIndex)) return false;\\n        \\n\\t\\t//mark this cell as used\\n        board[x][y] = \\'$\\';\\n        \\n        boolean isExist = exist(board, x + 1, y, word, wordIndex + 1) ||    // direction UP \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x - 1, y, word, wordIndex + 1) ||    // direction DOWN\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y + 1, word, wordIndex + 1) ||   // direction RIGHT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y - 1, word, wordIndex + 1);     // direction LEFT\\n            \\n\\t\\t//for the backtracking, try different possibilty,  now unmark this cell as free, \\t\\n        board[x][y] = currCellChar;\\n        \\n        return isExist;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        \\n        for(int x = 0; x < board.length; x++){\\n\\t\\t    for(int y = 0; y < board[0].length; y++){\\n\\t\\t\\t\\t//start from every cell, \\n\\t\\t\\t\\t//if any of found the word in the grid, return true\\n                if(exist(board, x, y, word, 0)) return true;\\n            }\\n        }\\n        \\n\\t\\t//if not found\\n        return false;\\n    }\\n    \\n    public boolean exist(char[][] board, int x, int y, String word, int wordIndex){\\n\\n        if(wordIndex == word.length()) return true;\\n        \\n\\t\\t//check boundary of grid\\n        if( x < 0 || x >= board.length ||  y < 0 ||  y >= board[0].length) return false;\\n\\t\\t\\n\\t\\tchar currCellChar =  board[x][y];\\n\\t\\t\\n\\t\\t//check currently, this cell is being used for dfs\\n\\t\\tif(currCellChar == \\'$\\') return false;\\n\\t\\t \\n\\t\\t //check cell char is equal to  current char of word\\n\\t\\tif(currCellChar != word.charAt(wordIndex)) return false;\\n        \\n\\t\\t//mark this cell as used\\n        board[x][y] = \\'$\\';\\n        \\n        boolean isExist = exist(board, x + 1, y, word, wordIndex + 1) ||    // direction UP \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x - 1, y, word, wordIndex + 1) ||    // direction DOWN\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y + 1, word, wordIndex + 1) ||   // direction RIGHT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  exist(board, x, y - 1, word, wordIndex + 1);     // direction LEFT\\n            \\n\\t\\t//for the backtracking, try different possibilty,  now unmark this cell as free, \\t\\n        board[x][y] = currCellChar;\\n        \\n        return isExist;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748682,
                "title": "python-3-dfs-backtracking",
                "content": "```\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(board,i,j,count,word):\\n            if(count == len(word)):\\n                return True\\n            if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or word[count]!=board[i][j]:\\n                return False\\n            temp = board[i][j]\\n            board[i][j] = \"\"\\n            found = dfs(board,i+1,j,count+1,word) or dfs(board,i-1,j,count+1,word) or dfs(board,i,j+1,count+1,word) or dfs(board,i,j-1,count+1,word)\\n            board[i][j] = temp\\n            return found\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and dfs(board,i,j,0,word):\\n                    return True\\n        return False",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def dfs(board,i,j,count,word):\\n            if(count == len(word)):\\n                return True\\n            if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or word[count]!=board[i][j]:\\n                return False\\n            temp = board[i][j]\\n            board[i][j] = \"\"\\n            found = dfs(board,i+1,j,count+1,word) or dfs(board,i-1,j,count+1,word) or dfs(board,i,j+1,count+1,word) or dfs(board,i,j-1,count+1,word)\\n            board[i][j] = temp\\n            return found\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and dfs(board,i,j,0,word):\\n                    return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 747107,
                "title": "java-dfs-simple-solution",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n```\\nclass Solution {\\n    boolean visited[][];\\n    public boolean exist(char[][] board, String word) {\\n        \\tvisited= new boolean[board.length][board[0].length];\\n\\t\\tfor(int i=0; i<board.length; i++)\\n\\t\\t\\tfor(int j=0; j<board[0].length; j++)\\n\\t\\t\\t\\tif(board[i][j]==word.charAt(0) && search(i,j,0,board,word))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\tprivate boolean search(int i, int j, int index, char[][] board, String word) {\\n\\t\\tif(index==word.length())\\n\\t\\t\\treturn true;\\n\\t\\tif(i>=board.length|| i<0 || j<0 || j>= board[0].length \\n\\t\\t\\t\\t|| visited[i][j] || word.charAt(index)!=board[i][j])\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tvisited[i][j]=true;\\n\\t\\tif(search(i+1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i-1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i, j+1, index+1, board, word)||\\n\\t\\t\\tsearch(i, j-1, index+1, board, word))\\n\\t\\t\\treturn true;\\n\\t\\t\\n\\t\\tvisited[i][j]=false;\\n\\t\\treturn false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean visited[][];\\n    public boolean exist(char[][] board, String word) {\\n        \\tvisited= new boolean[board.length][board[0].length];\\n\\t\\tfor(int i=0; i<board.length; i++)\\n\\t\\t\\tfor(int j=0; j<board[0].length; j++)\\n\\t\\t\\t\\tif(board[i][j]==word.charAt(0) && search(i,j,0,board,word))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\tprivate boolean search(int i, int j, int index, char[][] board, String word) {\\n\\t\\tif(index==word.length())\\n\\t\\t\\treturn true;\\n\\t\\tif(i>=board.length|| i<0 || j<0 || j>= board[0].length \\n\\t\\t\\t\\t|| visited[i][j] || word.charAt(index)!=board[i][j])\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tvisited[i][j]=true;\\n\\t\\tif(search(i+1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i-1, j, index+1, board, word)||\\n\\t\\t\\tsearch(i, j+1, index+1, board, word)||\\n\\t\\t\\tsearch(i, j-1, index+1, board, word))\\n\\t\\t\\treturn true;\\n\\t\\t\\n\\t\\tvisited[i][j]=false;\\n\\t\\treturn false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715627,
                "title": "dfs-backtracking-solution-without-extra-space-visited-map",
                "content": "```\\nfunc exist(board [][]byte, word string) bool {\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tif board[i][j] == word[0] {\\n\\t\\t\\t\\trs := dfs(board, i, j, 0, word)\\n\\n\\t\\t\\t\\tif rs {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, i, j, pos int, word string) bool {\\n\\tif i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) || board[i][j] == \\'*\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif word[pos] != board[i][j] {\\n\\t\\treturn false\\n\\t}\\n  \\n\\tif len(word)-1 == pos {\\n\\t\\treturn true\\n\\t}\\n\\n\\tpos++\\n    tmp := board[i][j]\\n\\tboard[i][j] = \\'*\\'\\n\\n\\tdfsResult :=\\n\\t\\tdfs(board, i-1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i+1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i, j+1, pos, word) ||\\n\\t\\t\\tdfs(board, i, j-1, pos, word)\\n    board[i][j] = tmp\\n  \\n\\treturn dfsResult\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc exist(board [][]byte, word string) bool {\\n\\tfor i := 0; i < len(board); i++ {\\n\\t\\tfor j := 0; j < len(board[0]); j++ {\\n\\t\\t\\tif board[i][j] == word[0] {\\n\\t\\t\\t\\trs := dfs(board, i, j, 0, word)\\n\\n\\t\\t\\t\\tif rs {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc dfs(board [][]byte, i, j, pos int, word string) bool {\\n\\tif i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) || board[i][j] == \\'*\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif word[pos] != board[i][j] {\\n\\t\\treturn false\\n\\t}\\n  \\n\\tif len(word)-1 == pos {\\n\\t\\treturn true\\n\\t}\\n\\n\\tpos++\\n    tmp := board[i][j]\\n\\tboard[i][j] = \\'*\\'\\n\\n\\tdfsResult :=\\n\\t\\tdfs(board, i-1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i+1, j, pos, word) ||\\n\\t\\t\\tdfs(board, i, j+1, pos, word) ||\\n\\t\\t\\tdfs(board, i, j-1, pos, word)\\n    board[i][j] = tmp\\n  \\n\\treturn dfsResult\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844365,
                "title": "java-brute-force-to-search-pruning-fully-explained",
                "content": "# Intuition\\nWe need to construct the given word from the characters in the board. This is a trial-and-error algorithm which we will solve using `backtracking`.\\n\\nNote: While meeting this question for the first time a few years ago, I thought of doing it with DP. The reason why DP doesn\\'t work here is that you cannot form smaller sub-problems because the path with which you arrive at some cell `(r, c)` changes with every move. Hence, you have conditional state that cannot be memoized (calculated for other problems).\\n\\nThe naive approach is to construct all the possible words of `length = given_word.length` and check for equality.\\n\\nThe code will look like this\\n\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, StringBuilder s) {\\n        // The reason I mutate the state here, and not before calling dfs() is because there are 2 places calling the function. And I don\\'t want to duplicate the logic\\n        s.append(board[row][col]);\\n        vis[row][col] = true;\\n\\n        if (s.length() == word.length()) {\\n            boolean hasFound = s.toString().equals(word);\\n            s.deleteCharAt(s.length() - 1);\\n            vis[row][col] = false;\\n            return hasFound;\\n        }\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        s.deleteCharAt(s.length() - 1);\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n\\nThis is inefficient because if we are looking for the word \"hello\" there is no point matching it with \"abcdef\". We can prune the searching on the first index, i.e. \"h\" != \"a\", therefore we don\\'t have to continue searching on that path.\\n\\nSo to optimize our algorithm we will keep track of the index we located at, and compare the letter on each index. If we reach the last index it means we built the whole string.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, int i) {\\n        if(board[row][col] != word.charAt(i)) return false;\\n\\n        if (i == word.length() -1) return true;\\n\\n        vis[row][col] = true;\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n\\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, i + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n\\nNote 2: you can optimize the algorithm by doing the checks before calling dfs(). I omitted that here for brevity.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, StringBuilder s) {\\n        // The reason I mutate the state here, and not before calling dfs() is because there are 2 places calling the function. And I don\\'t want to duplicate the logic\\n        s.append(board[row][col]);\\n        vis[row][col] = true;\\n\\n        if (s.length() == word.length()) {\\n            boolean hasFound = s.toString().equals(word);\\n            s.deleteCharAt(s.length() - 1);\\n            vis[row][col] = false;\\n            return hasFound;\\n        }\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            \\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, s)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        s.deleteCharAt(s.length() - 1);\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        StringBuilder s = new StringBuilder();\\n        boolean[][] vis = new boolean[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (dfs(board, vis, word, r, c, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean dfs(char[][] board, boolean[][] vis, String word, int row, int col, int i) {\\n        if(board[row][col] != word.charAt(i)) return false;\\n\\n        if (i == word.length() -1) return true;\\n\\n        vis[row][col] = true;\\n\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for (int[] dir : dirs) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n\\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !vis[newRow][newCol]) {\\n                if (dfs(board, vis, word, newRow, newCol, i + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        vis[row][col] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362461,
                "title": "python-simple-and-clean-backtracking-solution",
                "content": "**If you like Pls Upvote :-)**\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        rows=len(board)\\n        cols=len(board[0])\\n        visited=set()\\n        def dfs(i,j,curr):\\n            if curr==len(word):\\n                return True\\n            \\n            if i<0 or j>=cols or j<0 or i>=rows or board[i][j]!=word[curr] or (i,j) in visited:\\n                return False\\n            \\n            visited.add((i,j))\\n            res=dfs(i+1,j,curr+1) or dfs(i-1,j,curr+1) or dfs(i,j+1,curr+1) or dfs(i,j-1,curr+1)\\n            visited.remove((i,j))\\n            return res\\n            \\n        for i in range(rows):\\n            for j in range(cols):\\n                if dfs(i,j,0): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        rows=len(board)\\n        cols=len(board[0])\\n        visited=set()\\n        def dfs(i,j,curr):\\n            if curr==len(word):\\n                return True\\n            \\n            if i<0 or j>=cols or j<0 or i>=rows or board[i][j]!=word[curr] or (i,j) in visited:\\n                return False\\n            \\n            visited.add((i,j))\\n            res=dfs(i+1,j,curr+1) or dfs(i-1,j,curr+1) or dfs(i,j+1,curr+1) or dfs(i,j-1,curr+1)\\n            visited.remove((i,j))\\n            return res\\n            \\n        for i in range(rows):\\n            for j in range(cols):\\n                if dfs(i,j,0): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123807,
                "title": "0ms-tle-explained-easy-100-fast",
                "content": "\\t Do upvote\\u2764\\uFE0F\\n# Sol #1. DFS (800ms)\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\\n* This solution will take around 800ms\\n* you will get **TLE** if *arr* is passed by value like this in *dfs* function ```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\\n\\n\\n# Sol #2. DFS with Pruning  0ms sol\\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```\\n* **We use the same DFS with some prior analysis.**\\n* **Prune 3 is for such cases**\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"]]\\n\"AAAAAAAAAAAAAAB\"\\nit changes word to \"BAAAAAAAAAAAAAA\"\\n![image](https://assets.leetcode.com/users/images/c4161e1c-960a-47f8-a4d1-903ae22cbbcc_1653990215.8375807.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)//pass arr by reference\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            \\n\\t\\t\\tarr[r][c]=\\'*\\'; // changed in orignal arr to avoid taking same occurence of alphabet in arr for different occurences in word\\n            \\n\\t\\t\\tbool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1]; //as arr is passed by reference all changes must be reversed before next iteration\\n        return res;\\n            \\n\\n\\n    }\\n    \\n    bool exist(vector<vector<char>>& arr, string word) \\n    {\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n        \\n    }\\n};\\n```\n```bool dfs(vector<vector<char>> arr, string word, int k, int r, int c) ```\n```\\nclass Solution \\n{\\n    bool dfs(vector<vector<char>> &arr, string word, int k, int r, int c)\\n    {\\n        \\n        if(r>=arr.size()||r<0||c>=arr[0].size()||c<0||arr[r][c] != word[k])\\n            return false;\\n\\n            k++;\\n            if(k==word.size())\\n                return true;\\n            arr[r][c]=\\'.\\';\\n            bool res =  dfs(arr,word,k,r+1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r-1,c) || \\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c+1) ||\\n\\t\\t\\t\\t\\t\\tdfs(arr,word,k,r,c-1);\\n            \\n            arr[r][c]=word[k-1];\\n        return res;\\n    }\\n    \\npublic:\\n    bool exist(vector<vector<char>>& arr, string& word) {\\n        int R = arr.size(), C = arr[0].size(), N = word.size();\\n\\n        // Prune #1: the arr cannot contain the word.\\n        if (N > R * C) return false;\\n\\n        // Prune #2: the arr does not contain all occurrences of the chars in the word.\\n        unordered_map<char, int> occ;\\n        for (auto& row : arr) for (auto& c : row) ++occ[c];\\n        for (auto& c : word) if(--occ[c] < 0) return false;\\n\\n        // Prune #3: Find the longest prefix/suffix of the same character. If the longest\\n        // suffix is longer than the longest prefix, swap the strigns (so we are less\\n        // likely to have a long prefix with a lot of the same character).\\n        int left = word.find_first_not_of(word[0]);\\n        int right = N - word.find_last_not_of(word[N - 1]);\\n        if (left > right) reverse(begin(word), end(word));\\n\\n        for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr[0].size();++j)\\n                if(dfs(arr,word,0,i,j))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538495,
                "title": "python-solution-using-backtracking-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 1412ms   -   94.74%\\n#   Memory: 14.2MB  -   71.98%\\n\\n######################################################\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        # Below code will help in reducing time complexity significantly.\\n        # What below code does is, it creates a set with all chars present in board\\n        # and then it will check whether all chars in word are present in board\\n        # If a char in word is not present in the board, we can\\'t find the word in \\n        # board. So we return False\\n        # Without these lines of code, I got a Time Complexity of 8000+ ms\\n        # After adding these lines of code, my TC reduced to just 1400+ ms\\n        # Why this drastic change is, since we are checking all possible strings\\n        # using a backtracking paradigm, there will be some cases where we go to so\\n        # much deep just to find the required char is not even present in the board\\n        # So we are eliminating it before hand.\\n        characters = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] not in characters: characters.add(board[i][j])\\n        \\n        for s in word: \\n            if s not in characters: return False\\n        \\n        def dfs(row, col, index, visited):\\n            # index represents current index of word string\\n            # Checking for out of bounds indices and returning False\\n            if row < 0 or row > len(board) - 1 or col < 0 or col > len(board[0]) - 1: return False\\n            # If we already visited current cell, return False\\n            if (row, col) in visited: return False\\n            # If char at cell (row, col) matches with word[index] we go next char\\n            # in all the 4 directions\\n            if board[row][col] == word[index]:\\n                visited.add((row, col))\\n                # If we reach end of word return Trur\\n                if index == len(word) - 1: return True\\n                isExist = (\\n                            dfs(row, col - 1, index + 1, visited) or \\n                            dfs(row, col + 1, index + 1, visited) or\\n                            dfs(row - 1, col, index + 1, visited) or \\n                            dfs(row + 1, col, index + 1, visited)\\n                       )   \\n                # Why we are removing at the end is, we might encounter this cell\\n                # again in some other path if this path didn\\'t give us required \\n                # word. In that path, we haven\\'t yet visited the cell right. So, we\\n                # are removing it.\\n                visited.remove((row, col))\\n                return isExist\\n            \\n            return False\\n        \\n        # Running DFS when the char in the cell (i,j) matches with word[0] i.e; \\n        # starting of the word\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    visited = set()\\n                    if dfs(i, j, 0, visited): return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 1412ms   -   94.74%\\n#   Memory: 14.2MB  -   71.98%\\n\\n######################################################\\n\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        # Below code will help in reducing time complexity significantly.\\n        # What below code does is, it creates a set with all chars present in board\\n        # and then it will check whether all chars in word are present in board\\n        # If a char in word is not present in the board, we can\\'t find the word in \\n        # board. So we return False\\n        # Without these lines of code, I got a Time Complexity of 8000+ ms\\n        # After adding these lines of code, my TC reduced to just 1400+ ms\\n        # Why this drastic change is, since we are checking all possible strings\\n        # using a backtracking paradigm, there will be some cases where we go to so\\n        # much deep just to find the required char is not even present in the board\\n        # So we are eliminating it before hand.\\n        characters = set()\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] not in characters: characters.add(board[i][j])\\n        \\n        for s in word: \\n            if s not in characters: return False\\n        \\n        def dfs(row, col, index, visited):\\n            # index represents current index of word string\\n            # Checking for out of bounds indices and returning False\\n            if row < 0 or row > len(board) - 1 or col < 0 or col > len(board[0]) - 1: return False\\n            # If we already visited current cell, return False\\n            if (row, col) in visited: return False\\n            # If char at cell (row, col) matches with word[index] we go next char\\n            # in all the 4 directions\\n            if board[row][col] == word[index]:\\n                visited.add((row, col))\\n                # If we reach end of word return Trur\\n                if index == len(word) - 1: return True\\n                isExist = (\\n                            dfs(row, col - 1, index + 1, visited) or \\n                            dfs(row, col + 1, index + 1, visited) or\\n                            dfs(row - 1, col, index + 1, visited) or \\n                            dfs(row + 1, col, index + 1, visited)\\n                       )   \\n                # Why we are removing at the end is, we might encounter this cell\\n                # again in some other path if this path didn\\'t give us required \\n                # word. In that path, we haven\\'t yet visited the cell right. So, we\\n                # are removing it.\\n                visited.remove((row, col))\\n                return isExist\\n            \\n            return False\\n        \\n        # Running DFS when the char in the cell (i,j) matches with word[0] i.e; \\n        # starting of the word\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0]:\\n                    visited = set()\\n                    if dfs(i, j, 0, visited): return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556016,
                "title": "java-trie-based-approach-google-asked",
                "content": "```\\nclass Solution {\\n    TrieNode root;\\n    int row, col;\\n    public boolean exist(char[][] board, String word) {\\n        //Approach - Trie Approach\\n        root = new TrieNode();\\n        insertInTrie(word);\\n        TrieNode curr = root;\\n        row = board.length;\\n        col = board[0].length;\\n        for (int i = 0; i < row; i++){\\n            for (int j = 0; j < col; j++){\\n                char ch = board[i][j];\\n                if(curr.children.containsKey(ch) && dfs(curr, board, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n    private boolean dfs(TrieNode curr, char[][] board, int i, int j){\\n\\n        if (curr.isEnd) return curr.isEnd;\\n        if(i < 0 || j <0 || i>= row || j >= col || !curr.children.containsKey(board[i][j])) return false;\\n        char ch = board[i][j];\\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n\\n        if (dfs(curr.children.get(ch), board, i+1, j) || dfs(curr.children.get(ch), board, i-1, j)\\n                || dfs(curr.children.get(ch), board, i, j+1) || dfs(curr.children.get(ch), board, i, j-1))\\n            return true;\\n\\n        board[i][j] = temp;\\n        return false;\\n\\n    }\\n    private void insertInTrie(String word){\\n        TrieNode curr = root;\\n        for (int i = 0; i<word.length(); i++){\\n            char c = word.charAt(i);\\n            if (curr.children.containsKey(c)) {\\n                curr = curr.children.get(c);\\n                continue;\\n            }\\n            curr.children.put(c,new TrieNode());\\n            curr = curr.children.get(c);\\n        }\\n        curr.isEnd = true;\\n    }\\n}\\n    \\nclass TrieNode{\\n    Map<Character, TrieNode> children;\\n    boolean isEnd;\\n    TrieNode(){\\n        children = new HashMap<>();\\n        isEnd = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    TrieNode root;\\n    int row, col;\\n    public boolean exist(char[][] board, String word) {\\n        //Approach - Trie Approach\\n        root = new TrieNode();\\n        insertInTrie(word);\\n        TrieNode curr = root;\\n        row = board.length;\\n        col = board[0].length;\\n        for (int i = 0; i < row; i++){\\n            for (int j = 0; j < col; j++){\\n                char ch = board[i][j];\\n                if(curr.children.containsKey(ch) && dfs(curr, board, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n    private boolean dfs(TrieNode curr, char[][] board, int i, int j){\\n\\n        if (curr.isEnd) return curr.isEnd;\\n        if(i < 0 || j <0 || i>= row || j >= col || !curr.children.containsKey(board[i][j])) return false;\\n        char ch = board[i][j];\\n        char temp = board[i][j];\\n        board[i][j] = \\' \\';\\n\\n        if (dfs(curr.children.get(ch), board, i+1, j) || dfs(curr.children.get(ch), board, i-1, j)\\n                || dfs(curr.children.get(ch), board, i, j+1) || dfs(curr.children.get(ch), board, i, j-1))\\n            return true;\\n\\n        board[i][j] = temp;\\n        return false;\\n\\n    }\\n    private void insertInTrie(String word){\\n        TrieNode curr = root;\\n        for (int i = 0; i<word.length(); i++){\\n            char c = word.charAt(i);\\n            if (curr.children.containsKey(c)) {\\n                curr = curr.children.get(c);\\n                continue;\\n            }\\n            curr.children.put(c,new TrieNode());\\n            curr = curr.children.get(c);\\n        }\\n        curr.isEnd = true;\\n    }\\n}\\n    \\nclass TrieNode{\\n    Map<Character, TrieNode> children;\\n    boolean isEnd;\\n    TrieNode(){\\n        children = new HashMap<>();\\n        isEnd = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245581,
                "title": "short-python-dfs-recursion",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def search(board, x, y, word, visited=set()):\\n            if word == \\'\\':\\n                return True\\n            for i, j in [[x + 1, y], [x - 1, y], [x, y - 1], [x, y + 1]]:\\n                if 0 <= i < len(board) and 0 <= j < len(board[0]) and (i, j) not in visited and board[i][j] == word[0] \\\\\\n                and search(board, i, j, word[1:], visited | {(x, y)}):\\n                    return True\\n            return False\\n        \\n        if not board or not board[0]:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and search(board, i, j, word[1:]):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        def search(board, x, y, word, visited=set()):\\n            if word == \\'\\':\\n                return True\\n            for i, j in [[x + 1, y], [x - 1, y], [x, y - 1], [x, y + 1]]:\\n                if 0 <= i < len(board) and 0 <= j < len(board[0]) and (i, j) not in visited and board[i][j] == word[0] \\\\\\n                and search(board, i, j, word[1:], visited | {(x, y)}):\\n                    return True\\n            return False\\n        \\n        if not board or not board[0]:\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == word[0] and search(board, i, j, word[1:]):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890958,
                "title": "easy-python-solution-90-29-beats-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        ROWS, COLS = len(board), len(board[0])\\n        visited = set()\\n\\n        def dfs(r,c,idx):\\n        # if idx == len(word), then word has been found\\n            if idx == len(word):\\n                return True\\n\\n        # out of bounds\\n        # OR current letter does not match letter on board\\n        # OR letter already visited\\n            if ( \\n                r<0 or r>=ROWS \\n                or c<0 or c>=COLS\\n                or word[idx] != board[r][c]\\n                or (r,c) in visited\\n            ):\\n                return False\\n  \\n        # to keep track of the letter already visited, add it\\'s position to the set\\n        # after DFS we can remove it from the set.\\n            visited.add((r,c))\\n\\n        # performing DFS \\n            res = (\\n                dfs(r+1,c,idx+1) \\n                or dfs(r-1,c,idx+1) \\n                or dfs(r,c+1,idx+1) \\n                or dfs(r,c-1,idx+1)\\n            )\\n        \\n            visited.remove((r,c))\\n            return res\\n        \\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        ROWS, COLS = len(board), len(board[0])\\n        visited = set()\\n\\n        def dfs(r,c,idx):\\n        # if idx == len(word), then word has been found\\n            if idx == len(word):\\n                return True\\n\\n        # out of bounds\\n        # OR current letter does not match letter on board\\n        # OR letter already visited\\n            if ( \\n                r<0 or r>=ROWS \\n                or c<0 or c>=COLS\\n                or word[idx] != board[r][c]\\n                or (r,c) in visited\\n            ):\\n                return False\\n  \\n        # to keep track of the letter already visited, add it\\'s position to the set\\n        # after DFS we can remove it from the set.\\n            visited.add((r,c))\\n\\n        # performing DFS \\n            res = (\\n                dfs(r+1,c,idx+1) \\n                or dfs(r-1,c,idx+1) \\n                or dfs(r,c+1,idx+1) \\n                or dfs(r,c-1,idx+1)\\n            )\\n        \\n            visited.remove((r,c))\\n            return res\\n        \\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if dfs(i,j,0):\\n                    return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786896,
                "title": "word-search-java-solution-easy-recursive-approach-t-c-o-m-n",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t\\n\\t//finding first character of given word in given matrix \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[0].length; j++)\\n            {\\n\\t\\t\\t//if first character found then we call recursion for remaining task else return false\\n                if(board[i][j]==word.charAt(0)){\\n                 if(helper(board,word,0,i,j,board.length,board[0].length))\\n                     return true;\\n                }\\n            }\\n        }\\n       return false;\\n    }\\n    boolean helper(char[][] board, String word,int index,int i,int j, int rowLen,int colLen)\\n    {\\n    \\n        if(index==word.length())\\n        return true;\\n        \\n        if(i<0 || j<0 || i == rowLen || j == colLen || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n\\t\\t// mark that character cell so that we can\\'t revisit that cell to avoid infinity calls\\n            char temp = board[i][j];\\n            board[i][j] = \\'#\\';\\n            boolean ans1 = helper(board,word,index+1,i,j+1,rowLen,colLen);\\n            boolean ans2 = helper(board,word,index+1,i+1,j,rowLen,colLen);\\n            boolean ans3 = helper(board,word,index+1,i-1,j,rowLen,colLen);\\n            boolean ans4 = helper(board,word,index+1,i,j-1,rowLen,colLen);\\n            board[i][j] = temp;\\n            return ans1 || ans2 || ans3 || ans4;\\n        \\n    \\n    }\\n}\\nT.C :- O(m * n), m and n are the numbe rof row and column , at max for finding word we have to traverse whole matrix cell\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t\\n\\t//finding first character of given word in given matrix \\n        for(int i=0; i<board.length; i++)\\n        {\\n            for(int j=0; j<board[0].length; j++)\\n            {\\n\\t\\t\\t//if first character found then we call recursion for remaining task else return false\\n                if(board[i][j]==word.charAt(0)){\\n                 if(helper(board,word,0,i,j,board.length,board[0].length))\\n                     return true;\\n                }\\n            }\\n        }\\n       return false;\\n    }\\n    boolean helper(char[][] board, String word,int index,int i,int j, int rowLen,int colLen)\\n    {\\n    \\n        if(index==word.length())\\n        return true;\\n        \\n        if(i<0 || j<0 || i == rowLen || j == colLen || board[i][j] != word.charAt(index))\\n            return false;\\n        \\n\\t\\t// mark that character cell so that we can\\'t revisit that cell to avoid infinity calls\\n            char temp = board[i][j];\\n            board[i][j] = \\'#\\';\\n            boolean ans1 = helper(board,word,index+1,i,j+1,rowLen,colLen);\\n            boolean ans2 = helper(board,word,index+1,i+1,j,rowLen,colLen);\\n            boolean ans3 = helper(board,word,index+1,i-1,j,rowLen,colLen);\\n            boolean ans4 = helper(board,word,index+1,i,j-1,rowLen,colLen);\\n            board[i][j] = temp;\\n            return ans1 || ans2 || ans3 || ans4;\\n        \\n    \\n    }\\n}\\nT.C :- O(m * n), m and n are the numbe rof row and column , at max for finding word we have to traverse whole matrix cell\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839796,
                "title": "easy-c-dfs-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board,int i, int j , int count, string word){\\n        if(count == word.length())\\n            return true;\\n        if(i<0 || i>=board.size()||j<0 || j>=board[i].size() || board[i][j]!=word[count])\\n             return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        board[i][j]= temp;\\n        return found;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0] and dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board,int i, int j , int count, string word){\\n        if(count == word.length())\\n            return true;\\n        if(i<0 || i>=board.size()||j<0 || j>=board[i].size() || board[i][j]!=word[count])\\n             return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        board[i][j]= temp;\\n        return found;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0] and dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512534,
                "title": "c-dfs-2-methods-0-n-o-1-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/17498125-18a3-44f1-8921-caf9419ced12_1633608296.9319909.png)\\n\\n***Method - 1:***\\nO(n * word size)\\nn = rows*col\\n```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos, vector<vector<bool>>& visited){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        visited[i][j] = true;\\n        \\n        if(i > 0 && !visited[i-1][j] && board[i-1][j] == word[pos+1] &&search(board ,i-1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j > 0 && !visited[i][j-1] && board[i][j-1] == word[pos+1] &&search(board ,i ,j-1 ,word, pos+1, visited))\\n            return true;\\n        if(i < board.size()-1 && !visited[i+1][j] && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j < board[0].size()-1 && !visited[i][j+1] && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1, visited))\\n            return true;\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0,visited))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n***Method - 2:***\\n0(1)\\n```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        /* ASCII value of A-Z : 65-90 && a-z : 97-122\\n         That\\'s why i took 65, i.e ASCII value of A so that when i subtract it goes out of range of a-z & A-Z \\n         U can take any other no. also but after subtracting it should go out of range of words\\n        It works similar as visited just having less space now*/\\n        board[i][j] -= 65;\\n        \\n        if(i > 0 && board[i-1][j] == word[pos+1] && search(board ,i-1 ,j ,word, pos+1))\\n            return true;\\n        if(j > 0 &&  board[i][j-1] == word[pos+1] && search(board ,i ,j-1 ,word, pos+1))\\n            return true;\\n        if(i < board.size()-1 && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1))\\n            return true;\\n        if(j < board[0].size()-1 && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1))\\n            return true;\\n        \\n        board[i][j] += 65;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos, vector<vector<bool>>& visited){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        visited[i][j] = true;\\n        \\n        if(i > 0 && !visited[i-1][j] && board[i-1][j] == word[pos+1] &&search(board ,i-1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j > 0 && !visited[i][j-1] && board[i][j-1] == word[pos+1] &&search(board ,i ,j-1 ,word, pos+1, visited))\\n            return true;\\n        if(i < board.size()-1 && !visited[i+1][j] && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1, visited))\\n            return true;\\n        if(j < board[0].size()-1 && !visited[i][j+1] && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1, visited))\\n            return true;\\n        \\n        visited[i][j] = false;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0,visited))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool search(vector<vector<char>>& board, int i, int j, string& word, int pos){\\n        if(pos == word.length() - 1)\\n            return true;\\n        \\n        /* ASCII value of A-Z : 65-90 && a-z : 97-122\\n         That\\'s why i took 65, i.e ASCII value of A so that when i subtract it goes out of range of a-z & A-Z \\n         U can take any other no. also but after subtracting it should go out of range of words\\n        It works similar as visited just having less space now*/\\n        board[i][j] -= 65;\\n        \\n        if(i > 0 && board[i-1][j] == word[pos+1] && search(board ,i-1 ,j ,word, pos+1))\\n            return true;\\n        if(j > 0 &&  board[i][j-1] == word[pos+1] && search(board ,i ,j-1 ,word, pos+1))\\n            return true;\\n        if(i < board.size()-1 && board[i+1][j] == word[pos+1] &&search(board ,i+1 ,j ,word, pos+1))\\n            return true;\\n        if(j < board[0].size()-1 && board[i][j+1] == word[pos+1] &&search(board ,i ,j+1 ,word, pos+1))\\n            return true;\\n        \\n        board[i][j] += 65;\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++)\\n                if(board[i][j] == word[0] && search(board,i,j,word,0))\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004342,
                "title": "python-simple-solution-dfs",
                "content": "```python\\nclass Solution(object):\\n    def exist(self, board, word):\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, word, i, j): return True\\n        return False\\n                \\n    def dfs(self, board, word, i, j):\\n        if i <= -1 or i >= len(board) or j <= -1 or j >= len(board[0]): return False\\n        if board[i][j] == -1 or board[i][j] != word[0]: return False\\n        if len(word) == 1: return True\\n        \\n        temp, board[i][j] = board[i][j], -1\\n        if self.dfs(board, word[1:], i-1, j): return True\\n        if self.dfs(board, word[1:], i+1, j): return True\\n        if self.dfs(board, word[1:], i, j-1): return True\\n        if self.dfs(board, word[1:], i, j+1): return True\\n        board[i][j] = temp\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution(object):\\n    def exist(self, board, word):\\n        for i in xrange(len(board)):\\n            for j in xrange(len(board[0])):\\n                if self.dfs(board, word, i, j): return True\\n        return False\\n                \\n    def dfs(self, board, word, i, j):\\n        if i <= -1 or i >= len(board) or j <= -1 or j >= len(board[0]): return False\\n        if board[i][j] == -1 or board[i][j] != word[0]: return False\\n        if len(word) == 1: return True\\n        \\n        temp, board[i][j] = board[i][j], -1\\n        if self.dfs(board, word[1:], i-1, j): return True\\n        if self.dfs(board, word[1:], i+1, j): return True\\n        if self.dfs(board, word[1:], i, j-1): return True\\n        if self.dfs(board, word[1:], i, j+1): return True\\n        board[i][j] = temp\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747149,
                "title": "c-simplest-solution-possible-beats-85-solution",
                "content": "```\\n// Using DFS + Backtracking\\nclass Solution {\\npublic:\\n\\t// Check the boundary cases of the board.\\n    bool isSafe(int N, int M, int i, int j){\\n        return (i<N) && (i>=0) && (j>=0) && (j<M);\\n    }\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j){\\n        if(word[pos]!=board[i][j]){\\n            return false;\\n        }\\n        if(pos==word.length()-1){\\n            return true;\\n        }\\n\\t\\t// to avoid using of this character again in the backtracking\\n        board[i][j] = \\'#\\';\\n        if(isSafe(board.size(), board[0].size(), i+1, j)){\\n            if(backtrack(board, word, pos+1, i+1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i-1, j)){\\n            if(backtrack(board, word, pos+1, i-1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j+1)){\\n            if(backtrack(board, word, pos+1, i, j+1))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j-1)){\\n            if(backtrack(board, word, pos+1, i, j-1))\\n                return true;\\n        }\\n\\t\\t// Reassigning the character as backtracking is complete.\\n        board[i][j] = word[pos];\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0])   // This condition is not necessary as it will also be checked in the backtracking function.\\n                    if(backtrack(board, word, 0, i, j))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section. \\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// Using DFS + Backtracking\\nclass Solution {\\npublic:\\n\\t// Check the boundary cases of the board.\\n    bool isSafe(int N, int M, int i, int j){\\n        return (i<N) && (i>=0) && (j>=0) && (j<M);\\n    }\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j){\\n        if(word[pos]!=board[i][j]){\\n            return false;\\n        }\\n        if(pos==word.length()-1){\\n            return true;\\n        }\\n\\t\\t// to avoid using of this character again in the backtracking\\n        board[i][j] = \\'#\\';\\n        if(isSafe(board.size(), board[0].size(), i+1, j)){\\n            if(backtrack(board, word, pos+1, i+1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i-1, j)){\\n            if(backtrack(board, word, pos+1, i-1, j))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j+1)){\\n            if(backtrack(board, word, pos+1, i, j+1))\\n                return true;\\n        }\\n        if(isSafe(board.size(), board[0].size(), i, j-1)){\\n            if(backtrack(board, word, pos+1, i, j-1))\\n                return true;\\n        }\\n\\t\\t// Reassigning the character as backtracking is complete.\\n        board[i][j] = word[pos];\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==word[0])   // This condition is not necessary as it will also be checked in the backtracking function.\\n                    if(backtrack(board, word, 0, i, j))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639214,
                "title": "python-simple-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        self.W = len(board[0])\\n        self.H = len(board)\\n        self.board = board\\n        \\n        for i in range(self.H):\\n            for j in range(self.W):\\n                if board[i][j] == word[0]:\\n                    if self.dfs(i, j, word[1:]): return True\\n        return False\\n\\n    def dfs(self, i, j, word):\\n        # Stop Condition\\n        if not word:\\n            return True\\n        \\n        # Mark visited point and store origin\\n        self.board[i][j], origin = -1, self.board[i][j]\\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\\n            if 0 <= x < self.H and 0 <= y < self.W and self.board[x][y] == word[0]:\\n\\t\\t\\t\\t# Early Stop\\n                if self.dfs(x, y, word[1:]): return True\\n                \\n        # Revert the origin value\\n        self.board[i][j] = origin\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        self.W = len(board[0])\\n        self.H = len(board)\\n        self.board = board\\n        \\n        for i in range(self.H):\\n            for j in range(self.W):\\n                if board[i][j] == word[0]:\\n                    if self.dfs(i, j, word[1:]): return True\\n        return False\\n\\n    def dfs(self, i, j, word):\\n        # Stop Condition\\n        if not word:\\n            return True\\n        \\n        # Mark visited point and store origin\\n        self.board[i][j], origin = -1, self.board[i][j]\\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\\n            if 0 <= x < self.H and 0 <= y < self.W and self.board[x][y] == word[0]:\\n\\t\\t\\t\\t# Early Stop\\n                if self.dfs(x, y, word[1:]): return True\\n                \\n        # Revert the origin value\\n        self.board[i][j] = origin\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483988,
                "title": "python-easy-to-understand-95-faster",
                "content": "Please let me know if explanation is needed.\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m = len(board)\\n        n = len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    res = self.backtrack(board,m,n,i,j,word[1:])\\n                    if res:\\n                        return True\\n        return False\\n        \\n        \\n    def backtrack(self, board,m,n, i, j, target):\\n        temp = board[i][j]\\n        if len(target) == 0:\\n            return True\\n        board[i][j] = \\'#\\'\\n        for x,y in (i+1,j),(i-1,j),(i,j+1),(i,j-1):\\n            if 0<=x<m and 0<=y<n and target[0] == board[x][y]:\\n                dec = self.backtrack(board,m,n,x,y,target[1:])\\n                if dec:\\n                    return True\\n        board[i][j] = temp\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m = len(board)\\n        n = len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0]:\\n                    res = self.backtrack(board,m,n,i,j,word[1:])\\n                    if res:\\n                        return True\\n        return False\\n        \\n        \\n    def backtrack(self, board,m,n, i, j, target):\\n        temp = board[i][j]\\n        if len(target) == 0:\\n            return True\\n        board[i][j] = \\'#\\'\\n        for x,y in (i+1,j),(i-1,j),(i,j+1),(i,j-1):\\n            if 0<=x<m and 0<=y<n and target[0] == board[x][y]:\\n                dec = self.backtrack(board,m,n,x,y,target[1:])\\n                if dec:\\n                    return True\\n        board[i][j] = temp\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27707,
                "title": "three-9-ms-c-backtrack-solutions",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0|| word.size() == 0) return true;\\n        bool find = false;\\n        vector<vector<int>>visited(board.size(), vector<int>(board[0].size(),0));\\n        for(int i = 0 ; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++){\\n                if(board[i][j] == word[0]){\\n                     find = backtrack(i, j, board, word, visited);\\n                     if(find) return find;\\n                }\\n            }\\n        return find;\\n    }\\n    \\n    bool backtrack(int i, int j, vector<vector<char>>& board, string word, vector<vector<int>>& visited){\\n        if(word.size() == 0) return true;\\n        if(i < 0 || i > board.size() - 1 || j < 0 || j > board[0].size() - 1) return false;\\n        if(visited[i][j]) return false;\\n        bool find = false;\\n        if(board[i][j] == word[0]){\\n            word.erase(word.begin());\\n            visited[i][j] = 1;\\n            find = backtrack(i-1,j,board,word,visited) || backtrack(i,j-1,board,word,visited) \\n                || backtrack(i+1,j,board,word,visited) || backtrack(i,j+1,board,word,visited);\\n            visited[i][j] = 0;\\n        }\\n       return find;\\n    }\\n};\\n```\\n***\\n**Update(8/12/2017):** \\n\\n**Solution 2**\\n\\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0) return false;\\n        bool found = false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == word[0]) backtrack(board, 1, i, j, m, n, word, found);\\n                if(found) return true;\\n            }\\n        return false;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\\n***\\n*Update(9/12/2017):*\\n\\n**Solution 3.**\\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.empty()) return false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(board[i][j] == word[0] && BFS(board, i, j, m, n, 0, word)) return true;\\n        return false;\\n    }\\n    \\n    bool BFS(vector<vector<char>>& board, int r, int c, int m, int n, int len, string& word){\\n        if(len == word.size()) return true;\\n        if(r < 0 || c < 0 || r >= m || c >= n || board[r][c] == '#' || board[r][c] != word[len]) return false;\\n        char tmp = board[r][c];\\n        board[r][c] = '#';\\n        bool found =  BFS(board, r + 1, c, m, n, len + 1, word) || BFS(board, r, c + 1, m, n, len + 1, word) ||\\n                      BFS(board, r - 1, c, m, n, len + 1, word) || BFS(board, r, c - 1, m, n, len + 1, word);\\n        board[r][c] = tmp;\\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0|| word.size() == 0) return true;\\n        bool find = false;\\n        vector<vector<int>>visited(board.size(), vector<int>(board[0].size(),0));\\n        for(int i = 0 ; i < board.size(); i++)\\n            for(int j = 0; j < board[0].size(); j++){\\n                if(board[i][j] == word[0]){\\n                     find = backtrack(i, j, board, word, visited);\\n                     if(find) return find;\\n                }\\n            }\\n        return find;\\n    }\\n    \\n    bool backtrack(int i, int j, vector<vector<char>>& board, string word, vector<vector<int>>& visited){\\n        if(word.size() == 0) return true;\\n        if(i < 0 || i > board.size() - 1 || j < 0 || j > board[0].size() - 1) return false;\\n        if(visited[i][j]) return false;\\n        bool find = false;\\n        if(board[i][j] == word[0]){\\n            word.erase(word.begin());\\n            visited[i][j] = 1;\\n            find = backtrack(i-1,j,board,word,visited) || backtrack(i,j-1,board,word,visited) \\n                || backtrack(i+1,j,board,word,visited) || backtrack(i,j+1,board,word,visited);\\n            visited[i][j] = 0;\\n        }\\n       return find;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.size() == 0) return false;\\n        bool found = false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == word[0]) backtrack(board, 1, i, j, m, n, word, found);\\n                if(found) return true;\\n            }\\n        return false;\\n    }\\n    \\n    void backtrack(vector<vector<char>>& board, int pos, int r, int c, int m, int n, string& word, bool& found){\\n        if(board[r][c] == '0' || found) return;\\n        if(pos == word.size()){\\n            found = true;\\n            return;\\n        }\\n        char tmp = board[r][c];\\n        board[r][c] = '0';\\n        if(r - 1 >= 0 && board[r - 1][c] == word[pos]) backtrack(board, pos + 1, r - 1, c, m, n, word, found);\\n        if(r + 1 < m  && board[r + 1][c] == word[pos]) backtrack(board, pos + 1, r + 1, c, m, n, word, found);\\n        if(c + 1 < n  && board[r][c + 1] == word[pos]) backtrack(board, pos + 1, r, c + 1, m, n, word, found);\\n        if(c - 1 >= 0 && board[r][c - 1] == word[pos]) backtrack(board, pos + 1, r, c - 1, m, n, word, found);\\n        board[r][c] = tmp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(board.empty()) return false;\\n        int m = board.size(), n = board[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(board[i][j] == word[0] && BFS(board, i, j, m, n, 0, word)) return true;\\n        return false;\\n    }\\n    \\n    bool BFS(vector<vector<char>>& board, int r, int c, int m, int n, int len, string& word){\\n        if(len == word.size()) return true;\\n        if(r < 0 || c < 0 || r >= m || c >= n || board[r][c] == '#' || board[r][c] != word[len]) return false;\\n        char tmp = board[r][c];\\n        board[r][c] = '#';\\n        bool found =  BFS(board, r + 1, c, m, n, len + 1, word) || BFS(board, r, c + 1, m, n, len + 1, word) ||\\n                      BFS(board, r - 1, c, m, n, len + 1, word) || BFS(board, r, c - 1, m, n, len + 1, word);\\n        board[r][c] = tmp;\\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843892,
                "title": "98-java-solution-65-abdullayev",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public boolean exist(char[][] board, String word) {\\n        char c = word.charAt(0);\\n        int m = board.length;\\n        int n = board[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (c == board[i][j] && sub(board, word, i, j, 0, m, n, c))\\n                    return true;\\n\\n        return false;\\n    }\\n\\n    boolean exist(char[][] board, String word, int i, int j, int index, int m, int n) {\\n        if (word.length() == index)\\n            return true;\\n        char c = word.charAt(index);\\n\\n        if (i > 0 && board[i - 1][j] == c\\n                && sub(board, word, i - 1, j, index, m, n, c)) //top\\n            return true;\\n        if (i < m - 1 && board[i + 1][j] == c\\n                && sub(board, word, i + 1, j, index, m, n, c)) //down\\n            return true;\\n        if (j > 0 && board[i][j - 1] == c && sub(board, word, i, j - 1, index, m, n, c)) //left\\n            return true;\\n        if (j < n - 1 && board[i][j + 1] == c) //right\\n            return sub(board, word, i, j + 1, index, m, n, c);\\n\\n        return false;\\n    }\\n\\n    boolean sub(char[][] board, String word, int i, int j,\\n                int index, int m, int n, char c) {\\n        board[i][j] = 0;\\n        if (exist(board, word, i, j, index + 1, m, n))\\n            return true;\\n        else board[i][j] = c;\\n        return false;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public boolean exist(char[][] board, String word) {\\n        char c = word.charAt(0);\\n        int m = board.length;\\n        int n = board[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (c == board[i][j] && sub(board, word, i, j, 0, m, n, c))\\n                    return true;\\n\\n        return false;\\n    }\\n\\n    boolean exist(char[][] board, String word, int i, int j, int index, int m, int n) {\\n        if (word.length() == index)\\n            return true;\\n        char c = word.charAt(index);\\n\\n        if (i > 0 && board[i - 1][j] == c\\n                && sub(board, word, i - 1, j, index, m, n, c)) //top\\n            return true;\\n        if (i < m - 1 && board[i + 1][j] == c\\n                && sub(board, word, i + 1, j, index, m, n, c)) //down\\n            return true;\\n        if (j > 0 && board[i][j - 1] == c && sub(board, word, i, j - 1, index, m, n, c)) //left\\n            return true;\\n        if (j < n - 1 && board[i][j + 1] == c) //right\\n            return sub(board, word, i, j + 1, index, m, n, c);\\n\\n        return false;\\n    }\\n\\n    boolean sub(char[][] board, String word, int i, int j,\\n                int index, int m, int n, char c) {\\n        board[i][j] = 0;\\n        if (exist(board, word, i, j, index + 1, m, n))\\n            return true;\\n        else board[i][j] = c;\\n        return false;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843886,
                "title": "c-dfs-99-faster",
                "content": "``` C++ []\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n*Upvote if you liked it*",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "``` C++ []\\nclass Solution \\n{\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) \\n    {\\n        int dirs[5] = {0, -1, 0, 1, 0};\\n        map<char,int> cnt;\\n        int m = board.size(), n = board[0].size(), l = word.size();\\n        \\n        for (char c : word) cnt[c] += 1;\\n        \\n        if (cnt[word[0]] > cnt[word[l-1]])\\n            reverse(word.begin(), word.end());\\n        \\n        function<bool(int,int,int)> dfs;\\n        dfs = [&] (int i, int j, int s) -> bool\\n        {\\n            if (s == l) return true;\\n            \\n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\\n            if (board[i][j] != word[s])             return false;\\n            \\n            board[i][j] = \\'#\\';\\n            for (int d = 0; d < 4; ++d)\\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\\n            board[i][j] = word[s];\\n            \\n            return false;\\n        };\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (dfs(i, j, 0)) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843714,
                "title": "python-3-dfs-with-a-little-bit-of-pruning-t-m-97-94",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n\\n        row, col = len(board), len(board[0])\\n        R, C, seen = range(row), range(col), set()\\n\\n        def dfs(coord, i=0):\\n            \\n            if len(word) == i: return True\\n            \\n            r,c = coord\\n\\n            if (r not in R or c not in C or \\n                coord in seen            or \\n                board[r][c] != word[i]): return False\\n            \\n            seen.add(coord)\\n\\n            res = (dfs((r+1,c), i+1) or dfs((r,c+1), i+1) or\\n                   dfs((r-1,c), i+1) or dfs((r,c-1), i+1))\\n            \\n            seen.remove(coord)\\n\\n            return res\\n\\n        boardCt, wrdCt = Counter(chain(*board)), Counter(word)\\n        if any (boardCt[ch] < wrdCt[ch] for ch in wrdCt): return False\\n\\n        if boardCt[word[0]] > boardCt[word[-1]]: word = word[::-1]\\n        \\n        return any(dfs((r, c))  for c in C for r in R)\\n```\\nhttps://leetcode.com/submissions/detail/848874874/\\n\\nBefore you ask about time & space complexity, I do not know. Recursion baffles me.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n\\n        row, col = len(board), len(board[0])\\n        R, C, seen = range(row), range(col), set()\\n\\n        def dfs(coord, i=0):\\n            \\n            if len(word) == i: return True\\n            \\n            r,c = coord\\n\\n            if (r not in R or c not in C or \\n                coord in seen            or \\n                board[r][c] != word[i]): return False\\n            \\n            seen.add(coord)\\n\\n            res = (dfs((r+1,c), i+1) or dfs((r,c+1), i+1) or\\n                   dfs((r-1,c), i+1) or dfs((r,c-1), i+1))\\n            \\n            seen.remove(coord)\\n\\n            return res\\n\\n        boardCt, wrdCt = Counter(chain(*board)), Counter(word)\\n        if any (boardCt[ch] < wrdCt[ch] for ch in wrdCt): return False\\n\\n        if boardCt[word[0]] > boardCt[word[-1]]: word = word[::-1]\\n        \\n        return any(dfs((r, c))  for c in C for r in R)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843486,
                "title": "dfs-backtracking-in-c-js-python",
                "content": "# C++\\n```cpp\\nclass   Solution\\n{\\n    public:\\n\\n    bool    exist(vector<vector<char>>& board, string word)\\n    {\\n            int     rows, cols;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            for (int i = 0; i < rows; i++)\\n                for (int j = 0; j < cols; j++)\\n                    if (dfs(board, word, 0, i, j))\\n\\t\\t\\t    return (true);\\n            return (false);\\n    }\\n\\n    bool    dfs(vector<vector<char>> &board, string &word, int i, int x, int y)\\n    {\\n            int     rows, cols;\\n            bool    found;\\n            char    c;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            if (x < 0 || x == rows || y < 0 || y == cols || word[i] != board[x][y])\\n                return (false);\\n            if (i == (int) word.length() - 1)\\n                return (true);\\n            c = board[x][y];\\n            board[x][y] = 0;\\n            found = dfs(board, word, i + 1, x + 1, y) ||\\n                    dfs(board, word, i + 1, x - 1, y) ||\\n                    dfs(board, word, i + 1, x, y + 1) ||\\n                    dfs(board, word, i + 1, x, y - 1);\\n            board[x][y] = c;\\n            return (found);\\n    }\\n};\\n```\\n# Js\\n```js\\nvar exist = function(board, word) {\\n    let i = -1\\n    while (++i < board.length) {\\n        let j = -1\\n        while (++j < board[0].length) {\\n            if (dfs(board, word, 0, i, j))\\n                return true\\n        }\\n    }\\n    return false\\n};\\n\\nvar dfs = function(board, word, index, x, y) {\\n    if (index == word.length)\\n        return true\\n    let c = board[0].length\\n    let r = board.length\\n    if (x < 0 || y < 0 || x > r - 1 || y > c - 1 || board[x][y] != word[index])\\n        return false\\n    board[x][y] = \\'#\\'\\n    let isFound = (\\n        dfs(board, word, index + 1, x + 1, y) ||\\n        dfs(board, word, index + 1, x - 1, y) ||\\n        dfs(board, word, index + 1, x, y + 1) ||\\n        dfs(board, word, index + 1, x, y - 1)\\n    )\\n    board[x][y] = word[index]\\n    return isFound\\n}\\n```\\n# Python\\n```py\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                if self.DFS(board, word, 0, x, y):\\n                    return True\\n        return False\\n\\n    def DFS(self, board: List[List[str]], word:str, index: int, x: int, y: int) -> bool:\\n        if index == len(word):\\n            return True\\n        c = len(board[0])\\n        r = len(board)\\n        if x < 0 or y < 0 or x > r - 1 or y > c - 1 or word[index] != board[x][y] :\\n            return False\\n        board[x][y] = chr(0)\\n        found = (\\n            self.DFS(board, word, index + 1, x + 1, y) or\\n            self.DFS(board, word, index + 1, x - 1, y) or\\n            self.DFS(board, word, index + 1, x, y + 1) or\\n            self.DFS(board, word, index + 1, x, y - 1))\\n        board[x][y] = word[index]\\n        return found\\n```\\n# C\\n```c\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c);\\n\\nbool    exist(char** board, int boardSize, int* boardColSize, char * word)\\n{\\n        if (!board || !boardSize || !boardColSize) return (false);\\n        if (!word)  return (true);\\n        for (int i = 0; i < boardSize; i++)\\n            for (int j = 0; j < boardColSize[0]; j++)\\n                if (solve(board, word, 0, i, j, boardSize, boardColSize[0]))\\n                    return (true);\\n        return (false);\\n}\\n\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c)\\n{\\n        bool    found;\\n        char    temp;\\n\\n        if (x < 0 || x == r || y < 0 || y == c || word[i] != board[x][y])\\n\\t\\t    return (false);\\n        if (i == strlen(word) - 1)\\n\\t\\t    return (true);\\n        temp = board[x][y];\\n        board[x][y] = 0;\\n        found = solve(board, word, i + 1, x + 1, y, r, c) ||\\n                solve(board, word, i + 1, x - 1, y, r, c) ||\\n                solve(board, word, i + 1, x, y + 1, r, c) ||\\n                solve(board, word, i + 1, x, y - 1, r, c);\\n        board[x][y] = temp;\\n        return (found);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass   Solution\\n{\\n    public:\\n\\n    bool    exist(vector<vector<char>>& board, string word)\\n    {\\n            int     rows, cols;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            for (int i = 0; i < rows; i++)\\n                for (int j = 0; j < cols; j++)\\n                    if (dfs(board, word, 0, i, j))\\n\\t\\t\\t    return (true);\\n            return (false);\\n    }\\n\\n    bool    dfs(vector<vector<char>> &board, string &word, int i, int x, int y)\\n    {\\n            int     rows, cols;\\n            bool    found;\\n            char    c;\\n\\n            if (!board.size())\\n\\t\\t    return (false);\\n            rows = (int) board.size();\\n            cols = (int) board[0].size();\\n            if (x < 0 || x == rows || y < 0 || y == cols || word[i] != board[x][y])\\n                return (false);\\n            if (i == (int) word.length() - 1)\\n                return (true);\\n            c = board[x][y];\\n            board[x][y] = 0;\\n            found = dfs(board, word, i + 1, x + 1, y) ||\\n                    dfs(board, word, i + 1, x - 1, y) ||\\n                    dfs(board, word, i + 1, x, y + 1) ||\\n                    dfs(board, word, i + 1, x, y - 1);\\n            board[x][y] = c;\\n            return (found);\\n    }\\n};\\n```\n```js\\nvar exist = function(board, word) {\\n    let i = -1\\n    while (++i < board.length) {\\n        let j = -1\\n        while (++j < board[0].length) {\\n            if (dfs(board, word, 0, i, j))\\n                return true\\n        }\\n    }\\n    return false\\n};\\n\\nvar dfs = function(board, word, index, x, y) {\\n    if (index == word.length)\\n        return true\\n    let c = board[0].length\\n    let r = board.length\\n    if (x < 0 || y < 0 || x > r - 1 || y > c - 1 || board[x][y] != word[index])\\n        return false\\n    board[x][y] = \\'#\\'\\n    let isFound = (\\n        dfs(board, word, index + 1, x + 1, y) ||\\n        dfs(board, word, index + 1, x - 1, y) ||\\n        dfs(board, word, index + 1, x, y + 1) ||\\n        dfs(board, word, index + 1, x, y - 1)\\n    )\\n    board[x][y] = word[index]\\n    return isFound\\n}\\n```\n```py\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        for x in range(len(board)):\\n            for y in range(len(board[0])):\\n                if self.DFS(board, word, 0, x, y):\\n                    return True\\n        return False\\n\\n    def DFS(self, board: List[List[str]], word:str, index: int, x: int, y: int) -> bool:\\n        if index == len(word):\\n            return True\\n        c = len(board[0])\\n        r = len(board)\\n        if x < 0 or y < 0 or x > r - 1 or y > c - 1 or word[index] != board[x][y] :\\n            return False\\n        board[x][y] = chr(0)\\n        found = (\\n            self.DFS(board, word, index + 1, x + 1, y) or\\n            self.DFS(board, word, index + 1, x - 1, y) or\\n            self.DFS(board, word, index + 1, x, y + 1) or\\n            self.DFS(board, word, index + 1, x, y - 1))\\n        board[x][y] = word[index]\\n        return found\\n```\n```c\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c);\\n\\nbool    exist(char** board, int boardSize, int* boardColSize, char * word)\\n{\\n        if (!board || !boardSize || !boardColSize) return (false);\\n        if (!word)  return (true);\\n        for (int i = 0; i < boardSize; i++)\\n            for (int j = 0; j < boardColSize[0]; j++)\\n                if (solve(board, word, 0, i, j, boardSize, boardColSize[0]))\\n                    return (true);\\n        return (false);\\n}\\n\\nbool    solve(char **board, char *word, int i, int x, int y, int r, int c)\\n{\\n        bool    found;\\n        char    temp;\\n\\n        if (x < 0 || x == r || y < 0 || y == c || word[i] != board[x][y])\\n\\t\\t    return (false);\\n        if (i == strlen(word) - 1)\\n\\t\\t    return (true);\\n        temp = board[x][y];\\n        board[x][y] = 0;\\n        found = solve(board, word, i + 1, x + 1, y, r, c) ||\\n                solve(board, word, i + 1, x - 1, y, r, c) ||\\n                solve(board, word, i + 1, x, y + 1, r, c) ||\\n                solve(board, word, i + 1, x, y - 1, r, c);\\n        board[x][y] = temp;\\n        return (found);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733353,
                "title": "python-elegant-short-no-tle",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*m*k)\\n    Memory: O(k)\\n\\n    where k - word length\\n    \"\"\"\\n\\n    VISITED = \\'#\\'\\n\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        n, m = len(board), len(board[0])\\n\\n        beginning = end = 0\\n        for r in range(n):\\n            for c in range(m):\\n                if board[r][c] == word[0]:\\n                    beginning += 1\\n                elif board[r][c] == word[-1]:\\n                    end += 1\\n\\n        if beginning > end:\\n            word = word[::-1]\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if self.dfs(board, i, j, 0, word):\\n                    return True\\n\\n        return False\\n\\n    @classmethod\\n    def dfs(cls, board: List[List[str]], i: int, j: int, k: int, word: str) -> bool:\\n        if k == len(word):\\n            return True\\n\\n        n, m = len(board), len(board[0])\\n        if (i < 0 or i >= n) or (j < 0 or j >= m) or word[k] != board[i][j]:\\n            return False\\n\\n        board[i][j] = cls.VISITED\\n        res = cls.dfs(board, i + 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i - 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i, j + 1, k + 1, word) or \\\\\\n              cls.dfs(board, i, j - 1, k + 1, word)\\n        board[i][j] = word[k]\\n\\n        return res\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*m*k)\\n    Memory: O(k)\\n\\n    where k - word length\\n    \"\"\"\\n\\n    VISITED = \\'#\\'\\n\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        n, m = len(board), len(board[0])\\n\\n        beginning = end = 0\\n        for r in range(n):\\n            for c in range(m):\\n                if board[r][c] == word[0]:\\n                    beginning += 1\\n                elif board[r][c] == word[-1]:\\n                    end += 1\\n\\n        if beginning > end:\\n            word = word[::-1]\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if self.dfs(board, i, j, 0, word):\\n                    return True\\n\\n        return False\\n\\n    @classmethod\\n    def dfs(cls, board: List[List[str]], i: int, j: int, k: int, word: str) -> bool:\\n        if k == len(word):\\n            return True\\n\\n        n, m = len(board), len(board[0])\\n        if (i < 0 or i >= n) or (j < 0 or j >= m) or word[k] != board[i][j]:\\n            return False\\n\\n        board[i][j] = cls.VISITED\\n        res = cls.dfs(board, i + 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i - 1, j, k + 1, word) or \\\\\\n              cls.dfs(board, i, j + 1, k + 1, word) or \\\\\\n              cls.dfs(board, i, j - 1, k + 1, word)\\n        board[i][j] = word[k]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712727,
                "title": "java-easy-understandable-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visiting = new boolean[board.length][board[0].length];\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(word.charAt(0) == board[i][j]){\\n                    boolean found = dfs(0, i, j, visiting, board, word);\\n                    if(found){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean dfs(int idx, int row, int col, boolean[][] visiting, char[][] board, String word){\\n        if(idx == word.length()){\\n            return true;\\n        }\\n        if(row < 0 || row == board.length || col < 0 || col == board[0].length || visiting[row][col] || word.charAt(idx) != board[row][col]){\\n            return false;\\n        }\\n        visiting[row][col] = true;\\n        boolean left = dfs(idx + 1, row, col - 1, visiting, board, word);\\n        boolean right = dfs(idx + 1, row, col + 1, visiting, board, word);\\n        boolean up = dfs(idx + 1, row - 1, col, visiting, board, word);\\n        boolean down = dfs(idx + 1, row + 1, col, visiting, board, word);\\n        visiting[row][col] = false;\\n        return up || down || left || right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visiting = new boolean[board.length][board[0].length];\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(word.charAt(0) == board[i][j]){\\n                    boolean found = dfs(0, i, j, visiting, board, word);\\n                    if(found){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean dfs(int idx, int row, int col, boolean[][] visiting, char[][] board, String word){\\n        if(idx == word.length()){\\n            return true;\\n        }\\n        if(row < 0 || row == board.length || col < 0 || col == board[0].length || visiting[row][col] || word.charAt(idx) != board[row][col]){\\n            return false;\\n        }\\n        visiting[row][col] = true;\\n        boolean left = dfs(idx + 1, row, col - 1, visiting, board, word);\\n        boolean right = dfs(idx + 1, row, col + 1, visiting, board, word);\\n        boolean up = dfs(idx + 1, row - 1, col, visiting, board, word);\\n        boolean down = dfs(idx + 1, row + 1, col, visiting, board, word);\\n        visiting[row][col] = false;\\n        return up || down || left || right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936355,
                "title": "js-backtracking-read-this-if-you-are-having-problems-using-a-set",
                "content": "I spent some time confused as to why my solution, which was seamingly very similar to other\\'s in Java and Python was not working. There are two main ways to solve this problem with backtracking: changing the value of the board when visiting a position, or keeping a record of your visited positions and check against it. \\n\\nA Set is a great data structure for that record of visited positions. There is a caveat, however. In JavaScript, values put into the Set are stored by reference, so when looking them up, if you pass anything else other than the same reference, your item wont be found.\\n\\nWhy is this relevant?\\n\\n```\\nconst set = new Set();\\n//.....\\nconst arr = [1,4]\\nset.add(arr);\\n\\nset.has(arr) // true\\nset.has([1,4]) // false!\\n\\n```\\nAs you can see, looking up an array (or object) by values does not work, since when we pass the `[1,4]` array, we are essentially creating a new array, so the references are different.\\n\\nTo solve this, you have to convert your array to a unique value. I converted the coordinate array to a string with an \"r|c\" format. \\n\\nKeep in mind that the way in which you convert your array to a unique value has a runtime impact. Avoid `array.join()` or other iterartive approaches if possible.\\n\\nI hope this is helpful to anyone trying to implement this with a Set.\\n\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function(board, word) {\\n    \\n    const M = board.length;\\n    const N = board[0].length;\\n    \\n    const path = new Set();\\n    \\n    function backtrack(r,c,idx){\\n        \\n        if(idx === word.length) return true;\\n        if(r < 0 || c < 0 || r >= M || c >= N) return false;\\n        if(board[r][c] !== word.charAt(idx)) return false;\\n        \\n        const arrStr = `${r}|${c}`;\\n        if(path.has(arrStr)) return false;\\n        \\n        path.add(arrStr);\\n        const found = \\n              backtrack(r+1, c, idx+1) ||\\n              backtrack(r-1,c,idx+1) || \\n              backtrack(r,c+1, idx+1) ||               \\n              backtrack(r,c-1, idx+1);\\n        path.delete(arrStr);            \\n        return found;\\n    \\n    }\\n   \\n    \\n    for(let i = 0; i<M; i++){\\n        for(let j = 0; j<N; j++){\\n            if(board[i][j] === word.charAt(0))\\n                if(backtrack(i,j,0)) return true;        \\n        }\\n    }\\n\\t\\n    return false;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nconst set = new Set();\\n//.....\\nconst arr = [1,4]\\nset.add(arr);\\n\\nset.has(arr) // true\\nset.has([1,4]) // false!\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737606,
                "title": "java-easiest-code-with-comments-dfs-backtracking-80-faster",
                "content": "```\\nclass Solution {\\n    boolean flag = false; // Initially word not found\\n    public boolean exist(char[][] board, String word) {\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && !flag){ //only considering characters that are same as initial character of the string\\n                    boolean[][] visited = new boolean[board.length][board[0].length]; // boolean array to keep track of all the visited elements\\n                    backtrack(board,word,visited,i,j,0); // 0 is the pointer at first character of the word \\n                }\\n            }\\n        return flag;\\n    }\\n    public void backtrack(char[][] board,String word,boolean[][] visited,int i,int j,int idx){\\n        if(flag) return;\\n        if(idx == word.length() || i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j] == true || word.charAt(idx) != board[i][j]) return;\\n        if(idx == word.length()-1){\\n            flag = !flag; \\n            return;\\n        }\\n        idx++;\\n        visited[i][j] = true;\\n        backtrack(board,word,visited,i-1,j,idx);\\n        backtrack(board,word,visited,i,j+1,idx);\\n        backtrack(board,word,visited,i+1,j,idx);\\n        backtrack(board,word,visited,i,j-1,idx);\\n        idx--;\\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    boolean flag = false; // Initially word not found\\n    public boolean exist(char[][] board, String word) {\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j] == word.charAt(0) && !flag){ //only considering characters that are same as initial character of the string\\n                    boolean[][] visited = new boolean[board.length][board[0].length]; // boolean array to keep track of all the visited elements\\n                    backtrack(board,word,visited,i,j,0); // 0 is the pointer at first character of the word \\n                }\\n            }\\n        return flag;\\n    }\\n    public void backtrack(char[][] board,String word,boolean[][] visited,int i,int j,int idx){\\n        if(flag) return;\\n        if(idx == word.length() || i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j] == true || word.charAt(idx) != board[i][j]) return;\\n        if(idx == word.length()-1){\\n            flag = !flag; \\n            return;\\n        }\\n        idx++;\\n        visited[i][j] = true;\\n        backtrack(board,word,visited,i-1,j,idx);\\n        backtrack(board,word,visited,i,j+1,idx);\\n        backtrack(board,word,visited,i+1,j,idx);\\n        backtrack(board,word,visited,i,j-1,idx);\\n        idx--;\\n        visited[i][j] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706675,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\n// Please Upvote if you found it helpful\\n\\nclass Solution {\\npublic:\\n    bool visited[6][6];\\n    \\n    bool solve(vector<vector<char>>& board,string word,int m,int n,string s,int r,int c)\\n    {\\n        if(s==word) return true;\\n        if(r<0 || c<0 || r>=m || c>=n || board[r][c]!=word[s.size()] || visited[r][c]==true)\\n            return false;\\n        \\n        s+=board[r][c];\\n        visited[r][c]=true;\\n\\t\\tint d = solve(board,word,m,n,s,r+1,c);               // Moving downward\\n        int u = solve(board,word,m,n,s,r-1,c);               // Moving upward\\n        int f = solve(board,word,m,n,s,r,c+1);               // Moving right or forward\\n        int b = solve(board,word,m,n,s,r,c-1);               // Moving left or backward\\n        visited[r][c]=false;\\n        s.pop_back();\\n        return u || d || f || b;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size(),n=board[0].size();\\n        string s=\"\";\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(board[i][j]==word[0])\\n                    if(solve(board,word,m,n,s,i,j))\\n                        return true;\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool visited[6][6];\\n    \\n    bool solve(vector<vector<char>>& board,string word,int m,int n,string s,int r,int c)\\n    {\\n        if(s==word) return true;\\n        if(r<0 || c<0 || r>=m || c>=n || board[r][c]!=word[s.size()] || visited[r][c]==true)\\n            return false;\\n        \\n        s+=board[r][c];\\n        visited[r][c]=true;\\n\\t\\tint d = solve(board,word,m,n,s,r+1,c);               // Moving downward\\n        int u = solve(board,word,m,n,s,r-1,c);               // Moving upward\\n        int f = solve(board,word,m,n,s,r,c+1);               // Moving right or forward\\n        int b = solve(board,word,m,n,s,r,c-1);               // Moving left or backward\\n        visited[r][c]=false;\\n        s.pop_back();\\n        return u || d || f || b;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1507992,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool startsHere(vector<vector<char>>& board, int x, int y, string& word, int idx) {\\n        if (idx == word.size()) return true;\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || \\n            board[x][y] == \\'.\\' || board[x][y] != word[idx]) return false;\\n        \\n        char c = board[x][y];\\n        board[x][y] = \\'.\\';\\n        bool res = startsHere(board, x+1, y, word, idx+1) ||\\n                   startsHere(board, x-1, y, word, idx+1) ||\\n                   startsHere(board, x, y+1, word, idx+1) ||\\n                   startsHere(board, x, y-1, word, idx+1);\\n        board[x][y] = c;\\n        return res;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (startsHere(board, i, j, word, 0)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507663,
                "title": "simple-java-solution-reusing-board-runtime-94-ms-faster-than-80-12-of-java-online-submissions",
                "content": "Here, I am not using any extra boolean multidimensional array to track found characters but reusing the board itself. Reason : adding a boolean[][] to the code just increases the space complexity for no reason.\\n\\n```\\nclass Solution {\\n    int row;\\n    int col;\\n    public boolean exist(char[][] board, String word) {\\n        row = board.length;\\n        col = board[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(crosswordUtil(board, i, j, 0, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean crosswordUtil(char[][] board, int i, int j, int startIndex, String word) {\\n        // this denotes that all chars have been found. index is from 0 to word.length() - 1\\n        if(startIndex == word.length())\\n            return true;\\n        // base case for exit criteria\\n        if(i > row -1 || i < 0 || j < 0 || j > col - 1|| board[i][j] != word.charAt(startIndex))\\n        return false;\\n        // mark the current board cell as visited\\n        board[i][j] = \\'$\\';\\n        // check if next char in word can be found in any of the four directions - North, South, West Or East of the current position denoted by startIndex.\\n        boolean exists = crosswordUtil(board, i-1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i+1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j-1, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j+1, startIndex+1, word);\\n        // restore the element of board[i][j] with the char at word\\'s startIndex\\n        board[i][j] = word.charAt(startIndex);\\n        // if everything is fine, then exist will be true. Else it will be false\\n        return exists;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int row;\\n    int col;\\n    public boolean exist(char[][] board, String word) {\\n        row = board.length;\\n        col = board[0].length;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(crosswordUtil(board, i, j, 0, word)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean crosswordUtil(char[][] board, int i, int j, int startIndex, String word) {\\n        // this denotes that all chars have been found. index is from 0 to word.length() - 1\\n        if(startIndex == word.length())\\n            return true;\\n        // base case for exit criteria\\n        if(i > row -1 || i < 0 || j < 0 || j > col - 1|| board[i][j] != word.charAt(startIndex))\\n        return false;\\n        // mark the current board cell as visited\\n        board[i][j] = \\'$\\';\\n        // check if next char in word can be found in any of the four directions - North, South, West Or East of the current position denoted by startIndex.\\n        boolean exists = crosswordUtil(board, i-1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i+1, j, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j-1, startIndex+1, word) ||\\n                         crosswordUtil(board, i, j+1, startIndex+1, word);\\n        // restore the element of board[i][j] with the char at word\\'s startIndex\\n        board[i][j] = word.charAt(startIndex);\\n        // if everything is fine, then exist will be true. Else it will be false\\n        return exists;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424255,
                "title": "python-clean",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        def dfs(row, column, index):\\n            if index == len(word): return True\\n            path.add((row, column))\\n            for r, c in [(row-1, column), (row, column-1), (row, column+1), (row+1, column)]:\\n                if r in range(M) and c in range(N) and board[r][c] == word[index] and (r, c) not in path:\\n                    if dfs(r, c, index+1): return True\\n            path.remove((row, column))\\n        \\n        M, N = len(board), len(board[0])\\n        path = set()\\n        for row in range(M):\\n            for column in range(N):\\n                if board[row][column] == word[0]:\\n                    if dfs(row, column, 1): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        \\n        def dfs(row, column, index):\\n            if index == len(word): return True\\n            path.add((row, column))\\n            for r, c in [(row-1, column), (row, column-1), (row, column+1), (row+1, column)]:\\n                if r in range(M) and c in range(N) and board[r][c] == word[index] and (r, c) not in path:\\n                    if dfs(r, c, index+1): return True\\n            path.remove((row, column))\\n        \\n        M, N = len(board), len(board[0])\\n        path = set()\\n        for row in range(M):\\n            for column in range(N):\\n                if board[row][column] == word[0]:\\n                    if dfs(row, column, 1): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419624,
                "title": "c-solution-dfs-backtracking-explanation",
                "content": "This is a standard problem of DFS + Backtracking. One of the most frequently asked question in **Interviews**\\n\\n**Basic Idea :**\\n\\nWe iterate over every element of grid checking if it is equals to first element of given word. If found then we call the dfs() function with current position of board with starting position of word. \\n\\n1. Lets see the Base Condition : \\n\\t* Now in DFS check if current position of board position matches with current index of word. If no then return false. Else continue checking its adjacent for a match using dfs(). \\n\\t* Also, if current index of word equals to size of word, return true.\\n\\n2. Moving on, let\\'s develop the logic for checking the adjacent positions that are not yet visited. Here we use a simple trick for backtracking : \\n\\t* When we enter the dfs(), we mark current position as visited using this line : \\n`char curr = board[i][j]; board[i][j] = \\'*\\' `. \\n\\t* When checking for all the adjacents is finished, we again flip the value of current position to original, `board[i][j] = curr;`.\\n\\n# Algorithm : \\n\\n```\\nstatic int X[4] = {-1,1,0,0};\\nstatic int Y[4] = {0,0,-1,1};\\nint m, n, s;    \\n\\nbool isSafe(vector<vector<char>>& board, int x, int y, int k)\\n{\\n\\treturn (x >= 0 && y >=0 && x < m && y < n && k+1 < s && board[x][y] != \\'*\\');\\n}\\nbool dfs(vector<vector<char>>& board, string& word, int i, int j, int k)\\n{   \\n\\tif(board[i][j] != word[k]) return false;\\n\\tif(k == s-1) return true;\\n\\tchar curr = board[i][j];\\n\\tboard[i][j] = \\'*\\';\\n\\tbool success = false;\\n\\n\\tfor(int p=0; p<4; p++)\\n\\t{\\n\\t\\tint x = i + X[p];\\n\\t\\tint y = j + Y[p];\\n\\t\\tif(isSafe(board, x, y, k))\\n\\t\\t{\\n\\t\\t\\tsuccess = (success || dfs(board, word, x, y, k+1));\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = curr;              // Backtrack\\n\\treturn success;  \\n}\\n    \\nbool exist(vector<vector<char>>& board, string word) {\\n\\tm = board.size();\\n\\tif(m==0) return false;\\n\\tn = board[0].size();\\n\\ts = word.size();\\n\\tfor(int i=0; i<m; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j] == word[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(board, word, i, j, 0)) return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Follow Up :**\\n\\n* Similar Problems : \\n\\t* [Word Search II](https://leetcode.com/problems/word-search-ii/)\\n\\n*Feel free to ask anything or correct me. \\nHope you understood the solution. If you liked it do upvote :)*\\n\\n**Update :**\\n\\nThanks [@Blast_d](https://leetcode.com/Blast_d/) for your suggestion to add `isSafe()`. \\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nstatic int X[4] = {-1,1,0,0};\\nstatic int Y[4] = {0,0,-1,1};\\nint m, n, s;    \\n\\nbool isSafe(vector<vector<char>>& board, int x, int y, int k)\\n{\\n\\treturn (x >= 0 && y >=0 && x < m && y < n && k+1 < s && board[x][y] != \\'*\\');\\n}\\nbool dfs(vector<vector<char>>& board, string& word, int i, int j, int k)\\n{   \\n\\tif(board[i][j] != word[k]) return false;\\n\\tif(k == s-1) return true;\\n\\tchar curr = board[i][j];\\n\\tboard[i][j] = \\'*\\';\\n\\tbool success = false;\\n\\n\\tfor(int p=0; p<4; p++)\\n\\t{\\n\\t\\tint x = i + X[p];\\n\\t\\tint y = j + Y[p];\\n\\t\\tif(isSafe(board, x, y, k))\\n\\t\\t{\\n\\t\\t\\tsuccess = (success || dfs(board, word, x, y, k+1));\\n\\t\\t}\\n\\t}\\n\\tboard[i][j] = curr;              // Backtrack\\n\\treturn success;  \\n}\\n    \\nbool exist(vector<vector<char>>& board, string word) {\\n\\tm = board.size();\\n\\tif(m==0) return false;\\n\\tn = board[0].size();\\n\\ts = word.size();\\n\\tfor(int i=0; i<m; i++)\\n\\t{\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j] == word[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dfs(board, word, i, j, 0)) return true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168111,
                "title": "c-solution-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j, int r, int c){\\n        if(i >= r || j >= c || i < 0 || j < 0 || word[pos] != board[i][j])\\n            return false;\\n    \\n        if(pos == word.length()-1)\\n            return true;\\n        \\n        board[i][j] = \\'#\\'; // to avoid using of this character again in the backtracking\\n        if(backtrack(board, word, pos+1, i+1, j, r, c) || backtrack(board, word, pos+1, i-1, j, r, c) || backtrack(board, word, pos+1, i, j+1, r, c) || backtrack(board, word, pos+1, i, j-1, r, c))\\n            return true;\\n\\t\\n        board[i][j] = word[pos]; // Reassigning the character as backtracking is complete.\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                if(backtrack(board, word, 0, i, j, board.size(), board[0].size()))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backtrack(vector<vector<char>>& board, string& word, int pos, int i, int j, int r, int c){\\n        if(i >= r || j >= c || i < 0 || j < 0 || word[pos] != board[i][j])\\n            return false;\\n    \\n        if(pos == word.length()-1)\\n            return true;\\n        \\n        board[i][j] = \\'#\\'; // to avoid using of this character again in the backtracking\\n        if(backtrack(board, word, pos+1, i+1, j, r, c) || backtrack(board, word, pos+1, i-1, j, r, c) || backtrack(board, word, pos+1, i, j+1, r, c) || backtrack(board, word, pos+1, i, j-1, r, c))\\n            return true;\\n\\t\\n        board[i][j] = word[pos]; // Reassigning the character as backtracking is complete.\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                if(backtrack(board, word, 0, i, j, board.size(), board[0].size()))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113871,
                "title": "cpp-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,1,-1,0};\\n    int y[4]={-1,0,0,1};\\n    bool solve(int i,int j,vector<vector<char>>& board,vector<vector<int>>&vis,int k,string word,int m,int n)\\n    {\\n        if(k==word.size())\\n            return true;\\n        if(i<0||j<0||i>=m||j>=n)\\n            return false;\\n        if(vis[i][j]||word[k]!=board[i][j])\\n            return false;\\n        vis[i][j]=1;\\n        for(int r=0;r<4;r++)\\n        {\\n            if(solve(i+x[r],j+y[r],board,vis,k+1,word,m,n))\\n                return true; \\n        } \\n        vis[i][j]=0;\\n       return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[i].size();j++)\\n            {\\n                if(word[0]==board[i][j])\\n                {\\n                    int k=0;\\n                    if(solve(i,j,board,vis,k,word,m,n))\\n                       return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n                       \\n                     \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,1,-1,0};\\n    int y[4]={-1,0,0,1};\\n    bool solve(int i,int j,vector<vector<char>>& board,vector<vector<int>>&vis,int k,string word,int m,int n)\\n    {\\n        if(k==word.size())\\n            return true;\\n        if(i<0||j<0||i>=m||j>=n)\\n            return false;\\n        if(vis[i][j]||word[k]!=board[i][j])\\n            return false;\\n        vis[i][j]=1;\\n        for(int r=0;r<4;r++)\\n        {\\n            if(solve(i+x[r],j+y[r],board,vis,k+1,word,m,n))\\n                return true; \\n        } \\n        vis[i][j]=0;\\n       return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[i].size();j++)\\n            {\\n                if(word[0]==board[i][j])\\n                {\\n                    int k=0;\\n                    if(solve(i,j,board,vis,k,word,m,n))\\n                       return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n                       \\n                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044373,
                "title": "java-dfs-solution",
                "content": "```java\\nclass Solution {\\n    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        // Traverse board until encounter first char of word\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && dfs(board, i, j, 0, word)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean dfs(char[][] board, int row, int col, int soFar, String word){\\n        // Word search complete\\n        if(soFar == word.length()) return true;\\n        // OUT OF BOUNDS\\n        if(row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != word.charAt(soFar)) return false;\\n        // Consecutive word so far\\n        else{\\n            char current = board[row][col];\\n            // Avoid using the cell twice\\n            board[row][col] = \\'#\\';\\n            // Explore Neighbors\\n            for(int[] dir: directions)\\n                if(dfs(board, row + dir[0], col + dir[1], soFar + 1, word)) return true;\\n            // In case all directions failed\\n            board[row][col] = current;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public boolean exist(char[][] board, String word) {\\n        // Traverse board until encounter first char of word\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++)\\n                if(board[i][j] == word.charAt(0) && dfs(board, i, j, 0, word)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean dfs(char[][] board, int row, int col, int soFar, String word){\\n        // Word search complete\\n        if(soFar == word.length()) return true;\\n        // OUT OF BOUNDS\\n        if(row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != word.charAt(soFar)) return false;\\n        // Consecutive word so far\\n        else{\\n            char current = board[row][col];\\n            // Avoid using the cell twice\\n            board[row][col] = \\'#\\';\\n            // Explore Neighbors\\n            for(int[] dir: directions)\\n                if(dfs(board, row + dir[0], col + dir[1], soFar + 1, word)) return true;\\n            // In case all directions failed\\n            board[row][col] = current;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043968,
                "title": "python-only-need-to-pass-indices-no-board-or-word",
                "content": "```python\\nclass Solution:\\n    \\n    def exist(self, board, word):      \\n        self.board, self.word = board, word         \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):                \\n                if self.dfs(i, j, 0):\\n                    return True                    \\n        return False\\n    \\n    \\n    def dfs(self, i, j, k):                        \\n        \\n        if not self.board[i][j] == self.word[k]: return False # our termination condition  \\n        \\n        if len(self.word) == k+1: return True   # our success condition           \\n        \\n        self.board[i][j] = \"#\"   # start backtracking     \\n        \\n        for a, b in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n            if not (0 <= a < len(self.board) and 0 <= b < len(self.board[0])): continue\\n            if self.dfs(a, b, k+1): return True                        \\n            \\n        self.board[i][j] = self.word[k]    # end backtracking    \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def exist(self, board, word):      \\n        self.board, self.word = board, word         \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):                \\n                if self.dfs(i, j, 0):\\n                    return True                    \\n        return False\\n    \\n    \\n    def dfs(self, i, j, k):                        \\n        \\n        if not self.board[i][j] == self.word[k]: return False # our termination condition  \\n        \\n        if len(self.word) == k+1: return True   # our success condition           \\n        \\n        self.board[i][j] = \"#\"   # start backtracking     \\n        \\n        for a, b in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n            if not (0 <= a < len(self.board) and 0 <= b < len(self.board[0])): continue\\n            if self.dfs(a, b, k+1): return True                        \\n            \\n        self.board[i][j] = self.word[k]    # end backtracking    \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875183,
                "title": "java-solution-clean-code-with-full-comments-using-only-backtracking",
                "content": "```\\npublic boolean exist(char[][] board, String word) // Main method.\\n{\\n        for(int i = 0; i < board.length; i++)  // Iterate through the matrix, while doing so, call the support method so it will do the calculations.\\n        {\\n            for(int j = 0; j < board[0].length; j++) \\n            {                \\n                if(helper(board, i, j, word, 0))// Here the main method gets the results form the support method.\\n                {\\n                   return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean helper(char[][] board, int x, int y, String word, int end) // Support method.\\n    {     \\n        if(x < 0 || board.length-1 < x || y < 0 || board[0].length-1 < y || board[x][y] == \\'x\\' || word.charAt(end) != board[x][y]) // Check if we are in the boundaries, or the spot has been visited or that the current letter do not match to the letter in the matrix.\\n\\t    {\\n            return false;\\n        }\\n        \\n        if(end == word.length()-1) // If we have reached the end of the given word, we found it in the matrix.\\n        {\\n            return true;\\n        }\\n          \\n        char temp = board[x][y]; // Make a copy of the current spot that we are in.\\n\\t\\t\\tboard[x][y] = \\'x\\'; // Overwrite the current spot so that we will know that we have been here before (for the rest of the current iteration).\\n           \\n        boolean up = helper(board, x-1, y, word, end+1);       // Options of traversing the matrix.\\n        boolean down = helper(board, x+1, y, word, end+1);\\n        boolean left = helper(board, x, y-1, word, end+1);\\n        boolean right = helper(board, x, y+1, word, end+1);\\n        \\n        if(up || down || left || right) // If the options are valid, return true.\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n             board[x][y] = temp; // Else overwrite the current spot with the copy of the original value for the next iteration.\\n             return false;\\n\\t\\t}\\n\\t\\t\\t \\n          // Runtime: 5 ms, faster than 83.51% of Java online submissions for Word Search.\\n\\t\\t   // Memory Usage: 41.3 MB, less than 73.34% of Java online submissions for Word Search.\\n }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic boolean exist(char[][] board, String word) // Main method.\\n{\\n        for(int i = 0; i < board.length; i++)  // Iterate through the matrix, while doing so, call the support method so it will do the calculations.\\n        {\\n            for(int j = 0; j < board[0].length; j++) \\n            {                \\n                if(helper(board, i, j, word, 0))// Here the main method gets the results form the support method.\\n                {\\n                   return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean helper(char[][] board, int x, int y, String word, int end) // Support method.\\n    {     \\n        if(x < 0 || board.length-1 < x || y < 0 || board[0].length-1 < y || board[x][y] == \\'x\\' || word.charAt(end) != board[x][y]) // Check if we are in the boundaries, or the spot has been visited or that the current letter do not match to the letter in the matrix.\\n\\t    {\\n            return false;\\n        }\\n        \\n        if(end == word.length()-1) // If we have reached the end of the given word, we found it in the matrix.\\n        {\\n            return true;\\n        }\\n          \\n        char temp = board[x][y]; // Make a copy of the current spot that we are in.\\n\\t\\t\\tboard[x][y] = \\'x\\'; // Overwrite the current spot so that we will know that we have been here before (for the rest of the current iteration).\\n           \\n        boolean up = helper(board, x-1, y, word, end+1);       // Options of traversing the matrix.\\n        boolean down = helper(board, x+1, y, word, end+1);\\n        boolean left = helper(board, x, y-1, word, end+1);\\n        boolean right = helper(board, x, y+1, word, end+1);\\n        \\n        if(up || down || left || right) // If the options are valid, return true.\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n             board[x][y] = temp; // Else overwrite the current spot with the copy of the original value for the next iteration.\\n             return false;\\n\\t\\t}\\n\\t\\t\\t \\n          // Runtime: 5 ms, faster than 83.51% of Java online submissions for Word Search.\\n\\t\\t   // Memory Usage: 41.3 MB, less than 73.34% of Java online submissions for Word Search.\\n }",
                "codeTag": "Unknown"
            },
            {
                "id": 596775,
                "title": "short-c-code-directions-dfs-backtracking-explanations",
                "content": "\\n   my solution uses dfs to traverse the board with change in directions as dx, dy\\n   func--> it checks if a word matches or not recursively\\n   \\n   \\n   ```\\n   int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    bool func(int i,int j,string word,int in,vector<vector<char>>& board)\\n    {                                 \\n        int n=board.size();\\n        int m=board[0].size();\\n        if(in==word.size()) return true; \\n        if(i>=n||i<0||j>=m||j<0)  return false;   \\n        if(word[in]==board[i][j] )\\n        {\\n            board[i][j]=\\'@\\';               //  this prevents reusage of characters\\n            for(int l=0;l<4;l++)\\n                if(func(i+dx[l],j+dy[l],word,in+1,board)) return true;\\n            board[i][j]=word[in];      // again changing it to its previous state\\n        }\\n        return false;        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==word[0])              \\n                    if(func(i,j,word,0,board)) return true;\\n        return false;\\n    }\\n\\t\\n\\tNOTE- if any part is unclear feel free to leave a comment ;)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "\\n   my solution uses dfs to traverse the board with change in directions as dx, dy\\n   func--> it checks if a word matches or not recursively\\n   \\n   \\n   ```\\n   int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    bool func(int i,int j,string word,int in,vector<vector<char>>& board)\\n    {                                 \\n        int n=board.size();\\n        int m=board[0].size();\\n        if(in==word.size()) return true; \\n        if(i>=n||i<0||j>=m||j<0)  return false;   \\n        if(word[in]==board[i][j] )\\n        {\\n            board[i][j]=\\'@\\';               //  this prevents reusage of characters\\n            for(int l=0;l<4;l++)\\n                if(func(i+dx[l],j+dy[l],word,in+1,board)) return true;\\n            board[i][j]=word[in];      // again changing it to its previous state\\n        }\\n        return false;        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(board[i][j]==word[0])              \\n                    if(func(i,j,word,0,board)) return true;\\n        return false;\\n    }\\n\\t\\n\\tNOTE- if any part is unclear feel free to leave a comment ;)",
                "codeTag": "Unknown"
            },
            {
                "id": 568692,
                "title": "100-swift",
                "content": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let m = board.count\\n        let n = board[0].count\\n        let array = Array(word)\\n        var visited = Array(repeating: Array(repeating: false, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                if board[i][j] == array[0] {\\n                    if dfs(m, n, i, j, &visited, 0, array, board) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func dfs(_ m: Int, _ n: Int, _ x: Int, _ y: Int, _ visited: inout [[Bool]], _ index: Int, _ array: [Character], _ board: [[Character]]) -> Bool {\\n        guard x < m, y < n, x >= 0, y >= 0 else { return false }\\n        \\n        if visited[x][y] {\\n            return false\\n        }\\n        \\n        if board[x][y] != array[index] {\\n            return false\\n        } \\n        \\n        if index == array.count - 1 {\\n            return true\\n        }\\n        \\n        visited[x][y] = true \\n        if dfs(m, n, x + 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x - 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y + 1, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y - 1, &visited, index + 1, array, board) {\\n            return true\\n        }\\n        visited[x][y] = false\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\\n        let m = board.count\\n        let n = board[0].count\\n        let array = Array(word)\\n        var visited = Array(repeating: Array(repeating: false, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                if board[i][j] == array[0] {\\n                    if dfs(m, n, i, j, &visited, 0, array, board) {\\n                        return true\\n                    }\\n                }\\n            }\\n        }\\n        return false\\n    }\\n    \\n    func dfs(_ m: Int, _ n: Int, _ x: Int, _ y: Int, _ visited: inout [[Bool]], _ index: Int, _ array: [Character], _ board: [[Character]]) -> Bool {\\n        guard x < m, y < n, x >= 0, y >= 0 else { return false }\\n        \\n        if visited[x][y] {\\n            return false\\n        }\\n        \\n        if board[x][y] != array[index] {\\n            return false\\n        } \\n        \\n        if index == array.count - 1 {\\n            return true\\n        }\\n        \\n        visited[x][y] = true \\n        if dfs(m, n, x + 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x - 1, y, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y + 1, &visited, index + 1, array, board) \\n        || dfs(m, n, x, y - 1, &visited, index + 1, array, board) {\\n            return true\\n        }\\n        visited[x][y] = false\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452463,
                "title": "python-dfs-well-documented-with-dfs-template",
                "content": "\"\"\"\\nclass Solution:\\n    \\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n         if len(board) == 0 or len(board[0]) == 0:\\n            return False\\n         self.Nrows, self.Ncols = len(board), len(board[0])\\n        \\n         for r in range(self.Nrows):\\n            for c in range(self.Ncols):\\n                if board[r][c]==word[0] and self.dfs(board, r, c, 0 , word):\\n                    return True\\n         return False\\n    \\n    def dfs(self,board,i,j,idx,word):\\n        #basecase (if we checked all letters of the word already)\\n        if idx==len(word):\\n            return True \\n        ## if we are outside the board or we do not have a matching letter\\n        if i< 0 or i > len(board)-1 or j < 0 or j > len(board[0])-1 or board[i][j]!=word[idx]:\\n            return False\\n        #### Now this is the template for DFS \\n        # 1) Make a choice and mark it\\n        \\n        original=board[i][j]  ## first store board[i][j] so you can restore it if dfs does not work\\n        board[i][j]=\"\" ## make this unavailable/non-matching\\n        ## 2) Explore Depth-wise\\n        if self.dfs(board,i-1,j,idx+1,word) or self.dfs(board,i+1,j,idx+1,word) or self.dfs(board,i,j-1,idx+1,word) or self.dfs(board,i,j+1,idx+1,word):\\n            return True \\n        else:\\n        ### 3) Unchoose\\n            board[i][j]=original\\n            \\n        \\n        \\n        \\n        \\n        \\n\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nclass Solution:\\n    \\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n         if len(board) == 0 or len(board[0]) == 0:\\n            return False\\n         self.Nrows, self.Ncols = len(board), len(board[0])\\n        \\n         for r in range(self.Nrows):\\n            for c in range(self.Ncols):\\n                if board[r][c]==word[0] and self.dfs(board, r, c, 0 , word):\\n                    return True\\n         return False\\n    \\n    def dfs(self,board,i,j,idx,word):\\n        #basecase (if we checked all letters of the word already)\\n        if idx==len(word):\\n            return True \\n        ## if we are outside the board or we do not have a matching letter\\n        if i< 0 or i > len(board)-1 or j < 0 or j > len(board[0])-1 or board[i][j]!=word[idx]:\\n            return False\\n        #### Now this is the template for DFS \\n        # 1) Make a choice and mark it\\n        \\n        original=board[i][j]  ## first store board[i][j] so you can restore it if dfs does not work\\n        board[i][j]=\"\" ## make this unavailable/non-matching\\n        ## 2) Explore Depth-wise\\n        if self.dfs(board,i-1,j,idx+1,word) or self.dfs(board,i+1,j,idx+1,word) or self.dfs(board,i,j-1,idx+1,word) or self.dfs(board,i,j+1,idx+1,word):\\n            return True \\n        else:\\n        ### 3) Unchoose\\n            board[i][j]=original\\n            \\n        \\n        \\n        \\n        \\n        \\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 429314,
                "title": "faster-96-low-memory-100-backtracking-python",
                "content": "Runtime: 260 ms, faster than 96.31% of Python3 online submissions for Word Search.\\nMemory Usage: 13.8 MB, less than 100.00% of Python3 online submissions for Word Search.\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        nrows = len(board)\\n        ncols = len(board[0])\\n        \\n        def backtrack(i, j, idx):\\n            char = board[i][j]\\n            if char != word[idx]:\\n                return False\\n            elif idx == len(word)-1:\\n                return True\\n            \\n            board[i][j] = \\'\\'\\n            \\n            if i > 0 and backtrack(i-1, j, idx+1):\\n                return True\\n            if j > 0 and backtrack(i, j-1, idx+1):\\n                return True\\n            if i < nrows-1 and backtrack(i+1, j, idx+1):\\n                return True\\n            if j < ncols-1 and backtrack(i, j+1, idx+1):\\n                return True            \\n            board[i][j] = char\\n            return False\\n                    \\n        for i in range(nrows):\\n            for j in range(ncols):\\n                if backtrack(i, j, 0):\\n                    return True\\n            \\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 260 ms, faster than 96.31% of Python3 online submissions for Word Search.\\nMemory Usage: 13.8 MB, less than 100.00% of Python3 online submissions for Word Search.\\n\\n```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        nrows = len(board)\\n        ncols = len(board[0])\\n        \\n        def backtrack(i, j, idx):\\n            char = board[i][j]\\n            if char != word[idx]:\\n                return False\\n            elif idx == len(word)-1:\\n                return True\\n            \\n            board[i][j] = \\'\\'\\n            \\n            if i > 0 and backtrack(i-1, j, idx+1):\\n                return True\\n            if j > 0 and backtrack(i, j-1, idx+1):\\n                return True\\n            if i < nrows-1 and backtrack(i+1, j, idx+1):\\n                return True\\n            if j < ncols-1 and backtrack(i, j+1, idx+1):\\n                return True            \\n            board[i][j] = char\\n            return False\\n                    \\n        for i in range(nrows):\\n            for j in range(ncols):\\n                if backtrack(i, j, 0):\\n                    return True\\n            \\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 325978,
                "title": "clean-javascript-dfs-backtracking-solution",
                "content": "JavaScript version of the solution: https://leetcode.com/problems/word-search/discuss/27835/C%2B%2B-dfs-solution.\\n```\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\n\\nconst dfs = (board, i, j, remain) => {\\n    if (remain.length === 0) return true;\\n    if (i<0 || i>=board.length || j<0 || j>=board[0].length) return false;\\n    if (board[i][j] !== remain[0]) return false;\\n    \\n    let char = board[i][j];\\n    board[i][j] = \\'-\\';\\n    let result = (dfs(board,i+1,j,remain.substring(1))||dfs(board,i-1,j,remain.substring(1))\\n        || dfs(board,i,j+1,remain.substring(1)) || dfs(board,i,j-1,remain.substring(1)));\\n    board[i][j]=char;\\n    return result;\\n}\\n\\nvar exist = function(board, word) {\\n    if (board.length===0 || word.length===0) return false;\\n    for (let i=0; i<board.length; i++){\\n        for (let j=0; j<board[0].length; j++){\\n            if (dfs(board,i,j,word)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\n\\nconst dfs = (board, i, j, remain) => {\\n    if (remain.length === 0) return true;\\n    if (i<0 || i>=board.length || j<0 || j>=board[0].length) return false;\\n    if (board[i][j] !== remain[0]) return false;\\n    \\n    let char = board[i][j];\\n    board[i][j] = \\'-\\';\\n    let result = (dfs(board,i+1,j,remain.substring(1))||dfs(board,i-1,j,remain.substring(1))\\n        || dfs(board,i,j+1,remain.substring(1)) || dfs(board,i,j-1,remain.substring(1)));\\n    board[i][j]=char;\\n    return result;\\n}\\n\\nvar exist = function(board, word) {\\n    if (board.length===0 || word.length===0) return false;\\n    for (let i=0; i<board.length; i++){\\n        for (let j=0; j<board[0].length; j++){\\n            if (dfs(board,i,j,word)) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283374,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    int n;\\n    int m;\\n    public bool Exist(char[][] board, string word) {\\n        n = board.Length;\\n        if (n == 0) return false;\\n        m = board[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var result = false;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                result = DFS(board, isVisited, i, j, word, 0);\\n                if (result) return true;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool DFS(char[][] board, bool[,] isVisited, int x, int y, string word, int wordIndex) {\\n        if (wordIndex == word.Length) {\\n            return true;\\n        }\\n        \\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return false;\\n        }\\n\\n        if (word[wordIndex] != board[x][y]) {\\n            return false;\\n        }\\n\\n        if (isVisited[x, y]) return false;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var oneResult = DFS(board, isVisited, x + direction.Item1, y + direction.Item2, word, wordIndex + 1);\\n            if (oneResult) return true;\\n        }\\n\\n        isVisited[x, y] = false;\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int n;\\n    int m;\\n    public bool Exist(char[][] board, string word) {\\n        n = board.Length;\\n        if (n == 0) return false;\\n        m = board[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var result = false;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                result = DFS(board, isVisited, i, j, word, 0);\\n                if (result) return true;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool DFS(char[][] board, bool[,] isVisited, int x, int y, string word, int wordIndex) {\\n        if (wordIndex == word.Length) {\\n            return true;\\n        }\\n        \\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return false;\\n        }\\n\\n        if (word[wordIndex] != board[x][y]) {\\n            return false;\\n        }\\n\\n        if (isVisited[x, y]) return false;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var oneResult = DFS(board, isVisited, x + direction.Item1, y + direction.Item2, word, wordIndex + 1);\\n            if (oneResult) return true;\\n        }\\n\\n        isVisited[x, y] = false;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173887,
                "title": "swift-implementation",
                "content": "```\\nfunc exist(_ board: [[Character]], _ word: String) -> Bool {\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: 0)]\\n        \\n        for row in 0..<board.count {\\n            for col in 0..<board[0].count {\\n                if search(board, word, row, col, 0) { \\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func search(_ board: [[Character]], _ word: String, _ row: Int, _ col: Int, _ index: Int) -> Bool {\\n        if index >= word.count { return true }\\n        \\n        if row < 0  || row >= board.count || col < 0 || col >= board[0].count {\\n            return false\\n        }\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: index)]\\n        if board[row][col] == \"-\" || board[row][col] != char { \\n            return false \\n        }\\n        \\n        var board = board\\n        board[row][col] = \"-\"\\n        \\n        let ans = search(board, word, row+1, col, index+1) ||\\n                  search(board, word, row-1, col, index+1) ||\\n                  search(board, word, row, col+1, index+1) ||\\n                  search(board, word, row, col-1, index+1) \\n        \\n        return ans\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc exist(_ board: [[Character]], _ word: String) -> Bool {\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: 0)]\\n        \\n        for row in 0..<board.count {\\n            for col in 0..<board[0].count {\\n                if search(board, word, row, col, 0) { \\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func search(_ board: [[Character]], _ word: String, _ row: Int, _ col: Int, _ index: Int) -> Bool {\\n        if index >= word.count { return true }\\n        \\n        if row < 0  || row >= board.count || col < 0 || col >= board[0].count {\\n            return false\\n        }\\n        \\n        let char = word[word.index(word.startIndex, offsetBy: index)]\\n        if board[row][col] == \"-\" || board[row][col] != char { \\n            return false \\n        }\\n        \\n        var board = board\\n        board[row][col] = \"-\"\\n        \\n        let ans = search(board, word, row+1, col, index+1) ||\\n                  search(board, word, row-1, col, index+1) ||\\n                  search(board, word, row, col+1, index+1) ||\\n                  search(board, word, row, col-1, index+1) \\n        \\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27796,
                "title": "share-my-java-code-straightforward-dfs",
                "content": "    public class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return false;\\n            }\\n            boolean[][] isBeingVisited = new boolean[board.length][board[0].length];\\n            for (int i = 0; i < board.length; ++i) {\\n                for (int j = 0; j < board[0].length; ++j) {\\n                    if (board[i][j] == word.charAt(0) &&\\n                        dfs(board, word, isBeingVisited, 0, i, j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private boolean dfs(char[][] board, String word, boolean[][] isBeingVisited, int index, int row, int col) {\\n            if (index == word.length()) {  // reached the end of the word\\n                return true;\\n            }\\n            if (row < 0 || row >= board.length || col < 0 || col >= board[0].length\\n                || isBeingVisited[row][col] || word.charAt(index) != board[row][col]) {\\n                return false;    \\n            }\\n            isBeingVisited[row][col] = true;\\n            if (dfs(board, word, isBeingVisited, index + 1, row - 1, col)) {\\n                return true;\\n            }\\n            if (dfs(board, word, isBeingVisited, index + 1, row + 1, col)) {\\n                return true;\\n            }\\n            if (dfs(board, word, isBeingVisited, index + 1, row, col - 1)) {\\n                return true;\\n            }\\n            if (dfs(board, word, isBeingVisited, index + 1, row, col + 1)) {\\n                return true;\\n            }\\n            isBeingVisited[row][col] = false;  // umark current point; it might be used in other routes\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            if (word == null || word.length() == 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 27853,
                "title": "c-accepted-simpe-depth-first-search-with-comments",
                "content": "    private int rows;\\n    private int columns;\\n    bool[,] visited;\\n    \\n    public bool Exist(char[,] board, string word) \\n    {\\n        // init\\n        rows = board.GetLength(0);\\n        columns = board.GetLength(1);\\n        visited = new bool[rows,columns];\\n        \\n        // search one by one\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (Search(board, word, 0, i, j))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public bool Search(char[,] board, string word, int wordIndex, int i, int j)\\n    {\\n        // word search is already finished\\n        if (wordIndex == word.Length) return true;\\n        \\n        if (i < 0 || i >= rows || j < 0 || j >= columns // illegal boundaries\\n           || visited[i, j] == true                     // already visited\\n           || board[i, j] != word[wordIndex])           // char does not match\\n        {\\n            return false;\\n        }\\n        \\n        // mark current position as visited\\n        visited[i, j] = true; \\n        \\n        // search four directions: right, down, left, up\\n        if (Search(board, word, wordIndex + 1, i, j + 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i - 1, j)) return true;\\n        if (Search(board, word, wordIndex + 1, i, j - 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i + 1, j)) return true;\\n        \\n        // not found, restore current position to unvisited\\n        visited[i, j] = false; \\n        return false;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "    private int rows;\\n    private int columns;\\n    bool[,] visited;\\n    \\n    public bool Exist(char[,] board, string word) \\n    {\\n        // init\\n        rows = board.GetLength(0);\\n        columns = board.GetLength(1);\\n        visited = new bool[rows,columns];\\n        \\n        // search one by one\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (Search(board, word, 0, i, j))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public bool Search(char[,] board, string word, int wordIndex, int i, int j)\\n    {\\n        // word search is already finished\\n        if (wordIndex == word.Length) return true;\\n        \\n        if (i < 0 || i >= rows || j < 0 || j >= columns // illegal boundaries\\n           || visited[i, j] == true                     // already visited\\n           || board[i, j] != word[wordIndex])           // char does not match\\n        {\\n            return false;\\n        }\\n        \\n        // mark current position as visited\\n        visited[i, j] = true; \\n        \\n        // search four directions: right, down, left, up\\n        if (Search(board, word, wordIndex + 1, i, j + 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i - 1, j)) return true;\\n        if (Search(board, word, wordIndex + 1, i, j - 1)) return true;\\n        if (Search(board, word, wordIndex + 1, i + 1, j)) return true;\\n        \\n        // not found, restore current position to unvisited\\n        visited[i, j] = false; \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27872,
                "title": "accepted-16ms-c-solution-use-backtracking-easy-understand",
                "content": "    class Solution {\\n    public:\\n        bool exist(std::vector<std::vector<char> > &board, std::string word) {\\n            rows = static_cast<int>(board.size()), cols = static_cast<int>(board[0].size());\\n            for (int row = 0; row != rows; ++row)\\n                for (int col = 0; col != cols; ++col)\\n                    if (exist(board, word, row, col, 0))\\n                        return true;\\n            return false;\\n        }\\n    private:\\n        int rows, cols;\\n        bool exist(std::vector<std::vector<char> > &board, std::string &word, int row, int col, int pos) {\\n            if (board[row][col] != word[pos] || board[row][col] == ' ')\\n                return false;\\n            else if (pos == word.size() - 1)\\n                return true;\\n            char c = board[row][col];\\n            board[row][col] = ' ';\\n            if (row > 0 && exist(board, word, row - 1, col, pos + 1) ||\\n                row < rows - 1 && exist(board, word, row + 1, col, pos + 1) ||\\n                col > 0 && exist(board, word, row, col - 1, pos + 1) ||\\n                col < cols - 1 && exist(board, word, row, col + 1, pos + 1)) {\\n                board[row][col] = c;\\n                return true;\\n            }\\n            board[row][col] = c;\\n            return false;\\n        }\\n    };\\n\\n\\nUpdated **Jun 28:**\\n\\n    class Solution {\\n    public:\\n        bool exist(std::vector<std::vector<char> > &board, std::string word) {\\n            rows = static_cast<int>(board.size()), cols = static_cast<int>(board[0].size());\\n            for (int row = 0; row != rows; ++row)\\n                for (int col = 0; col != cols; ++col)\\n                    if (exist(board, word, row, col, 0))\\n                        return true;\\n            return false;\\n        }\\n    private:\\n        int rows, cols;\\n        bool exist(std::vector<std::vector<char> > &board, std::string &word, int row, int col, int pos) {\\n            if (board[row][col] != word[pos] || board[row][col] == ' ')\\n                return false;\\n            else if (pos == word.size() - 1)\\n                return true;\\n            char c = board[row][col];\\n            board[row][col] = ' ';\\n            bool next_exist = row > 0 && exist(board, word, row - 1, col, pos + 1) ||\\n                row < rows - 1 && exist(board, word, row + 1, col, pos + 1) ||\\n                col > 0 && exist(board, word, row, col - 1, pos + 1) ||\\n                col < cols - 1 && exist(board, word, row, col + 1, pos + 1);\\n            board[row][col] = c;\\n            return next_exist;\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        bool exist(std::vector<std::vector<char> > &board, std::string word) {\\n            rows = static_cast<int>(board.size()), cols = static_cast<int>(board[0].size());\\n            for (int row = 0; row != rows; ++row)\\n                for (int col = 0; col != cols; ++col)\\n                    if (exist(board, word, row, col, 0))\\n                        return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 27692,
                "title": "my-java-accepted-solution-using-iterative-method-no-recursive-call",
                "content": "I saw a lot dfs recursive version. I happen to do it in a iterative way. Share my solution with you. \\n**Notice:** Need to trace back and reset visited from true->false once a wrong end encountered.\\n      \\n    public class Solution {\\n            public boolean exist(char[][] board, String word) {\\n                for(int i = 0;i < board.length;i++){\\n                    for(int j = 0;j < board[0].length;j++){\\n                        if(board[i][j] == word.charAt(0)){\\n                            // dfs\\n                            Stack<Integer> x_pos = new Stack<Integer>();\\n                            Stack<Integer> y_pos = new Stack<Integer>();\\n                            Stack<Integer> word_index = new Stack<Integer>();\\n                            Stack<Integer> x_track = new Stack<Integer>();\\n                            Stack<Integer> y_track = new Stack<Integer>();\\n                            int[][] subpath_num = new int[board.length][board[0].length];\\n                            boolean[][] visited = new boolean[board.length][board[0].length];\\n                            for(int q = 0;q < board.length;q++)\\n                                for(int p = 0;p < board[0].length;p++)\\n                                    visited[q][p] = false;\\n                            x_pos.add(i);y_pos.add(j);\\n                            word_index.add(0);\\n                            while(!x_pos.isEmpty()){\\n                                int x = x_pos.pop();\\n                                int y = y_pos.pop();\\n                                int index = word_index.pop()+1;\\n                                if(index == word.length()){return true;}\\n                                int count_subpath = 0;\\n                                x_track.add(x);y_track.add(y);\\n                                visited[x][y] = true;\\n                                if(x-1 >= 0){\\n                                    if(board[x-1][y] == word.charAt(index) && !visited[x-1][y]){\\n                                        x_pos.add(x-1);y_pos.add(y);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                if(x+1 < board.length){\\n                                    if(board[x+1][y] == word.charAt(index) && !visited[x+1][y]){\\n                                        x_pos.add(x+1);y_pos.add(y);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                if(y-1 >= 0){\\n                                    if(board[x][y-1] == word.charAt(index) && !visited[x][y-1]){\\n                                        x_pos.add(x);y_pos.add(y-1);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                if(y+1 < board[0].length){\\n                                    if(board[x][y+1] == word.charAt(index) && !visited[x][y+1]){\\n                                        x_pos.add(x);y_pos.add(y+1);\\n                                        word_index.add(index);\\n                                        count_subpath++;\\n                                    }\\n                                }\\n                                subpath_num[x][y] = count_subpath;\\n                                // reset the visited mark\\n                                if(subpath_num[x][y] == 0){\\n                                    int cur_x = x_track.pop();\\n                                    int cur_y = y_track.pop();\\n                                    while(subpath_num[cur_x][cur_y] <= 1){\\n                                        visited[cur_x][cur_y] = false;\\n                                        if(x_track.isEmpty()){break;}\\n                                        cur_x = x_track.pop();\\n                                        cur_y = y_track.pop();\\n                                    }\\n                                    subpath_num[cur_x][cur_y]--;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public boolean exist(char[][] board, String word) {\\n                for(int i = 0;i < board.length;i++){\\n                    for(int j = 0;j < board[0].length;j++){\\n                        if(board[i][j] == word.charAt(0)){\\n                            // dfs\\n                            Stack<Integer> x_pos = new Stack<Integer>();\\n                            Stack<Integer> y_pos = new Stack<Integer>();\\n                            Stack<Integer> word_index = new Stack<Integer>();\\n                            Stack<Integer> x_track = new Stack<Integer>();\\n                            Stack<Integer> y_track = new Stack<Integer>();\\n                            int[][] subpath_num = new int[board.length][board[0].length];\\n                            boolean[][] visited = new boolean[board.length][board[0].length];\\n                            for(int q = 0;q < board.length;q++)\\n                                for(int p = 0;p < board[0].length;p++)\\n                                    visited[q][p] = false;\\n                            x_pos.add(i);y_pos.add(j);\\n                            word_index.add(0);\\n                            while(!x_pos.isEmpty()){\\n                                int x = x_pos.pop();\\n                                int y = y_pos.pop();\\n                                int index = word_index.pop()+1;\\n                                if(index == word.length()){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 3696604,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& vis, string &word, int i, int j, int start) {\\n        int m = board.size(), n = board[0].size();\\n        if(start == word.size()) return true;\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || board[i][j] != word[start]) return false;\\n        \\n        vis[i][j] = true;\\n        bool a = dfs(board, vis, word, i+1, j, start+1) ||\\n                 dfs(board, vis, word, i-1, j, start+1) ||\\n                 dfs(board, vis, word, i, j+1, start+1) ||\\n                 dfs(board, vis, word, i, j-1, start+1);\\n        \\n        vis[i][j] = false; // Reset the visited state for backtracking\\n        return a;\\n    }\\n\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(dfs(board, vis, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& vis, string &word, int i, int j, int start) {\\n        int m = board.size(), n = board[0].size();\\n        if(start == word.size()) return true;\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || board[i][j] != word[start]) return false;\\n        \\n        vis[i][j] = true;\\n        bool a = dfs(board, vis, word, i+1, j, start+1) ||\\n                 dfs(board, vis, word, i-1, j, start+1) ||\\n                 dfs(board, vis, word, i, j+1, start+1) ||\\n                 dfs(board, vis, word, i, j-1, start+1);\\n        \\n        vis[i][j] = false; // Reset the visited state for backtracking\\n        return a;\\n    }\\n\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(dfs(board, vis, word, i, j, 0))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475730,
                "title": "java-solution-for-word-search-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to determine if a given word exists in a given 2D board of characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given solution is Depth First Search (DFS) algorithm. The solution iterates over each cell of the input matrix and calls the dfs function to check if the given word can be formed starting from that cell. The dfs function searches for the next character of the word in the neighbouring cells (up, down, left, right) and marks the current cell as visited by changing the value to \\'#\\' to avoid revisiting the same cell. If the entire word is found in the matrix, the function returns true; otherwise, it backtracks by restoring the value of the current cell and returns false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(mn4^k), where m and n are the number of rows and columns in the input matrix, and k is the length of the given word. This is because the solution iterates over each cell of the matrix, and for each cell, it makes at most four recursive calls, one for each neighbouring cell. The worst-case time complexity occurs when the word is not found, and the DFS algorithm traverses all possible paths, which can be up to 4^k paths.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k), where k is the length of the given word. This is because the solution uses the call stack to store the state of the recursive calls, and the maximum depth of the call stack is k.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        boolean result = false;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(dfs(board,word,i,j,0))\\n                {\\n                    result = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean dfs(char[][] board, String word, int i, int j, int k)\\n    {\\n        int m = board.length;\\n        int n = board[0].length;\\n        if(i<0 || j<0 || i>=m || j>=n)\\n        {\\n            return false;\\n        }\\n        if(board[i][j] == word.charAt(k))\\n        {\\n            char temp = board[i][j];\\n            board[i][j]=\\'#\\';\\n            if(k==word.length()-1)\\n            {\\n                return true;\\n            }\\n            else if(dfs(board, word, i-1, j, k+1) ||dfs(board, word, i+1, j, k+1) ||dfs(board, word, i, j-1, k+1) ||dfs(board, word, i, j+1, k+1))\\n            {\\n                return true;\\n            }\\n            board[i][j]=temp;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        int m = board.length;\\n        int n = board[0].length;\\n        boolean result = false;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(dfs(board,word,i,j,0))\\n                {\\n                    result = true;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean dfs(char[][] board, String word, int i, int j, int k)\\n    {\\n        int m = board.length;\\n        int n = board[0].length;\\n        if(i<0 || j<0 || i>=m || j>=n)\\n        {\\n            return false;\\n        }\\n        if(board[i][j] == word.charAt(k))\\n        {\\n            char temp = board[i][j];\\n            board[i][j]=\\'#\\';\\n            if(k==word.length()-1)\\n            {\\n                return true;\\n            }\\n            else if(dfs(board, word, i-1, j, k+1) ||dfs(board, word, i+1, j, k+1) ||dfs(board, word, i, j-1, k+1) ||dfs(board, word, i, j+1, k+1))\\n            {\\n                return true;\\n            }\\n            board[i][j]=temp;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100391,
                "title": "idea-of-backtracking-explained-c-detailed",
                "content": "**problem link \\uD83D\\uDC47\\u2714**\\n\\n[https://leetcode.com/problems/word-search/description/](https://leetcode.com/problems/word-search/description/)\\n\\n- We are given a *(m x n)* grid of characters , like one below.\\n   []()\\n![BACKTRACKING_0.jpeg](https://assets.leetcode.com/users/images/1527cb39-66ae-4e74-9804-172f43694185_1674711594.5905821.jpeg)\\n    \\n- We have been given a string *word=\\u201CABCCED\"* which we need to find if it can be formed using adjacent cells , horizontally or vertically grid.\\n- We can think of this of finding a ****path**** of this word if its exists in the gird.\\n- For example if the **word = \\u201C*ABCCED\\u201D,*  then the path would look something like this :\\n\\n![BACKTRACKING_1.PNG](https://assets.leetcode.com/users/images/11cfae2a-81c0-457e-b1b0-410fdd56124c_1674711681.5046153.png)\\n\\n\\n- Another example would be the word = ***\\u201CSFDEESE\\u201D**.*\\n![BACKTRACKING_2.PNG](https://assets.leetcode.com/users/images/dedd97ca-7f7b-4142-b7b3-5aa5f402aded_1674711707.833588.png)\\n\\n\\n## How we build solution using backtracking\\n\\n- Let\\u2019s look at the first testcase. We need to search for the word \\u201C*********ABCCED\\u201D.*********\\n![BACKTRACKING_3.PNG](https://assets.leetcode.com/users/images/6a9331e9-1ca0-4175-8ce8-cfff2e7f5f59_1674711730.6457713.png)\\n\\n- So my first letter is \\u2018A\\u2019 in the word \\u201CABCCED\\u201D.\\n- Let\\u2019s traverse the grid from (0,0).\\n\\n![BACKTRACKING_4.PNG](https://assets.leetcode.com/users/images/226d169d-7ea2-4fbf-b671-f97b9eb32536_1674711752.4014783.png)\\n\\n### **The basic strategy would be to traverse all paths and try seeing if those paths will build up the word which we are trying to find in the grid.**\\n\\n- Also, let\\u2019s make a sequence bag, which will show if the sequence or path we follow is building up our target word. Initially it would be empty.\\n- So we are currently at ****************(0,0)**************** and the character at (0,0) = ******\\u2018A\\u2019,****** which matches with the first letter of our target word.\\n- So we can say, that **since we have found a match, it *******may be******* possible that a path might follow from that particular cell to our target word.** So, from (0,0) a path might exists for the word = \\u201C***ABCCED\\u201D.***\\n\\n![BACKTRACKING_5.PNG](https://assets.leetcode.com/users/images/74873225-895f-48de-8f11-75ef23f920a7_1674711806.0440943.png)\\n\\n\\n- Let\\u2019s look at some possible paths from (0,0).\\n\\n![BACKTRACKING_6.PNG](https://assets.leetcode.com/users/images/7cc8a989-501d-47cb-90d5-9ac21d848554_1674711820.0786366.png)\\n\\n\\n- But **************from (0,0)************** (or \\u2018A\\u2019) you can either go right or down **************************************as the first move of ANY path.**************************************\\n- You cannot go diagonal or up from (0,0).\\n\\n![BACKTRACKING_7.PNG](https://assets.leetcode.com/users/images/b78c62e6-e1b0-47c3-9943-05df82e7ea79_1674711847.8853803.png)\\n\\n\\n- So there are two possible paths we may follow : \\u201CAB..\\u201D or \\u201CAS\\u2026\\u201D from (0,0) so as to build our target word.\\n- But in our target word = ********\\u201CABCCED\\u201D,******** the **************second word is \\u2018B\\u2019. Therefore , we have a guarantee that following the path \\u201CAS..\\u201D will NEVER  build our target word.  Therefore, we can refuse to traverse that path.**************\\n\\n ****************************\\n\\n![BACKTRACKING_8.PNG](https://assets.leetcode.com/users/images/a227ec2f-1093-4937-b107-60d35a843b6f_1674711866.3551629.png)\\n\\n\\n- Since \\u2018AB..\\u2019 path has a \\u2018B\\u2019 as a second character which matches with the second character of our target word, we can safely traverse this path, hoping it can lead to our target word.\\n- Now we are currently at the cell **************(0,1) ie \\u2018B\\u2019.************** From (0,1) we can go in 3 directions : left , right , bottom.\\n\\n![BACKTRACKING_9.PNG](https://assets.leetcode.com/users/images/b797d598-acda-4464-aed1-6e4d6b351c10_1674711890.9708087.png)\\n\\n\\n- Now we can either have the sequence as ****\\u201CABA..\\u201D if we go left, \\u201CABC..\\u201D if we go right, \\u201CABF..\\u201D if we go down.****\\n- But our third character is ************\\u2018C\\u2019,************ that\\u2019s why we don\\u2019t need to traverse the paths \\u201CABA..\\u201D or \\u201CABF\\u2026\\u201D since they won\\u2019t build our word. \\u201CABC..\\u201D path can possibly build our target word.\\n- And this is how we will keep on going, until we find our word\\u2026(see below)\\n\\n![BACKTRACKING_10.PNG](https://assets.leetcode.com/users/images/0e46d27f-84e5-4f47-9aaf-1d19c8fa4b31_1674711913.5524411.png)\\n\\n![BACKTRACKING_11.PNG](https://assets.leetcode.com/users/images/8e1f0581-08b7-4b09-b3de-6b1d7d90b9e3_1674711926.5692747.png)\\n\\n\\n![BACKTRACKING_12.PNG](https://assets.leetcode.com/users/images/433c6d42-cbbd-49b7-9745-8ec45f177cdc_1674711942.4101472.png)\\n\\n![BACKTRACKING_13.PNG](https://assets.leetcode.com/users/images/2692eec8-f8a0-427b-b50f-f72ed0a0fda1_1674711955.8107622.png)\\n\\n\\n- Finally we have found that a possible path/solution exists in the grid \\uD83D\\uDCAF\\uD83D\\uDCAF.\\n\\n## **What if multiple true paths exist?**\\n\\n- Let\\u2019s tweak the grid up a bit and go back to an intermediate step.\\n\\n![BACKTRACKING_14.PNG](https://assets.leetcode.com/users/images/2e4e6ffa-edd0-46c3-95c6-4dfe6112f554_1674711973.1489658.png)\\n\\n\\n- Here the paths \\u201C********************************************ABCCC..\\u201D by going UP,  \\u201CABCCF..\\u201D by going left******************************************** will be rejected since we need the character \\u2018E\\u2019 up next.\\n- Here, we have two paths \\u201C******ABCCE..\\u201D by going right, \\u201CABCCE..\\u201D also by going down.******\\n- Let\\u2019s say we traverse \\u201C**************************************************ABCCE..\\u201D by going RIGHT.**************************************************\\n\\n![BACKTRACKING_15.PNG](https://assets.leetcode.com/users/images/ee0af524-1831-4adb-b3e7-b14fb608b313_1674712001.3424916.png)\\n\\n\\n- From ************************************************\\u2018E\\u2019 , we will get \\u201CABCCEE\\u201D if we go UP , \\u201CABCCEEF\\u201D if we go down, \\u201CABCCEC\\u201D if we go left, which DON\\u2019T build the target word \\u201CABCCED\\u201D.************************************************\\n- So what we should do is , that we should go back a previous step, till where our solution was ************************going correct. And try some other direction to build the solution. So,************************\\n\\n![BACKTRACKING_16.PNG](https://assets.leetcode.com/users/images/adc3a9d8-3d7e-4563-9a43-644a34735aca_1674712019.407731.png)\\n\\n- Our traversal was correct up to ******\\u201CABCC..\\u201D , and since going RIGHT to \\u2018E\\u2019 did not build our solution, we will traverse \\u201CABCCE..\\u201D by going DOWN.**\\n- This path will eventually find that the target word \\u201C************ABCCED\\u201D************ exists in the grid.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rows;\\n  int cols;\\n  int dx[4] = {1,-1,0,0};\\n  int dy[4] = {0,0,1,-1};\\n\\n  bool backtrack(vector<vector<char>>&board , int i , int j , string word, int index)\\n  {\\n    if(index == word.size())\\n        return true;\\n    \\n    if(i >= rows or j >= cols or i < 0 or j < 0 or board[i][j] != word[index])\\n        return false;\\n\\n    char t = board[i][j];\\n    board[i][j] = \\'*\\';\\n    \\n    bool x =\\n    backtrack(board,i+dx[0],j+dy[0],word,index+1) or\\n    backtrack(board,i+dx[1],j+dy[1],word,index+1) or\\n    backtrack(board,i+dx[2],j+dy[2],word,index+1) or\\n    backtrack(board,i+dx[3],j+dy[3],word,index+1);\\n\\n    board[i][j] = t;\\n\\n    return x;\\n  }\\n\\n  bool exist(vector<vector<char>>& board, string word)\\n  {\\n    rows = board.size();\\n    cols = board[0].size();\\n\\n    for(int i=0;i<rows;i++)\\n    {\\n        for(int j=0;j<cols;j++)\\n        {\\n            if(backtrack(board,i,j,word,0))\\n                return true; \\n        }\\n    }\\n    return false;\\n  }\\n \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rows;\\n  int cols;\\n  int dx[4] = {1,-1,0,0};\\n  int dy[4] = {0,0,1,-1};\\n\\n  bool backtrack(vector<vector<char>>&board , int i , int j , string word, int index)\\n  {\\n    if(index == word.size())\\n        return true;\\n    \\n    if(i >= rows or j >= cols or i < 0 or j < 0 or board[i][j] != word[index])\\n        return false;\\n\\n    char t = board[i][j];\\n    board[i][j] = \\'*\\';\\n    \\n    bool x =\\n    backtrack(board,i+dx[0],j+dy[0],word,index+1) or\\n    backtrack(board,i+dx[1],j+dy[1],word,index+1) or\\n    backtrack(board,i+dx[2],j+dy[2],word,index+1) or\\n    backtrack(board,i+dx[3],j+dy[3],word,index+1);\\n\\n    board[i][j] = t;\\n\\n    return x;\\n  }\\n\\n  bool exist(vector<vector<char>>& board, string word)\\n  {\\n    rows = board.size();\\n    cols = board[0].size();\\n\\n    for(int i=0;i<rows;i++)\\n    {\\n        for(int j=0;j<cols;j++)\\n        {\\n            if(backtrack(board,i,j,word,0))\\n                return true; \\n        }\\n    }\\n    return false;\\n  }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844379,
                "title": "word-search-c-using-dfs-easy-to-learn-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word){\\n\\t// if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count)\\n            return true;\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size()|| board[i][j]!=word[count]){\\n            return false;\\n        }\\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        bool ans =  dfs(i-1,j,count+1,board,word) ||\\n                    dfs(i+1,j,count+1,board,word) ||\\n                    dfs(i,j-1,count+1,board,word) ||\\n                    dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp; // make board as it is for the upcoming calls\\n        \\n        return ans;\\n        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n       for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0]) {\\n\\t\\t\\t\\t\\t  if(dfs(i,j,0,board,word))\\n                {\\n                    return true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\nIf you like it , please do **Upvote**\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int i,int j,int count,vector<vector<char>>& board,string word){\\n\\t// if we have found the whole string then count will become (word.length()==count) so return true\\n        if(word.length()==count)\\n            return true;\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size()|| board[i][j]!=word[count]){\\n            return false;\\n        }\\n        \\n        char temp = board[i][j];                    // curr char\\n        board[i][j] = \\' \\';                          // mark as visited\\n        \\n        bool ans =  dfs(i-1,j,count+1,board,word) ||\\n                    dfs(i+1,j,count+1,board,word) ||\\n                    dfs(i,j-1,count+1,board,word) ||\\n                    dfs(i,j+1,count+1,board,word);\\n        \\n        board[i][j] = temp; // make board as it is for the upcoming calls\\n        \\n        return ans;\\n        \\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n       for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==word[0]) {\\n\\t\\t\\t\\t\\t  if(dfs(i,j,0,board,word))\\n                {\\n                    return true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844050,
                "title": "java-my-easy-to-understand-solution-with-comments-beginner-friendly",
                "content": "```\\n//TC : O(V + E) ~ O(m * n + 4 * m * n) ~ O(m * n)\\n//SC : O(m * n), visited array\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visited = new boolean[board.length][board[0].length];\\n        for(int r = 0; r < board.length; ++r){\\n            for(int c = 0; c < board[0].length; ++c){\\n                if(board[r][c] == word.charAt(0)){\\n                   boolean res = search(0, r, c, board, visited, word);\\n                   if(res) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean search(int idx, int r, int c, char[][] board, boolean[][] visited, String word){\\n        if(idx == word.length()) return true; //means all the character of the words are found\\n        \\n        if(r < 0 || c < 0 || r >= board.length || c >= board[0].length){ //out of boundry so return false\\n            return false;\\n        }else if(board[r][c] != word.charAt(idx)){ //different char than word.charAt(idx) so return false\\n            return false;\\n        }else if(visited[r][c] == true){ //already visited cell so return false \\n            return false;\\n        }\\n        \\n        visited[r][c] = true; //mark visited\\n        \\n        //up call\\n        boolean ans1 = search(idx + 1, r - 1, c, board, visited, word);\\n        if(ans1) return true;\\n        \\n        //left call\\n        boolean ans2 = search(idx + 1, r, c - 1, board, visited, word);\\n        if(ans2) return true;\\n        \\n        //down call\\n        boolean ans3 = search(idx + 1, r + 1, c, board, visited, word);\\n        if(ans3) return true;\\n        \\n        //right call\\n        boolean ans4 = search(idx + 1, r, c + 1, board, visited, word);\\n        if(ans4) return true;\\n        \\n        visited[r][c] = false; //backtrack\\n        \\n        return false;\\n    }\\n}\\n```\\n**If you liked the solution please do UPVOTE it, Thank You!**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n//TC : O(V + E) ~ O(m * n + 4 * m * n) ~ O(m * n)\\n//SC : O(m * n), visited array\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        boolean[][] visited = new boolean[board.length][board[0].length];\\n        for(int r = 0; r < board.length; ++r){\\n            for(int c = 0; c < board[0].length; ++c){\\n                if(board[r][c] == word.charAt(0)){\\n                   boolean res = search(0, r, c, board, visited, word);\\n                   if(res) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public boolean search(int idx, int r, int c, char[][] board, boolean[][] visited, String word){\\n        if(idx == word.length()) return true; //means all the character of the words are found\\n        \\n        if(r < 0 || c < 0 || r >= board.length || c >= board[0].length){ //out of boundry so return false\\n            return false;\\n        }else if(board[r][c] != word.charAt(idx)){ //different char than word.charAt(idx) so return false\\n            return false;\\n        }else if(visited[r][c] == true){ //already visited cell so return false \\n            return false;\\n        }\\n        \\n        visited[r][c] = true; //mark visited\\n        \\n        //up call\\n        boolean ans1 = search(idx + 1, r - 1, c, board, visited, word);\\n        if(ans1) return true;\\n        \\n        //left call\\n        boolean ans2 = search(idx + 1, r, c - 1, board, visited, word);\\n        if(ans2) return true;\\n        \\n        //down call\\n        boolean ans3 = search(idx + 1, r + 1, c, board, visited, word);\\n        if(ans3) return true;\\n        \\n        //right call\\n        boolean ans4 = search(idx + 1, r, c + 1, board, visited, word);\\n        if(ans4) return true;\\n        \\n        visited[r][c] = false; //backtrack\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843923,
                "title": "simple-java-solution-using-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n         boolean visited[][]=new boolean[board.length][board[0].length];\\n          for(int i=0;i<board.length;i++){\\n              for(int j=0;j<board[0].length;j++){\\n                  if(board[i][j]==word.charAt(0) && search(board,word,i,j,0,visited)){\\n                      return true;\\n                  }\\n              }\\n          }\\n        return false;\\n        \\n    }\\n    public boolean search(char[][]board,String word,int i,int j,int idx,boolean visited[][]){\\n       if(idx==word.length()){\\n           return true;\\n       }\\n       if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=word.charAt(idx) || visited[i][j]){\\n            return false;\\n        }\\n        visited[i][j]=true;\\n        if(search(board,word,i+1,j,idx+1,visited) || search(board,word,i,j+1,idx+1,visited) || search(board,word,i-1,j,idx+1,visited) || search(board,word,i,j-1,idx+1,visited)){\\n            return true;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n         boolean visited[][]=new boolean[board.length][board[0].length];\\n          for(int i=0;i<board.length;i++){\\n              for(int j=0;j<board[0].length;j++){\\n                  if(board[i][j]==word.charAt(0) && search(board,word,i,j,0,visited)){\\n                      return true;\\n                  }\\n              }\\n          }\\n        return false;\\n        \\n    }\\n    public boolean search(char[][]board,String word,int i,int j,int idx,boolean visited[][]){\\n       if(idx==word.length()){\\n           return true;\\n       }\\n       if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=word.charAt(idx) || visited[i][j]){\\n            return false;\\n        }\\n        visited[i][j]=true;\\n        if(search(board,word,i+1,j,idx+1,visited) || search(board,word,i,j+1,idx+1,visited) || search(board,word,i-1,j,idx+1,visited) || search(board,word,i,j-1,idx+1,visited)){\\n            return true;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498848,
                "title": "simple-backtracking-with-go",
                "content": "```\\nfunc exist(board [][]byte, word string) bool {\\n    var backtrack func(int, int, int) bool\\n    backtrack = func(r, c int, i int)  bool {\\n        if r < 0 || r > len(board)-1 || c < 0 || c > len(board[0])-1 || board[r][c] == \\'0\\' {\\n            return false\\n        }\\n        \\n        if board[r][c] != word[i] {\\n            return false\\n        }\\n        \\n        if i == len(word)-1 {\\n            return word[i] == board[r][c]\\n        }\\n        \\n        originalValue := board[r][c]\\n        \\n        board[r][c] = \\'0\\'\\n        \\n        if backtrack(r, c-1, i+1) || backtrack(r, c+1, i+1) || backtrack(r-1, c, i+1) || backtrack(r+1, c, i+1) {\\n            return true\\n        }\\n        \\n        board[r][c] = originalValue\\n        \\n        return false\\n    }\\n\\n    for r := 0; r < len(board); r++ {\\n        for c := 0; c < len(board[0]); c++ {\\n            if backtrack(r, c, 0){\\n                return true\\n            }\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc exist(board [][]byte, word string) bool {\\n    var backtrack func(int, int, int) bool\\n    backtrack = func(r, c int, i int)  bool {\\n        if r < 0 || r > len(board)-1 || c < 0 || c > len(board[0])-1 || board[r][c] == \\'0\\' {\\n            return false\\n        }\\n        \\n        if board[r][c] != word[i] {\\n            return false\\n        }\\n        \\n        if i == len(word)-1 {\\n            return word[i] == board[r][c]\\n        }\\n        \\n        originalValue := board[r][c]\\n        \\n        board[r][c] = \\'0\\'\\n        \\n        if backtrack(r, c-1, i+1) || backtrack(r, c+1, i+1) || backtrack(r-1, c, i+1) || backtrack(r+1, c, i+1) {\\n            return true\\n        }\\n        \\n        board[r][c] = originalValue\\n        \\n        return false\\n    }\\n\\n    for r := 0; r < len(board); r++ {\\n        for c := 0; c < len(board[0]); c++ {\\n            if backtrack(r, c, 0){\\n                return true\\n            }\\n        }\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276765,
                "title": "python3-simple-backtracking-with-dfs",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def find(i, j, pos = 0):\\n            if pos == len(word):\\n                return True\\n            if not(0 <= i < m) or not(0 <= j < n) or board[i][j] == \"#\":\\n                return False\\n            if board[i][j] == word[pos]:\\n                temp = board[i][j]\\n                board[i][j] = \"#\"\\n                if find(i, j-1, pos+1) or find(i, j+1, pos+1) or find(i-1, j, pos+1) or find(i+1, j, pos+1):\\n                    return True\\n                board[i][j] = temp\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                if find(i ,j):\\n                    return True\\n        return False\\n```\\nTime : O(MNL)\\nSpace : (L)\\nPlease **UPVOTE**.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def find(i, j, pos = 0):\\n            if pos == len(word):\\n                return True\\n            if not(0 <= i < m) or not(0 <= j < n) or board[i][j] == \"#\":\\n                return False\\n            if board[i][j] == word[pos]:\\n                temp = board[i][j]\\n                board[i][j] = \"#\"\\n                if find(i, j-1, pos+1) or find(i, j+1, pos+1) or find(i-1, j, pos+1) or find(i+1, j, pos+1):\\n                    return True\\n                board[i][j] = temp\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                if find(i ,j):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257923,
                "title": "c-backtracking-time-complexity-explanation-notes",
                "content": "**My Solution Using Backtracking Algorithm:**\\n```\\nbool solve(int row, int col, string &curr, string &word, vector<vector<char>> &board) {\\n        if(curr.size() == word.size()) return true;\\n        for(int i = 1; i <= 4; i++) {\\n            int newRow = row, newCol = col;\\n            if(i == 1) newRow = row - 1;\\n            else if(i == 2) newCol = col + 1;\\n            else if(i == 3) newRow = row + 1;\\n            else newCol = col - 1;\\n            if(newRow >= 0 && newRow < board.size() && newCol >= 0 && newCol < board[0].size() && board[newRow][newCol] != \\'.\\' && board[newRow][newCol] == word[curr.size()]){\\n                char ch = board[newRow][newCol];\\n                board[newRow][newCol] = \\'.\\';\\n                curr.push_back(ch);\\n                bool b = solve(newRow, newCol, curr, word, board);\\n                curr.pop_back();\\n                board[newRow][newCol] = ch;\\n                if(b) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        string curr;\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board[i].size(); j++) {\\n                curr.push_back(board[i][j]);\\n                char ch = board[i][j];\\n                board[i][j] = \\'.\\';\\n                if(word[0] == ch && solve(i, j, curr, word, board)) \\n                    return true;\\n                board[i][j] = ch;\\n                curr.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n```\\n**Time Complexity Analysis:**\\n```\\nTC = O(nm3^k), k = size of the given word\\n```\\n* The given word can start from any cell.\\n* So, We have to traverse each cell of the board. So, it will take nm time for two for loops. \\n* For each cell we will try to find the given word, we have 3 direction to explore (as we can\\'t go to the direction from which we came so there are 3 posibilities)\\n* The max depth of the recursion tree can be the length of the given word (let length be k)\\n* So, considering the depth (k) and and 3 direction to explore the TC for each cell will come out to be 3^k\\n* So, the overall time complexity will be O(nm3^k)\\n\\n**Space Complexity Analysis:**\\nI am calculating only stack space:\\n```\\nStack space = O(k)\\n```\\n* As maximum depth of the recursion tree can be equal to size of the given word, so stack space will be O(k)\\n\\n![image](https://assets.leetcode.com/users/images/42e54db2-378a-4303-bbcf-5264a8e6c3a8_1657357575.2659547.jpeg)\\n\\n\\n\\n* Please like and comment on the post if you really find it helpfull.\\n* If I have made some mistakes, I am open to suggestions. Please comment it down.\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nbool solve(int row, int col, string &curr, string &word, vector<vector<char>> &board) {\\n        if(curr.size() == word.size()) return true;\\n        for(int i = 1; i <= 4; i++) {\\n            int newRow = row, newCol = col;\\n            if(i == 1) newRow = row - 1;\\n            else if(i == 2) newCol = col + 1;\\n            else if(i == 3) newRow = row + 1;\\n            else newCol = col - 1;\\n            if(newRow >= 0 && newRow < board.size() && newCol >= 0 && newCol < board[0].size() && board[newRow][newCol] != \\'.\\' && board[newRow][newCol] == word[curr.size()]){\\n                char ch = board[newRow][newCol];\\n                board[newRow][newCol] = \\'.\\';\\n                curr.push_back(ch);\\n                bool b = solve(newRow, newCol, curr, word, board);\\n                curr.pop_back();\\n                board[newRow][newCol] = ch;\\n                if(b) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool exist(vector<vector<char>>& board, string word) {\\n        string curr;\\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board[i].size(); j++) {\\n                curr.push_back(board[i][j]);\\n                char ch = board[i][j];\\n                board[i][j] = \\'.\\';\\n                if(word[0] == ch && solve(i, j, curr, word, board)) \\n                    return true;\\n                board[i][j] = ch;\\n                curr.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nTC = O(nm3^k), k = size of the given word\\n```\n```\\nStack space = O(k)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200649,
                "title": "c-dfs-solution-tle-explanation",
                "content": "For those of you who are getting TLE, eventhough the logic seems correct, make sure you **pass board by reference** instead of passing by value.\\n\\nUse :\\n`bool dfsSearch(vector<vector<char>>& board, string word, int i, int j, int n) `\\n\\nInstead of :\\n`bool dfsSearch(vector<vector<char>> board, string word, int i, int j, int n) {`\\n\\nWhen it is passed by value, the function creates its own copy of the parameters passed as arguments. This means it makes a copy of board everytime the function is called.\\n\\nHere\\'s my code,\\n```\\nclass Solution {\\n    //always pass board by reference to avoid TLE\\n    bool dfsSearch(vector<vector<char>>& board,string& word,int i,int j,int n){\\n        if(n==word.size())  //if last position ,means if word ends, search is successful\\n            return true;\\n        \\n        //return false for out of bound condition\\n        if(i<0 || i>=board.size() || j<0 || j>=board[i].size() || board[i][j]!=word[n]) return false;\\n        \\n        //mark as visited\\n        board[i][j]=\\'0\\';\\n        \\n        bool status = dfsSearch(board,word,i+1,j,n+1) //down\\n                    ||dfsSearch(board,word,i-1,j,n+1) //up\\n                    ||dfsSearch(board,word,i,j-1,n+1) //left\\n                    ||dfsSearch(board,word,i,j+1,n+1); //right\\n        \\n        //change back the original character for other word searches\\n        board[i][j]=word[n];\\n        \\n        return status;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word==\"\")  //return false if word is empty\\n            return false;\\n        \\n        int n=board.size(), m=board[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(board[i][j]==word[0] and dfsSearch(board,word,i,j,0)) //return true if search is successful\\n                    return true;\\n            }\\n        }\\n        return false; //Search failed, WORD NOT FOUND!! :(\\n    }\\n};\\n```\\n\\n**Runtime:** 309 ms, faster than 81.59% of C++ online submissions for Word Search.\\n**Memory Usage:** 7.8 MB, less than 99.07% of C++ online submissions for Word Search.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    //always pass board by reference to avoid TLE\\n    bool dfsSearch(vector<vector<char>>& board,string& word,int i,int j,int n){\\n        if(n==word.size())  //if last position ,means if word ends, search is successful\\n            return true;\\n        \\n        //return false for out of bound condition\\n        if(i<0 || i>=board.size() || j<0 || j>=board[i].size() || board[i][j]!=word[n]) return false;\\n        \\n        //mark as visited\\n        board[i][j]=\\'0\\';\\n        \\n        bool status = dfsSearch(board,word,i+1,j,n+1) //down\\n                    ||dfsSearch(board,word,i-1,j,n+1) //up\\n                    ||dfsSearch(board,word,i,j-1,n+1) //left\\n                    ||dfsSearch(board,word,i,j+1,n+1); //right\\n        \\n        //change back the original character for other word searches\\n        board[i][j]=word[n];\\n        \\n        return status;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        if(word==\"\")  //return false if word is empty\\n            return false;\\n        \\n        int n=board.size(), m=board[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(board[i][j]==word[0] and dfsSearch(board,word,i,j,0)) //return true if search is successful\\n                    return true;\\n            }\\n        }\\n        return false; //Search failed, WORD NOT FOUND!! :(\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679994,
                "title": "simple-dfs-backtracking-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string &word,int i,int j){\\n        \\n        //base case\\n        if(word.size()==0) return true;\\n        if(i<0 || j<0 || i>=board.size() || j>= board[0].size() || board[i][j]!=word[0]) return false;\\n        \\n        char c = board[i][j];\\n         board[i][j] =\\'X\\';\\n        string s = word.substr(1);\\n        \\n        //dfs call\\n        bool res = dfs(board,s,i+1,j)||dfs(board,s,i-1,j)||dfs(board,s,i,j+1)||dfs(board,s,i,j-1);\\n        \\n        //backtrack\\n        board[i][j] =c;\\n        return res;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dfs(board,word,i,j)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string &word,int i,int j){\\n        \\n        //base case\\n        if(word.size()==0) return true;\\n        if(i<0 || j<0 || i>=board.size() || j>= board[0].size() || board[i][j]!=word[0]) return false;\\n        \\n        char c = board[i][j];\\n         board[i][j] =\\'X\\';\\n        string s = word.substr(1);\\n        \\n        //dfs call\\n        bool res = dfs(board,s,i+1,j)||dfs(board,s,i-1,j)||dfs(board,s,i,j+1)||dfs(board,s,i,j-1);\\n        \\n        //backtrack\\n        board[i][j] =c;\\n        return res;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dfs(board,word,i,j)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640918,
                "title": "java-dfs-no-visited-array-beats-86-time-beats-99-space",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t// Call function for each board entry since any could be the start of a valid sequence\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n\\t\\t\\t\\t// If the function call returns true, this starting char lead to a valid word match\\n                if(dfs(board, word, 0, i, j) == true){\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t// If none of the grid entries lead to a matching word return false\\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, String word, int index, int i, int j){\\n        // Index is 1 past the last character in word, thus all letters in word have been checked return true\\n        if(index == word.length()){\\n            return true;\\n        }\\n        // Catch-all for common edge cases, if out of bounds, if seen before, if doesnt match expected index, return false\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || word.charAt(index) != board[i][j]){\\n            return false;\\n        }\\n        // At this point we\\'re at a valid letter in the sequence. Store current letter and set to placeholder for visited\\n        char tmp = board[i][j];\\n        board[i][j] = \\'0\\';\\n        // Do the same checks for all surrounding/later characters, if any returns true down the line, \\n        // pass \"true\" up the stack\\n        if(dfs(board, word, index + 1, i + 1, j) || \\n           dfs(board, word, index + 1, i - 1, j) ||\\n           dfs(board, word, index + 1, i, j + 1) ||\\n           dfs(board, word, index + 1, i, j - 1))\\n        {\\n            return true;\\n        }\\n        // This statement is met when we had a valid character but it did not lead to a valid match down the line\\n        // Change character back to unvisited while going back up the stack and return false for this character/path\\n        board[i][j] = tmp;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n\\t// Call function for each board entry since any could be the start of a valid sequence\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n\\t\\t\\t\\t// If the function call returns true, this starting char lead to a valid word match\\n                if(dfs(board, word, 0, i, j) == true){\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t// If none of the grid entries lead to a matching word return false\\n        return false;\\n    }\\n    \\n    public boolean dfs(char[][] board, String word, int index, int i, int j){\\n        // Index is 1 past the last character in word, thus all letters in word have been checked return true\\n        if(index == word.length()){\\n            return true;\\n        }\\n        // Catch-all for common edge cases, if out of bounds, if seen before, if doesnt match expected index, return false\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || word.charAt(index) != board[i][j]){\\n            return false;\\n        }\\n        // At this point we\\'re at a valid letter in the sequence. Store current letter and set to placeholder for visited\\n        char tmp = board[i][j];\\n        board[i][j] = \\'0\\';\\n        // Do the same checks for all surrounding/later characters, if any returns true down the line, \\n        // pass \"true\" up the stack\\n        if(dfs(board, word, index + 1, i + 1, j) || \\n           dfs(board, word, index + 1, i - 1, j) ||\\n           dfs(board, word, index + 1, i, j + 1) ||\\n           dfs(board, word, index + 1, i, j - 1))\\n        {\\n            return true;\\n        }\\n        // This statement is met when we had a valid character but it did not lead to a valid match down the line\\n        // Change character back to unvisited while going back up the stack and return false for this character/path\\n        board[i][j] = tmp;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578096,
                "title": "simple-java-backtracking",
                "content": "```\\n\\tpublic boolean exist(char[][] board, String word) {\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        char[] words = word.toCharArray();\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board[0].length; j++) {\\n                if(solve(board, words, visited, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean solve(char[][] board, char[] words, boolean[][] visited, int x, int y, int i) {\\n        if(i == words.length) {\\n            return true;\\n        }\\n        \\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y]) {\\n            return false;\\n        }\\n        \\n        if(board[x][y] != words[i]) {\\n            return false;\\n        }\\n        \\n        visited[x][y] = true;\\n        boolean exists = \\n            solve(board, words, visited, x + 1, y, i + 1) ||\\n            solve(board, words, visited, x - 1, y, i + 1) ||\\n            solve(board, words, visited, x, y + 1, i + 1) ||\\n            solve(board, words, visited, x, y - 1, i + 1);\\n        visited[x][y] = false;\\n        return exists;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\tpublic boolean exist(char[][] board, String word) {\\n        boolean visited[][] = new boolean[board.length][board[0].length];\\n        char[] words = word.toCharArray();\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board[0].length; j++) {\\n                if(solve(board, words, visited, i, j, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    boolean solve(char[][] board, char[] words, boolean[][] visited, int x, int y, int i) {\\n        if(i == words.length) {\\n            return true;\\n        }\\n        \\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y]) {\\n            return false;\\n        }\\n        \\n        if(board[x][y] != words[i]) {\\n            return false;\\n        }\\n        \\n        visited[x][y] = true;\\n        boolean exists = \\n            solve(board, words, visited, x + 1, y, i + 1) ||\\n            solve(board, words, visited, x - 1, y, i + 1) ||\\n            solve(board, words, visited, x, y + 1, i + 1) ||\\n            solve(board, words, visited, x, y - 1, i + 1);\\n        visited[x][y] = false;\\n        return exists;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1571612,
                "title": "dfs-c-no-extra-space-backtracking-intution",
                "content": "Intution : We traverse the givin grid and try to find the first char of the given string word after that we do a dfs from the char to all the four directions and if we find the  ans we return true it else we backtrack.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board,int i,int j,int count,string word)\\n    {\\n        if(count==word.length()) return true;\\n        \\n        if(i<0||j<0||i>=board.size()||j>=board[0].size()||board[i][j]!=word[count]) return false;\\n        \\n        char temp=board[i][j];\\n        board[i][j]=\\' \\';\\n        \\n        bool found=dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||\\n                   dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        \\n        board[i][j]=temp;\\n        \\n        return found;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==word[0]&&dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Pls Give an upvote if you found this to be helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board,int i,int j,int count,string word)\\n    {\\n        if(count==word.length()) return true;\\n        \\n        if(i<0||j<0||i>=board.size()||j>=board[0].size()||board[i][j]!=word[count]) return false;\\n        \\n        char temp=board[i][j];\\n        board[i][j]=\\' \\';\\n        \\n        bool found=dfs(board,i+1,j,count+1,word)||dfs(board,i-1,j,count+1,word)||\\n                   dfs(board,i,j+1,count+1,word)||dfs(board,i,j-1,count+1,word);\\n        \\n        board[i][j]=temp;\\n        \\n        return found;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==word[0]&&dfs(board,i,j,0,word))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304308,
                "title": "c-dfs-clean-solution-clean-code-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]== word[0] && dfs(board,i,j,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n         return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,int i,int j,string word,int count) {\\n        if(count == word.size())\\n            return true;\\n        if(i<0 || j<0 || i>=board.size()|| j>=board[i].size() ||board[i][j] != word[count])\\n            return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,word,count+1) || dfs(board,i-1,j,word,count+1) ||\\n                     dfs(board,i,j+1,word,count+1) || dfs(board,i,j-1,word,count+1);\\n        board[i][j] = temp;\\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]== word[0] && dfs(board,i,j,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n         return false;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& board,int i,int j,string word,int count) {\\n        if(count == word.size())\\n            return true;\\n        if(i<0 || j<0 || i>=board.size()|| j>=board[i].size() ||board[i][j] != word[count])\\n            return false;\\n        char temp = board[i][j];\\n        board[i][j]= \\' \\';\\n        bool found = dfs(board,i+1,j,word,count+1) || dfs(board,i-1,j,word,count+1) ||\\n                     dfs(board,i,j+1,word,count+1) || dfs(board,i,j-1,word,count+1);\\n        board[i][j] = temp;\\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983655,
                "title": "my-simple-java-solution-faster-than-99-07-of-java-online-submissions",
                "content": "Runtime: 4 ms, faster than 99.07% of Java online submissions\\n\\n```\\nclass Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        visited = new boolean[board.length][board[0].length];\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (backtrack(board, i, j, w, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int row, int col, char[] w, int index) {\\n        if (index == w.length) {\\n            return true;\\n        }\\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || visited[row][col]) {\\n            return false;\\n        }\\n        if (w[index] != board[row][col]) {\\n            return false;\\n        }\\n        \\n        visited[row][col] = true;\\n\\n        if (backtrack(board, row + 1, col, w, index+1) \\n            || backtrack(board, row - 1, col, w, index+1) \\n            || backtrack(board, row, col + 1, w, index+1) \\n            || backtrack(board, row, col - 1, w, index+1)) {\\n            return true;\\n        }\\n        \\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```\\n**Time Complexity: O(N*3^min(L, N))**\\nEach cell has only 3 directions to be potentially explored because one direction has been already visited by its parent.\\nSo, the worst case can be expressed by N * 4 * 3^min(L - 1, N - 1) (4 means the beginning point) and by big O,\\nO(N * 3^min(L, N))\\n**Space complexity: O(L)**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static boolean[][] visited;\\n    public boolean exist(char[][] board, String word) {\\n        char[] w = word.toCharArray();\\n        visited = new boolean[board.length][board[0].length];\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (backtrack(board, i, j, w, 0)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int row, int col, char[] w, int index) {\\n        if (index == w.length) {\\n            return true;\\n        }\\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || visited[row][col]) {\\n            return false;\\n        }\\n        if (w[index] != board[row][col]) {\\n            return false;\\n        }\\n        \\n        visited[row][col] = true;\\n\\n        if (backtrack(board, row + 1, col, w, index+1) \\n            || backtrack(board, row - 1, col, w, index+1) \\n            || backtrack(board, row, col + 1, w, index+1) \\n            || backtrack(board, row, col - 1, w, index+1)) {\\n            return true;\\n        }\\n        \\n        visited[row][col] = false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977776,
                "title": "java-simple-easy-line-by-line-explanation-dfs-backtracking",
                "content": "```\\nclass Solution {\\n  public boolean exist(char[][] board, String word) {\\n      \\n    /*\\n    Idea: Backtracking\\n    \\n    -> Iterate through each cell in the matrix & check if char matches index 0 of word\\n            -> if yes - increment index & find the boundary cells (top, down, bottom, left) to find the char at index 1 of word\\n            -> if No - return false;\\n    \\n    -> Keep visited matrix to avoid recounting visited cells & eliminating endless loop\\n            -> eg  [[\"a\",\"a\"]]   find if \"aaaaaaaa\" exists would return Yes without visited matrix but its a No.\\n    \\n    -> check for boundary conditions at each stage !important\\n    \\n    */\\n      \\n    boolean[][] visited = new boolean[board.length][board[0].length];\\n    int index = 0;\\n      \\n    // iterate all cells\\n    for (int i = 0; i < board.length; i++) {\\n      for (int j = 0; j < board[0].length; j++) {\\n\\n        if(findWordInBoard(board, word, visited, index, i, j))\\n        {\\n            return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n    \\n  // recursive calls for each cell\\n  public boolean findWordInBoard(char[][] board, String word, boolean[][] visited, int index, int i, int j) {\\n      \\n    // terminating condition if length of index reaches lenght of word\\n    if (index == word.length()) {\\n      return true;\\n    }\\n\\n    // else check bounds & if already visited\\n    if (!withinBounds(i, j, board.length, board[0].length) || visited[i][j]) {\\n      return false;\\n    }\\n\\n    // check index char\\n    char cell = board[i][j];\\n    char indexChar = word.charAt(index);\\n\\n    // mismatch\\n    if (cell != indexChar) {\\n      return false;\\n    }\\n\\n    // visit this cell if matched\\n    visited[i][j] = true;\\n\\n    // check boundary chars\\n    if (findWordInBoard(board, word, visited, index + 1, i - 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i + 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j - 1)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j + 1)) return true;\\n\\n    // unvisit cell - after checking all possibilites (would not come here if a valid answer existed using this cell \\n    // else clear up visiting for checking with other cells)\\n    visited[i][j] = false;\\n\\n    return false;\\n  }\\n\\n  // boundary condition checks\\n  public boolean withinBounds(int i, int j, int rows, int cols) {\\n    if (i < rows && i >= 0 && j < cols && j >= 0) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean exist(char[][] board, String word) {\\n      \\n    /*\\n    Idea: Backtracking\\n    \\n    -> Iterate through each cell in the matrix & check if char matches index 0 of word\\n            -> if yes - increment index & find the boundary cells (top, down, bottom, left) to find the char at index 1 of word\\n            -> if No - return false;\\n    \\n    -> Keep visited matrix to avoid recounting visited cells & eliminating endless loop\\n            -> eg  [[\"a\",\"a\"]]   find if \"aaaaaaaa\" exists would return Yes without visited matrix but its a No.\\n    \\n    -> check for boundary conditions at each stage !important\\n    \\n    */\\n      \\n    boolean[][] visited = new boolean[board.length][board[0].length];\\n    int index = 0;\\n      \\n    // iterate all cells\\n    for (int i = 0; i < board.length; i++) {\\n      for (int j = 0; j < board[0].length; j++) {\\n\\n        if(findWordInBoard(board, word, visited, index, i, j))\\n        {\\n            return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n    \\n  // recursive calls for each cell\\n  public boolean findWordInBoard(char[][] board, String word, boolean[][] visited, int index, int i, int j) {\\n      \\n    // terminating condition if length of index reaches lenght of word\\n    if (index == word.length()) {\\n      return true;\\n    }\\n\\n    // else check bounds & if already visited\\n    if (!withinBounds(i, j, board.length, board[0].length) || visited[i][j]) {\\n      return false;\\n    }\\n\\n    // check index char\\n    char cell = board[i][j];\\n    char indexChar = word.charAt(index);\\n\\n    // mismatch\\n    if (cell != indexChar) {\\n      return false;\\n    }\\n\\n    // visit this cell if matched\\n    visited[i][j] = true;\\n\\n    // check boundary chars\\n    if (findWordInBoard(board, word, visited, index + 1, i - 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i + 1, j)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j - 1)) return true;\\n\\n    if (findWordInBoard(board, word, visited, index + 1, i, j + 1)) return true;\\n\\n    // unvisit cell - after checking all possibilites (would not come here if a valid answer existed using this cell \\n    // else clear up visiting for checking with other cells)\\n    visited[i][j] = false;\\n\\n    return false;\\n  }\\n\\n  // boundary condition checks\\n  public boolean withinBounds(int i, int j, int rows, int cols) {\\n    if (i < rows && i >= 0 && j < cols && j >= 0) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713113,
                "title": "c-usiing-dfs-and-recursion-perfect-for-beginners",
                "content": "***Pls upvote if you find this helpful  :)***\\nThe basic idea is to iterate through the entire board and use dfs once we find a character matching the first character of the string and look if we could find the entire string on the board.\\n```\\nclass Solution {\\npublic:\\n     bool dfs(int i,int j,int count,string& word,vector<vector<char>>& board){\\n         if(count==word.size())return true;\\n         if(i<0||i>=board.size()||j<0||j>=board[0].size()||board[i][j]!=word[count])return false;\\n         char temp=board[i][j];\\n         board[i][j]=\\'#\\';\\n         bool answer=   dfs(i-1,j,count+1,word,board)||\\n                        dfs(i+1,j,count+1,word,board)||\\n                        dfs(i,j-1,count+1,word,board)||\\n                        dfs(i,j+1,count+1,word,board);\\n         board[i][j]=temp;\\n         return answer;\\n     }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if((board[i][j]==word[0])&&dfs(i,j,0,word,board))return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool dfs(int i,int j,int count,string& word,vector<vector<char>>& board){\\n         if(count==word.size())return true;\\n         if(i<0||i>=board.size()||j<0||j>=board[0].size()||board[i][j]!=word[count])return false;\\n         char temp=board[i][j];\\n         board[i][j]=\\'#\\';\\n         bool answer=   dfs(i-1,j,count+1,word,board)||\\n                        dfs(i+1,j,count+1,word,board)||\\n                        dfs(i,j-1,count+1,word,board)||\\n                        dfs(i,j+1,count+1,word,board);\\n         board[i][j]=temp;\\n         return answer;\\n     }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if((board[i][j]==word[0])&&dfs(i,j,0,word,board))return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598473,
                "title": "simple-python-solution-dfs-visited",
                "content": "```\\ndef dfs(board, word, r, c, visited):\\n    if not word:\\n        return True\\n\\n    if (\\n        (r, c) in visited\\n        or r < 0\\n        or r >= len(board)\\n        or c < 0\\n        or c >= len(board[0])\\n        or board[r][c] != word[0]\\n    ):\\n        return False\\n\\n    return (\\n        dfs(board, word[1:], r + 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r - 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c + 1, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c - 1, visited + [(r, c)])\\n    )\\n\\n\\nclass Solution:\\n    def exist(self, board, word):\\n        for r, row in enumerate(board):\\n            for c, l in enumerate(row):\\n                if dfs(board, word, r, c, []):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(board, word, r, c, visited):\\n    if not word:\\n        return True\\n\\n    if (\\n        (r, c) in visited\\n        or r < 0\\n        or r >= len(board)\\n        or c < 0\\n        or c >= len(board[0])\\n        or board[r][c] != word[0]\\n    ):\\n        return False\\n\\n    return (\\n        dfs(board, word[1:], r + 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r - 1, c, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c + 1, visited + [(r, c)])\\n        or dfs(board, word[1:], r, c - 1, visited + [(r, c)])\\n    )\\n\\n\\nclass Solution:\\n    def exist(self, board, word):\\n        for r, row in enumerate(board):\\n            for c, l in enumerate(row):\\n                if dfs(board, word, r, c, []):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576945,
                "title": "simple-and-elegant-ruby-solution-using-dfs",
                "content": "```\\ndef exist(board, word)\\n  return false if board.empty? || word.empty?\\n  m = board.length\\n  n = board[0].length\\n  @board, @word = board, word\\n  (0...m).each { |i|\\n    (0...n).each { |j|\\n      return true if word_exists?(i, j, 0)\\n    }\\n  }\\n  p board\\n  false\\nend\\n\\ndef word_exists?(i, j, wi)\\n  return false if !within_bounds?(i, j) || @board[i][j] != @word[wi]\\n  return true if wi == @word.length-1\\n  @board[i][j] = \\'*\\'\\n  result = word_exists?(i+1, j, wi+1) ||\\n    word_exists?(i, j+1, wi+1) ||\\n    word_exists?(i-1, j, wi+1) ||\\n    word_exists?(i, j-1, wi+1)\\n  \\n  @board[i][j] = @word[wi]\\n  result\\nend\\n\\ndef within_bounds?(i, j)\\n  i >= 0 && j >= 0 && i < @board.length && j < @board[0].length\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search"
                ],
                "code": "```\\ndef exist(board, word)\\n  return false if board.empty? || word.empty?\\n  m = board.length\\n  n = board[0].length\\n  @board, @word = board, word\\n  (0...m).each { |i|\\n    (0...n).each { |j|\\n      return true if word_exists?(i, j, 0)\\n    }\\n  }\\n  p board\\n  false\\nend\\n\\ndef word_exists?(i, j, wi)\\n  return false if !within_bounds?(i, j) || @board[i][j] != @word[wi]\\n  return true if wi == @word.length-1\\n  @board[i][j] = \\'*\\'\\n  result = word_exists?(i+1, j, wi+1) ||\\n    word_exists?(i, j+1, wi+1) ||\\n    word_exists?(i-1, j, wi+1) ||\\n    word_exists?(i, j-1, wi+1)\\n  \\n  @board[i][j] = @word[wi]\\n  result\\nend\\n\\ndef within_bounds?(i, j)\\n  i >= 0 && j >= 0 && i < @board.length && j < @board[0].length\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 480038,
                "title": "clean-python-dfs",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not word or not any(board): return False\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(x:int, y:int, i: int = 0):\\n            if i == len(word) - 1: return board[x][y] == word[i]\\n            if board[x][y] != word[i]: return False\\n            value = board[x][y]\\n            board[x][y] = \\'#\\'\\n            for r, c in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n                if 0 <= r < m and 0 <= c < n and dfs(r, c, i + 1):\\n                    return True\\n            board[x][y] = value\\n            return False\\n\\n        return any(dfs(x, y) for x in range(m) for y in range(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        if not word or not any(board): return False\\n        m, n = len(board), len(board[0])\\n\\n        def dfs(x:int, y:int, i: int = 0):\\n            if i == len(word) - 1: return board[x][y] == word[i]\\n            if board[x][y] != word[i]: return False\\n            value = board[x][y]\\n            board[x][y] = \\'#\\'\\n            for r, c in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n                if 0 <= r < m and 0 <= c < n and dfs(r, c, i + 1):\\n                    return True\\n            board[x][y] = value\\n            return False\\n\\n        return any(dfs(x, y) for x in range(m) for y in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214773,
                "title": "go-golang-4ms-100",
                "content": "```\\nfunc exist(board [][]byte, word string) bool {\\n    \\n    row := len(board)\\n    if row == 0{\\n        return false\\n    }\\n    col := len(board[0])\\n    words:= []byte(word)\\n    \\n    for i:=0; i<row; i++{\\n        for j:=0;j<col; j++{\\n            if helper(board, words, i, j, 0){\\n                return true\\n            }\\n        }\\n    }\\n    return false   \\n}\\n\\nfunc helper(board [][]byte, word []byte, i, j , k int) bool{\\n    if i<0 || j<0 || i >= len(board) || j>= len(board[0]){\\n        return false\\n    }\\n    \\n    if board[i][j] == word[k]{\\n        if k == len(word)-1{\\n        return true\\n       }\\n        temp := board[i][j]\\n        board[i][j] = 0\\n        found := helper(board,word, i+1, j , k+1) || helper(board,word, i, j+1 , k+1) ||helper(board,word, i-1, j , k+1) || helper(board,word, i, j-1 , k+1)\\n        board[i][j] = temp\\n        return found\\n    } else{\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc exist(board [][]byte, word string) bool {\\n    \\n    row := len(board)\\n    if row == 0{\\n        return false\\n    }\\n    col := len(board[0])\\n    words:= []byte(word)\\n    \\n    for i:=0; i<row; i++{\\n        for j:=0;j<col; j++{\\n            if helper(board, words, i, j, 0){\\n                return true\\n            }\\n        }\\n    }\\n    return false   \\n}\\n\\nfunc helper(board [][]byte, word []byte, i, j , k int) bool{\\n    if i<0 || j<0 || i >= len(board) || j>= len(board[0]){\\n        return false\\n    }\\n    \\n    if board[i][j] == word[k]{\\n        if k == len(word)-1{\\n        return true\\n       }\\n        temp := board[i][j]\\n        board[i][j] = 0\\n        found := helper(board,word, i+1, j , k+1) || helper(board,word, i, j+1 , k+1) ||helper(board,word, i-1, j , k+1) || helper(board,word, i, j-1 , k+1)\\n        board[i][j] = temp\\n        return found\\n    } else{\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209469,
                "title": "java-dfs-beats-99-6-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        // at each board[i][j] start a dfs traversal and try to match the given word.\\n        // dfs traverses top, left right and bottom cells.\\n        for(int i = 0 ; i < board.length; ++i) {\\n            for(int j = 0; j < board[0].length; ++j) {\\n                if(dfs(board, i, j, word, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // board[i][j] - current cell, under investigation.\\n    // off - starting index of unmatched part of the word.\\n    private boolean dfs(char[][] board, int i, int j, String word, int off) {\\n        // check out of bounce\\n        if(i < 0 || i >= board.length)\\n            return false;\\n        if(j < 0 || j >= board[0].length)\\n            return false;\\n        \\n        char c = board[i][j];\\n        // check visited\\n        if(c == \\'#\\')\\n            return false;\\n        // mismatch\\n        if(c != word.charAt(off))\\n            return false;\\n        // if we have reached the end of the word, then we found the word.\\n        if(off == word.length() - 1)\\n            return true;\\n        \\n        // mark node as visited\\n        board[i][j] = \\'#\\';\\n        boolean res = dfs(board, i + 1, j, word, off + 1) || \\n            dfs(board, i - 1, j, word, off + 1) || \\n            dfs(board, i, j + 1, word, off + 1) || \\n            dfs(board, i, j - 1, word, off + 1);\\n        // unmark vistied \\n        board[i][j] = c;\\n        return res;\\n    }\\n}\\n```\\nTime Complexity - `O(m * n * l)`\\nn - number of rows in board.\\nm - number of cols in board.\\nl - length of the word to be matched.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean exist(char[][] board, String word) {\\n        // at each board[i][j] start a dfs traversal and try to match the given word.\\n        // dfs traverses top, left right and bottom cells.\\n        for(int i = 0 ; i < board.length; ++i) {\\n            for(int j = 0; j < board[0].length; ++j) {\\n                if(dfs(board, i, j, word, 0))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    // board[i][j] - current cell, under investigation.\\n    // off - starting index of unmatched part of the word.\\n    private boolean dfs(char[][] board, int i, int j, String word, int off) {\\n        // check out of bounce\\n        if(i < 0 || i >= board.length)\\n            return false;\\n        if(j < 0 || j >= board[0].length)\\n            return false;\\n        \\n        char c = board[i][j];\\n        // check visited\\n        if(c == \\'#\\')\\n            return false;\\n        // mismatch\\n        if(c != word.charAt(off))\\n            return false;\\n        // if we have reached the end of the word, then we found the word.\\n        if(off == word.length() - 1)\\n            return true;\\n        \\n        // mark node as visited\\n        board[i][j] = \\'#\\';\\n        boolean res = dfs(board, i + 1, j, word, off + 1) || \\n            dfs(board, i - 1, j, word, off + 1) || \\n            dfs(board, i, j + 1, word, off + 1) || \\n            dfs(board, i, j - 1, word, off + 1);\\n        // unmark vistied \\n        board[i][j] = c;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110930,
                "title": "python-dfs-solution-similar-to-max-area-of-islands",
                "content": "```class Solution(object):\\n    def exist(self, board, word):\\n        def backtracking(board, i, j, word):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board):\\n                return False\\n            if j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"#\"\\n                if backtracking(board, i+1, j, word[1:]) or backtracking(board, i-1, j, word[1:]) or backtracking(board, i, j+1, word[1:]) or backtracking(board, i, j-1, word[1:]):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if backtracking(board, i, j, word):\\n                    return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```class Solution(object):\\n    def exist(self, board, word):\\n        def backtracking(board, i, j, word):\\n            if len(word) == 0:\\n                return True\\n            if i < 0 or i >= len(board):\\n                return False\\n            if j < 0 or j >= len(board[i]):\\n                return False\\n            if board[i][j] == word[0]:\\n                board[i][j] = \"#\"\\n                if backtracking(board, i+1, j, word[1:]) or backtracking(board, i-1, j, word[1:]) or backtracking(board, i, j+1, word[1:]) or backtracking(board, i, j-1, word[1:]):\\n                    return True\\n                board[i][j] = word[0]\\n            return False\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if backtracking(board, i, j, word):\\n                    return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 27669,
                "title": "clean-and-short-c-code-9ms",
                "content": "DFS with backtracking\\n\\n \\n```\\nclass Solution {\\n    bool helper(vector<vector<char>>& board, string &word, int k, int i, int j) {\\n        if (k == word.length()) return true;\\n        if (i<0 || i>=board.size()) return false;\\n        if (j<0 || j>=board[i].size()) return false;\\n        \\n        \\n        if (word[k] == board[i][j]) {\\n            board[i][j] = ' ';\\n            if (helper(board, word, k+1, i+1, j)) return true;\\n            if (helper(board, word, k+1, i-1, j)) return true;\\n            if (helper(board, word, k+1, i, j+1)) return true;\\n            if (helper(board, word, k+1, i, j-1)) return true;\\n            board[i][j] = word[k];\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i=0; i<board.size(); ++i)\\n            for (int j=0; j<board[i].size(); ++j) {\\n                if (helper(board, word, 0, i, j)) {\\n                    return true;\\n                }\\n            }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool helper(vector<vector<char>>& board, string &word, int k, int i, int j) {\\n        if (k == word.length()) return true;\\n        if (i<0 || i>=board.size()) return false;\\n        if (j<0 || j>=board[i].size()) return false;\\n        \\n        \\n        if (word[k] == board[i][j]) {\\n            board[i][j] = ' ';\\n            if (helper(board, word, k+1, i+1, j)) return true;\\n            if (helper(board, word, k+1, i-1, j)) return true;\\n            if (helper(board, word, k+1, i, j+1)) return true;\\n            if (helper(board, word, k+1, i, j-1)) return true;\\n            board[i][j] = word[k];\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        for (int i=0; i<board.size(); ++i)\\n            for (int j=0; j<board[i].size(); ++j) {\\n                if (helper(board, word, 0, i, j)) {\\n                    return true;\\n                }\\n            }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27751,
                "title": "clean-python-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n\\n    def exist(self, board, word):\\n        char_to_pos = defaultdict(list)\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                char_to_pos[board[i][j]].append((i, j))\\n        return self._exist(char_to_pos, word, set())\\n\\n    def _exist(self, char_to_pos, word, used, last_pos=None):\\n        if not word:\\n            return True\\n        for p in char_to_pos[word[0]]:\\n            if p in used or (last_pos and not self._is_pos_valid(p, last_pos)):\\n                continue\\n            used.add(p)\\n            if self._exist(char_to_pos, word[1:], used, p):\\n                return True\\n            used.remove(p)\\n        return False\\n        \\n    def _is_pos_valid(self, (i1, j1), (i2, j2)):\\n        return (i1 == i2 and abs(j1-j2) == 1) or (j1 == j2 and abs(i1-i2) == 1)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n\\n    def exist(self, board, word):\\n        char_to_pos = defaultdict(list)\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                char_to_pos[board[i][j]].append((i, j))\\n        return self._exist(char_to_pos, word, set())\\n\\n    def _exist(self, char_to_pos, word, used, last_pos=None):\\n        if not word:\\n            return True\\n        for p in char_to_pos[word[0]]:\\n            if p in used or (last_pos and not self._is_pos_valid(p, last_pos)):\\n                continue\\n            used.add(p)\\n            if self._exist(char_to_pos, word[1:], used, p):\\n                return True\\n            used.remove(p)\\n        return False\\n        \\n    def _is_pos_valid(self, (i1, j1), (i2, j2)):\\n        return (i1 == i2 and abs(j1-j2) == 1) or (j1 == j2 and abs(i1-i2) == 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27800,
                "title": "java-dfs-solution",
                "content": "    public class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            \\n            for(int i=0;i<board.length;i++){\\n                for(int j=0;j<board[i].length;j++){\\n                    if(helper(board,i,j,word,0)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        private boolean helper(char[][] board, int i, int j, String word, int step){\\n            if(step==word.length()){\\n                return true;\\n            }\\n            if(i<0||i>=board.length||j<0||j>=board[i].length){\\n                return false;\\n            }\\n            if((board[i][j]-word.charAt(step))!=0){\\n                return false;\\n            }\\n            char record=board[i][j];\\n            board[i][j]='1';\\n            boolean res=helper(board,i-1,j,word,step+1)||helper(board,i,j-1,word,step+1)||helper(board,i,j+1,word,step+1)||helper(board,i+1,j,word,step+1);\\n            board[i][j]=record;\\n            return res;\\n            \\n        }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean exist(char[][] board, String word) {\\n            \\n            for(int i=0;i<board.length;i++){\\n                for(int j=0;j<board[i].length;j++){\\n                    if(helper(board,i,j,word,0)){\\n                        return true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 27803,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0)  return false;\\n            int m=board.size(), n=board[0].size();\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(help(board, i, j, 0, word))  return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        bool help(vector<vector<char>>& board, int i, int j, int len, string word){\\n            if(len==word.size())   return true;\\n            if(i<0 || j<0 || i>=board.size() || j>=board[0].size())  return false;\\n            if(board[i][j]!=word[len] || board[i][j]=='*')  return false;\\n            char ch=board[i][j];\\n            board[i][j]='*';\\n            bool result= help(board, i+1, j, len+1, word) ||\\n                         help(board, i-1, j, len+1, word) ||\\n                         help(board, i, j+1, len+1, word) ||\\n                         help(board, i, j-1, len+1, word);\\n            board[i][j]=ch;\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char>>& board, string word) {\\n            if(board.size()==0)  return false;\\n            int m=board.size(), n=board[0].size();\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(help(board, i, j, 0, word))  return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27870,
                "title": "52ms-simple-dfs-without-extra-space",
                "content": "All words are ASCII, so they only use 7 bits. Is this cheating?\\n\\n    class Solution {\\n    public:\\n        bool exist(vector<vector<char> > &board, string word) {\\n            m = board.size() - 1;\\n            n = board[0].size() - 1;\\n            for (int i = 0; i <= m; i++)\\n                for (int j = 0; j <= n; j++)\\n                    if (board[i][j] == word[0])\\n                        if (dfs(board, i, j, word.c_str() + 1))\\n                            return true;\\n            return false;\\n        }\\n    private:\\n        int m, n;\\n        bool dfs(vector<vector<char> > &board, int i, int j, const char *w) {\\n            if (*w == 0)\\n                return true;\\n            board[i][j] ^= 0x80;\\n            for (int k = -(i != 0); k <= (i < m); k++)\\n                for (int l = -(j != 0); l <= (j < n); l++)\\n                    if ((k ^ l) & 1 && board[i + k][j + l] == *w)\\n                        if (dfs(board, i + k, j + l, w + 1))\\n                            return true;\\n            board[i][j] ^= 0x80;\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool exist(vector<vector<char> > &board, string word) {\\n            m = board.size() - 1;\\n            n = board[0].size() - 1;\\n            for (int i = 0; i <= m; i++)\\n                for (int j = 0; j <= n; j++)\\n                    if (board[i][j] == word[0])\\n                        if (dfs(board, i, j, word.c_str() + 1))\\n                            return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3848683,
                "title": "easiest-approach-recursion-backtracking-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThink for dfs approach with backtracking.\\nAs just search in four directions for word\\'s each character as you get it in adjacent then call dfs for next character in adjacent of current indexes where we get our previous character.\\n\\n\\uD83E\\uDDD0 Why Backtracking required ?\\n   In some cases there are repetative character present and whenever we are searching in four directions it gets ecvaluating the previous one which one is already taken by us for the previous same charcter (\\uD83D\\uDC40 take look at test case 3 \\uD83D\\uDC40).\\nSo we have to store the path\\'s visited status.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int dr[4]={0,1,0,-1};\\n    int dc[4]={1,0,-1,0};\\n    int vis[7][7];\\n    bool f(int i, int j, vector<vector<char>>&board , string word,int index){\\n        int m = board.size();\\n        int n = board[0].size();\\n        if(index == word.size()) return true;\\n        for(int k=0;k<4;k++){\\n            int nr = dr[k]+i;\\n            int nc = dc[k]+j;\\n            if(nr>=0 && nc>=0 && nr<m && nc<n){\\n                if(board[nr][nc] == word[index]){\\n                      if(!vis[nr][nc]){\\n                      vis[nr][nc]=1;\\n                      if(f(nr,nc,board,word,index+1)) return true;\\n                      vis[nr][nc]=0;\\n                      }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==word[0]){\\n                    vis[i][j]=1;\\n                    if(f(i,j,board,word,1)) return true;\\n                    vis[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        return false;\\n     \\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dr[4]={0,1,0,-1};\\n    int dc[4]={1,0,-1,0};\\n    int vis[7][7];\\n    bool f(int i, int j, vector<vector<char>>&board , string word,int index){\\n        int m = board.size();\\n        int n = board[0].size();\\n        if(index == word.size()) return true;\\n        for(int k=0;k<4;k++){\\n            int nr = dr[k]+i;\\n            int nc = dc[k]+j;\\n            if(nr>=0 && nc>=0 && nr<m && nc<n){\\n                if(board[nr][nc] == word[index]){\\n                      if(!vis[nr][nc]){\\n                      vis[nr][nc]=1;\\n                      if(f(nr,nc,board,word,index+1)) return true;\\n                      vis[nr][nc]=0;\\n                      }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==word[0]){\\n                    vis[i][j]=1;\\n                    if(f(i,j,board,word,1)) return true;\\n                    vis[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        return false;\\n     \\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757941,
                "title": "java-code-with-explanation",
                "content": "```\\nclass Solution {\\npublic boolean exist(char[][] board, String word) {\\n \\n        // len for matrix\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                // if backtracking result returned is true then return\\n                if(check(board, word, i, j, m, n, 0))\\n                    return true;\\n            }\\n        }\\n      \\n        return false;\\n    }\\n    \\n    public boolean check(char board[][], String word,\\n                          int i, int j, int m , int n, int curr){\\n        \\n        // meaning if it has reached abcced and then when it calls further tracks of \\'d\\' in recursion. you need to check length to see if whole word is already met.       \\n        if(curr >= word.length())\\n            return true;\\n      \\n        // corner cases\\n        if(i<0 || j<0 || i >=m || j>=n|| board[i][j] != word.charAt(curr))\\n            return false;\\n        \\n\\t\\t// if character match then mask board\\'s character so that we don\\'t visit it again\\n        if(board[i][j]== word.charAt(curr))\\n            board[i][j] += 100;\\n        \\n        // to return final results\\n        boolean exists = false;\\n        \\n        // check bottom right top left\\n        exists = check(board, word, i+1, j, m, n, curr+1) ||\\n                check(board, word, i, j+1, m, n, curr+1) ||\\n                check(board, word, i-1, j, m, n, curr+1) ||\\n                check(board, word, i, j-1, m, n, curr+1);\\n        \\n\\t\\t//unmask masked character\\n        board[i][j] -= 100;\\n            \\n        return exists;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic boolean exist(char[][] board, String word) {\\n \\n        // len for matrix\\n        int m = board.length;\\n        int n = board[0].length;\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                // if backtracking result returned is true then return\\n                if(check(board, word, i, j, m, n, 0))\\n                    return true;\\n            }\\n        }\\n      \\n        return false;\\n    }\\n    \\n    public boolean check(char board[][], String word,\\n                          int i, int j, int m , int n, int curr){\\n        \\n        // meaning if it has reached abcced and then when it calls further tracks of \\'d\\' in recursion. you need to check length to see if whole word is already met.       \\n        if(curr >= word.length())\\n            return true;\\n      \\n        // corner cases\\n        if(i<0 || j<0 || i >=m || j>=n|| board[i][j] != word.charAt(curr))\\n            return false;\\n        \\n\\t\\t// if character match then mask board\\'s character so that we don\\'t visit it again\\n        if(board[i][j]== word.charAt(curr))\\n            board[i][j] += 100;\\n        \\n        // to return final results\\n        boolean exists = false;\\n        \\n        // check bottom right top left\\n        exists = check(board, word, i+1, j, m, n, curr+1) ||\\n                check(board, word, i, j+1, m, n, curr+1) ||\\n                check(board, word, i-1, j, m, n, curr+1) ||\\n                check(board, word, i, j-1, m, n, curr+1);\\n        \\n\\t\\t//unmask masked character\\n        board[i][j] -= 100;\\n            \\n        return exists;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281598,
                "title": "an-in-depth-video-tutorial-for-word-search",
                "content": "An in-depth video tutorial/solution for Word Search leetcode problem : [Word Search](https://youtu.be/iOLyhjDWg2M)\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iOLyhjDWg2M\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "An in-depth video tutorial/solution for Word Search leetcode problem : [Word Search](https://youtu.be/iOLyhjDWg2M)\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iOLyhjDWg2M\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3176254,
                "title": "time-85-and-space-98-beats-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int &m,int &n,vector<vector<char>> &board,string &str,int s){\\n        if(s>=str.length()){\\n            return true;\\n        }\\n        if(i<0||j<0||i>=m||j>=n||board[i][j]==\\'#\\'){\\n            return false;\\n        }\\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        bool a = false;\\n        if(c==str[s])\\n        a = solve(i+1,j,m,n,board,str,s+1)||solve(i-1,j,m,n,board,str,s+1)||solve(i,j-1,m,n,board,str,s+1) ||  solve(i,j+1,m,n,board,str,s+1);\\n        board[i][j] = c;\\n        return a;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int i,j,m=board.size(),n=board[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(board[i][j]==word[0] && solve(i,j,m,n,board,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int &m,int &n,vector<vector<char>> &board,string &str,int s){\\n        if(s>=str.length()){\\n            return true;\\n        }\\n        if(i<0||j<0||i>=m||j>=n||board[i][j]==\\'#\\'){\\n            return false;\\n        }\\n        char c = board[i][j];\\n        board[i][j] = \\'#\\';\\n        bool a = false;\\n        if(c==str[s])\\n        a = solve(i+1,j,m,n,board,str,s+1)||solve(i-1,j,m,n,board,str,s+1)||solve(i,j-1,m,n,board,str,s+1) ||  solve(i,j+1,m,n,board,str,s+1);\\n        board[i][j] = c;\\n        return a;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int i,j,m=board.size(),n=board[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(board[i][j]==word[0] && solve(i,j,m,n,board,word,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844777,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        R, C = len(board), len(board[0])\\n        \\n        \\n        def dfs(r, c, ci):\\n            \\n            if ci == len(word):\\n                return True\\n            \\n            if r < 0 or c < 0 or r >= R or c >= C:\\n                return False\\n            \\n            if board[r][c] != word[ci]:\\n                return False\\n            \\n            curr = board[r][c]\\n            board[r][c] = \"#\"\\n            a1 = dfs(r + 1, c, ci + 1)\\n            b1 = dfs(r - 1, c, ci + 1)\\n            c1 = dfs(r, c + 1, ci + 1)\\n            d1 = dfs(r, c - 1, ci + 1)\\n            board[r][c] = curr\\n            \\n            return a1 or b1 or c1 or d1\\n            \\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == word[0] and dfs(r, c, 0):\\n                    return True\\n                \\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        R, C = len(board), len(board[0])\\n        \\n        \\n        def dfs(r, c, ci):\\n            \\n            if ci == len(word):\\n                return True\\n            \\n            if r < 0 or c < 0 or r >= R or c >= C:\\n                return False\\n            \\n            if board[r][c] != word[ci]:\\n                return False\\n            \\n            curr = board[r][c]\\n            board[r][c] = \"#\"\\n            a1 = dfs(r + 1, c, ci + 1)\\n            b1 = dfs(r - 1, c, ci + 1)\\n            c1 = dfs(r, c + 1, ci + 1)\\n            d1 = dfs(r, c - 1, ci + 1)\\n            board[r][c] = curr\\n            \\n            return a1 or b1 or c1 or d1\\n            \\n        \\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == word[0] and dfs(r, c, 0):\\n                    return True\\n                \\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844084,
                "title": "c-intutive-dfs-easy-understanding-video-solution",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/606RcnDuplY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int i,int j,int count){\\n//          Base case\\n\\n        // Complete traversal of word.\\n        if(count == word.size()){return true;}\\n        //  Return  cases.\\n        if(i<0 || i>=board.size() ||j<0 || j>=board[0].size() || word[count] != board[i][j])\\n\\u2003\\u2003{return false;}\\n\\n//         Make it visited.\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n\\n\\n//         Make traversal\\n\\u2003\\u2003bool isfound = dfs(board,word,i+1,j,count+1) || dfs(board,word,i-1,j,count+1) ||dfs(board,word,i,j+1,count+1)||dfs(board,word,i,j-1,count+1);\\n\\n//         Backtrack.\\n        board[i][j] = temp;\\n\\n        return isfound;\\n\\n\\n    }\\n\\n\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n//\\u2003\\u2003\\u2003if word[0] matches call dfs\\n                if(board[i][j]  == word[0] && dfs(board,word,i,j,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int i,int j,int count){\\n//          Base case\\n\\n        // Complete traversal of word.\\n        if(count == word.size()){return true;}\\n        //  Return  cases.\\n        if(i<0 || i>=board.size() ||j<0 || j>=board[0].size() || word[count] != board[i][j])\\n\\u2003\\u2003{return false;}\\n\\n//         Make it visited.\\n        char temp = board[i][j];\\n        board[i][j] = \\'*\\';\\n\\n\\n//         Make traversal\\n\\u2003\\u2003bool isfound = dfs(board,word,i+1,j,count+1) || dfs(board,word,i-1,j,count+1) ||dfs(board,word,i,j+1,count+1)||dfs(board,word,i,j-1,count+1);\\n\\n//         Backtrack.\\n        board[i][j] = temp;\\n\\n        return isfound;\\n\\n\\n    }\\n\\n\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n//\\u2003\\u2003\\u2003if word[0] matches call dfs\\n                if(board[i][j]  == word[0] && dfs(board,word,i,j,0)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843615,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size(), n = board[0].size();\\n        int index = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == word[index])\\n                {\\n                    if(search(i, j, index, board, word))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(int i, int j, int index, vector<vector<char>>& board, string& word)\\n    {\\n        int m = board.size(), n = board[0].size();\\n        \\n        if(index == word.size()) return true;\\n        if(i < 0 or j < 0 or i >= m or j >= n) return false;\\n        \\n        bool all = false;\\n        if(word[index] == board[i][j])\\n        {\\n            char temp = word[index];\\n            board[i][j] = \\'#\\';\\n            all = search(i+1, j, index+1, board, word) or search(i-1, j, index+1, board, word) or \\n                search(i, j+1, index+1, board, word) or search(i, j-1, index+1, board, word);\\n            \\n            board[i][j] = temp;\\n        }\\n        \\n        return all;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int m = board.size(), n = board[0].size();\\n        int index = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == word[index])\\n                {\\n                    if(search(i, j, index, board, word))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(int i, int j, int index, vector<vector<char>>& board, string& word)\\n    {\\n        int m = board.size(), n = board[0].size();\\n        \\n        if(index == word.size()) return true;\\n        if(i < 0 or j < 0 or i >= m or j >= n) return false;\\n        \\n        bool all = false;\\n        if(word[index] == board[i][j])\\n        {\\n            char temp = word[index];\\n            board[i][j] = \\'#\\';\\n            all = search(i+1, j, index+1, board, word) or search(i-1, j, index+1, board, word) or \\n                search(i, j+1, index+1, board, word) or search(i, j-1, index+1, board, word);\\n            \\n            board[i][j] = temp;\\n        }\\n        \\n        return all;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838651,
                "title": "c-backtracking-with-time-complexity-explanation",
                "content": "<a name=a1></a>\\n### Approach-1, Backtracking\\n#### Logic\\n```c++\\n- Start from board[0][0]\\n- if(board[i][j] == word[0])\\n        -> Compare neighbours (left,right,top,bottom)\\n        -> Keep on comparing neighbours until\\n                - Find a mis-match\\n                - OR word ends\\n        -> if alphabets keep matching replace with \\'#\\'\\n           so that it should not be retravelled.\\n```\\n- **Backtrack Tree**\\n```c\\nA B C E A B\\t\\t//Search:ABCCED\\nS F C S B C\\nA D E E R Z\\n\\t\\t\\t\\t\\t\\t[]\\n\\t\\t\\t\\t-------------------------------------------\\n\\t\\t\\t\\t|\\t\\t\\t|\\t\\t\\n\\t\\t\\t\\tA(0,0)\\t\\t\\tA(0,4)\\n\\t\\t\\t------------------\\t\\t----------------\\n\\t\\t\\t|\\t|\\t\\t\\t|\\t\\t|\\n\\t\\t\\tAB\\tAS\\t\\t\\tAB(1,4)\\t\\tAB\\n\\t\\t\\t|\\t(stop)\\t\\t\\t|\\n  \\t\\t-------------------------\\t\\t-----------------\\n  \\t\\t|     |\\t\\t\\t\\t\\t|\\t|\\t|\\n \\t\\tABC\\tABF\\t\\t\\t\\tABS\\tABR\\tABC\\n  \\t\\t|\\t(stop)\\n\\t-------------------\\n\\t|\\t   |\\t   |\\n\\tABCE\\t  ABCC\\t   \\n\\t(stop)\\t   |\\n\\t --------------------------------\\n\\t |\\t\\t|\\t\\t|\\n\\t ABCCS\\t\\tABCCF\\t\\tABCCE\\t\\t//At any level 3 directions can be traversed.\\n\\t (stop)\\t\\t(stop)\\t\\t|\\n\\t \\t\\t\\t-----------------------------\\n\\t\\t\\t\\t|\\t\\t|\\n\\t\\t\\t\\tABCCEE\\t\\tABCCED\\n\\t\\t\\t\\t(stop)\\t\\t(found)\\n```\\n ### Code\\n ```cpp\\n#include<iostream>\\n#include<string>\\n#include<vector>\\nusing namespace std;\\nusing VecC = vector<char>;\\nusing VecVecC = vector<VecC>;\\nusing VecC = vector<char>;\\nusing vecVecC = vector<VecC>;\\n\\nclass Solution {\\n        int maxRows, maxCols;\\n        string target;\\npublic:\\n    bool recursive_backtrack(int row, int col, vecVecC& board, int presentIndex) {\\n    \\n        /// Base cases\\n        if (presentIndex >= target.size())\\n            return true;\\n\\n        /// Character does not match\\n        if (board[row][col] != target[presentIndex])\\n            return false;\\n        \\n        //Iterate thru all directions\\n        /*\\n                    N(r-1,c)(-1,0)\\n        (0,-1)E(r,c-1)   rc      W(r,c+1)(0,1)\\n                    S(r+1,c)(1,0)\\n        */\\n        bool ret = false;\\n        \\n        int ch = board[row][col];\\n        board[row][col] = \\'#\\';\\n\\t\\t\\n        int dRow[] = {-1,0,0,1};\\n        int dCol[] = {0,-1,1,0};\\n        for (int i=0; i<4; ++i) {\\n            int nextRow = row + dRow[i];\\n            int nextCol = col + dCol[i];\\n            \\n            if (nextRow >= maxRows || nextCol >= maxCols || nextRow < 0 || nextCol < 0)\\n                    continue;\\n        \\n            /// Break only when matching character is found\\n            /// Donot break if after going on path we donot find match\\n            ret = recursive_backtrack(nextRow, nextCol, board, presentIndex+1);\\n            if (ret)\\n                break;\\n        }\\n\\n        /// Place character on board again\\n        /// This is same as Removing last element from candidate list\\n        board[row][col] = ch;\\n        return ret;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        maxRows = board.size();\\n        maxCols = board[0].size();\\n        target = word;\\n        int presentIndex = 0;   //This is index of character in target word to be searched\\n        \\n        /// if board has 1 alphabet and word also has 1\\n        if(maxRows == 1 && maxCols == 1 && target.size() == 1 && board[0][0] == target[0])\\n                return true;\\n\\n        /// Iterate thru every character on board\\n        for (int i=0; i < maxRows; ++i) {\\n            for (int j=0; j < maxCols; ++j) {\\n                if (board[i][j] == target[presentIndex]) {\\n                        if (recursive_backtrack(i, j, board, presentIndex))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n#### [Complexity Analysis for Backtracking](https://github.com/amitkumar50/Code-examples/blob/master/DS_Questions/Algorithms/Backtracking/README.md#t)\\n- **Time:** O(N x 3<sup>L</sup>)\\n  - Look at backtrack Tree above. At any level 3 children are allowed, since we cannot traverse back to path from where we came. if levels=L. Complexity = 3<sup>L</sup>\\n  - N=Number of letters in grid. From Every letter there can be a path to target word.\\n- **Space:** \\n  - O(k) where k is the length of the word to be matched.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\n- Start from board[0][0]\\n- if(board[i][j] == word[0])\\n        -> Compare neighbours (left,right,top,bottom)\\n        -> Keep on comparing neighbours until\\n                - Find a mis-match\\n                - OR word ends\\n        -> if alphabets keep matching replace with \\'#\\'\\n           so that it should not be retravelled.\\n```\n```c\\nA B C E A B\\t\\t//Search:ABCCED\\nS F C S B C\\nA D E E R Z\\n\\t\\t\\t\\t\\t\\t[]\\n\\t\\t\\t\\t-------------------------------------------\\n\\t\\t\\t\\t|\\t\\t\\t|\\t\\t\\n\\t\\t\\t\\tA(0,0)\\t\\t\\tA(0,4)\\n\\t\\t\\t------------------\\t\\t----------------\\n\\t\\t\\t|\\t|\\t\\t\\t|\\t\\t|\\n\\t\\t\\tAB\\tAS\\t\\t\\tAB(1,4)\\t\\tAB\\n\\t\\t\\t|\\t(stop)\\t\\t\\t|\\n  \\t\\t-------------------------\\t\\t-----------------\\n  \\t\\t|     |\\t\\t\\t\\t\\t|\\t|\\t|\\n \\t\\tABC\\tABF\\t\\t\\t\\tABS\\tABR\\tABC\\n  \\t\\t|\\t(stop)\\n\\t-------------------\\n\\t|\\t   |\\t   |\\n\\tABCE\\t  ABCC\\t   \\n\\t(stop)\\t   |\\n\\t --------------------------------\\n\\t |\\t\\t|\\t\\t|\\n\\t ABCCS\\t\\tABCCF\\t\\tABCCE\\t\\t//At any level 3 directions can be traversed.\\n\\t (stop)\\t\\t(stop)\\t\\t|\\n\\t \\t\\t\\t-----------------------------\\n\\t\\t\\t\\t|\\t\\t|\\n\\t\\t\\t\\tABCCEE\\t\\tABCCED\\n\\t\\t\\t\\t(stop)\\t\\t(found)\\n```\n```cpp\\n#include<iostream>\\n#include<string>\\n#include<vector>\\nusing namespace std;\\nusing VecC = vector<char>;\\nusing VecVecC = vector<VecC>;\\nusing VecC = vector<char>;\\nusing vecVecC = vector<VecC>;\\n\\nclass Solution {\\n        int maxRows, maxCols;\\n        string target;\\npublic:\\n    bool recursive_backtrack(int row, int col, vecVecC& board, int presentIndex) {\\n    \\n        /// Base cases\\n        if (presentIndex >= target.size())\\n            return true;\\n\\n        /// Character does not match\\n        if (board[row][col] != target[presentIndex])\\n            return false;\\n        \\n        //Iterate thru all directions\\n        /*\\n                    N(r-1,c)(-1,0)\\n        (0,-1)E(r,c-1)   rc      W(r,c+1)(0,1)\\n                    S(r+1,c)(1,0)\\n        */\\n        bool ret = false;\\n        \\n        int ch = board[row][col];\\n        board[row][col] = \\'#\\';\\n\\t\\t\\n        int dRow[] = {-1,0,0,1};\\n        int dCol[] = {0,-1,1,0};\\n        for (int i=0; i<4; ++i) {\\n            int nextRow = row + dRow[i];\\n            int nextCol = col + dCol[i];\\n            \\n            if (nextRow >= maxRows || nextCol >= maxCols || nextRow < 0 || nextCol < 0)\\n                    continue;\\n        \\n            /// Break only when matching character is found\\n            /// Donot break if after going on path we donot find match\\n            ret = recursive_backtrack(nextRow, nextCol, board, presentIndex+1);\\n            if (ret)\\n                break;\\n        }\\n\\n        /// Place character on board again\\n        /// This is same as Removing last element from candidate list\\n        board[row][col] = ch;\\n        return ret;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        maxRows = board.size();\\n        maxCols = board[0].size();\\n        target = word;\\n        int presentIndex = 0;   //This is index of character in target word to be searched\\n        \\n        /// if board has 1 alphabet and word also has 1\\n        if(maxRows == 1 && maxCols == 1 && target.size() == 1 && board[0][0] == target[0])\\n                return true;\\n\\n        /// Iterate thru every character on board\\n        for (int i=0; i < maxRows; ++i) {\\n            for (int j=0; j < maxCols; ++j) {\\n                if (board[i][j] == target[presentIndex]) {\\n                        if (recursive_backtrack(i, j, board, presentIndex))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2779254,
                "title": "python-intuitive-dfs-solution",
                "content": "```\\nfrom collections import deque, Counter\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(row, col, i):\\n            if i == len(word):\\n                return True\\n            original, board[row][col] = board[row][col], \\'#\\'\\n            spreaded = False\\n            for dy, dx in ((1, 0), (-1,0), (0, 1), (0, -1)):\\n                nr, nc = row + dy, col + dx\\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == word[i] and dfs(nr, nc, i+1):\\n                    spreaded = True\\n                    break\\n            board[row][col] = original\\n            return spreaded\\n                                \\n                    \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0] and dfs(i, j, 1):\\n                        return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, Counter\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(row, col, i):\\n            if i == len(word):\\n                return True\\n            original, board[row][col] = board[row][col], \\'#\\'\\n            spreaded = False\\n            for dy, dx in ((1, 0), (-1,0), (0, 1), (0, -1)):\\n                nr, nc = row + dy, col + dx\\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == word[i] and dfs(nr, nc, i+1):\\n                    spreaded = True\\n                    break\\n            board[row][col] = original\\n            return spreaded\\n                                \\n                    \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == word[0] and dfs(i, j, 1):\\n                        return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564941,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565218,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1575694,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1809106,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1804756,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565829,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566547,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1572297,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566820,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1576664,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1564941,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565218,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1575694,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1809106,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1804756,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565829,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566547,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1572297,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1566820,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1576664,
                "content": [
                    {
                        "username": "pinkfloyda",
                        "content": "First we have to find the first letter to start, which gives time O(N^2), then for each search step it has 2~4 neighbours to go, and it has k steps, where k is the length of the word to be searched."
                    },
                    {
                        "username": "stuymedova",
                        "content": "Finding first letter would be O(m * n)"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@twoseat](/twoseat) Yes"
                    },
                    {
                        "username": "twoseat",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) I don't think it will be O(N^4). you're k steps deep and each step has 2 to 3 neighbours so it's (2 to 3)^k steps which is a lot more than N^4. Complexity is probably something like O(N * 3^k) where N is the number of elements on the board and k is the length of the target word. It's 3^k because one of the neighbours is eliminated since you can't go back to the source cell from the destination cell."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@bikcrum](/bikcrum)  For the worst case it will be O(N^4), like if the grid of 3*3 is filled with \\'a\\' and we have to check if the word \\'aaaaaaaaaa\\' [\\'a\\' * 10] is present, it will check all possible ways for each \\'a\\'"
                    },
                    {
                        "username": "bikcrum",
                        "content": "What would overall time complexity be?"
                    },
                    {
                        "username": "wintryleo",
                        "content": "Hello!\\n\\nThere is a follow-up question for this problem - \\n\\n**Follow up: Could you use search pruning to make your solution faster with a larger board?**\\n\\nCan someone please provide some insight for that?"
                    },
                    {
                        "username": "charonme",
                        "content": "I believe pruning would mean that if from a particular position we didn\\'t find the rest of the word in some path, we would prune that position and don\\'t try to look for the same rest of the word again in a different path from that position; however the condition that cells shouldn\\'t be reused messes with this kind of pruning, because the reason we didn\\'t find the rest of the word from some path might be that the path would have to reuse some cells, but from a different path we would be able to find the rest of the word without reusing cells, so we don\\'t know whether we can prune it in the first path."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is a great tip [@suhaanbhandary1](/suhaanbhandary1)! Thanks."
                    },
                    {
                        "username": "codingmoding",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) awesome idea, thanks for the tip."
                    },
                    {
                        "username": "jayr777",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1) thanks for the tip. improved my TLE code to 95%"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "[@vinayagarwal360](/vinayagarwal360) And also a smart pruning technique is to check the frequency of first and last char of the word in the board, and if the freq of first char is greater than last one, simple reverse the string and find the result\\n\\nIt will reduce the number of starting cells for dfs"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "In pruning you just have to stop the search when you have reached an index whose value does not matches with the original word. For example you have the word \"HELLO\" and in the search you have got \"HELP_\" so there is no point on generating the last word because you have already got a index where there is a mismatch. I guess most of the people have implemented this in the back of their mind without even noticing it."
                    },
                    {
                        "username": "chillimunchkin",
                        "content": "Example input:\\n[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\\n\"AAAAAAAAAAAAABB\"\\n\\nThis keeps giving time limit exceeded during submission, but not when run as a test case by itself. Has anyone seen this?\\n"
                    },
                    {
                        "username": "pansari",
                        "content": "THis could be because, leetcode has time limit for say 100 test cases. It might be the case that at this test case you got time limit"
                    },
                    {
                        "username": "yetee",
                        "content": "Yeah this edge case is too strict. I\\'ve got bottom 5% with only small difference btw the top voted ones. Idk why."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I\\'ve got this problem too.\\nTestcase #47.\\n\\nThere is about 1M variants for each starting point in worst case. And 36 starting points. So, i\\'am not surprised. But I do not know how to optimise solution."
                    },
                    {
                        "username": "Dat09VN",
                        "content": "[@nilay2014](/nilay2014)  could you please help me know what is difference in this?"
                    },
                    {
                        "username": "user1440f",
                        "content": "In my case using a visited matrix was causing TLE."
                    },
                    {
                        "username": "nilay2014",
                        "content": "pass the board by reference (use & symbol). use backtracking."
                    },
                    {
                        "username": "VacuusUmbra",
                        "content": "Some optimizations can be made to pass that case in time such as getting the counts of the letters in the grid and reversing the word if the last letter is less frequent."
                    },
                    {
                        "username": "mg5050",
                        "content": "I find it irritating that some of the test cases on this problem, and more generally on Leetcode are overly adversarial.\n\nI had a decent solution after 15 - 20 minutes. I know it was fairly quick, but of course it gives TLE on the very last test case (for which I was unable to view the input due to some bug). Knowing how Leetcode is, I already knew without even being able to access the input that they would pass a board filled with many instances of the word minus the last letter or something ridiculously skewed like that, in order to lead the algorithm astray.\n\nLo and behold, with the assumption above in mind, I simply reverse the order of the target word to search from end to start, same exact algorithm, and it beats 80% in time, and 90% in space complexity.\n\nIn my opinion, these are poorly written test cases on this problem. Increasingly, the problems focus on \"gotchas!\" instead of actual preparation for interviews or working in the industry."
                    },
                    {
                        "username": "skippythegoat",
                        "content": "Thanks bruv, I had the same problem and your hack worked for me"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Bug in question??\\nIt says 85/85 testcases passed\\nIt says time limit exceeded\\nAnd then under last executed input it literally shows\\n\\n\"board = \"\\n\\nAnd nothing else. It\\'s not showing the input where the time limit was exceeded\\n"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "Here my code gives TLE for the Same issue.\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        \\n        \\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Leetcode works on 2 types of time limit, one is the time limit for each testcase and other is the time limit for the whole set of testcases, your problem arises when you are passing all testcases individually within their time limits but when the testcases are run together your code is over the limit, hope this helps\\n"
                    },
                    {
                        "username": "jain411",
                        "content": "Facing the same. Found the reason?"
                    },
                    {
                        "username": "d2345486",
                        "content": "Get the same outcome here"
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I think the board for Python language should not be `[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]`, since for Python language string is immutable, we can not assign value like `board[i][j] = \"#\"`. The board should be initialied as `[\\n  [\"A\", \"B\", \"C\", \"E\"],\\n  [\"S\", \"F\", \"C\", \"S\"],\\n  [\"A\", \"D\", \"E\", \"E\"]\\n]` . The function input is `type board: List[List[str]]`, which implies the inner parameter should be a list of strings . [Word Search II ][1] gives the right figure. \\n\\n\\n  [1]: https://leetcode.com/problems/word-search-ii/"
                    },
                    {
                        "username": "uri200",
                        "content": "All,\\nI have been reading lots of post and I havent been able to find the proper solution. I am just trying to understand the time complexity.\\n\\nSo if we have a\\n-Word of lenght = l\\n-A boar of M x N.\\n\\nUsingl DFS with 4 directions to search for that word, what should the time complexity be??\\n\\nM * N * 4^l?\\nM * N * M * N?\\nM * N * L ?\\nM * N * min(4^L , M*N)?\\n\\nI have seen all those different complexities for the same code\\nIf you can help to clarify that would be great!"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "We can also say that time complexity will be:\\nO(N + freq * 3^K) ~ O(freq * 3 ^ K)\\nSince DFS is only called for the cells which having the starting char \\nAnd 3^K as for each char there is 3 path at max\\n\\nN: Total cells\\nfreq: Cells with the starting char \\nK: Length of the word"
                    },
                    {
                        "username": "codeitout",
                        "content": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\nFor this test case, the output is true, but E in ABCE doesn\\'t have any neighbor starting with F.  How is the output true?"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "https://ibb.co/hK3p097\\n\\n\\nBrother here it is."
                    },
                    {
                        "username": "judeyoung",
                        "content": "I came up with the idea using DP when I saw this problem because of its 2D array. When I tried to solve it, however, I failed in solving the cases when repetitive words are included in the array. And I couldn\\'t find any discusses about DP, so I am wondering if it is a feasible way to solve this problem. "
                    },
                    {
                        "username": "codestarter112",
                        "content": "In your DP solution, make sure you also memoize i,j with offset."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Don\\'t think it\\'s viable"
                    },
                    {
                        "username": "uiLqwenmv",
                        "content": "Looks like leetcode server is having some issue, my code is exceeding time even without invoking the backtracking solution. Has this happened to anyone ?"
                    }
                ]
            },
            {
                "id": 1565426,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1568484,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1568483,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1568063,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1567187,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1783736,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1694965,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1576320,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1575038,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1574421,
                "content": [
                    {
                        "username": "stpeterh",
                        "content": "In the instructions, it is said that the board as input would be \"a list of list of 1 length string\".\\n\\n\"For example,\\nGiven board =\\n<pre>\\n<code>\\n[\\n  [\"ABCE\"],\\n  [\"SFCS\"],\\n  [\"ADEE\"]\\n]\\n</code>\\n</pre>\\n\"\\n\\nHowever, all actual test cases have a different datatype --- the board is a list of strings. \\n\\nWith the same example above, the actual board =\\n<pre>\\n<code>\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]\\n</code>\\n</pre>"
                    },
                    {
                        "username": "NeosDeus",
                        "content": "can someone explain why this problem can\\'t use memoization? like what specific properties prevent us from using it?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Because you cannot keep track of the visited cells"
                    },
                    {
                        "username": "campout",
                        "content": "I tried memoizing the i, j of the board along with the current word we have left. It fails this test case because there are two ways we can get to the \\'E\\' at i = 2 j = 2 with the same remaining word, from the top and from the right. If we memoize i, j, and the remaining word and we get to that E from the top first, it will return False. The second time where we get to the same \\'E\\' with the same remaining word from the right will also return False when it should actually be able to find a path for the rest of the remaining word. So depending on which direction we check first, it might give us the wrong answer if we only store those 3 states in our memo. I\\'m not sure how else to memoize it though. Have you figured it out? \\n\\nABCE\\nSFES\\nADEE \\n\\nword = ABCESEEEFS \\n\\n"
                    },
                    {
                        "username": "coiby",
                        "content": "After connecting ABCE, the only letter adjecent to E is S not F. So \"ABCEF\" can\\'t be constructed from sequentially adjencent letters. What  do I miss? Thank you!"
                    },
                    {
                        "username": "jennykim1016",
                        "content": "It seems like no one implemented breadth first search... :("
                    },
                    {
                        "username": "geraudwllg",
                        "content": "I tried to use bfs and fails. With DFS you cannot keep track of visited parent nodes properly for this problem"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "It would be nice to see some alternative solutions."
                    },
                    {
                        "username": "pra3eek",
                        "content": "I don\\'t know why but when I am submiting my code it get time limit exceeded error and when I look at the test cases passed it show 85/85 and in the test case for which my code is getting error it show the board empty like if the board is null but it can\\'t be true as constraints of this question says the board length is in between 1 and 6, I am very confused here if someone have any idea of why I am getting the error please enlighten me."
                    },
                    {
                        "username": "adityagnet",
                        "content": "I\\'m gettting the same thing"
                    },
                    {
                        "username": "yikhim",
                        "content": "What does passing 84 / 84 testcases with Time Limit Exceeded mean?\\nDoes it mean barely failed?\\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "for me 85/85 testcases passed and TLE"
                    },
                    {
                        "username": "hunny9891",
                        "content": "This statement is confusing \"The same letter cell may not be used more than once.\" \\nI don\\'t know what you think but I interpreted this as use one cell only therefore indicating if you have visited the cell you cannot reset it, however, there are test cases that wants you to reconsider the visited cells.\\n\\nCan someone clarify?\\n\\nThanks!"
                    },
                    {
                        "username": "Shru93",
                        "content": "Can someone please explain how the below testcase is true\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\n\"ABCEFSADEESE\"\\n\\nA B C E\\nS F E S\\nA D E E\\n Here 5th character F(1,1) is not adjacent to E (0,4) right?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "https://ibb.co/hK3p097\\n\\n"
                    },
                    {
                        "username": "santiagobox6",
                        "content": "No, but it is adjacent to E (1,2)"
                    },
                    {
                        "username": "GuanzhaoLi",
                        "content": "Hello,\\n\\nInput:\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\n\"abcd\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nI\\'m wondering why this test expects a false, the matrix seems contains all elements from \"abcd\"."
                    },
                    {
                        "username": "marcoSpery",
                        "content": "you can\\'t go from cell 0, 1 (letter b) to cell 1, 0 (letter c) because you can only move to horizontally/vertically adjacent cells"
                    }
                ]
            },
            {
                "id": 1876348,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1576383,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1576238,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1573681,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1569283,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568899,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568900,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568901,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 1568902,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 2035547,
                "content": [
                    {
                        "username": "agrawal99saurabh",
                        "content": "Can some one please explain how the following testcase is true?\\n\\nboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword = \"ABCESEEEFS\"\\n\\nIt should be false right?"
                    },
                    {
                        "username": "wimdetroyer",
                        "content": "also not sure about this one!"
                    },
                    {
                        "username": "therealsangwoohan",
                        "content": "If you use a set or a hashmap to track visited nodes, you will at most visit mn nodes..."
                    },
                    {
                        "username": "kamikaze16",
                        "content": "In a recent interview, I got tangled into the solution when I had to save the coordinates of the blocks that formed the word. I started with the true & false and got it working. Any thoughts on that?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Mostly In such problems, If only one solution is asked then keep track of the path and store it in a result when returning true"
                    },
                    {
                        "username": "gopher0420",
                        "content": "The following test-case is expected to return \\'false\\', whereas the expected result should be \\'true\\':\\n\\n[[\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"b\",\"b\",\"b\"],[\"a\",\"a\",\"a\"],[\"b\",\"b\",\"b\"],[\"a\",\"b\",\"b\"],[\"a\",\"a\",\"b\"],[\"a\",\"b\",\"a\"]]\\n\"aabaaaabbb\"\\n\\nHere\\'s the path of indices of the 2D char-array that traces the given string :\\n\\n[0,0], [1,0], [1,2], [0,2], [9,2], [9,0], [8,0], [8,2], [7,2], [6,2].\\n"
                    },
                    {
                        "username": "gte125u",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gte125u/image_1535581262.png)\\n"
                    },
                    {
                        "username": "fenchaoDu",
                        "content": "Input:\\n[\"FYCENRD\",\"KLNFINU\",\"AAARAHR\",\"**ND**KLPNE\",\"**AL**ANSAP\",\"O**O**GOTPN\",\"H**P**OLANO\"], \"poland\"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nUsing **selected** why it is false?"
                    },
                    {
                        "username": "wwweii",
                        "content": "In Leetcode No.79, when I face test case [\"aa\"], \"aa\", the compiled result for my code in Sublime is True (correct answer). However, the result in Online judgement is False. Even i reset the class variable (https://gist.github.com/anonymous/b2f8d87a4751d86965a9) or avoid to use it (https://gist.github.com/anonymous/d75889648252efc30dd6), the problem still occur. I dont know whats going on. Can anyone help me to figure out what the problem is? Thanks a lot!!"
                    },
                    {
                        "username": "janevans",
                        "content": "Board should be:\\n\\n[\\n  \"ABCE\",\\n  \"SFCS\",\\n  \"ADEE\"\\n]"
                    },
                    {
                        "username": "Yudong",
                        "content": "I think the input variable `board` is not a `list of lists of 1 length string` as describe in the python code snippet, in fact, according my AC-ed code, the `board` is a `list of strings with the same length`, which is the same with what people may intuitively think."
                    },
                    {
                        "username": "cs_can",
                        "content": "U can loop the board until u find the initial char of the word given ...now u can do dfs to see if it has a path ..that makes word...no need to keep visited u can change the board[row][col] to smthng like '.' each time...and while backtracking again u can make it what it was originally ... and if u find a valid path containing the word u can straightaway return true and do no further rec...simple way i solved it by my own and it beats 90% users...feel free to extend this discussion.\nUpvote if it helped!"
                    }
                ]
            },
            {
                "id": 2034059,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 2018376,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 2007044,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1845454,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1811825,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1795858,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1788965,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1694967,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1672474,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1576276,
                "content": [
                    {
                        "username": "devhindo",
                        "content": "I\\'m struggling with recursion"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "Me too.. "
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "Why is my solution : https://leetcode.com/problems/word-search/submissions/1024252513/ giving TLE? Can anyone suggest any optimization?"
                    },
                    {
                        "username": "AKSaurav",
                        "content": "Man! I am just so Tired\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "Pseudo code tip for a DFS backtracking optimal solution:\\n```\\n    function DFS(i, j, k = 0) {\\n        if k == len(word) return TRUE\\n        if board[i][j] != word[k] return FALSE\\n\\n        board[i][j] = \\'!\\' // Invalid character to prevent going back a traversed path\\n\\n        if  ( DFS(i, j-1, k+1) \\n             OR DFS(i, j+1, k+1)\\n             OR DFS(i+1, j, k+1)\\n             OR DFS(i-1, j, k+1) )\\n           return TRUE\\n\\n        board[i][j] = word[k] // backtracking and restoring the value\\n    }\\n\\n    for (i = 0; i < m; i++)\\n        for (j = 0; j < n; j++)\\n            if DFS(i, j) return TRUE\\n\\n    return FALSE\\n}\\n```"
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "Common on lets all agree, Its a hard problem its not an easy one!\\n"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "I have done exact same thing as solution\\n\\nBut mine is TLE\\ncan anyone explain why?\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<char>>& board, string word,int x, int y, vector<vector<int>>& visited,string curr){\\n        //cout<<curr<<endl;\\n        if(curr == word){\\n            return true;\\n        }\\n        int m=board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<int>> directions = {\\n            {-1,0},{0,-1},{0,1},{1,0}\\n        };\\n        for(int i=0; i<4; i++){\\n            int newi = x+directions[i][0];\\n            int newj = y+directions[i][1];\\n            if(newi >=0 && newi<m && newj>=0 && newj<n && !visited[newi][newj] &&curr.length()<word.size() && word[curr.length()] == board[newi][newj]){\\n                //cout<<newi<<\" \"<<newj<<endl;\\n                visited[newi][newj]=1;\\n                curr+=board[newi][newj];\\n                if(dfs(board,word,newi,newj,visited,curr)){\\n                    return true;\\n                }\\n                visited[newi][newj]=0;\\n                curr.pop_back();\\n            }\\n\\n        }\\n        return false;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        \\n        for(int i=0; i<board.size();i++){\\n            for(int j=0; j<board[i].size();j++){\\n                vector<vector<int>> visited(board.size(),vector<int>(board[i].size(),0));\\n                visited[i][j]=1;\\n                string curr=\"\";\\n                curr+=board[i][j];\\n                if(board[i][j]== word[0]){\\n                    if(dfs(board,word,i,j,visited,curr)){\\n                        return true;\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Why there are Two Normal Curves in Submissions? Some people Really aced in timing.. How did they do it? Are they not using dfs? Or including something better for pruning?"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[\"a\",\"b\"],[\"c\",\"d\"]] word =\"abcd\" why expected output is false"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Visualize the board, it will look something like this:\\n\\n```\\na     b\\nc     d\\n```\\n\\nYou can go in 4 directions (left, right, up, down) and within the constraints of the board. Now imagine you are at b, you can go down only to c (no right because its out of bounds, no left because its already visited, no up because it out of bounds). So, abcd isnt possible (abdc is possible!)"
                    },
                    {
                        "username": "yzhao156",
                        "content": "Why I got time out even copy paste the official solution?\nVery disappointed and frustrated unless I can get 1000 leetcode coins..."
                    },
                    {
                        "username": "user6375E",
                        "content": "is it because BFS doesnt allow backtracking?"
                    }
                ]
            },
            {
                "id": 1574086,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1573547,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1573281,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571849,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571183,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571184,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571185,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571186,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 1571880,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 2058630,
                "content": [
                    {
                        "username": "arjitkansal",
                        "content": "Well the naive DFS solution, starting from one cell and continuing in every possible direction until the word is found. Though it\\'s giving the accepted verdict. But I think the test cases are weak. \\n\\nWhat about the test case, having a 20 x 20 grid having all letter as \\'a\\'. And we are looking for word having all a\\'s of length 401 ??? It\\'s giving TLE.\\n\\nIt\\'s much lesser than the mentioned constraints. So why is the DFS solution as an accepted one ? We can make the above solution acceptable by adding memoization. But the question is why it is getting accepted without memoization ?\\n\\nAnyone with an idea can please let me know ?\\n\\n[MAYBE EVEN I\\'M MISSING SOMETHING, WHICH I OVERLOOKED IN THE PROBLEM STATEMENT...]"
                    },
                    {
                        "username": "mezhaka",
                        "content": "The proposed solution and all of the ones I have skimmed through in the discussion are `O(board_width * board_height * 4^word_length)`.  With the given constraints of word_length up to 1000 this is not feasible.  So is there a better way to do it?  Is it something done on purpose to see how a candidate copes with an unrealistic expectations?"
                    },
                    {
                        "username": "gepo",
                        "content": "mem = hashttable;  // (x,y,index) ==> true or false\\n// key is : (x,y,index): x,y are locations of grid. index is the index of word-to-search. \\nSo (x,y,index) should identify a unique state. \\nAnything wrong here?"
                    },
                    {
                        "username": "xipixiaolian",
                        "content": "Is there any solutions that are not brute force and quicker than brute force???????"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "No. NP-hard problem"
                    },
                    {
                        "username": "jamesly",
                        "content": "My first submitted DFS code got TLE and even after I tried some modification here and there, it still ran around 80ms. After comparing my code with several faster solution online, I found below 2 tricks to speed it up from ~80ms to 16ms.\\n\\n1. Use the input board to store whether a character is visited or not, which avoid from creating another array. This would speed up my code from ~80ms to ~40ms.\\n\\n2. In the DFS function, pass the word by reference (\"const string& word\") to avoid unnecessary copying. I think this should also be a good coding habit and it reduce the running time to 16ms.\\n\\nHope these help."
                    },
                    {
                        "username": "lc_13",
                        "content": "The input  [\"aa\"], \"aa\" doesn't look like a valid input as [\"aa\"] is not a 2D array and the functions accepts a 2D array. Please explain the input. \\n\\nThanks in advance."
                    },
                    {
                        "username": "rg90",
                        "content": "I think the question description is misleading. For example, according to my understanding of question, if board is ['abc', 'def'] and word is 'abce', the result should be True. \\n\\nThe description says \"The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\" \\n\\nNowhere in my example are any of the constraints mentioned in the description violated.\\n\\nThis becomes a much harder question if someone misunderstands it as I did."
                    },
                    {
                        "username": "zzViola",
                        "content": "I may not understand the problem very well."
                    },
                    {
                        "username": "userLee",
                        "content": "as title says"
                    },
                    {
                        "username": "liayn15",
                        "content": "Can anyone please tell why my solution is getting TLE? Have followed the same backtracking approach as other problems   ```\n\nclass Solution {\npublic:\n\n    bool dfs(vector<vector<char>>& board,string word, int i, int j,int m,int n,int k){\n\n        if(k==word.size()-1) return true;\n\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\n\n        int r,c,nr,nc;\n        int nk = k+1;\n\n        r = i;\n        c = j;\n\n        board[r][c] = '#';\n            \n        bool ans = false;\n\n        for(int p=0;p<4;p++){\n            nr = r + dir[p][0];\n            nc = c + dir[p][1];  \n            if(nr>=0 && nc>=0 && nr<m && nc<n && board[nr][nc]==word[nk]){    \n                ans = dfs(board,word,nr,nc,m,n,nk);\n                if(ans) return true;\n            }\n\n        }\n\n        board[r][c] = word[k];\n    \n        return ans;\n\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word[0]){\n                    board[i][j] = '#';\n                    if(dfs(board,word,i,j,m,n,0)) return true;\n                    board[i][j] = word[0];\n                }\n            }\n        }\n\n        return false;\n        \n    }\n};\n\n``` \n"
                    }
                ]
            },
            {
                "id": 2046552,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2042347,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2026877,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2014112,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 2001553,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1999399,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1994483,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1989782,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1986354,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1985849,
                "content": [
                    {
                        "username": "itookyourboo",
                        "content": "What\\'s wrong with the last testcase?\\n\\n**Time Limit Exceeded**\\n\\n```\\nboard = \\n```"
                    },
                    {
                        "username": "HaRsH_DeeP___",
                        "content": "board =\\n[[\"a\",\"b\"],[\"c\",\"d\"]]\\nword =\\n\"abcd\"\\nFor this input what should be the output"
                    },
                    {
                        "username": "NAYEEM_BASHA",
                        "content": "board= [ [\"a\",\"b\"] , [\"c\",\"d\"] ]\\nword=\"abcd\"\\nHow the expected output is false for this input if word is found in the board?"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Submitted a code, TLE.\\nSubmitted again, Accepted with 91% faster than others.\\nJUST LEETCODE THINGS"
                    },
                    {
                        "username": "mafishere",
                        "content": "I have noticed that memory or time limit exceeds when we keep track of visited cells using a map, set or a vector. So change the current element to a character like \\'.\\' to indicate that it has been visited. And in the end change it back to what it was before."
                    },
                    {
                        "username": "ganeshnathan06",
                        "content": "The test cases are bad in this question, just reversing the word takes the runtime from 1000ms to 2ms!!\\nsmh "
                    },
                    {
                        "username": "Ranjith_77R",
                        "content": "class Solution {\\n    int count=0;int len=0;String ans=\"\";\\n    public boolean exist(char[][] board, String word) {\\n        int vis[][]=new int[board.length][board[0].length];\\n        len=word.length();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                if(vis[i][j]==0 && board[i][j]==word.charAt(0))\\n                {\\n                    ans+=word.charAt(0);\\n                    dfs(i,j,vis,0,board,word);\\n                    vis[i][j]=1;\\n                    System.out.println(ans);\\n                    ans=\"\";\\n                    if(count==1)\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    void dfs(int i,int j,int[][] vis,int ptr,char[][]grid,String wrd)\\n    {\\n        vis[i][j]=1;\\n        int r=grid.length,c=grid[0].length;\\n         if(ptr==len-1)\\n        {\\n            count=1;\\n            return;\\n        } \\n        lookneighbour(vis,grid,i-1,j,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j-1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i,j+1,r,c,ptr+1,wrd);\\n        lookneighbour(vis,grid,i+1,j,r,c,ptr+1,wrd);\\n        vis[i][j]=0;\\n        return;\\n    }\\n    void lookneighbour(int[][] vis,char[][] grid,int r,int c,int m,int n,int ptr,String word)\\n    {\\n        if(r<m && c<n && r>=0 && c>=0 && vis[r][c]==0 && grid[r][c]==word.charAt(ptr))\\n        {     ans+=word.charAt(ptr);\\n            dfs(r,c,vis,ptr,grid,word);\\n                return;\\n        }\\n    }\\n}\\n\\nwhat is wrong in my approach only 66 cases passes"
                    },
                    {
                        "username": "Blaster1617",
                        "content": "is their any optimal solution of this solution other then backtracking "
                    },
                    {
                        "username": "dadinho",
                        "content": "On the Elixir test case, all my test cases pass locally, but the same fail in the website, has anyone experienced this as well?"
                    },
                    {
                        "username": "urodoloh",
                        "content": "84 / 85 testcases passed\\n[\"a\",\"a\",\"a\"]\\n[\"A\",\"A\",\"A\"]\\n[\"a\",\"a\",\"a\"]\\n\\nword \"aAaaaAaaA\"\\n\\nI\\'m fine"
                    }
                ]
            },
            {
                "id": 1967439,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1965816,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1964607,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1951506,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1935422,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1929276,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1914068,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1910606,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1905517,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1893767,
                "content": [
                    {
                        "username": "itsHitler_999",
                        "content": "i am getting wrong output for 2nd testcase \"SEE\"\ncan anyone identify the fault in the below code:\n\n `\nbool exist(vector<vector<char>>& b, string w) {\n\n        int m = b.size(),n = b[0].size();\n\n        vector<vector<bool>> dp(m,vector<bool>(n,false));\n        \n        function<bool(int,int,int)> dfs = [&](int r,int c,int i)-> bool{\n            if(i == w.size())return true;\n\n            if(r < 0 or r >= m or c < 0 or c >= n or w[i] != b[r][c] or dp[r][c] == true)return false;\n\n            dp[r][c] = true;\n\n            bool res = (dfs(r+1,c,i+1) or dfs(r-1,c,i+1) or dfs(r,c+1,i+1) or dfs(r,c-1,i+1));\n \n            dp[r][c] = false;\n\n            return res;\n        };\n        for(int i=0; i<m; i++){\n            for(int j=0; j<m; j++){\n                if(dfs(i,j,0))return true;\n            }\n        }\n\n        return false;\n    }\n`"
                    },
                    {
                        "username": "jeffmachyo",
                        "content": "I still can\\'t quite wrap my head around this test case:\\nboard =\\n[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\n\\nword =\\n\"AAB\"\\n\\nHow does this evaluate to true? "
                    },
                    {
                        "username": "fulltilt",
                        "content": "board[1][1] -> board[1][0] -> board[2][0]"
                    },
                    {
                        "username": "krishnatra",
                        "content": "It is a recursion question instead\\n"
                    },
                    {
                        "username": "rajat_98",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCEFSADEESE\"\\n\\nwhy is expected output true?\\n"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "for duirections use \\n\\n vector<vector<int>> directions{{1,0},{-1,0},{0,1},{0,-1}};  //up down left right"
                    },
                    {
                        "username": "jeetu_23",
                        "content": " ```\\nclass Solution {\\npublic:\\n    bool solve(int r,int c,int& ind,int row,int col,vector<vector<char>>& board,vector<vector<int>>&vis, string& word)\\n    {\\n        if(ind==word.size())return true;\\n        if(r<0||c<0||r>=row||c>=col||board[r][c]!=word[ind]||vis[r][c]==1)\\n            return false;\\n        vis[r][c]=1;\\n        ind++;\\n        bool ans1=solve(r+1,c,ind,row,col,board,vis,word);\\n        bool ans2=solve(r-1,c,ind,row,col,board,vis,word);\\n        bool ans3=solve(r,c+1,ind,row,col,board,vis,word);\\n        bool ans4=solve(r,c-1,ind,row,col,board,vis,word);\\n        return ans1||ans2||ans3||ans4;\\n    }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int row=board.size(),col=board[0].size();\\n        for(int r=0;r<row;r++)\\n        {\\n            for(int c=0;c<col;c++)\\n            {\\n                if(word[0]==board[r][c])\\n                {\\n                    int ind=0;\\n                    vector<vector<int>>vis(row,vector<int>(col,0));\\n                    if(solve(r,c,ind,row,col,board,vis,word))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nWhy is it failing this test case?\\nboard =[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\\nword =\"AAB\"\\nSomebody please enlighten me \\uD83D\\uDE4F\\uD83D\\uDE4F"
                    },
                    {
                        "username": "ManasT4",
                        "content": "can we solve this using BFS besides from backtracking ?"
                    },
                    {
                        "username": "Gudun",
                        "content": "EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n  bool solve(vector<vector<char>>& board,string word, int i, int j, int n ,int m ,int idx){\\n      \\n     if(idx==word.size())return true;\\n     \\n     if(i<0 ||j<0||i==n ||j==m ||word[idx]!=board[i][j]||board[i][j]==\\'*\\')return false;\\n     \\n     char temp= board[i][j];\\n     board[i][j]=\\'*\\';\\n     \\n      bool a=solve(board,word,i-1,j,n,m,idx+1);\\n      bool b=solve(board,word,i+1,j,n,m,idx+1);\\n      bool c=solve(board,word,i,j-1,n,m,idx+1);\\n      bool d=solve(board,word,i,j+1,n,m,idx+1);\\n      \\n      board[i][j]=temp;\\n      \\n      return a||b||c||d;\\n      \\n      \\n      \\n      \\n      \\n  }\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size();\\n       int m=board[0].size();\\n       \\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               if(board[i][j]==word[0] and solve(board,word,i,j,n,m,0))return true;\\n           }\\n       }\\n       return false;\\n    }\\n};"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Need to remember this template for backtracking questions. This, subsets I II, combination sum I II for sure"
                    },
                    {
                        "username": "alice_liu_w",
                        "content": "board =\\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\\nword =\\n\"ABCESEEEFS\"\\nFor this test case expected is true but i\\'m failing to see why. ABCESEEE reaches the last E which has no neighbouring F?\\n"
                    }
                ]
            },
            {
                "id": 1877860,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1873785,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1871913,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1858909,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1846172,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1837842,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1832796,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1810962,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1802218,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1795182,
                "content": [
                    {
                        "username": "tulusibrahim",
                        "content": "Has anyone failed on test `input=[[\"a\",\"b\"],[\"c\",\"d\"]]` and `word=\"abcd\"`? My code return it as true but the expected is false. I think it should return true as my code return because all letter is constructed from the input"
                    },
                    {
                        "username": "Mithlesh2103",
                        "content": "what about this testcase : board=[[\"a\",\"b\"],[\"c\",\"d\"]] , word=\"abcd\" ?\\ntrue or false?"
                    },
                    {
                        "username": "shubh404",
                        "content": "class Solution {\\n    bool dfs(int i, int j, vector<vector<int>> &vis, vector<vector<char>>& board, string word,  int index){\\n        // cout<<board[i][j]<<\" \"<<index<<endl;\\n        if(index==word.length()-1) return true;\\n\\n        vis[i][j]=1;\\n        int row[] ={-1, 0, 1, 0};\\n        int col[] = {0, 1, 0, -1};\\n        for(int it=0; it<4; it++){\\n            int nrow = i+row[it];\\n            int ncol = j+col[it];\\n\\n            if(nrow<board.size() && nrow>=0 && ncol < board[0].size()&&ncol>=0&&board[nrow][ncol]==word[index+1]&&vis[nrow][ncol]!=1){\\n                index++;\\n                dfs(nrow, ncol, vis, board, word, index);\\n                index--;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));\\n        for(int i=0; i<board.size();i++ ){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==word[0]){\\n                    if(dfs(i, j, vis, board, word, 0)){\\n                        cout<<\"hello\";\\n                         return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n**ERROR**\\nwhere i am doing wrong? I\\'ve no clue what to do with this. PLZ HELP ME TO FIX THIS PROB (:)  "
                    },
                    {
                        "username": "amitpandey00sept",
                        "content": "  `class Solution {\npublic:\n    bool Backtrack(int r,int c, string &s ,string word ,vector<vector<char>> &board, vector<vector<int>>&mark){\n        if(r<0||r>=board.size()){\n            return false;\n        }\n        if(c<0||c>=board[r].size()){\n            return false;\n        }\n        if(s.length()==word.length()){\n            if(word.compare(s)==0){\n                return true;\n            }\n            return false;\n        }\n        // s = s + board[r][c]; // adding the character;\n        if(mark[r][c]==0){\n            s.push_back(board[r][c]);\n            mark[r][c]=1;\n        }else{\n            return false;\n        }\n\n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call with character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call with character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call with character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call with character at [r][c]\n\n        s.pop_back(); // removing the character;\n        mark[r][c]= 0;\n        \n        if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c]\n        if(Backtrack(r,c+1,s,word,board,mark)==true) return true; // right call without character at [r][c]\n        if(Backtrack(r-1,c,s,word,board,mark)==true) return true; // up call without character at [r][c]\n        if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // down call without character at [r][c]\n        \n\n        // if not found return false;\n        return false;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        string s;\n        vector<vector<int>>mark(board.size(),vector<int>(board[0].size(),0));\n\n        return Backtrack(0,0,s,word,board,mark);\n\n    }\n}; `why this is not getting passed, every time it gives run-time error. Also if \" if(Backtrack(r,c-1,s,word,board,mark)==true) return true; // left call without character at [r][c] \" this conditions(all 4 without conditions) if these are changed to \"if(Backtrack(r+1,c,s,word,board,mark)==true) return true; // left call without character at [r][c] \" then it runs fine and accepts 2 cases, which are ABCCED && ABCB gets correct output but the 3rd case of \"SEE\" it gets false.                     can anyone please tell me why?"
                    },
                    {
                        "username": "ankush920",
                        "content": "TIME and SPACE optimized code with useful comment\\nankush920\\n-1\\na few seconds ago\\nIntuition\\ncheck all element for word\\n\\nApproach\\ndo backtrack on each element for searching the word\\n\\nComplexity\\nTime complexity:\\n0(mnL)\\n\\nSpace complexity:\\n0(L)\\n\\nCode\\nclass Solution {\\npublic:\\n   \\n  bool  help( int m ,int n , vector<vector<char>>&board ,string word , int i ,int j)\\n   {\\n       if(word.size()==0)\\n       {\\n            return true;\\n       }\\n        if(i<0 || j<0 || i>=m ||j>=n||word[0]==\\'#\\'|| word[0]!=board[i][j])\\n        {\\n             return false;\\n        }\\n\\n    char store =board[i][j];\\n\\n    board[i][j] =\\'#\\';\\n    \\n   \\nif( help( m,n,board ,word.substr(1) , i+1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j+1 )|| \\n    help( m,n,board ,word.substr(1) , i-1 ,j )||\\n    help( m,n,board ,word.substr(1) , i ,j-1) )\\n   {\\n        return true;\\n   }\\n   \\n   board[i][j]=store;\\n   return false;\\n    \\n   }\\n\\n\\n    bool ispresent( vector<vector<char>>&board ,string&word )\\n    {\\n\\n          int occurrences[128] = {0};\\n        \\n        for(vector v : board){\\n            for(char c : v)\\n                occurrences[c]++; \\n        }\\n        for(char c : word)\\n            if(--occurrences[c]<0){\\n                return false; \\n            }\\n            return true;\\n         \\n    }\\n       \\n    bool exist(vector<vector<char>>& board, string word) {\\n      int m= board.size();\\n      int n=board[0].size();\\n\\n\\n      if(m*n <word.size()) ///length of matrix should  be bigger than  matrix element\\n      {\\n           return false; \\n      }\\n\\n    if(!(ispresent(board,word))) // every element of word is present is board\\n    {\\n         return false ;\\n    }  \\n\\n    for( int i= 0 ; i<m ;i++)\\n    {\\n        for( int j=0 ;j<n ;j++)\\n        {\\n        if(help(m,n ,board, word ,i ,j )) ///checking for word which each element of matrix\\n        {\\n             return true ;\\n        }\\n        }\\n    }\\n\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "prabaljainn",
                        "content": "# Why my code giving TLE ? C++ Backtracking\\n\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\nset<pair<int,int>> s;\\n    int n, m;\\n    bool flag = false;\\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y) {\\n        if(x<0 or y<0 or x >= n or y >= m)\\n            return false;\\n        return true;\\n    }\\n    void rec(int cur_x, int cur_y, int level, vector<vector<char>> &board, string &word) {\\n        if(level == word.size()-1) {\\n            flag = true;\\n        }\\n        for(int i=0; i<4; i++){\\n            int x = cur_x +dx[i];\\n            int y = cur_y+dy[i];\\n\\n            if(check(x,y) and board[x][y]==word[level+1]\\n               ){\\n\\n                if(s.find(make_pair(x, y))==s.end()){\\n                    s.insert(make_pair(x, y));\\n                    rec(x,y,level+1, board, word);\\n                    s.erase(make_pair(x, y));\\n                    }\\n            }\\n        }\\n    }\\n    bool exist(vector<vector<char>> &board, string word) {\\n        n = board.size();\\n        if(n==0)\\n        return false;\\n        m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                if(word[0]==board[i][j] and !flag){\\n                    s.insert(make_pair(i, j));\\n                    rec(i, j, 0, board, word);            \\n                    s.clear();\\n                }\\n            }\\n        }\\n        return flag; \\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "mehrak205",
                        "content": "can anyone correct my code..? please help.\\n\\n\\ncode-->\\n\\nclass Solution {\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int n=board.size()-1;\\n        int m=board[0].size();\\n        sort(board.begin(),board.end());\\n        sort(word.begin(),word.end());\\n        vector<int> visited(n*m,0);\\n        vector<char> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans.push_back(board[i][j]);\\n            }\\n        }\\n        int k=word.size()-1;\\n        while(k>=0){\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==word[k]&& visited[i]==0){\\n                word.pop_back();\\n                visited[i]=1;\\n                break;\\n                }\\n                else\\n                continue;\\n    \\n            }\\n            k--;\\n\\n        }\\n       \\n       return word.empty();\\n    }\\n};"
                    },
                    {
                        "username": "KingLewi",
                        "content": "I'm pretty sure this problem is actually NP-hard. Hamiltonian path on general grid graphs is [NP-hard](https://epubs.siam.org/doi/10.1137/0211056).\n\nReduction example:\nG=\ns n n n\n  n n n\nt n n\n\ngets reduced to:\n\nboard= \n s n n n\nn n n x\nt n n x\nword = snnnnnnnnt\n\nThere's a hamiltonian path in G if and only if snnnnnnnnt appears in board.\n\nAll the solutions I've seen have been exponential. The issue is that you can't reuse letters. If you could this would be fairly trivial to solve in polynomial time."
                    },
                    {
                        "username": "seanajohnston85",
                        "content": "While I haven't submitted a solution and failed test cases yet, I'm guessing solutions needs to guard against reusing the same postion. Illustrated by example, say our board looks like:\n\nA B C\nD E F\nG H I\n\nAnd the tartet is ADEBA. I doubt you are able to reuse the A since it's already in the path, so the target doesn't exist in this board. The problem is compounded when letters can duplicate in the board, for Instance swap out C for A in the above board.\n\nA B A\nD E F\nG H I\n\nAnd now the target ADEBA does exist. So keeping track of wether or not a position is already included in the path probably needs to be baked into the solution."
                    },
                    {
                        "username": "AnushkaZ_",
                        "content": "Can anyone tell me why my code is not working.\\n\\n `your inline code...your inline code...`//{ Driver Code Starts\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n// } Driver Code Ends\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int idx,vector<vector<char>> & board, string & word,vector<vector<int>> & vis\\n    ,int del_row[],int del_col[]){\\n        \\n        if(idx == word.size()){\\n            return true;\\n        } \\n        vis[i][j]=1;\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int k=0;k< 4 ;k++){\\n            int row = i + del_row[k];\\n            int col = j + del_col[k];\\n            if( row >= 0 && col >= 0 && row < n && col < m && vis[i][j]== 0 &&\\n            board[row][col] == word[idx]){\\n                if(dfs(row,col,idx+1,board,word,vis,del_row,del_col)){\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[i][j] =0;\\n        return false;\\n        \\n    }\\n    bool isWordExist(vector<vector<char>>& board, string word) {\\n        // Code here\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n    \\n        int del_row [] = {-1,+1,0,0};\\n        int del_col [] = {0,0,-1,+1};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == word[0] && !vis[i][j]){\\n                    if(dfs(i,j,1,board,word,vis,del_row,del_col)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n   "
                    }
                ]
            },
            {
                "id": 1793344,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1780978,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1754134,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1749991,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1719807,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1716975,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1705157,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1703370,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1695221,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            },
            {
                "id": 1695168,
                "content": [
                    {
                        "username": "mannnish_",
                        "content": "what is wrong with this solution, it is failing a sample test case\\n```\\n    bool solve(int n, int i, int j, vvc& b, string& w){\\n        if(n == w.size())    return true;\\n        int r = b.size();\\n        int c = b[0].size();\\n\\n        // for this i,j go (t,b,r,l) and check if n is equal or not\\n        if( i+1<r and j<c && b[i+1][j]==w[n] && solve(n+1,i+1,j,b,w))\\n            return true;\\n        if( i-1>=0 and j<c && b[i-1][j]==w[n] && solve(n+1,i-1,j,b,w))\\n            return true;\\n        if( i<r and j+1<c && b[i][j+1]==w[n] && solve(n+1,i,j+1,b,w))\\n            return true;\\n        if( i<r and j-1>=0 && b[i][j-1]==w[n] && solve(n+1,i,j-1,b,w))\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool exist(vector<vector<char>>& board, string word) {\\n        int r = board.size();\\n        int c = board[0].size();\\n        for(int i=0 ; i<r ; ++i){\\n            for(int j=0 ; j<c; ++j){\\n                if( board[i][j] == word[0] and solve(1, i, j, board, word))\\n                    return true;    \\n            }\\n        }    \\n        return false;\\n    }\\n```"
                    },
                    {
                        "username": "Its_manali",
                        "content": "Anyone solved in BFS ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user4419A",
                        "content": "Can\\'t we use trie data structure in solving this type of question."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "If you are using O(M*n*k) DFS approach, remember to backtrack if you aren't able to find a solution, or else you might miss some cases where the character is on another path.\n\nA good test case for you : \n[[\"A\", \"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\""
                    },
                    {
                        "username": "davidtn",
                        "content": "When I passed in the index instead of the whole current string, speed went from 20 to 80 percentile.\\n\\nString concatenation is slow af. If Java, using StringBuilder append may help"
                    },
                    {
                        "username": "user4400",
                        "content": "Hi, not sure if anyone else has the same issue or is this an internal bug? \n\nWhen I finished coding and tried to submit. Sometimes it'll pass, but sometimes it'll be TLE for the same code. When I directly submit the solution, it'll be fine. However, when I run the test firstly and then submit the code, it'll show TLE. \n\nI attached my code here. Anyone has the same issue? \n```\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        row = len(board)\n        col = len(board[0])\n        flag = False\n        for i in range(row):\n            for j in range(col):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False\n\n    def dfs(self, board, i, j, word):\n        if len(word) == 0:\n            return True\n\n        if i < 0 or j < 0 or i > len(board) - 1 or j > len(board[0]) - 1 or board[i][j] != word[0]:\n            return False\n        \n        save = board[i][j]\n        board[i][j] = '*'\n        temp = self.dfs(board, i-1, j, word[1:]) or self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i, j-1, word[1:]) or self.dfs(board, i, j+1, word[1:])\n        board[i][j] = save\n        return temp\n\n```"
                    },
                    {
                        "username": "drecep",
                        "content": "   \\ni have a non recursive solution but i could\\'nt find a way to solve [[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]] word= \"AAB\" if there is more than one same char this code does\\'nt work\\n\\n`class Solution {\\n    public boolean exist(char[][] board, String word) {\\n         int a=0; boolean var=false; \\n\\t        int c=board[0].length;\\n\\t        int b=board.length;\\n\\t        int k=word.length(); \\n\\t     int x=0;int y=0; if(b*c<k){ return false; }\\n\\t\\n\\t       if(k==1&&word.charAt(0)==board[x][y]) return true;\\n           if(k==1&&word.charAt(0)!=board[x][y]) return false;\\n\\t      \\n    for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                       if(word.charAt(0)==board[i][j]){board[i][j]=Integer.toString(1).charAt(0);}  \\n\\n                }}\\n                a=1;\\n    while(a<k){\\n        \\n       \\n         for(int i=0; i<board.length;i++){\\n                for(int j=0;j<board[0].length;j++){\\n                        \\n                    if(board[i][j]==word.charAt(a)){\\n               if(i>0&&board[i-1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(i<b-1&&board[i+1][j]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j>0&&board[i][j-1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n               if(j<c-1&&board[i][j+1]-\\'0\\'==a) { board[i][j]=Integer.toString(a+1).charAt(0); }\\n                    }\\n               if(board[i][j]-\\'0\\'==k) var=true;\\n                }}\\n        \\n     a++;\\n    }\\n\\t   return var;\\n}\\n}`"
                    },
                    {
                        "username": "matthew-cheney",
                        "content": "**Hint if you're getting TLE on your DFS:**\n(see below)\n.\n.\n.\n.\n.\n.\n.\n.\n\nReverse the word before starting your DFS.\n\nThe test cases happen to favor processing the word backwards. In an ideal world any solution with the correct order of complexity would pass, but that is not the case with this problem."
                    },
                    {
                        "username": "KareemSarhan",
                        "content": "Can anyone Tell me how to fix this \nit doesn't pass this test case\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"E\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCESEEEFS\"\n```import java.util.Arrays;\n\nclass Solution {\n    char [] word;\n    int wordLen,len1,len2;\n    char [] [] board;\n    public boolean check(int i , int j ,boolean [] [] passed,int charInd)\n    {\n        if(charInd==wordLen)\n            return true;\n        if(i<0 || i >= len1 || j<0 || j >= len2)\n            return false;\n        if(passed[i][j])\n            return false;\n        if (board[i][j]!=word[charInd])\n            return false;\n        passed[i][j]=true;\n        System.out.println(Arrays.deepToString(passed));\n        charInd++;\n        return check(i+1,j,passed.clone(),charInd) ||check(i-1,j,passed.clone(),charInd)\n                ||check(i,j+1,passed.clone(),charInd)||check(i,j-1,passed.clone(),charInd);\n    }\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        len1 = this.board.length;\n        len2 = this.board[0].length;\n        this.word = word.toCharArray();\n        wordLen=word.length();\n        for (int i = 0; i < len1; i++) {\n            for (int j = 0; j < len2; j++) {\n                if(check(i,j,new boolean[len1][len2],0))\n                    return true;\n                System.out.println(\"_______________\");\n            }\n        }\n        return false;\n    }\n}\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Number",
        "question_content": "<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p>\n\n<p>Since the result may be very large, so you need to return a string instead of an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2]\n<strong>Output:</strong> &quot;210&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,30,34,5,9]\n<strong>Output:</strong> &quot;9534330&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 53157,
                "title": "a-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            vector<string> arr;\\n            for(auto i:num)\\n                arr.push_back(to_string(i));\\n            sort(begin(arr), end(arr), [](string &s1, string &s2){ return s1+s2>s2+s1; });\\n            string res;\\n            for(auto s:arr)\\n                res+=s;\\n            while(res[0]=='0' && res.length()>1)\\n                res.erase(0,1);\\n            return  res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            vector<string> arr;\\n            for(auto i:num)\\n                arr.push_back(to_string(i));\\n            sort(begin(arr), end(arr), [](string &s1, string &s2){ return s1+s2>s2+s1; }",
                "codeTag": "Java"
            },
            {
                "id": 53158,
                "title": "my-java-solution-to-share",
                "content": "The idea here is basically implement a String comparator to decide which String  should come first during concatenation. Because when you have 2 numbers (let\\'s convert them into String), you\\'ll face only 2 cases:\\nFor example:\\n```\\nString s1 = \"9\";\\nString s2 = \"31\";\\n\\nString case1 =  s1 + s2; // 931\\nString case2 = s2 + s1; // 319\\n\\n```\\nApparently, case1 is greater than case2 in terms of value.\\nSo, we should always put s1 in front of s2.\\n\\nI have received many good suggestions from you in this discussion. Below is the modified version of codes based on your suggestions:\\n\\n```\\npublic class Solution {\\n     public String largestNumber(int[] num) {\\n\\t\\tif(num == null || num.length == 0)\\n\\t\\t    return \"\";\\n\\t\\t\\n\\t\\t// Convert int array to String array, so we can sort later on\\n\\t\\tString[] s_num = new String[num.length];\\n\\t\\tfor(int i = 0; i < num.length; i++)\\n\\t\\t    s_num[i] = String.valueOf(num[i]);\\n\\t\\t\\t\\n\\t\\t// Comparator to decide which string should come first in concatenation\\n\\t\\tComparator<String> comp = new Comparator<String>(){\\n\\t\\t    @Override\\n\\t\\t    public int compare(String str1, String str2){\\n\\t\\t        String s1 = str1 + str2;\\n\\t\\t\\t\\tString s2 = str2 + str1;\\n\\t\\t\\t\\treturn s2.compareTo(s1); // reverse order here, so we can do append() later\\n\\t\\t    }\\n\\t     };\\n\\t\\t\\n\\t\\tArrays.sort(s_num, comp);\\n\\t\\t// An extreme edge case by lc, say you have only a bunch of 0 in your int array\\n\\t\\tif(s_num[0].charAt(0) == \\'0\\')\\n\\t\\t\\treturn \"0\";\\n            \\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor(String s: s_num)\\n\\t        sb.append(s);\\n\\t\\t\\n\\t\\treturn sb.toString();\\n\\t\\t\\n\\t}\\n}\\n```\\n\\nIn terms of Time and Space Complexity:\\nLet\\'s assume:\\nthe length of input array is `n`,\\naverage length of Strings in s_num is `k`,\\nThen, compare 2 strings will take `O(k)`.\\nSorting will take `O(nlgn)`\\nAppending to StringBuilder takes `O(n)`.\\n\\n*Updates:* according to how merge sort time complexity is calculated from this [post](https://cs.stackexchange.com/questions/54525/how-to-calculate-the-mergesort-time-complexity)\\nWe still need `lg(n)` times of operations, but the comparison at the leaf node takes `O(k)` instead of `O(1)`\\nThus, the total will be `O(n*k*lgn) + O(n) = O(nklgn).`\\n\\nSpace is pretty straight forward: `O(n)`.",
                "solutionTags": [],
                "code": "```\\nString s1 = \"9\";\\nString s2 = \"31\";\\n\\nString case1 =  s1 + s2; // 931\\nString case2 = s2 + s1; // 319\\n\\n```\n```\\npublic class Solution {\\n     public String largestNumber(int[] num) {\\n\\t\\tif(num == null || num.length == 0)\\n\\t\\t    return \"\";\\n\\t\\t\\n\\t\\t// Convert int array to String array, so we can sort later on\\n\\t\\tString[] s_num = new String[num.length];\\n\\t\\tfor(int i = 0; i < num.length; i++)\\n\\t\\t    s_num[i] = String.valueOf(num[i]);\\n\\t\\t\\t\\n\\t\\t// Comparator to decide which string should come first in concatenation\\n\\t\\tComparator<String> comp = new Comparator<String>(){\\n\\t\\t    @Override\\n\\t\\t    public int compare(String str1, String str2){\\n\\t\\t        String s1 = str1 + str2;\\n\\t\\t\\t\\tString s2 = str2 + str1;\\n\\t\\t\\t\\treturn s2.compareTo(s1); // reverse order here, so we can do append() later\\n\\t\\t    }\\n\\t     };\\n\\t\\t\\n\\t\\tArrays.sort(s_num, comp);\\n\\t\\t// An extreme edge case by lc, say you have only a bunch of 0 in your int array\\n\\t\\tif(s_num[0].charAt(0) == \\'0\\')\\n\\t\\t\\treturn \"0\";\\n            \\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor(String s: s_num)\\n\\t        sb.append(s);\\n\\t\\t\\n\\t\\treturn sb.toString();\\n\\t\\t\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53298,
                "title": "python-different-solutions-bubble-insertion-selection-merge-quick-sorts",
                "content": "    \\n    # build-in function\\n    def largestNumber1(self, nums):\\n        if not any(nums):\\n            return \"0\"\\n        return \"\".join(sorted(map(str, nums), cmp=lambda n1, n2: -1 if n1+n2>n2+n1 else (1 if n1+n2<n2+n1 else 0)))\\n        \\n    # bubble sort\\n    def largestNumber2(self, nums):\\n        for i in xrange(len(nums), 0, -1):\\n            for j in xrange(i-1):\\n                if not self.compare(nums[j], nums[j+1]):\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return str(int(\"\".join(map(str, nums))))\\n        \\n    def compare(self, n1, n2):\\n        return str(n1) + str(n2) > str(n2) + str(n1)\\n        \\n    # selection sort\\n    def largestNumber3(self, nums):\\n        for i in xrange(len(nums), 0, -1):\\n            tmp = 0\\n            for j in xrange(i):\\n                if not self.compare(nums[j], nums[tmp]):\\n                    tmp = j\\n            nums[tmp], nums[i-1] = nums[i-1], nums[tmp]\\n        return str(int(\"\".join(map(str, nums))))\\n        \\n    # insertion sort\\n    def largestNumber4(self, nums):\\n        for i in xrange(len(nums)):\\n            pos, cur = i, nums[i]\\n            while pos > 0 and not self.compare(nums[pos-1], cur):\\n                nums[pos] = nums[pos-1]  # move one-step forward\\n                pos -= 1\\n            nums[pos] = cur\\n        return str(int(\"\".join(map(str, nums))))\\n    \\n    # merge sort        \\n    def largestNumber5(self, nums):\\n        nums = self.mergeSort(nums, 0, len(nums)-1)\\n        return str(int(\"\".join(map(str, nums))))\\n        \\n    def mergeSort(self, nums, l, r):\\n        if l > r:\\n            return \\n        if l == r:\\n            return [nums[l]]\\n        mid = l + (r-l)//2\\n        left = self.mergeSort(nums, l, mid)\\n        right = self.mergeSort(nums, mid+1, r)\\n        return self.merge(left, right)\\n        \\n    def merge(self, l1, l2):\\n        res, i, j = [], 0, 0\\n        while i < len(l1) and j < len(l2):\\n            if not self.compare(l1[i], l2[j]):\\n                res.append(l2[j])\\n                j += 1\\n            else:\\n                res.append(l1[i])\\n                i += 1\\n        res.extend(l1[i:] or l2[j:])\\n        return res\\n        \\n    # quick sort, in-place\\n    def largestNumber(self, nums):\\n        self.quickSort(nums, 0, len(nums)-1)\\n        return str(int(\"\".join(map(str, nums)))) \\n    \\n    def quickSort(self, nums, l, r):\\n        if l >= r:\\n            return \\n        pos = self.partition(nums, l, r)\\n        self.quickSort(nums, l, pos-1)\\n        self.quickSort(nums, pos+1, r)\\n        \\n    def partition(self, nums, l, r):\\n        low = l\\n        while l < r:\\n            if self.compare(nums[l], nums[r]):\\n                nums[l], nums[low] = nums[low], nums[l]\\n                low += 1\\n            l += 1\\n        nums[low], nums[r] = nums[r], nums[low]\\n        return low",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "    \\n    # build-in function\\n    def largestNumber1(self, nums):\\n        if not any(nums):\\n            return \"0\"\\n        return \"\".join(sorted(map(str, nums), cmp=lambda n1, n2: -1 if n1+n2>n2+n1 else (1 if n1+n2<n2+n1 else 0)))\\n        \\n    # bubble sort\\n    def largestNumber2(self, nums):\\n        for i in xrange(len(nums), 0, -1):\\n            for j in xrange(i-1):\\n                if not self.compare(nums[j], nums[j+1]):\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return str(int(\"\".join(map(str, nums))))\\n        \\n    def compare(self, n1, n2):\\n        return str(n1) + str(n2) > str(n2) + str(n1)\\n        \\n    # selection sort\\n    def largestNumber3(self, nums):\\n        for i in xrange(len(nums), 0, -1):\\n            tmp = 0\\n            for j in xrange(i):\\n                if not self.compare(nums[j], nums[tmp]):\\n                    tmp = j\\n            nums[tmp], nums[i-1] = nums[i-1], nums[tmp]\\n        return str(int(\"\".join(map(str, nums))))\\n        \\n    # insertion sort\\n    def largestNumber4(self, nums):\\n        for i in xrange(len(nums)):\\n            pos, cur = i, nums[i]\\n            while pos > 0 and not self.compare(nums[pos-1], cur):\\n                nums[pos] = nums[pos-1]  # move one-step forward\\n                pos -= 1\\n            nums[pos] = cur\\n        return str(int(\"\".join(map(str, nums))))\\n    \\n    # merge sort        \\n    def largestNumber5(self, nums):\\n        nums = self.mergeSort(nums, 0, len(nums)-1)\\n        return str(int(\"\".join(map(str, nums))))\\n        \\n    def mergeSort(self, nums, l, r):\\n        if l > r:\\n            return \\n        if l == r:\\n            return [nums[l]]\\n        mid = l + (r-l)//2\\n        left = self.mergeSort(nums, l, mid)\\n        right = self.mergeSort(nums, mid+1, r)\\n        return self.merge(left, right)\\n        \\n    def merge(self, l1, l2):\\n        res, i, j = [], 0, 0\\n        while i < len(l1) and j < len(l2):\\n            if not self.compare(l1[i], l2[j]):\\n                res.append(l2[j])\\n                j += 1\\n            else:\\n                res.append(l1[i])\\n                i += 1\\n        res.extend(l1[i:] or l2[j:])\\n        return res\\n        \\n    # quick sort, in-place\\n    def largestNumber(self, nums):\\n        self.quickSort(nums, 0, len(nums)-1)\\n        return str(int(\"\".join(map(str, nums)))) \\n    \\n    def quickSort(self, nums, l, r):\\n        if l >= r:\\n            return \\n        pos = self.partition(nums, l, r)\\n        self.quickSort(nums, l, pos-1)\\n        self.quickSort(nums, pos+1, r)\\n        \\n    def partition(self, nums, l, r):\\n        low = l\\n        while l < r:\\n            if self.compare(nums[l], nums[r]):\\n                nums[l], nums[low] = nums[low], nums[l]\\n                low += 1\\n            l += 1\\n        nums[low], nums[r] = nums[r], nums[low]\\n        return low",
                "codeTag": "Python3"
            },
            {
                "id": 53162,
                "title": "my-3-lines-code-in-java-and-python",
                "content": "The logic is pretty straightforward. Just compare number by convert it to string.\\n\\nThanks for Java 8, it makes code beautiful.\\n\\nJava:\\n\\n    public class Solution {\\n        public String largestNumber(int[] num) {\\n            String[] array = Arrays.stream(num).mapToObj(String::valueOf).toArray(String[]::new);\\n            Arrays.sort(array, (String s1, String s2) -> (s2 + s1).compareTo(s1 + s2));\\n            return Arrays.stream(array).reduce((x, y) -> x.equals(\"0\") ? y : x + y).get();\\n        }\\n    }\\n\\nPython:\\n\\n    class Solution:\\n        # @param num, a list of integers\\n        # @return a string\\n        def largestNumber(self, num):\\n            num = [str(x) for x in num]\\n            num.sort(cmp=lambda x, y: cmp(y+x, x+y))\\n            return ''.join(num).lstrip('0') or '0'",
                "solutionTags": [],
                "code": "class Solution {\\n        public String largestNumber(int[] num) {\\n            String[] array = Arrays.stream(num).mapToObj(String::valueOf).toArray(String[]::new);\\n            Arrays.sort(array, (String s1, String s2) -> (s2 + s1).compareTo(s1 + s2));\\n            return Arrays.stream(array).reduce((x, y) -> x.equals(\"0\") ? y : x + y).get();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 213599,
                "title": "thinking-process-in-python",
                "content": "\\n> If we use the default string comparator of sort(), and concatenate sorted strings,\\n> cases as [\\'3\\', \\'30\\'] will fail for \\'3\\' < \\'30\\' but we want \\'330\\' rather than \\'303\\'.\\n> If we use customized `cmp_func` such that string x is smaller than string y if x + y < y + x, \\'30\\' < \\'3\\', we will get \\'330\\' at last.\\n****\\n```\\nfrom functools import cmp_to_key\\n\\nclass Solution:        \\n    def largestNumber(self, nums):\\n        \\n        def cmp_func(x, y):\\n            \"\"\"Sorted by value of concatenated string increasingly.\"\"\"\\n            if x + y > y + x:\\n                return 1\\n            elif x == y:\\n                return 0\\n            else:\\n                return -1\\n            \\n        # Build nums contains all numbers in the String format.\\n        nums = [str(num) for num in nums]\\n        \\n        # Sort nums by cmp_func decreasingly.\\n        nums.sort(key = cmp_to_key(cmp_func), reverse = True)\\n        \\n        # Remove leading 0s, if empty return \\'0\\'.\\n        return \\'\\'.join(nums).lstrip(\\'0\\') or \\'0\\'\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nfrom functools import cmp_to_key\\n\\nclass Solution:        \\n    def largestNumber(self, nums):\\n        \\n        def cmp_func(x, y):\\n            \"\"\"Sorted by value of concatenated string increasingly.\"\"\"\\n            if x + y > y + x:\\n                return 1\\n            elif x == y:\\n                return 0\\n            else:\\n                return -1\\n            \\n        # Build nums contains all numbers in the String format.\\n        nums = [str(num) for num in nums]\\n        \\n        # Sort nums by cmp_func decreasingly.\\n        nums.sort(key = cmp_to_key(cmp_func), reverse = True)\\n        \\n        # Remove leading 0s, if empty return \\'0\\'.\\n        return \\'\\'.join(nums).lstrip(\\'0\\') or \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53195,
                "title": "mathematical-proof-of-correctness-of-sorting-method",
                "content": "    string largestNumber(vector<int>& nums) {\\n            vector<string> vs;\\n            string s=\"\";\\n            for(int &num:nums)  vs.push_back(to_string(num));\\n            sort(vs.begin(),vs.end(),[](string a,string b){return a+b>b+a;});\\n            if(vs[0][0]=='0') return \"0\"; //deal with all \"0\" value\\n            for(string & ss:vs)  s+=ss;\\n            return s;\\n        }\\n\\n\\nWhy does this solution work?\\n\\nFirst, we need to show the comparator works, or the array is sortable. Meaning if A comes before B and B comes before C, then A must comes before C.\\n\\nNext, we must prove after sorting, by concatenating the array,we get the largest number.\\n\\nThe first proof is by @19thhell.\\n\\nLet A, B, C be the integer given. To concatenate A and B into AB, we need to know how many digits are there in B, then multiply power of 10 with A, add B to the result. Example: 12312 = 123 * 100 + 12. The number of digits in B is lgB + 1, therefore we need to multiply A with 10^(lgB + 1), then add the result with B to get AB. Now we can start our proof.\\n\\n    Proof:\\n    \\n        Let us define f(X) = 10^(lgX + 1), then XY = f(Y)X + Y\\n    \\n        If AB <= BA, then we have\\n        f(B)A + B <= f(A)B + A\\n        (f(B) - 1)A <= (f(A) - 1)B\\n        that is\\n        A <= B\\xb7(f(A) - 1) / (f(B) - 1)   (1)\\n    \\n        If BC <= CB, then we have\\n        f(C)B + C <= f(B)C + B\\n        (f(C) - 1)B <= (f(B) - 1)C\\n        that is\\n        B <= C\\xb7(f(B) - 1) / (f(C) - 1)   (2)\\n    \\n        Combine (1), (2), we have\\n        A <= C\\xb7(f(A) - 1) / (f(C) - 1)\\n        (f(C) - 1)A <= (f(A) - 1)C\\n        f(C)A + C <= f(A)C + A\\n        AC <= CA\\n\\nThe second proof:\\n\\nFirst, some properties. (IF THE IMAGE BELOW IS NOT SHOWN PROPERLY, OPEN IT IN ANOTHER WINDOW OR DOWNLOAD IT) \\n![enter image description here][1]\\n\\n\\n![enter image description here][2]\\n\\n\\n  [1]: https://i.imgsafe.org/8de935e.png\\n  [2]: https://i.imgsafe.org/90816ce.png",
                "solutionTags": [],
                "code": "    string largestNumber(vector<int>& nums) {\\n            vector<string> vs;\\n            string s=\"\";\\n            for(int &num:nums)  vs.push_back(to_string(num));\\n            sort(vs.begin(),vs.end(),[](string a,string b){return a+b>b+a;});\\n            if(vs[0][0]=='0') return \"0\"; //deal with all \"0\" value\\n            for(string & ss:vs)  s+=ss;\\n            return s;\\n        }\\n\\n\\nWhy does this solution work?\\n\\nFirst, we need to show the comparator works, or the array is sortable. Meaning if A comes before B and B comes before C, then A must comes before C.\\n\\nNext, we must prove after sorting, by concatenating the array,we get the largest number.\\n\\nThe first proof is by @19thhell.\\n\\nLet A, B, C be the integer given. To concatenate A and B into AB, we need to know how many digits are there in B, then multiply power of 10 with A, add B to the result. Example: 12312 = 123 * 100 + 12. The number of digits in B is lgB + 1, therefore we need to multiply A with 10^(lgB + 1), then add the result with B to get AB. Now we can start our proof.\\n\\n    Proof:\\n    \\n        Let us define f(X) = 10^(lgX + 1), then XY = f(Y)X + Y\\n    \\n        If AB <= BA, then we have\\n        f(B)A + B <= f(A)B + A\\n        (f(B) - 1)A <= (f(A) - 1)B\\n        that is\\n        A <= B\\xb7(f(A) - 1) / (f(B) - 1)   (1)\\n    \\n        If BC <= CB, then we have\\n        f(C)B + C <= f(B)C + B\\n        (f(C) - 1)B <= (f(B) - 1)C\\n        that is\\n        B <= C\\xb7(f(B) - 1) / (f(C) - 1)   (2)\\n    \\n        Combine (1), (2), we have\\n        A <= C\\xb7(f(A) - 1) / (f(C) - 1)\\n        (f(C) - 1)A <= (f(A) - 1)C\\n        f(C)A + C <= f(A)C + A\\n        AC <= CA\\n\\nThe second proof:\\n\\nFirst, some properties. (IF THE IMAGE BELOW IS NOT SHOWN PROPERLY, OPEN IT IN ANOTHER WINDOW OR DOWNLOAD IT) \\n![enter image description here][1]\\n\\n\\n![enter image description here][2]\\n\\n\\n  [1]: https://i.imgsafe.org/8de935e.png\\n  [2]: https://i.imgsafe.org/90816ce.png",
                "codeTag": "Unknown"
            },
            {
                "id": 863453,
                "title": "beats-98-60-easy-understanding-c",
                "content": "```\\n\\nbool compare(string a,string b){\\n    return a+b > b+a;\\n}\\n\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n\\t\\n        vector<string> container;\\n\\t\\t\\n        for(int i : nums)  container.push_back(to_string(i));\\n        \\n        sort(container.begin(),container.end(),compare);\\n        \\n        string result;\\n        \\n        for(int i=0;i<container.size();i++)  result+=container[i];\\n        \\n        return result[0]==\\'0\\'? \"0\" : result;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\nbool compare(string a,string b){\\n    return a+b > b+a;\\n}\\n\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n\\t\\n        vector<string> container;\\n\\t\\t\\n        for(int i : nums)  container.push_back(to_string(i));\\n        \\n        sort(container.begin(),container.end(),compare);\\n        \\n        string result;\\n        \\n        for(int i=0;i<container.size();i++)  result+=container[i];\\n        \\n        return result[0]==\\'0\\'? \"0\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53270,
                "title": "python-simple-solution-in-4-lines",
                "content": "It's all about comparison . We define a func that compares two strings a ,b. we consider a bigger than b if a+b > b+a . then we sort the numbers and concatenate them .\\n\\n\\n    class Solution:\\n    # @param num, a list of integers\\n    # @return a string\\n    def largestNumber(self, num):\\n        comp=lambda a,b:1 if a+b>b+a else -1 if a+b<b+a else 0\\n        num=map(str,num)\\n        num.sort(cmp=comp,reverse=True)\\n        return str(int(\"\".join(num)))\\n\\n\\n**UPDATE**\\n\\nMore explanation \\n\\n1-we define a function that compares two string (a,b) . we consider a bigger than b if a+b>b+a\\nfor example : (a=\"2\",b=\"11\") a is bigger than b because \"211\" >\"112\"\\n\\n2-convert all elements of the list from int to string\\n\\n3-sort the list descendingly using the comparing function we defined\\nfor example sorting this list [\"2\",\"11\",\"13\"] using the function defined in step 1 would produce [\"2\",\"13\",\"11\"]\\n\\n4-we concatatenate the list \"21311\"",
                "solutionTags": [],
                "code": "It's all about comparison . We define a func that compares two strings a ,b. we consider a bigger than b if a+b > b+a . then we sort the numbers and concatenate them .\\n\\n\\n    class Solution:\\n    # @param num, a list of integers\\n    # @return a string\\n    def largestNumber(self, num):\\n        comp=lambda a,b:1 if a+b>b+a else -1 if a+b<b+a else 0\\n        num=map(str,num)\\n        num.sort(cmp=comp,reverse=True)\\n        return str(int(\"\".join(num)))\\n\\n\\n**UPDATE**\\n\\nMore explanation \\n\\n1-we define a function that compares two string (a,b) . we consider a bigger than b if a+b>b+a\\nfor example : (a=\"2\",b=\"11\") a is bigger than b because \"211\" >\"112\"\\n\\n2-convert all elements of the list from int to string\\n\\n3-sort the list descendingly using the comparing function we defined\\nfor example sorting this list [\"2\",\"11\",\"13\"] using the function defined in step 1 would produce [\"2\",\"13\",\"11\"]\\n\\n4-we concatatenate the list \"21311\"",
                "codeTag": "Java"
            },
            {
                "id": 53160,
                "title": "share-a-short-code-in-c",
                "content": "    class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            sort(num.begin(), num.end(), [](int a, int b){\\n                return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n            });\\n            string ans;\\n            for(int i=0; i<num.size(); i++){\\n                ans += to_string(num[i]);\\n            }\\n            return ans[0]=='0' ? \"0\" : ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            sort(num.begin(), num.end(), [](int a, int b){\\n                return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 53159,
                "title": "share-my-fast-java-solution-beat-98-64",
                "content": "    public class Solution {\\n        public String largestNumber(int[] nums) {\\n            if (nums == null || nums.length == 0) return \"\";\\n            String[] strs = new String[nums.length];\\n            for (int i = 0; i < nums.length; i++) {\\n                strs[i] = nums[i]+\"\";\\n            }\\n            Arrays.sort(strs, new Comparator<String>() {\\n                @Override\\n                public int compare(String i, String j) {\\n                    String s1 = i+j;\\n                    String s2 = j+i;\\n                    return s1.compareTo(s2);\\n                }\\n            });\\n            if (strs[strs.length-1].charAt(0) == '0') return \"0\";\\n            String res = new String();\\n            for (int i = 0; i < strs.length; i++) {\\n                res = strs[i]+res;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String largestNumber(int[] nums) {\\n            if (nums == null || nums.length == 0) return \"\";\\n            String[] strs = new String[nums.length];\\n            for (int i = 0; i < nums.length; i++) {\\n                strs[i] = nums[i]+\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 53331,
                "title": "simple-10-line-c-solution",
                "content": " \\n\\n     class Solution {\\n        public:\\n            string largestNumber(vector<int>& nums) {\\n                string ret;\\n                sort(nums.begin(),nums.end(),\\n                    [](const int &m,const int&n){\\n                        return to_string(m)+to_string(n)>to_string(n)+to_string(m);});\\n                for(int i=0;i<nums.size();++i){\\n                    ret+=to_string(nums[i]);\\n                }\\n                if(ret[0]=='0') //for the case nums are all zeros\\n                    return \"0\";\\n                return ret;\\n            }  \\n        };",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\n        public:\\n            string largestNumber(vector<int>& nums) {\\n                string ret;\\n                sort(nums.begin(),nums.end(),\\n                    [](const int &m,const int&n){\\n                        return to_string(m)+to_string(n)>to_string(n)+to_string(m);}",
                "codeTag": "Java"
            },
            {
                "id": 863489,
                "title": "python-2-lines-solution-using-sort-explained",
                "content": "Note, that we need to somehow sort our data, but be carefull about it: if we have `3`, `32` and `31`, then we need to choose `3` as the first element. However if we have `3`, `34` and `32`, then we need to chose `34` as the first element. So, let us for each two numbers `x` and `y` decide which one is better: we need to compare `xy` and `yx` and choose the best one: we work with `x` and `y` as with strings: for example for `x = 3` and `y = 32`, we need to compare `xy = 332` and `yx = 323`. Also it can be shown that if `xy >= yx` and `yz >= zy`, then `xz >= zx`, this means that we have transitivity property, and this is enough to ensure that our sort is consistent: https://en.wikipedia.org/wiki/Comparison_sort \\n\\n**Complexity**: time complexity is `O(n log n)`, if we assume that we can make comparison in constant time. In practise, we use strings and compare them, so complexity will be ineed `O(1)`. Space complexity is `O(n)` to keep sorted numbers.\\n\\n**Note** I use `cmp_to_key` function from `functools` library, which is imported in leetcode already. Also in the end we can have results like `00`, which we need to make `0`, so we use `str(int(...))` trick.\\n\\n```\\nclass Solution:\\n    def largestNumber(self, nums):\\n        compare = lambda a, b: -1 if a+b > b+a else 1 if a+b < b+a else 0\\n        return str(int(\"\".join(sorted(map(str, nums), key = cmp_to_key(compare)))))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums):\\n        compare = lambda a, b: -1 if a+b > b+a else 1 if a+b < b+a else 0\\n        return str(int(\"\".join(sorted(map(str, nums), key = cmp_to_key(compare)))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726675,
                "title": "custom-sort-function-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Make some modifications to the sort function to maximize the number value.**\\nFor example:- **array = [2,20,1,100]**\\n\\n**Simple Sort Function:-**\\nA simple sort function sorts the array in ascending order without any constraints.\\n **after sorting array = [1,2,20,100]**\\n\\n**Custom Sort Function:-**\\nIn a custom sort function we can put some constraints to sort the array, here I have put a constraint to check the pair of integers-\\n**to_string(a)+to_string(b)>to_string(b)+to_string(a)**\\nIf this statement is true then a comes first in the array otherwise b comes first.\\n**after sorting array = [2,20,1,100]**\\n\\n**Note:-In sorted array we can check that above statement is true for all pairs.**\\n**220>202 [2,20]\\n21>12 [2,1]\\n2100>1002 [2,100]\\n201>120 [20,1]\\n20100>10020 [20,100]\\n1100>1001 [1,100]**\\n\\n\\n# Complexity\\n- Time complexity:O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool compare(int a,int b)\\n{\\n    return to_string(a)+to_string(b)>to_string(b)+to_string(a);\\n}\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& arr) {\\n        sort(arr.begin(),arr.end(),compare);\\n        string ans = \"\";\\n        for(int i = 0;i<arr.size();i++)\\n        ans+=to_string(arr[i]);\\n        if(ans[0]==\\'0\\') return \"0\";\\n        return ans; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/a1de3469-6a82-4a10-ba46-1db4884d06b8_1688638078.4775126.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nbool compare(int a,int b)\\n{\\n    return to_string(a)+to_string(b)>to_string(b)+to_string(a);\\n}\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& arr) {\\n        sort(arr.begin(),arr.end(),compare);\\n        string ans = \"\";\\n        for(int i = 0;i<arr.size();i++)\\n        ans+=to_string(arr[i]);\\n        if(ans[0]==\\'0\\') return \"0\";\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53306,
                "title": "5-lines-solution-in-javascript",
                "content": "    function largestNumber(num) {\\n        return num.sort(function(a, b) {\\n            return (b + '' + a ) - (a + '' + b);\\n        }).join('').replace(/^0*/,'') || '0';\\n    }",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "    function largestNumber(num) {\\n        return num.sort(function(a, b) {\\n            return (b + '' + a ) - (a + '' + b);\\n        }).join('').replace(/^0*/,'') || '0';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1406356,
                "title": "c-using-sort-with-custom-comparator-t-c-o-nlogn-s-c-o-1",
                "content": "```\\nclass compare{\\n  public:\\n        bool operator()(int a, int b){\\n            string s1 = to_string(a), s2=to_string(b);\\n            return s1+s2 > s2+s1;\\n        }\\n};\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        sort(begin(nums),end(nums), compare());\\n        string s=\"\";\\n        for(auto &n : nums) s+=to_string(n);\\n        if(nums[0]==0) return \"0\";\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass compare{\\n  public:\\n        bool operator()(int a, int b){\\n            string s1 = to_string(a), s2=to_string(b);\\n            return s1+s2 > s2+s1;\\n        }\\n};\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        sort(begin(nums),end(nums), compare());\\n        string s=\"\";\\n        for(auto &n : nums) s+=to_string(n);\\n        if(nums[0]==0) return \"0\";\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863698,
                "title": "python-3-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=xH3fgc8Q7Xc)\\nhttps://www.youtube.com/watch?v=xH3fgc8Q7Xc\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(map(bool, nums)):\\n            return \\'0\\'\\n        \\n        nums = list(map(str, nums))\\n        if len(nums) < 2:\\n            return \"\".join(nums)\\n        \\n        def compare(x, y):\\n            return (int(nums[x]+nums[y])) > (int(nums[y]+nums[x]))\\n        \\n        for x in range(len(nums) - 1):\\n            y = x + 1\\n            while x < len(nums) and y < (len(nums)):\\n                if not compare(x,y):\\n                    nums[y], nums[x] = nums[x], nums[y]\\n                y+=1\\n\\n        return \"\".join(nums)        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(map(bool, nums)):\\n            return \\'0\\'\\n        \\n        nums = list(map(str, nums))\\n        if len(nums) < 2:\\n            return \"\".join(nums)\\n        \\n        def compare(x, y):\\n            return (int(nums[x]+nums[y])) > (int(nums[y]+nums[x]))\\n        \\n        for x in range(len(nums) - 1):\\n            y = x + 1\\n            while x < len(nums) and y < (len(nums)):\\n                if not compare(x,y):\\n                    nums[y], nums[x] = nums[x], nums[y]\\n                y+=1\\n\\n        return \"\".join(nums)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 692060,
                "title": "python-detailed-explanation-with-comparator",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        ## RC ##\\n        ## APPROACH : CUSTOM SORTING WITH COMPARATOR ##\\n        ## MAIN IDEA : It\\'s all about comparison . We define a func that compares two strings a ,b. we consider a bigger than b if a+b > b+a . then we sort the numbers and concatenate them .\\n        ## a-> 3, b-> 30 => 330 > 303\\n        ## Things to note : Your comparator is supposed to return negative/zero/positive, not a boolean. ##\\n        \\n        ## ALSO : We can use any type of sort, while sorting instead of comparing two numbers directly, we can use the current comparator logic to compare and swap elements accordingly.\\n        \\n        ## Edge case : o/p -> \"00\" expected:\"0\"\\n        \\n\\t\\t## TIME COMPLEXITY : O(NlogN) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        import functools\\n        def comparator(s1, s2):\\n            if int(s1+s2) < int(s2+s1):\\n                return -1\\n            if int(s1+s2) > int(s2+s1):\\n                return 1\\n            return 0\\n        \\n        nums = [str(num) for num in nums]\\n        nums = sorted(nums, key = functools.cmp_to_key(comparator),  reverse = True)\\n        ans = \\'0\\' if nums[0] == \\'0\\' else \\'\\'.join(nums)      # if the biggest number after sorting is 0 in first position, then rest all will also be 0\\'s so return 0\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        ## RC ##\\n        ## APPROACH : CUSTOM SORTING WITH COMPARATOR ##\\n        ## MAIN IDEA : It\\'s all about comparison . We define a func that compares two strings a ,b. we consider a bigger than b if a+b > b+a . then we sort the numbers and concatenate them .\\n        ## a-> 3, b-> 30 => 330 > 303\\n        ## Things to note : Your comparator is supposed to return negative/zero/positive, not a boolean. ##\\n        \\n        ## ALSO : We can use any type of sort, while sorting instead of comparing two numbers directly, we can use the current comparator logic to compare and swap elements accordingly.\\n        \\n        ## Edge case : o/p -> \"00\" expected:\"0\"\\n        \\n\\t\\t## TIME COMPLEXITY : O(NlogN) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        import functools\\n        def comparator(s1, s2):\\n            if int(s1+s2) < int(s2+s1):\\n                return -1\\n            if int(s1+s2) > int(s2+s1):\\n                return 1\\n            return 0\\n        \\n        nums = [str(num) for num in nums]\\n        nums = sorted(nums, key = functools.cmp_to_key(comparator),  reverse = True)\\n        ans = \\'0\\' if nums[0] == \\'0\\' else \\'\\'.join(nums)      # if the biggest number after sorting is 0 in first position, then rest all will also be 0\\'s so return 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338252,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(string a,string b)\\n    {\\n        return a+b >b+a;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(to_string(nums[i]));\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        if(v[0]==\"0\")return \"0\";\\n        string ans=\"\";\\n        for(string x: v)\\n        {\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/26ee91ef-cab5-4b6d-a25a-66bc95310f5d_1679723301.1577163.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(string a,string b)\\n    {\\n        return a+b >b+a;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(to_string(nums[i]));\\n        }\\n        sort(v.begin(),v.end(),comp);\\n        if(v[0]==\"0\")return \"0\";\\n        string ans=\"\";\\n        for(string x: v)\\n        {\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53347,
                "title": "simple-solution-with-java-o-nlogn-and-no-need-for-biginteger",
                "content": "    class StringComparator implements Comparator<String> {\\n        public int compare(String a, String b) {\\n            if (a.length() == b.length()) {\\n                return b.compareTo(a);\\n            } else {\\n                String ab = a + b;\\n                String ba = b + a;\\n                return ba.compareTo(ab);\\n            }\\n        }\\n    }\\n    \\n    public class Solution {\\n        public String largestNumber(int[] num) {\\n            StringBuffer sbuf = new StringBuffer();\\n            ArrayList<String> numstrings = new ArrayList<String>(num.length);\\n            \\n            for (int i : num) numstrings.add(String.valueOf(i));\\n            Collections.sort(numstrings,  new StringComparator());\\n            \\n            for (String s : numstrings) sbuf.append(s);\\n            \\n            String res = sbuf.toString();\\n            if (res.length() > 0 && res.charAt(0) == '0') return \"0\";\\n            \\n            return res;\\n        }\\n    }\\n\\n\\nJust write a `Comparator`  to sort the list with `Collections.sort`.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String largestNumber(int[] num) {\\n            StringBuffer sbuf = new StringBuffer();\\n            ArrayList<String> numstrings = new ArrayList<String>(num.length);\\n            \\n            for (int i : num) numstrings.add(String.valueOf(i));\\n            Collections.sort(numstrings,  new StringComparator());\\n            \\n            for (String s : numstrings) sbuf.append(s);\\n            \\n            String res = sbuf.toString();\\n            if (res.length() > 0 && res.charAt(0) == '0') return \"0\";\\n            \\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 53184,
                "title": "c-solution-simple-compare-function",
                "content": "    class Solution { \\n    public:\\n    string largestNumber(vector<int> &num) {\\n        string result;\\n        vector<string> str;\\n        for (auto n : num) {\\n            str.push_back(to_string(n));\\n        }\\n        sort(str.begin(), str.end(), compareNum);\\n        for (auto s: str) {\\n            result += s;\\n        }\\n        \\n        int pos = 0;\\n        while (result[pos] == '0' && pos + 1 < result.size()) pos++; \\n        return result.substr(pos);\\n    } \\n    private:\\n    static bool compareNum(string a, string b) {\\n        return a + b > b + a;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution { \\n    public:\\n    string largestNumber(vector<int> &num) {\\n        string result;\\n        vector<string> str;\\n        for (auto n : num) {\\n            str.push_back(to_string(n));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2992571,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool comp(string& a, string& b)\\n{\\n    return a+b>b+a;\\n}\\n    string largestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<string> v;\\n        for(int i:nums)\\n        v.push_back(to_string(i));\\n        sort(v.begin(), v.end(), comp);\\n        string s=\"\";\\n        for(auto a:v)\\n        s+=a;\\n        int i=0;\\n        while(i<s.size()-1 && s[i]==\\'0\\')\\n        i++;\\n        return s.substr(i, s.size());\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool comp(string& a, string& b)\\n{\\n    return a+b>b+a;\\n}\\n    string largestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<string> v;\\n        for(int i:nums)\\n        v.push_back(to_string(i));\\n        sort(v.begin(), v.end(), comp);\\n        string s=\"\";\\n        for(auto a:v)\\n        s+=a;\\n        int i=0;\\n        while(i<s.size()-1 && s[i]==\\'0\\')\\n        i++;\\n        return s.substr(i, s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53341,
                "title": "a-simple-python-solution-with-sort",
                "content": "    def largestNumber(self, nums):\\n            nums = map(str, nums)\\n            nums.sort(cmp=lambda a,b: cmp(a+b, b+a), reverse=True)\\n            return str(int(''.join(nums)))",
                "solutionTags": [],
                "code": "    def largestNumber(self, nums):\\n            nums = map(str, nums)\\n            nums.sort(cmp=lambda a,b: cmp(a+b, b+a), reverse=True)\\n            return str(int(''.join(nums)))",
                "codeTag": "Python3"
            },
            {
                "id": 53210,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def largestNumber(self, nums):\\n            r = ''.join(sorted(map(str, nums), lambda x, y: [1, -1][x + y > y + x]))\\n            return r.lstrip('0') or '0'",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def largestNumber(self, nums):\\n            r = ''.join(sorted(map(str, nums), lambda x, y: [1, -1][x + y > y + x]))\\n            return r.lstrip('0') or '0'",
                "codeTag": "Java"
            },
            {
                "id": 53411,
                "title": "java-code-by-providing-comparator-with-explaination-o-nlogn",
                "content": "Some useful test case before you start: { 0,0 }, { 12,121 }.\\n\\n    public String largestNumber(int[] num) {\\n            StringBuilder res = new StringBuilder();\\n    \\t\\tif (num == null || num.length == 0)\\n                return null;\\n            \\n            //conver Integer to string\\n            String[] nums = new String[num.length];\\n            for (int i = 0; i < num.length; i++)\\n                nums[i] = Integer.toString(num[i]);\\n                \\n            //Define comparator\\n            Comparator<String> comp = new Comparator<String>()\\n                    {\\n                        @Override\\n                        public int compare(String o1, String o2)\\n                        {\\n                        \\treturn (o1+o2).compareTo(o2+o1);\\n                        }\\n                    };\\n             Arrays.sort(nums, comp);\\n             \\n             //The new number should not start with 0 unless it is 0\\n            if (nums[nums.length-1].equals(\"0\")) \\n                return \"0\";\\n           \\n            for (int i = nums.length-1; i >= 0; i--)\\n             {\\n            \\t res.append(nums[i]);\\n             }\\n            \\n            return res.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Some useful test case before you start: { 0,0 }, { 12,121 }.\\n\\n    public String largestNumber(int[] num) {\\n            StringBuilder res = new StringBuilder();\\n    \\t\\tif (num == null || num.length == 0)\\n                return null;\\n            \\n            //conver Integer to string\\n            String[] nums = new String[num.length];\\n            for (int i = 0; i < num.length; i++)\\n                nums[i] = Integer.toString(num[i]);\\n                \\n            //Define comparator\\n            Comparator<String> comp = new Comparator<String>()\\n                    {\\n                        @Override\\n                        public int compare(String o1, String o2)\\n                        {\\n                        \\treturn (o1+o2).compareTo(o2+o1);\\n                        }\\n                    };\\n             Arrays.sort(nums, comp);\\n             \\n             //The new number should not start with 0 unless it is 0\\n            if (nums[nums.length-1].equals(\"0\")) \\n                return \"0\";\\n           \\n            for (int i = nums.length-1; i >= 0; i--)\\n             {\\n            \\t res.append(nums[i]);\\n             }\\n            \\n            return res.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1391073,
                "title": "python-easy-custom-sort-solution",
                "content": "My solution is based on this obvious math inference:\\nx: n digit; y: m digit\\nif xy > yx,\\nthen 10^m * x + y  > 10^n * y + x\\nthen x / (10^n - 1) > y / (10^m - 1)\\nso we could use this method to make a sorting custom key.\\n\\n\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = sorted(nums,key=lambda x:x / (10 ** len(str(x)) - 1 ), reverse=True)\\n        str_nums = [str(num) for num in nums]\\n        res = \\'\\'.join(str_nums)\\n        res = str(int(res))\\n        return res\\n     \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "My solution is based on this obvious math inference:\\nx: n digit; y: m digit\\nif xy > yx,\\nthen 10^m * x + y  > 10^n * y + x\\nthen x / (10^n - 1) > y / (10^m - 1)\\nso we could use this method to make a sorting custom key.\\n\\n\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = sorted(nums,key=lambda x:x / (10 ** len(str(x)) - 1 ), reverse=True)\\n        str_nums = [str(num) for num in nums]\\n        res = \\'\\'.join(str_nums)\\n        res = str(int(res))\\n        return res\\n     \\n",
                "codeTag": "Java"
            },
            {
                "id": 1214550,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {   \\n        if(nums.length==0)\\n            return \"\";\\n        String[] conv=new String[nums.length];\\n        //convert it to a string array\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            conv[i]=Integer.toString(nums[i]);\\n        }\\n        // for eg:[10,2]\\n        // a+b=102\\n        // b+a=210\\n        // compare numerical value of these 2 strings\\n        Arrays.sort(conv,(a,b) -> (b+a).compareTo(a+b));\\n        StringBuilder res=new StringBuilder();\\n        //after sorting if the array starts with 0\\n        if(conv[0].equals(\"0\"))\\n            return \"0\";\\n        for(int i=0;i<conv.length;i++)\\n        {\\n            res.append(conv[i]);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {   \\n        if(nums.length==0)\\n            return \"\";\\n        String[] conv=new String[nums.length];\\n        //convert it to a string array\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            conv[i]=Integer.toString(nums[i]);\\n        }\\n        // for eg:[10,2]\\n        // a+b=102\\n        // b+a=210\\n        // compare numerical value of these 2 strings\\n        Arrays.sort(conv,(a,b) -> (b+a).compareTo(a+b));\\n        StringBuilder res=new StringBuilder();\\n        //after sorting if the array starts with 0\\n        if(conv[0].equals(\"0\"))\\n            return \"0\";\\n        for(int i=0;i<conv.length;i++)\\n        {\\n            res.append(conv[i]);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012321,
                "title": "javascript-with-sort-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {string}\\n */\\nconst largestNumber = (nums) => {\\n    if(!nums || nums.length === 0) {\\n        return \\'0\\';\\n    }\\n    \\n    nums.sort((a, b) => `${b}${a}` - `${a}${b}`);\\n    if(nums[0] === 0) {\\n        return \\'0\\';\\n    }\\n    return nums.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {string}\\n */\\nconst largestNumber = (nums) => {\\n    if(!nums || nums.length === 0) {\\n        return \\'0\\';\\n    }\\n    \\n    nums.sort((a, b) => `${b}${a}` - `${a}${b}`);\\n    if(nums[0] === 0) {\\n        return \\'0\\';\\n    }\\n    return nums.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001668,
                "title": "short-clean-sorting-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] s = new String[nums.length];         \\n        for(int i=0; i<nums.length; i++)  s[i] = String.valueOf(nums[i]);\\n        Arrays.sort(s, (a,b) -> (b + a).compareTo(a + b));\\n        return s[0].equals(\"0\") ? \"0\" : String.join(\"\",s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting"
                ],
                "code": "```java []\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] s = new String[nums.length];         \\n        for(int i=0; i<nums.length; i++)  s[i] = String.valueOf(nums[i]);\\n        Arrays.sort(s, (a,b) -> (b + a).compareTo(a + b));\\n        return s[0].equals(\"0\") ? \"0\" : String.join(\"\",s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819852,
                "title": "c-from-good-to-best-tree-different-solutions-step-by-step-optimization-with-explanations",
                "content": "##  First Solution (12-16 ms)\\n\\n**Here, we basically do the first thing that comes to our minds, first we convert each integer to string, then we sort them by creating custom comparator. The trick here is that;**\\n\\n**(a+b) < (b+a)**\\n**Assume that a = 97, b = 978**\\n**We check which is greater;**\\n**a+b = 97978  >  b+a= 97897**\\n\\n**So, this trick does the job but there is also one edge case, the trailing zeros 000...**\\n**if res contains only zeros such as res = \"000\" meaning that we can basically check the first digit of res, if it is zero then we return zero, because there is no possibility that the digits greater than zero comes after the first zero**\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        int size = nums.size();\\n        string res = \"\";\\n        vector<string> strNums(size, \"\");\\n        for (int i = 0; i < size; i++) {\\n            strNums[i] = to_string(nums[i]);\\n        }\\n        \\n        sort(strNums.begin(), strNums.end(), [](const string &a, const string &b){\\n            return ((a+b) > (b+a));\\n        });\\n        \\n        for (auto num : strNums) {\\n            res += num;\\n        }\\n        \\n        return res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```\\n\\n\\n##  Second Solution (8 ms)\\n\\n**Here, this time, we are aware of optimization of the custom comparator, right?, we know that we can start checking the digits of each string one by one starting from the left side, in this way we can recognize which one is greater earlier; What I mean is, just consider this case;**\\n\\n**Given that a = 123456789, b = 987654321**\\n\\n**This operation \"(a+b) > (b+a)\", checking this concatenation of two strings will take  much more time than checking only first digits (a[i] > b[i])**\\n**So this is the core trick/optimization here :)**\\n\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        int size = nums.size();\\n        string res = \"\";\\n        vector<string> strNums(size, \"\");\\n        for (int i = 0; i < size; i++) {\\n            strNums[i] = to_string(nums[i]);\\n        }\\n        \\n        sort(strNums.begin(), strNums.end(), [](const string &a, const string &b){\\n            int len = min(a.size(), b.size());\\n            for (int i = 0; i < len; i++) {\\n                if (a[i] != b[i]) {\\n                    return (a[i] > b[i]);\\n                }\\n            }\\n            return ((a+b) > (b+a));\\n        });\\n        \\n        for (auto num : strNums) {\\n            res += num;\\n        }\\n        \\n        return res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```\\n\\n\\n##  Third and The BEST Solution (4 ms)\\n*Runtime: 4 ms, faster than 99.91% of C++ online submissions*\\n\\n**Here, lastly, we realized that we can also check our result string \"res\" inside of the loop! Because the result string which has trailing zeros may appear much earlier than until we finish the loop**\\n```\\nif (res[0] == \\'0\\') {\\n\\treturn \"0\";\\n}\\n```\\n**we don\\'t have to wait till the end, so we just add code snippet above**\\n\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        int size = nums.size();\\n        string res = \"\";\\n        vector<string> strNums(size, \"\");\\n        for (int i = 0; i < size; i++) {\\n            strNums[i] = to_string(nums[i]);\\n        }\\n        \\n        sort(strNums.begin(), strNums.end(), [](const string &a, const string &b){\\n            int len = min(a.size(), b.size());\\n            for (int i = 0; i < len; i++) {\\n                if (a[i] != b[i]) {\\n                    return (a[i] > b[i]);\\n                }\\n            }\\n            return ((a+b) > (b+a));\\n        });\\n        \\n        for (auto num : strNums) {\\n            res += num;\\n            if (res[0] == \\'0\\') {\\n                return \"0\";\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        int size = nums.size();\\n        string res = \"\";\\n        vector<string> strNums(size, \"\");\\n        for (int i = 0; i < size; i++) {\\n            strNums[i] = to_string(nums[i]);\\n        }\\n        \\n        sort(strNums.begin(), strNums.end(), [](const string &a, const string &b){\\n            return ((a+b) > (b+a));\\n        });\\n        \\n        for (auto num : strNums) {\\n            res += num;\\n        }\\n        \\n        return res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        int size = nums.size();\\n        string res = \"\";\\n        vector<string> strNums(size, \"\");\\n        for (int i = 0; i < size; i++) {\\n            strNums[i] = to_string(nums[i]);\\n        }\\n        \\n        sort(strNums.begin(), strNums.end(), [](const string &a, const string &b){\\n            int len = min(a.size(), b.size());\\n            for (int i = 0; i < len; i++) {\\n                if (a[i] != b[i]) {\\n                    return (a[i] > b[i]);\\n                }\\n            }\\n            return ((a+b) > (b+a));\\n        });\\n        \\n        for (auto num : strNums) {\\n            res += num;\\n        }\\n        \\n        return res[0] == \\'0\\' ? \"0\" : res;\\n    }\\n};\\n```\n```\\nif (res[0] == \\'0\\') {\\n\\treturn \"0\";\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        int size = nums.size();\\n        string res = \"\";\\n        vector<string> strNums(size, \"\");\\n        for (int i = 0; i < size; i++) {\\n            strNums[i] = to_string(nums[i]);\\n        }\\n        \\n        sort(strNums.begin(), strNums.end(), [](const string &a, const string &b){\\n            int len = min(a.size(), b.size());\\n            for (int i = 0; i < len; i++) {\\n                if (a[i] != b[i]) {\\n                    return (a[i] > b[i]);\\n                }\\n            }\\n            return ((a+b) > (b+a));\\n        });\\n        \\n        for (auto num : strNums) {\\n            res += num;\\n            if (res[0] == \\'0\\') {\\n                return \"0\";\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730050,
                "title": "python3-simple-merge-sort-approach-o-n-logn",
                "content": "```\\nclass Solution:\\n\\n    \\n    def largestNumber(self, nums: List[int]) -> str:\\n        def merge_sort(nums):\\n            if len(nums)<=1:\\n                return nums\\n            \\n            length = len(nums)//2\\n            \\n            l = merge_sort(nums[:length])\\n            r = merge_sort(nums[length:])\\n            return merge(l,r)\\n        \\n        def merge(l,r):\\n            result = []\\n            i= 0\\n            j= 0\\n            while i<len(l) and j<len(r):\\n                if int(str(l[i])+str(r[j])) >int(str(r[j])+str(l[i])):\\n                    result.append(l[i])\\n                    i+=1\\n                else:\\n                    result.append(r[j])\\n                    j+=1\\n            while i<len(l):\\n                result.append(l[i])\\n                i+=1\\n            while j<len(r):\\n                result.append(r[j])\\n                j+=1\\n            return result\\n        \\n        new_nums = merge_sort(nums)\\n        return str(int(\"\".join(map(str,new_nums)))) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n\\n    \\n    def largestNumber(self, nums: List[int]) -> str:\\n        def merge_sort(nums):\\n            if len(nums)<=1:\\n                return nums\\n            \\n            length = len(nums)//2\\n            \\n            l = merge_sort(nums[:length])\\n            r = merge_sort(nums[length:])\\n            return merge(l,r)\\n        \\n        def merge(l,r):\\n            result = []\\n            i= 0\\n            j= 0\\n            while i<len(l) and j<len(r):\\n                if int(str(l[i])+str(r[j])) >int(str(r[j])+str(l[i])):\\n                    result.append(l[i])\\n                    i+=1\\n                else:\\n                    result.append(r[j])\\n                    j+=1\\n            while i<len(l):\\n                result.append(l[i])\\n                i+=1\\n            while j<len(r):\\n                result.append(r[j])\\n                j+=1\\n            return result\\n        \\n        new_nums = merge_sort(nums)\\n        return str(int(\"\".join(map(str,new_nums)))) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 53320,
                "title": "short-32ms-c-solution-using-lexicographic-comparison",
                "content": "Given two numbers, we want to know which one should go first to create the lexicographically greater string. So we sort the numbers based on this rule.\\n\\n    class Solution {\\n    public:\\n        string largestNumber(vector<int>& nums) {\\n            string result;\\n            sort(nums.begin(), nums.end(), [](int a, int b) { return to_string(a) + to_string(b) > to_string(b) + to_string(a); });\\n            for (int n : nums) { result += to_string(n); }\\n            return result.front() == '0' ? \"0\" : result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int>& nums) {\\n            string result;\\n            sort(nums.begin(), nums.end(), [](int a, int b) { return to_string(a) + to_string(b) > to_string(b) + to_string(a); }",
                "codeTag": "Java"
            },
            {
                "id": 3212971,
                "title": "179-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we need to sort the given list of numbers such that they form the largest possible number. To do this, we need to create a custom sorting function that compares two numbers at a time and concatenates them in different orders to see which order forms the larger number. Once we have sorted the numbers, we can concatenate them to form the final result.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n56.81%\\n\\n- Space complexity:\\nBeats\\n95.75%\\n\\n# Code\\n```\\nclass LargerNumKey(str):\\n    def __lt__(x, y):\\n        # Compare x+y with y+x in reverse order to get descending order\\n        return x+y > y+x\\n\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        # Convert the list of numbers to list of strings\\n        nums = [str(num) for num in nums]\\n        \\n        # Sort the list of strings using our custom sorting function\\n        nums.sort(key=LargerNumKey)\\n        \\n        # Join the sorted list of strings to form the final result\\n        largest_num = \\'\\'.join(nums)\\n        \\n        # If the largest number is 0, return \"0\"\\n        # Otherwise, return the largest number\\n        return \"0\" if largest_num[0] == \"0\" else largest_num\\n\\n```\\nThe LargerNumKey class is a subclass of the built-in str class that overrides the less than operator (<) to compare two strings in a special way. The __lt__ method is called when we use the less than operator to compare two strings. We define the method to compare two strings x and y in the following way:\\n\\n1. Concatenate x and y in reverse order: x+y.\\n2. Concatenate y and x in reverse order: y+x.\\n3. Compare the two concatenated strings in reverse order to get descending order. That is, if x+y is greater than y+x, we return True. Otherwise, we return False.\\n\\nIn the largestNumber method, we first convert the list of numbers to a list of strings. We then sort the list of strings using our custom sorting function. Finally, we join the sorted list of strings to form the largest number.\\n\\nNote that if the largest number is 0, we return \"0\" instead of the actual largest number. This is because \"0\" is the only case where the leading digit is \"0\".",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass LargerNumKey(str):\\n    def __lt__(x, y):\\n        # Compare x+y with y+x in reverse order to get descending order\\n        return x+y > y+x\\n\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        # Convert the list of numbers to list of strings\\n        nums = [str(num) for num in nums]\\n        \\n        # Sort the list of strings using our custom sorting function\\n        nums.sort(key=LargerNumKey)\\n        \\n        # Join the sorted list of strings to form the final result\\n        largest_num = \\'\\'.join(nums)\\n        \\n        # If the largest number is 0, return \"0\"\\n        # Otherwise, return the largest number\\n        return \"0\" if largest_num[0] == \"0\" else largest_num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53265,
                "title": "clean-python-solution",
                "content": "    class Solution(object):\\n        def largestNumber(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, nums)\\n            nums.sort(cmp = lambda x, y: cmp(x + y, y + x), reverse = True)\\n            return '0' if nums[0] == '0' else ''.join(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def largestNumber(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, nums)\\n            nums.sort(cmp = lambda x, y: cmp(x + y, y + x), reverse = True)\\n            return '0' if nums[0] == '0' else ''.join(nums)",
                "codeTag": "Java"
            },
            {
                "id": 53318,
                "title": "a-2-line-c-code",
                "content": "    public string LargestNumber(int[] nums){\\n        Array.Sort(nums, (a, b) => (b + \"\" + a).CompareTo(a + \"\" + b));\\n        return nums[0] == 0 ? \"0\" : string.Join(\"\", nums);\\n    }",
                "solutionTags": [],
                "code": "    public string LargestNumber(int[] nums){\\n        Array.Sort(nums, (a, b) => (b + \"\" + a).CompareTo(a + \"\" + b));\\n        return nums[0] == 0 ? \"0\" : string.Join(\"\", nums);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 863449,
                "title": "python-super-simple-explained-solution-o-nlogn",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        str_nums = []\\n        for num in nums:\\n            str_nums.append(str(num)) # turn numbers to strings\\n            \\n        str_nums.sort(reverse=True) # sort by lexicographical order\\n        \\n        flag = False # flag to keep track if there were swaps, if no more swaps needed - finished\\n        while not flag:\\n            flag = True\\n            i=0\\n            while i < len(str_nums)-1:\\n                if str_nums[i]+str_nums[i+1] < str_nums[i+1]+str_nums[i]: # if larger when swapped - swap\\n                    str_nums[i], str_nums[i+1] = str_nums[i+1], str_nums[i]\\n                    flag = False\\n                i += 1\\n                \\n        res = \"\".join(str_nums)\\n        \\n        if res[0] == \\'0\\':\\n            return str(0)\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        str_nums = []\\n        for num in nums:\\n            str_nums.append(str(num)) # turn numbers to strings\\n            \\n        str_nums.sort(reverse=True) # sort by lexicographical order\\n        \\n        flag = False # flag to keep track if there were swaps, if no more swaps needed - finished\\n        while not flag:\\n            flag = True\\n            i=0\\n            while i < len(str_nums)-1:\\n                if str_nums[i]+str_nums[i+1] < str_nums[i+1]+str_nums[i]: # if larger when swapped - swap\\n                    str_nums[i], str_nums[i+1] = str_nums[i+1], str_nums[i]\\n                    flag = False\\n                i += 1\\n                \\n        res = \"\".join(str_nums)\\n        \\n        if res[0] == \\'0\\':\\n            return str(0)\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267353,
                "title": "tree-solution",
                "content": "**Intuition**\\n\\nWe build a Tree. Every Node has at most ten children, each child represent a digit, \\nFor example, the input numbers are [4, 63, 67, 56], the tree is\\n     \\n```text\\n       root\\n      /  |  \\\\\\n     6   5   4\\n    / \\\\  |   \\u2193 \\n   7   3 6   4\\n   \\u2193   \\u2193 \\u2193\\n  67  63 56\\n```\\n*The symbol \\u2193 means the node has a number.*\\n<br>\\n\\n**DFS Algorithm**\\nFor a Node, its ahead digits are *abc*, its digit is X, it has a child node with number *abcXi* and another child node with number *abcXjk*. The contrast is\\n```\\nabcXiabcXjk -> iabcXjk -> i\\nabcXjkabcXi -> jkabcXi -> j\\n```\\nIf **i > j**, then **abcXiabcXjk > abcXjkabcXi**. The DFS should traverse its children from 9 to 0.\\nThe largest number for previous example is 6763564.\\n<br>\\n\\nThe tree for [4, 43] is\\n```text\\n       root\\n        |\\n        4\\n      \\u2199 |\\n     4  3\\n        \\u2193\\n       43\\n```\\nFor a Node, its ahead digits are *abc*, its digit is X, it has a number *abcX* and a child node *abcXjk*. The contrast is\\n```\\nabcXabcXjk\\nabcXjkabcX\\n```\\nIf **a > j** , then **abcXabcXjk > abcXjkabcX**. The DFS should traverse its children from 9 to **a**, then handle its own number, then traverse its children from **a** to 0.\\nThe largest number for previous example is 443.\\n\\n**The Trouble when a == j**\\nThe tree for [4, 443] is\\n```text\\n       root\\n        |\\n        4\\n        | \\u2198\\n        4  4\\n\\t\\t|\\n\\t\\t3\\n        \\u2193\\n       443\\n```\\nFor a Node, its ahead digits are *abc*, its digit is X, it has a number ***abcX*** and a child node ***abcXak***. The contrast is\\n```\\nabcXabcXak -> bcXak\\nabcXakabcX -> kabcX\\n```\\nIt\\'s not a easy contrast. Let\\'s check another fact.\\n\\n**A Fact**\\nCompare two results for numbers [abcX, abcXabcX].\\n```\\nabcXabcXabcX\\nabcXabcXabcX\\n```\\nThey\\'re the same. That means, number **abcXabcX** has the same weight as number **abcX** in the tree. *The number abcXabcXabcX has the same weight too.*\\n\\nIt\\'s hard to compare **abcX** with **abcXak**, how about ***abcXabcX*** ?\\n```\\nabcXabcXabcXak -> bcXabcXak\\nabcXakabcXabcX -> kabcXabcX\\n```\\nIts first four effective digit is **bcXa vs kabc** , the same as **abcX** compare with **abcXak** . Same weight means same contrast. \\nAnd the new contrast will be done by the Tree.\\n<br>\\n\\n**Solution**\\nBack to the Node with number ***abcX*** and the child node ***abcXak***, we move its number to node ***abcXabcX*** and traverse its child with digit **a**. \\nIf the new node ***abcXabcX*** has a child with digit **a**, we have to move the original number to node ***abcXabcXabcX*** and go on.\\n\\nFor a Node with leading digit **a**, we only handle its own number when its doesn\\'t have child with digit **a**. This is our solution.\\n\\nFor numbers [4, 443], let\\'s copy number \"4\" from node \"4\" to node \"44\", the new tree is\\n```text\\n       root\\n        |\\n    4 \\u2190 4\\n        |\\n        4\\n      \\u2199 |\\n     4  3\\n        \\u2193\\n       443\\n```\\nIts largest number is 4443, since \"3\" is small than its leading digit \"4\".\\n\\nFor numbers [4, 44, 443], the tree is\\n```text\\n       root\\n        |\\n    4 \\u2190 4\\n        |\\n   44 \\u2190 4\\n      \\u2199 |\\n     4  3\\n        \\u2193\\n       443\\n```\\nThe largest number is 444443. And we certainly sure number 4 and number 44 have the same weight. Their sequence doesn\\'t make sense.\\n<br>\\n\\n**A complex example**\\nThe tree for [412, 412412, 412413, 4124125]\\n```text\\n        root\\n         |\\n         4\\n         |\\n         1\\n         |\\n   412 \\u2190 2\\n         |\\n         4\\n         |\\n         1\\n       / |\\n     3   2  \\u2192 412412\\n   \\u2199     |  \\u2198\\n412413   5  412\\n         \\u2193\\n      4124125\\n```\\nThe largest number is 4124134124125412412412.\\n<br>\\n\\n**Accepted Code**\\n```java\\nclass Solution {\\n    \\n    class Node {\\n        Node father;\\n        Node[] children = new Node[10];\\n        List<Integer> numberOffsets;\\n        \\n        Node() {    \\n        }\\n        \\n        Node(Node father) {\\n            this.father = father;\\n            this.numberOffsets = new ArrayList<>();\\n        }\\n    }\\n    \\n    public String largestNumber(int[] nums) {\\n        Node root = new Node();\\n        int zeroCount = 0;\\n        int size = 0;\\n        for (int number : nums) {\\n            if (number == 0) {\\n                zeroCount++;\\n                size++;\\n            } else {\\n                char[] chars = Integer.toString(number).toCharArray();\\n                register(root, chars);\\n                size += chars.length;\\n            }\\n        }\\n        \\n        StringBuilder builder = new StringBuilder(size);\\n        for (int digit = 9; digit > 0; digit--) {\\n            Node forefather = root.children[digit];\\n            if (forefather != null) {\\n                StringBuilder chars = new StringBuilder();\\n                dfs(forefather, digit, chars, builder);\\n            }\\n        }\\n        \\n        if (builder.length() == 0) return \"0\";\\n        \\n        while (zeroCount > 0) {\\n            builder.append(\\'0\\');\\n            zeroCount--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private void register(Node forefather, char[] chars) {\\n        Node node = forefather;\\n        for (int i = 0; i < chars.length; i++) {\\n            int digit = chars[i] - \\'0\\';\\n            \\n            Node next = node.children[digit];\\n            if (next == null) {\\n                next = new Node(node);\\n                node.children[digit] = next;\\n            }\\n            node = next;\\n        }\\n        node.numberOffsets.add(chars.length);\\n    }\\n    \\n    private void dfs(Node node, int digit, StringBuilder chars, StringBuilder builder) {\\n        chars.append(digit);\\n        int leadingDigit = chars.charAt(0) - \\'0\\';\\n        \\n        for (int i = 9; i > leadingDigit; i--) {\\n            Node child = node.children[i];\\n            if (child != null) {\\n                dfs(child, i, chars, builder);\\n            }\\n        }\\n        \\n        if (node.children[leadingDigit] == null) {\\n            for (int end : node.numberOffsets) {\\n                builder.append(chars, 0, end);\\n            }\\n        } else {\\n            for (int end : node.numberOffsets) {\\n                char[] temp = new char[end];\\n                chars.getChars(0, end, temp, 0);\\n                register(node, temp);\\n            }\\n            \\n            dfs(node.children[leadingDigit], leadingDigit, chars, builder);\\n        }\\n        \\n        for (int i = leadingDigit - 1; i >= 0; i--) {\\n            Node child = node.children[i];\\n            if (child != null) {\\n                dfs(child, i, chars, builder);\\n            }\\n        }\\n        \\n        chars.deleteCharAt(chars.length() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```text\\n       root\\n      /  |  \\\\\\n     6   5   4\\n    / \\\\  |   \\u2193 \\n   7   3 6   4\\n   \\u2193   \\u2193 \\u2193\\n  67  63 56\\n```\n```\\nabcXiabcXjk -> iabcXjk -> i\\nabcXjkabcXi -> jkabcXi -> j\\n```\n```text\\n       root\\n        |\\n        4\\n      \\u2199 |\\n     4  3\\n        \\u2193\\n       43\\n```\n```\\nabcXabcXjk\\nabcXjkabcX\\n```\n```text\\n       root\\n        |\\n        4\\n        | \\u2198\\n        4  4\\n\\t\\t|\\n\\t\\t3\\n        \\u2193\\n       443\\n```\n```\\nabcXabcXak -> bcXak\\nabcXakabcX -> kabcX\\n```\n```\\nabcXabcXabcX\\nabcXabcXabcX\\n```\n```\\nabcXabcXabcXak -> bcXabcXak\\nabcXakabcXabcX -> kabcXabcX\\n```\n```text\\n       root\\n        |\\n    4 \\u2190 4\\n        |\\n        4\\n      \\u2199 |\\n     4  3\\n        \\u2193\\n       443\\n```\n```text\\n       root\\n        |\\n    4 \\u2190 4\\n        |\\n   44 \\u2190 4\\n      \\u2199 |\\n     4  3\\n        \\u2193\\n       443\\n```\n```text\\n        root\\n         |\\n         4\\n         |\\n         1\\n         |\\n   412 \\u2190 2\\n         |\\n         4\\n         |\\n         1\\n       / |\\n     3   2  \\u2192 412412\\n   \\u2199     |  \\u2198\\n412413   5  412\\n         \\u2193\\n      4124125\\n```\n```java\\nclass Solution {\\n    \\n    class Node {\\n        Node father;\\n        Node[] children = new Node[10];\\n        List<Integer> numberOffsets;\\n        \\n        Node() {    \\n        }\\n        \\n        Node(Node father) {\\n            this.father = father;\\n            this.numberOffsets = new ArrayList<>();\\n        }\\n    }\\n    \\n    public String largestNumber(int[] nums) {\\n        Node root = new Node();\\n        int zeroCount = 0;\\n        int size = 0;\\n        for (int number : nums) {\\n            if (number == 0) {\\n                zeroCount++;\\n                size++;\\n            } else {\\n                char[] chars = Integer.toString(number).toCharArray();\\n                register(root, chars);\\n                size += chars.length;\\n            }\\n        }\\n        \\n        StringBuilder builder = new StringBuilder(size);\\n        for (int digit = 9; digit > 0; digit--) {\\n            Node forefather = root.children[digit];\\n            if (forefather != null) {\\n                StringBuilder chars = new StringBuilder();\\n                dfs(forefather, digit, chars, builder);\\n            }\\n        }\\n        \\n        if (builder.length() == 0) return \"0\";\\n        \\n        while (zeroCount > 0) {\\n            builder.append(\\'0\\');\\n            zeroCount--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private void register(Node forefather, char[] chars) {\\n        Node node = forefather;\\n        for (int i = 0; i < chars.length; i++) {\\n            int digit = chars[i] - \\'0\\';\\n            \\n            Node next = node.children[digit];\\n            if (next == null) {\\n                next = new Node(node);\\n                node.children[digit] = next;\\n            }\\n            node = next;\\n        }\\n        node.numberOffsets.add(chars.length);\\n    }\\n    \\n    private void dfs(Node node, int digit, StringBuilder chars, StringBuilder builder) {\\n        chars.append(digit);\\n        int leadingDigit = chars.charAt(0) - \\'0\\';\\n        \\n        for (int i = 9; i > leadingDigit; i--) {\\n            Node child = node.children[i];\\n            if (child != null) {\\n                dfs(child, i, chars, builder);\\n            }\\n        }\\n        \\n        if (node.children[leadingDigit] == null) {\\n            for (int end : node.numberOffsets) {\\n                builder.append(chars, 0, end);\\n            }\\n        } else {\\n            for (int end : node.numberOffsets) {\\n                char[] temp = new char[end];\\n                chars.getChars(0, end, temp, 0);\\n                register(node, temp);\\n            }\\n            \\n            dfs(node.children[leadingDigit], leadingDigit, chars, builder);\\n        }\\n        \\n        for (int i = leadingDigit - 1; i >= 0; i--) {\\n            Node child = node.children[i];\\n            if (child != null) {\\n                dfs(child, i, chars, builder);\\n            }\\n        }\\n        \\n        chars.deleteCharAt(chars.length() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951350,
                "title": "sort-comparator-explained-step-by-step-cpp",
                "content": "The Intuition is to compare two numbers not based on their values, but by considering the concatenation of the two numbers as strings and comparing which concatenation gives a larger value.\\n\\n```\\nsort(vec.begin(), vec.end(), [](string &a, string&b){\\n         return a + b > b + a;\\n});\\n```\\n\\nwhat does it mean ?? \\n```return a + b > b + a;```\\nit means if the concatenation a + b produces a larger value than b + a, indicating that a should come before b in the sorted order.\\n\\n\\nconsider the example ```nums = [3,30,34,5,9]```\\nFirstly, Convert the numbers to strings: ```[\"3\", \"30\", \"34\", \"5\", \"9\"]```.\\nNow use custom comparator,\\nComparing \"3\" and \"30\": \"330\" vs. \"303\" => \"330\" comes first.\\nComparing \"3\" and \"34\": \"334\" vs. \"343\" => \"343\" comes first.\\nComparing \"3\" and \"5\": \"35\" vs. \"53\" => \"53\" comes first.\\nComparing \"3\" and \"9\": \"39\" vs. \"93\" => \"93\" comes first.\\nComparing \"30\" and \"34\": \"3430\" vs. \"3034\" => \"3430\" comes first.\\nand so on.\\nAfter sorting: ```[\"9\", \"5\", \"34\", \"3\", \"30\"]```.\\nConcatenate the sorted strings: ```\"95334330\"```.\\nRemove leading zeros ( if any ): ```\"95334330\"```.\\n\\nC++ Code:\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> vec;\\n        \\n        for(auto it: nums){\\n            vec.push_back(to_string(it));\\n        }\\n        \\n        sort(vec.begin(), vec.end(), [](string &a, string&b){\\n            return a + b > b + a;\\n        });\\n        \\n        string ans;\\n        for(auto it: vec){\\n            ans += it;\\n        }\\n        \\n        int i = 0;\\n        while(ans[i] == \\'0\\' && i + 1 < ans.size()){\\n            i++;\\n        }\\n        \\n        return ans.substr(i);\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF IT HELPS :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nsort(vec.begin(), vec.end(), [](string &a, string&b){\\n         return a + b > b + a;\\n});\\n```\n```return a + b > b + a;```\n```nums = [3,30,34,5,9]```\n```[\"3\", \"30\", \"34\", \"5\", \"9\"]```\n```[\"9\", \"5\", \"34\", \"3\", \"30\"]```\n```\"95334330\"```\n```\"95334330\"```\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> vec;\\n        \\n        for(auto it: nums){\\n            vec.push_back(to_string(it));\\n        }\\n        \\n        sort(vec.begin(), vec.end(), [](string &a, string&b){\\n            return a + b > b + a;\\n        });\\n        \\n        string ans;\\n        for(auto it: vec){\\n            ans += it;\\n        }\\n        \\n        int i = 0;\\n        while(ans[i] == \\'0\\' && i + 1 < ans.size()){\\n            i++;\\n        }\\n        \\n        return ans.substr(i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084089,
                "title": "the-simplest-solution-in-javascript-beats-95",
                "content": "```\\nvar largestNumber = function(nums) {\\n    nums.sort((a,b)=>{\\n        let sa = a.toString()\\n        let sb = b.toString()\\n        return parseInt(sa + sb) > parseInt(sb + sa) ? -1 : 1\\n    })\\n    if(nums[0] === 0) return \\'0\\'\\n    \\n    return nums.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestNumber = function(nums) {\\n    nums.sort((a,b)=>{\\n        let sa = a.toString()\\n        let sb = b.toString()\\n        return parseInt(sa + sb) > parseInt(sb + sa) ? -1 : 1\\n    })\\n    if(nums[0] === 0) return \\'0\\'\\n    \\n    return nums.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53336,
                "title": "simple-java-solution-using-arrays-sort-and-custom-object-implementing-comparable",
                "content": "    public class Solution {\\n        public String largestNumber(int[] nums) {\\n            if(nums.length==0)return \"\";\\n            if(nums.length==1)return Integer.toString(nums[0]);\\n            NumStr[] n = new NumStr[nums.length];\\n            for(int i=0; i<nums.length; i++){\\n                n[i]=new NumStr(nums[i]);\\n            }\\n            Arrays.sort(n);\\n            if(n[0].num.equals(\"0\"))return \"0\";\\n            StringBuilder b = new StringBuilder();\\n            for(int i=0; i<n.length; i++){\\n                b.append(n[i].num);\\n            }\\n            return b.toString();\\n        }\\n    }\\n    \\n    class NumStr implements Comparable<NumStr>{\\n        String num;\\n        public NumStr(int n){\\n            this.num=Integer.toString(n);\\n        }\\n        @Override\\n        public int compareTo(NumStr n){\\n            String s1=n.num+this.num;\\n            String s2=this.num+n.num;\\n            for(int i=0; i<s1.length(); i++){\\n                if(s1.charAt(i)>s2.charAt(i))return 1;\\n                else if(s1.charAt(i)<s2.charAt(i))return -1;\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String largestNumber(int[] nums) {\\n            if(nums.length==0)return \"\";\\n            if(nums.length==1)return Integer.toString(nums[0]);\\n            NumStr[] n = new NumStr[nums.length];\\n            for(int i=0; i<nums.length; i++){\\n                n[i]=new NumStr(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3337661,
                "title": "easiest-solution-ever-you-will-see-jugadu-out-of-the-box-approach",
                "content": "# Intuition\\nMOST JUGADU SOLUTION BY TRIPPY THE CODDER : ) \\nEASY JAVA SOL HERE\\nYou may be easily able to convert it in C++ if you go through it.\\n\\n# Approach\\nSolution by **SS** approach \\nJust **Smile** and **Solve**\\n\\n# Complexity\\nJUST SMILE AND SOLVE\\n# HUMBLE REQUEST\\nPLEASE UPVOTE IF I HELPED YOU \\nTHANK YOU.\\nKEEP IT UP.\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String s2=\"\";\\n        int ll=nums.length;\\n        String arr[]=new String[ll];\\n        for(int i=0;i<ll;i++)\\n        arr[i]=\"\"+nums[i];\\n        Arrays.sort(arr, Collections.reverseOrder());\\n        for(int i=0;i<ll-1;i++)\\n        {\\n                int l=Math.min(arr[i].length(),arr[i+1].length());\\n                if(arr[i].substring(0,l).equals(arr[i+1].substring(0,l)))\\n                {\\n                    long x=Long.parseLong(arr[i]+arr[i+1]);\\n                    long y=Long.parseLong(arr[i+1]+arr[i]);\\n                    if(x<y)\\n                   { String t=arr[i];\\n                    arr[i]=arr[i+1];\\n                    arr[i+1]=t;\\n                    i=-1;\\n                   }\\n                }\\n        \\n        }\\n        for(int i=0;i<ll;i++)\\n        s2+=arr[i];\\n        \\n            if(s2.charAt(0)==\\'0\\'&&s2.charAt(s2.length()-1)==\\'0\\')\\n            return \"0\";\\n            \\n        return s2;\\n       \\n        //PLEASE UPVOTE\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String s2=\"\";\\n        int ll=nums.length;\\n        String arr[]=new String[ll];\\n        for(int i=0;i<ll;i++)\\n        arr[i]=\"\"+nums[i];\\n        Arrays.sort(arr, Collections.reverseOrder());\\n        for(int i=0;i<ll-1;i++)\\n        {\\n                int l=Math.min(arr[i].length(),arr[i+1].length());\\n                if(arr[i].substring(0,l).equals(arr[i+1].substring(0,l)))\\n                {\\n                    long x=Long.parseLong(arr[i]+arr[i+1]);\\n                    long y=Long.parseLong(arr[i+1]+arr[i]);\\n                    if(x<y)\\n                   { String t=arr[i];\\n                    arr[i]=arr[i+1];\\n                    arr[i+1]=t;\\n                    i=-1;\\n                   }\\n                }\\n        \\n        }\\n        for(int i=0;i<ll;i++)\\n        s2+=arr[i];\\n        \\n            if(s2.charAt(0)==\\'0\\'&&s2.charAt(s2.length()-1)==\\'0\\')\\n            return \"0\";\\n            \\n        return s2;\\n       \\n        //PLEASE UPVOTE\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717723,
                "title": "c-solution-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool myCmp(string a,string b){\\n        return (a+b)>(b+a);\\n    }\\n    \\n    string largestNumber(vector<int>& nums) {\\n        string s = \"\";\\n        vector<string> str;\\n        for(auto& x:nums){\\n            str.push_back(to_string(x));\\n        }\\n        sort(str.begin(),str.end(),myCmp);\\n        if(str[0]==\"0\") return \"0\";\\n        for(auto& x:str){\\n            s += x;\\n        }\\n        return s;\\n    }\\n};\\n```\\nIf you like the solution please upvote.. :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool myCmp(string a,string b){\\n        return (a+b)>(b+a);\\n    }\\n    \\n    string largestNumber(vector<int>& nums) {\\n        string s = \"\";\\n        vector<string> str;\\n        for(auto& x:nums){\\n            str.push_back(to_string(x));\\n        }\\n        sort(str.begin(),str.end(),myCmp);\\n        if(str[0]==\"0\") return \"0\";\\n        for(auto& x:str){\\n            s += x;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53307,
                "title": "some-one-liners",
                "content": "The code is all mine, but using the [basic ideas from here](http://stackoverflow.com/questions/30140796/sort-a-list-to-form-the-largest-possible-number). I was involved a bit there, but not much. Some day I still want to prove these methods, I still haven't seen a proof yet...\\n\\n---\\n\\n**Ruby**\\n\\nComparing stringified b+a with a+b:\\n\\n    def largest_number(nums)\\n        nums.map(&:to_s).sort { |a, b| b + a <=> a + b }.join.to_i.to_s\\n    end\\n\\nSame, but stringifying on-the-fly just for the comparison:\\n\\n    def largest_number(nums)\\n        nums.sort { |a, b| \"#{b}#{a}\" <=> \"#{a}#{b}\" }.join.to_i.to_s\\n    end\\n\\nSorting **by key**, for example number 457 gets key -457/999, which is -0.457457457...\\n\\n    def largest_number(nums)\\n        nums.sort_by { |n| Rational(n, 1 - 10**n.to_s.size) }.join.to_i.to_s\\n    end\\n\\nSorting by key, using the repeated stringified number as key (nine times seems enough):\\n\\n    def largest_number(nums)\\n        nums.sort_by { |n| n.to_s * 9 }.reverse.join.to_i.to_s\\n    end\\n\\n---\\n\\n**Python**\\n\\nBy repeated stringified number:\\n\\n    def largestNumber(self, nums):\\n        return str(int(''.join(sorted(map(str, nums), key=lambda s:s*9)[::-1])))\\n\\nBy stringified b+a vs a+b:\\n\\n    def largestNumber(self, nums):\\n        return str(int(''.join(sorted(map(str, nums), cmp=lambda a, b: cmp(b+a, a+b)))))\\n\\nBy fraction. It's possible to write it as one-liner, but it would be really ugly, so I don't. Just want also to show the Python version of it.\\n\\n    def largestNumber(self, nums):\\n        from fractions import Fraction\\n        key = lambda n: Fraction(n, 1 - 10**len(str(n)))\\n        return str(int(''.join(map(str, sorted(nums, key=key)))))",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "The code is all mine, but using the [basic ideas from here](http://stackoverflow.com/questions/30140796/sort-a-list-to-form-the-largest-possible-number). I was involved a bit there, but not much. Some day I still want to prove these methods, I still haven't seen a proof yet...\\n\\n---\\n\\n**Ruby**\\n\\nComparing stringified b+a with a+b:\\n\\n    def largest_number(nums)\\n        nums.map(&:to_s).sort { |a, b| b + a <=> a + b }.join.to_i.to_s\\n    end\\n\\nSame, but stringifying on-the-fly just for the comparison:\\n\\n    def largest_number(nums)\\n        nums.sort { |a, b| \"#{b}#{a}\" <=> \"#{a}#{b}\" }.join.to_i.to_s\\n    end\\n\\nSorting **by key**, for example number 457 gets key -457/999, which is -0.457457457...\\n\\n    def largest_number(nums)\\n        nums.sort_by { |n| Rational(n, 1 - 10**n.to_s.size) }.join.to_i.to_s\\n    end\\n\\nSorting by key, using the repeated stringified number as key (nine times seems enough):\\n\\n    def largest_number(nums)\\n        nums.sort_by { |n| n.to_s * 9 }.reverse.join.to_i.to_s\\n    end\\n\\n---\\n\\n**Python**\\n\\nBy repeated stringified number:\\n\\n    def largestNumber(self, nums):\\n        return str(int(''.join(sorted(map(str, nums), key=lambda s:s*9)[::-1])))\\n\\nBy stringified b+a vs a+b:\\n\\n    def largestNumber(self, nums):\\n        return str(int(''.join(sorted(map(str, nums), cmp=lambda a, b: cmp(b+a, a+b)))))\\n\\nBy fraction. It's possible to write it as one-liner, but it would be really ugly, so I don't. Just want also to show the Python version of it.\\n\\n    def largestNumber(self, nums):\\n        from fractions import Fraction\\n        key = lambda n: Fraction(n, 1 - 10**len(str(n)))\\n        return str(int(''.join(map(str, sorted(nums, key=key)))))",
                "codeTag": "Python3"
            },
            {
                "id": 53380,
                "title": "java-solution-rewritting-comparator",
                "content": "    public class Solution {\\n    class StringComparator implements Comparator<String> {\\n        public int compare(String s1, String s2){\\n            String s1s2 = s1+s2;\\n            String s2s1 = s2+s1;\\n            if(s1s2.compareTo(s2s1)>0) return -1;\\n            else if(s1s2.compareTo(s2s1)<0) return 1;\\n            else if(s1.length()<=s2.length()) return -1;\\n            else  return 1;\\n        }\\n    }\\n    \\n    public String largestNumber(int[] num){\\n        String[] nums = new String[num.length];\\n        for(int i =0 ;i<num.length;i++){\\n            nums[i]=String.valueOf(num[i]);\\n        }\\n        Comparator<String> comparator = new StringComparator();\\n        Arrays.sort(nums,comparator);\\n        \\n        StringBuilder str = new StringBuilder();\\n        for(String n:nums){\\n            str.append(n);\\n        }\\n        return str.charAt(0)=='0'?\"0\":str.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    class StringComparator implements Comparator<String> {\\n        public int compare(String s1, String s2){\\n            String s1s2 = s1+s2;\\n            String s2s1 = s2+s1;\\n            if(s1s2.compareTo(s2s1)>0) return -1;\\n            else if(s1s2.compareTo(s2s1)<0) return 1;\\n            else if(s1.length()<=s2.length()) return -1;\\n            else  return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2677506,
                "title": "c-easy-solution-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) { \\n        if(count(nums.begin(),nums.end(),0)==nums.size()) return \"0\";\\n        sort(nums.begin(),nums.end(),[](int x,int y){\\n            string a = to_string(x), b = to_string(y);\\n            return a+b>=b+a;\\n        });\\n        string ans = \"\";\\n        for(auto it:nums) ans+=to_string(it);\\n        return ans;\\n    }\\n};\\n```\\n***Do upvote if you like my solution***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) { \\n        if(count(nums.begin(),nums.end(),0)==nums.size()) return \"0\";\\n        sort(nums.begin(),nums.end(),[](int x,int y){\\n            string a = to_string(x), b = to_string(y);\\n            return a+b>=b+a;\\n        });\\n        string ans = \"\";\\n        for(auto it:nums) ans+=to_string(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522640,
                "title": "simple-well-explained-c-solution",
                "content": "**Please do upvote if you like the approach as it motivates me to create such post!!**\\n```\\nclass Solution {\\npublic:\\n    //simple idea here is to convert all numbers of vector into the string and then compare it to arrange such that it will form the greatest number\\n    \\n    //this is comparator function used while sorting.. This basically compares between the two strings that which pair forms greatest number\\n    static bool compare(string a, string b){\\n        return a+b>b+a;\\n    }\\n    \\n    string largestNumber(vector<int>& nums) {\\n        vector<string>res;\\n        \\n        //for every integer we convert it into the string and push to our vector\\n        for(int x : nums){\\n            string temp = to_string(x);\\n            res.push_back(temp);\\n        }\\n        \\n        //after that we will sort our array such that we get maximum number\\n        sort(res.begin(),res.end(),compare);\\n        string op = \"\";\\n        //this is used to add our numbers to output string\\n        for(string s : res){\\n            op += s;\\n        }\\n        return op[0]==\\'0\\' ? \"0\" : op; //if the number has leading zeroes istead of returning all the zeroes we return single zero else we return our op string..\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //simple idea here is to convert all numbers of vector into the string and then compare it to arrange such that it will form the greatest number\\n    \\n    //this is comparator function used while sorting.. This basically compares between the two strings that which pair forms greatest number\\n    static bool compare(string a, string b){\\n        return a+b>b+a;\\n    }\\n    \\n    string largestNumber(vector<int>& nums) {\\n        vector<string>res;\\n        \\n        //for every integer we convert it into the string and push to our vector\\n        for(int x : nums){\\n            string temp = to_string(x);\\n            res.push_back(temp);\\n        }\\n        \\n        //after that we will sort our array such that we get maximum number\\n        sort(res.begin(),res.end(),compare);\\n        string op = \"\";\\n        //this is used to add our numbers to output string\\n        for(string s : res){\\n            op += s;\\n        }\\n        return op[0]==\\'0\\' ? \"0\" : op; //if the number has leading zeroes istead of returning all the zeroes we return single zero else we return our op string..\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863380,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] sArr = new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sArr[i] = Integer.toString(nums[i]);\\n        }\\n        //we need to sort numbers according to starting values to get highest number\\n        //Eg. 947 > 892829 \\n        //To acheive this we add two string in same and reverse order and then compare\\n        Arrays.sort(sArr,new Comparator<String>(){\\n            @Override\\n            public int compare(String a,String b){\\n                String s1 = a + b;\\n                String s2 = b + a;\\n                return s2.compareTo(s1);\\n            }\\n        });\\n        \\n        //if large number is zero then all the numbers are zeroes\\n        //we dont need remaining zeroes \"00000\" => \"0\"\\n        if(sArr[0].equals(\"0\")){\\n            return \"0\";\\n        }\\n        //Add all the strings \\n        StringBuilder sb = new StringBuilder();\\n        for(String s : sArr){\\n            sb.append(s);\\n        }\\n         \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] sArr = new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            sArr[i] = Integer.toString(nums[i]);\\n        }\\n        //we need to sort numbers according to starting values to get highest number\\n        //Eg. 947 > 892829 \\n        //To acheive this we add two string in same and reverse order and then compare\\n        Arrays.sort(sArr,new Comparator<String>(){\\n            @Override\\n            public int compare(String a,String b){\\n                String s1 = a + b;\\n                String s2 = b + a;\\n                return s2.compareTo(s1);\\n            }\\n        });\\n        \\n        //if large number is zero then all the numbers are zeroes\\n        //we dont need remaining zeroes \"00000\" => \"0\"\\n        if(sArr[0].equals(\"0\")){\\n            return \"0\";\\n        }\\n        //Add all the strings \\n        StringBuilder sb = new StringBuilder();\\n        for(String s : sArr){\\n            sb.append(s);\\n        }\\n         \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53236,
                "title": "1-liner-in-python",
                "content": "\\n```\\nclass Solution:\\n    def largestNumber(self, nums):\\n        return str(int(\"\".join(sorted([str(x) for x in nums], \\n                        cmp = lambda a, b: int(b + a) - int(a + b)))))\\n\\n# 221/221 test cases passed.\\n# Status: Accepted\\n# Runtime: 61 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums):\\n        return str(int(\"\".join(sorted([str(x) for x in nums], \\n                        cmp = lambda a, b: int(b + a) - int(a + b)))))\\n\\n# 221/221 test cases passed.\\n# Status: Accepted\\n# Runtime: 61 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53257,
                "title": "3-line-c-extremely-concise-code",
                "content": "If you write C++, you can utilize STL to simplify your code.\\nThe code below shows why STL is great to write concise code, though the run time wasn't great because I chose to use string comparison which is expensive (not STL's fault).\\n\\n    class Solution {\\n    public:\\n        string largestNumber(vector<int>& nums) {\\n           sort(nums.begin(), nums.end(), [](int a, int b){ return to_string(a) + to_string(b) > to_string(b) + to_string(a);});\\n           string result = accumulate(nums.begin(), nums.end(), string(), [](string &r, int a){return r + to_string(a);});\\n           return result[0] == '0' ? \"0\" : result;\\n           }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int>& nums) {\\n           sort(nums.begin(), nums.end(), [](int a, int b){ return to_string(a) + to_string(b) > to_string(b) + to_string(a);}",
                "codeTag": "Java"
            },
            {
                "id": 3765084,
                "title": "simple-solution-using-sort-and-string-comparison-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        lst = []\\n\\n        for ele in nums:\\n            lst += [str(ele)]\\n        \\n        n = len(lst)\\n\\n        for i in range(n):\\n            for j in range(i+1 , n):\\n                \\n                if str(lst[i]) + str(lst[j]) > str(lst[j]) + str(lst[i]):\\n                    # if current order is greatest value .. continue\\n                    continue\\n                else:\\n                    # else swap the values ..!!!\\n                    lst[i] , lst[j] = lst[j] , lst[i]\\n        \\n        \\n        ans = \\'\\'.join(lst)\\n\\n        if int(ans) == 0:\\n            return \"0\"\\n        \\n        return ans\\n\\n        \"\"\"\\n        A = str(lst[i])\\n        B = str(lst[j])\\n\\n        if AB > BA:\\n            continue\\n        else:\\n            str(lst[i]) = B\\n            str(lst[j]) = A\\n            # to make the order as BA\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        lst = []\\n\\n        for ele in nums:\\n            lst += [str(ele)]\\n        \\n        n = len(lst)\\n\\n        for i in range(n):\\n            for j in range(i+1 , n):\\n                \\n                if str(lst[i]) + str(lst[j]) > str(lst[j]) + str(lst[i]):\\n                    # if current order is greatest value .. continue\\n                    continue\\n                else:\\n                    # else swap the values ..!!!\\n                    lst[i] , lst[j] = lst[j] , lst[i]\\n        \\n        \\n        ans = \\'\\'.join(lst)\\n\\n        if int(ans) == 0:\\n            return \"0\"\\n        \\n        return ans\\n\\n        \"\"\"\\n        A = str(lst[i])\\n        B = str(lst[j])\\n\\n        if AB > BA:\\n            continue\\n        else:\\n            str(lst[i]) = B\\n            str(lst[j]) = A\\n            # to make the order as BA\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766614,
                "title": "east-java-solution-with-comments",
                "content": "```\\npublic class Solution {\\n     public String largestNumber(int[] num) {\\n\\t\\tif(num == null || num.length == 0)\\n\\t\\t    return \"\";\\n\\t\\t\\n\\t\\t// Convert int array to String array, so we can sort later on\\n\\t\\tString[] s_num = new String[num.length];\\n\\t\\tfor(int i = 0; i < num.length; i++)\\n\\t\\t    s_num[i] = String.valueOf(num[i]);\\n\\t\\t\\t\\n\\t\\t// Comparator to decide which string should come first in concatenation\\n\\t\\tComparator<String> comp = new Comparator<String>(){\\n\\t\\t    @Override\\n\\t\\t    public int compare(String str1, String str2){\\n\\t\\t        String s1 = str1 + str2;\\n\\t\\t\\t\\tString s2 = str2 + str1;\\n\\t\\t\\t\\treturn s2.compareTo(s1); // reverse order here, so we can do append() later\\n\\t\\t    }\\n\\t     };\\n\\t\\t\\n\\t\\tArrays.sort(s_num, comp);\\n\\t\\t// An extreme edge case by lc, say you have only a bunch of 0 in your int array\\n\\t\\tif(s_num[0].charAt(0) == \\'0\\')\\n\\t\\t\\treturn \"0\";\\n            \\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor(String s: s_num)\\n\\t        sb.append(s);\\n\\t\\t\\n\\t\\treturn sb.toString();\\n\\t\\t\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n     public String largestNumber(int[] num) {\\n\\t\\tif(num == null || num.length == 0)\\n\\t\\t    return \"\";\\n\\t\\t\\n\\t\\t// Convert int array to String array, so we can sort later on\\n\\t\\tString[] s_num = new String[num.length];\\n\\t\\tfor(int i = 0; i < num.length; i++)\\n\\t\\t    s_num[i] = String.valueOf(num[i]);\\n\\t\\t\\t\\n\\t\\t// Comparator to decide which string should come first in concatenation\\n\\t\\tComparator<String> comp = new Comparator<String>(){\\n\\t\\t    @Override\\n\\t\\t    public int compare(String str1, String str2){\\n\\t\\t        String s1 = str1 + str2;\\n\\t\\t\\t\\tString s2 = str2 + str1;\\n\\t\\t\\t\\treturn s2.compareTo(s1); // reverse order here, so we can do append() later\\n\\t\\t    }\\n\\t     };\\n\\t\\t\\n\\t\\tArrays.sort(s_num, comp);\\n\\t\\t// An extreme edge case by lc, say you have only a bunch of 0 in your int array\\n\\t\\tif(s_num[0].charAt(0) == \\'0\\')\\n\\t\\t\\treturn \"0\";\\n            \\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor(String s: s_num)\\n\\t        sb.append(s);\\n\\t\\t\\n\\t\\treturn sb.toString();\\n\\t\\t\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058228,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n//here we create a custom sort function.\\n    static bool cmp(string a , string b){\\n        return a+b>b+a;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> arr; //created to convert all the elements from int to string for easy iteration.\\n        for(int i = 0 ; i<nums.size() ; i++)\\n            arr.push_back(to_string(nums[i]));\\n        \\n        sort(arr.begin() , arr.end() , cmp);\\n        string ans = \"\";\\n        //after sorting we will add all the sorted values in aur ans.\\n        for(int i = 0 ; i<arr.size() ; i++){\\n            ans+=arr[i];\\n        }\\n\\t\\t\\n\\t\\t//written to handle the corner case like [0,0,0] in these cases of all zeros we need to return 0 only. \\n        int i = 0 ; \\n        while(ans[i]==\\'0\\'){\\n            i++;\\n        }\\n        if(i==ans.size())\\n            ans=\"0\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//here we create a custom sort function.\\n    static bool cmp(string a , string b){\\n        return a+b>b+a;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> arr; //created to convert all the elements from int to string for easy iteration.\\n        for(int i = 0 ; i<nums.size() ; i++)\\n            arr.push_back(to_string(nums[i]));\\n        \\n        sort(arr.begin() , arr.end() , cmp);\\n        string ans = \"\";\\n        //after sorting we will add all the sorted values in aur ans.\\n        for(int i = 0 ; i<arr.size() ; i++){\\n            ans+=arr[i];\\n        }\\n\\t\\t\\n\\t\\t//written to handle the corner case like [0,0,0] in these cases of all zeros we need to return 0 only. \\n        int i = 0 ; \\n        while(ans[i]==\\'0\\'){\\n            i++;\\n        }\\n        if(i==ans.size())\\n            ans=\"0\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53225,
                "title": "java-priority-queue-o-n-logn-solution",
                "content": "```\\npublic class Solution {\\n    public static class LargetNumberComparator implements Comparator<String> {\\n\\n        @Override\\n        public int compare(String s1, String s2) {\\n            String str1 = s1 + s2;\\n            String str2 = s2 + s1;\\n            return str2.compareTo(str1);\\n        }\\n    }\\n\\n\\n    public static String largestNumber(int[] nums) {\\n        PriorityQueue<String> queue = new PriorityQueue<String>(new LargetNumberComparator());\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nums.length; i++){\\n            queue.add(String.valueOf(nums[i]));\\n        }\\n        boolean zero_f = true;\\n        while(!queue.isEmpty()){\\n            String tmp = queue.poll();\\n            if(!tmp.equals(\"0\")) zero_f = false;\\n            sb.append(tmp);\\n        }\\n        if(zero_f) return \"0\";\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public static class LargetNumberComparator implements Comparator<String> {\\n\\n        @Override\\n        public int compare(String s1, String s2) {\\n            String str1 = s1 + s2;\\n            String str2 = s2 + s1;\\n            return str2.compareTo(str1);\\n        }\\n    }\\n\\n\\n    public static String largestNumber(int[] nums) {\\n        PriorityQueue<String> queue = new PriorityQueue<String>(new LargetNumberComparator());\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nums.length; i++){\\n            queue.add(String.valueOf(nums[i]));\\n        }\\n        boolean zero_f = true;\\n        while(!queue.isEmpty()){\\n            String tmp = queue.poll();\\n            if(!tmp.equals(\"0\")) zero_f = false;\\n            sb.append(tmp);\\n        }\\n        if(zero_f) return \"0\";\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53232,
                "title": "c-solution-sort-function-is-essence-point",
                "content": "```\\nclass Solution {\\npublic:\\n  string largestNumber(vector<int>& nums) {\\n    string ret = \"\";\\n    sort(nums.begin(), nums.end(), compare);\\n    for (int i = 0; i < nums.size(); i ++)\\n    {\\n      ret += to_string(nums[i]);\\n    }\\n    if (ret[0] == '0')\\n    {\\n      return \"0\";\\n    }\\n    return ret;\\n  }\\n  static bool compare(int a, int b)\\n  {\\n    string x = to_string(a);\\n    string y = to_string(b);\\n\\n    return x + y > y + x;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  string largestNumber(vector<int>& nums) {\\n    string ret = \"\";\\n    sort(nums.begin(), nums.end(), compare);\\n    for (int i = 0; i < nums.size(); i ++)\\n    {\\n      ret += to_string(nums[i]);\\n    }\\n    if (ret[0] == '0')\\n    {\\n      return \"0\";\\n    }\\n    return ret;\\n  }\\n  static bool compare(int a, int b)\\n  {\\n    string x = to_string(a);\\n    string y = to_string(b);\\n\\n    return x + y > y + x;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53351,
                "title": "python-one-liner",
                "content": "I am trying to push to the limit of the length of codes. Could anyone improve on this?\\n\\nThanks to @hexchain, the current shortest version is like this:\\n\\n    def largestNumber(self, num):\\n        return str(int(\"\".join(sorted(map(str,num), key=lambda x:-float(x)/(10**len(x)-1)))))",
                "solutionTags": [],
                "code": "I am trying to push to the limit of the length of codes. Could anyone improve on this?\\n\\nThanks to @hexchain, the current shortest version is like this:\\n\\n    def largestNumber(self, num):\\n        return str(int(\"\".join(sorted(map(str,num), key=lambda x:-float(x)/(10**len(x)-1)))))",
                "codeTag": "Python3"
            },
            {
                "id": 53164,
                "title": "how-to-prove-that-comparator-based-solutions-are-correct",
                "content": "Most solutions in the thread rely on a comparator.\\n\\nHere is an example of such one by ***liaison***: \\n\\n    class CombinationComparator implements Comparator<String> {\\n            @Override\\n            public int compare(String a, String b) {\\n                String ab = a + b;\\n                String ba = b + a;\\n    \\n                // Compare directly two options of combination.\\n                return ab.compareTo(ba);\\n            }\\n    }\\n\\nEach comparator imposes a binary relationship (see for example [http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html][1] ).  \\nFor two strings A and B it will establish a binary relationship *lessOrEqual(A, B)* that holds if  AB <= BA. \\nAccording to requirements to a comparator, this relationship has to be a total order. How can we prove that? How to reasonably justify that it will be a transitive relationship as required by Comparator contract? \\n\\nI.e. why is it that for any three numbers A, B, C  from AB<=BA, BC <= CB, follows that AC <= CA. How to prove that without considering a bunch of different possible cases?\\n\\n\\n  [1]: http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html",
                "solutionTags": [],
                "code": "Most solutions in the thread rely on a comparator.\\n\\nHere is an example of such one by ***liaison***: \\n\\n    class CombinationComparator implements Comparator<String> {\\n            @Override\\n            public int compare(String a, String b) {\\n                String ab = a + b;\\n                String ba = b + a;\\n    \\n                // Compare directly two options of combination.\\n                return ab.compareTo(ba);\\n            }\\n    }\\n\\nEach comparator imposes a binary relationship (see for example [http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html][1] ).  \\nFor two strings A and B it will establish a binary relationship *lessOrEqual(A, B)* that holds if  AB <= BA. \\nAccording to requirements to a comparator, this relationship has to be a total order. How can we prove that? How to reasonably justify that it will be a transitive relationship as required by Comparator contract? \\n\\nI.e. why is it that for any three numbers A, B, C  from AB<=BA, BC <= CB, follows that AC <= CA. How to prove that without considering a bunch of different possible cases?\\n\\n\\n  [1]: http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html",
                "codeTag": "Java"
            },
            {
                "id": 2370417,
                "title": "c-easy-code-with-edge-case-explanation-using-comperator",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(string a,string b){\\n        //we cannot use greater<string>() because it will fail on testcase [3,30,34,5,9]\\n        //it wll give \"9534303\" insted of \"9534330\"\\n        string x=a+b;\\n        string y=b+a;\\n        return x>y;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        string str=\"\";\\n        vector<string>v(nums.size());\\n        for(int i=0;i<nums.size();++i){\\n            v[i]=to_string(nums[i]);\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        for(int i=0;i<v.size();i++)\\n            str+=v[i];\\n        cout<<str;\\n        for(int i=0;i<str.size();i++){ //this conditon is for  testCase [0,0] \\n            if(str[i]!=\\'0\\') return str;\\n        }\\n        return \"0\";\\n    }\\n};\\n**If U Like It Plz Upvote.**\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(string a,string b){\\n        //we cannot use greater<string>() because it will fail on testcase [3,30,34,5,9]\\n        //it wll give \"9534303\" insted of \"9534330\"\\n        string x=a+b;\\n        string y=b+a;\\n        return x>y;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        string str=\"\";\\n        vector<string>v(nums.size());\\n        for(int i=0;i<nums.size();++i){\\n            v[i]=to_string(nums[i]);\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        for(int i=0;i<v.size();i++)\\n            str+=v[i];\\n        cout<<str;\\n        for(int i=0;i<str.size();i++){ //this conditon is for  testCase [0,0] \\n            if(str[i]!=\\'0\\') return str;\\n        }\\n        return \"0\";\\n    }\\n};\\n**If U Like It Plz Upvote.**\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1395398,
                "title": "very-easy-solution-using-manual-comparator-in-c",
                "content": "\\nTime Complexity : O(nlogn)\\nMemory Complexity : O(1) \\n```\\nclass Solution {\\npublic:\\n    static bool myComparator(int a, int b)\\n    {\\n        string s1=to_string(a), s2=to_string(b);\\n        return s1+s2>s2+s1;\\n    }\\n    \\n    string largestNumber(vector<int>& nums) \\n    {\\n        string s=\"\", ns=\"\";\\n        sort(nums.begin(), nums.end(), myComparator);\\n        for(int i:nums) s+=to_string(i);\\n        if(s[0]==\\'0\\') return \"0\";\\n        return s;\\n    }\\n};\\n```\\nEdge Case : [0,0,0,0,0]\\nExpected Output : \"0\" (and NOT \"00000\")\\n\\n(Upvote the answer if you find it helpful. Thank You)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool myComparator(int a, int b)\\n    {\\n        string s1=to_string(a), s2=to_string(b);\\n        return s1+s2>s2+s1;\\n    }\\n    \\n    string largestNumber(vector<int>& nums) \\n    {\\n        string s=\"\", ns=\"\";\\n        sort(nums.begin(), nums.end(), myComparator);\\n        for(int i:nums) s+=to_string(i);\\n        if(s[0]==\\'0\\') return \"0\";\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016443,
                "title": "c-0ms-faster-than-100-using-comparator-function",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n   static bool comp(string &s1 , string &s2){\\n        return (s1+s2) >= (s2+s1);\\n   }\\n    string largestNumber(vector<int>& nums) {\\n        int  n = nums.size();\\n        if(n==1)\\n            return to_string(nums[0]);\\n        int count=0;\\n        for(int x : nums)\\n            if(x==0)\\n                count++;\\n        if(count == n)\\n            return \"0\";\\n        vector<string> s(n,\"\");\\n        for(int i=0;i<n;i++)\\n            s[i] = to_string(nums[i]);\\n        \\n        sort(s.begin() , s.end() , comp);\\n        string ans =\"\";\\n        for(int i=0;i<n;i++)\\n            ans+= s[i];\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   static bool comp(string &s1 , string &s2){\\n        return (s1+s2) >= (s2+s1);\\n   }\\n    string largestNumber(vector<int>& nums) {\\n        int  n = nums.size();\\n        if(n==1)\\n            return to_string(nums[0]);\\n        int count=0;\\n        for(int x : nums)\\n            if(x==0)\\n                count++;\\n        if(count == n)\\n            return \"0\";\\n        vector<string> s(n,\"\");\\n        for(int i=0;i<n;i++)\\n            s[i] = to_string(nums[i]);\\n        \\n        sort(s.begin() , s.end() , comp);\\n        string ans =\"\";\\n        for(int i=0;i<n;i++)\\n            ans+= s[i];\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863466,
                "title": "java-easy",
                "content": "```\\nThe idea is to keep the largest digit as left as possible\\n```\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int num : nums) list.add(num);\\n        Collections.sort(list, (a, b) -> {\\n            String n1 = String.valueOf(a);\\n            String n2 = String.valueOf(b);\\n            return (n2 + n1).compareTo(n1 + n2);\\n        });\\n        StringBuilder ans = new StringBuilder();\\n        for(int num : list) ans.append(num);\\n        while(ans.length() > 1 && ans.charAt(0) == \\'0\\') ans.deleteCharAt(0);\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThe idea is to keep the largest digit as left as possible\\n```\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int num : nums) list.add(num);\\n        Collections.sort(list, (a, b) -> {\\n            String n1 = String.valueOf(a);\\n            String n2 = String.valueOf(b);\\n            return (n2 + n1).compareTo(n1 + n2);\\n        });\\n        StringBuilder ans = new StringBuilder();\\n        for(int num : list) ans.append(num);\\n        while(ans.length() > 1 && ans.charAt(0) == \\'0\\') ans.deleteCharAt(0);\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510085,
                "title": "javascript-solution",
                "content": "```js\\nfunction largestNumber(nums) {\\n  let sorted = nums.sort((a, b) => `${b}${a}` - `${a}${b}`).join(\\'\\');\\n  return sorted == 0 ? \\'0\\' : sorted;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction largestNumber(nums) {\\n  let sorted = nums.sort((a, b) => `${b}${a}` - `${a}${b}`).join(\\'\\');\\n  return sorted == 0 ? \\'0\\' : sorted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255814,
                "title": "golang",
                "content": "```\\nfunc largestNumber(nums []int) string {\\n\\tstrs := make([]string, len(nums))\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tstrs[i] = strconv.Itoa(nums[i])\\n\\t}\\n\\tsort.Slice(strs, func(i, j int) bool {\\n\\t\\treturn (strs[i] + strs[j]) > (strs[j] + strs[i])\\n\\t})\\n\\tnumsStr := strings.Join(strs, \"\")\\n\\tnumsStr = strings.TrimLeft(numsStr, \"0\")\\n\\tif numsStr == \"\" {\\n\\t\\treturn \"0\"\\n\\t}\\n\\treturn numsStr\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestNumber(nums []int) string {\\n\\tstrs := make([]string, len(nums))\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tstrs[i] = strconv.Itoa(nums[i])\\n\\t}\\n\\tsort.Slice(strs, func(i, j int) bool {\\n\\t\\treturn (strs[i] + strs[j]) > (strs[j] + strs[i])\\n\\t})\\n\\tnumsStr := strings.Join(strs, \"\")\\n\\tnumsStr = strings.TrimLeft(numsStr, \"0\")\\n\\tif numsStr == \"\" {\\n\\t\\treturn \"0\"\\n\\t}\\n\\treturn numsStr\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53163,
                "title": "solve-this-problem-by-python3-x",
                "content": "In python3.x, the sorted() builtin and the list.sort() method no longer accept a cmp function. But we can easily accomplish it using cmp_to_key.\\n```\\nfrom functools import cmp_to_key\\n\\n\\nclass Solution:\\n    # @param {integer[]} nums\\n    # @return {string}\\n    def largestNumber(self, nums):\\n        def mycmp(x, y):\\n            if x + y > y + x:\\n                return 1\\n            elif x == y:\\n                return 0\\n            else:\\n                return -1\\n\\n        nums = list(map(str, nums))\\n        nums.sort(key=cmp_to_key(mycmp), reverse=True)\\n        return \"\".join(nums).lstrip(\"0\") or \"0\"\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import cmp_to_key\\n\\n\\nclass Solution:\\n    # @param {integer[]} nums\\n    # @return {string}\\n    def largestNumber(self, nums):\\n        def mycmp(x, y):\\n            if x + y > y + x:\\n                return 1\\n            elif x == y:\\n                return 0\\n            else:\\n                return -1\\n\\n        nums = list(map(str, nums))\\n        nums.sort(key=cmp_to_key(mycmp), reverse=True)\\n        return \"\".join(nums).lstrip(\"0\") or \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53299,
                "title": "python-using-cmp-function-with-sort",
                "content": "    def largestNumber(self, nums):\\n        if not nums:\\n            return 0\\n            \\n        def compare(n1, n2):\\n            if int(n1+n2)>int(n2+n1):\\n                return -1\\n            else:\\n                return 1\\n            \\n        nums = map(str, nums)\\n        nums.sort(cmp = compare)\\n        return str(int(''.join(nums)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def largestNumber(self, nums):\\n        if not nums:\\n            return 0\\n            \\n        def compare(n1, n2):\\n            if int(n1+n2)>int(n2+n1):\\n                return -1\\n            else:\\n                return 1\\n            \\n        nums = map(str, nums)\\n        nums.sort(cmp = compare)\\n        return str(int(''.join(nums)))",
                "codeTag": "Python3"
            },
            {
                "id": 53308,
                "title": "my-simple-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string largestNumber(vector<int>& nums) {\\n            sort(nums.begin(), nums.end(), [](const int &a, const int &b)\\n            {\\n                return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n            });\\n            string ret = \"\";\\n            for (auto &v : nums) ret += to_string(v);\\n            return ret[0] == '0' ? \"0\" : ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int>& nums) {\\n            sort(nums.begin(), nums.end(), [](const int &a, const int &b)\\n            {\\n                return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 53166,
                "title": "4ms-solution-in-c",
                "content": "    int cmp(const void * a, const void * b){\\n    \\tchar * str1 = *(char**)a;\\n    \\tchar * str2 = *(char**)b;\\n    \\tstatic buffer1[24] = { 0 };\\n    \\tstatic buffer2[24] = { 0 };\\n    \\n    \\tbuffer1[0] = buffer2[0] = 0;\\n    \\n    \\tstrcat(buffer1, str1);\\n    \\tstrcat(buffer1, str2);\\n    \\tstrcat(buffer2, str2);\\n    \\tstrcat(buffer2, str1);\\n    \\treturn strcmp(buffer1, buffer2);\\n    }\\n    void printStrArr(char ** as, int num){\\n    \\tfor (int i = 0; i < num; ++i)\\n    \\t\\tprintf(\"%s\\\\n\", as[i]);\\n    }\\n    char* largestNumber(int* nums, int numsSize) {\\n    \\tif (numsSize<1) return NULL;\\n    \\tchar ** numstring = malloc(sizeof(char*)* numsSize);\\n    \\tfor (int i = 0; i < numsSize; ++i){\\n    \\t\\tchar * s = malloc(sizeof(char)* 12);\\n    \\t\\tsprintf(s, \"%d\", nums[i]);\\n    \\t\\tnumstring[i] = s;\\n    \\t}\\n    \\t//cmp(numstring[0], numstring[1]);\\n    //\\tprintStrArr(numstring, numsSize);\\n    \\tqsort(numstring, numsSize, sizeof(char*), cmp);\\n    //\\tprintStrArr(numstring, numsSize);\\n    \\t// cat all string\\n    \\tchar * buffer = malloc(sizeof(char) * 1280);\\n    \\tbuffer[0] = 0;\\n    \\n    \\tfor (int i = (numsSize - 1); i >= 0; --i){\\n    \\t\\tstrcat(buffer, numstring[i]);\\n    \\t\\tfree(numstring[i]);\\n    \\t}\\n        // all zeros\\n        if(buffer[0] == '0')\\n            buffer[1] = 0;\\n    \\treturn buffer;\\n    }",
                "solutionTags": [],
                "code": "    int cmp(const void * a, const void * b){\\n    \\tchar * str1 = *(char**)a;\\n    \\tchar * str2 = *(char**)b;\\n    \\tstatic buffer1[24] = { 0 };\\n    \\tstatic buffer2[24] = { 0 };\\n    \\n    \\tbuffer1[0] = buffer2[0] = 0;\\n    \\n    \\tstrcat(buffer1, str1);\\n    \\tstrcat(buffer1, str2);\\n    \\tstrcat(buffer2, str2);\\n    \\tstrcat(buffer2, str1);\\n    \\treturn strcmp(buffer1, buffer2);\\n    }\\n    void printStrArr(char ** as, int num){\\n    \\tfor (int i = 0; i < num; ++i)\\n    \\t\\tprintf(\"%s\\\\n\", as[i]);\\n    }\\n    char* largestNumber(int* nums, int numsSize) {\\n    \\tif (numsSize<1) return NULL;\\n    \\tchar ** numstring = malloc(sizeof(char*)* numsSize);\\n    \\tfor (int i = 0; i < numsSize; ++i){\\n    \\t\\tchar * s = malloc(sizeof(char)* 12);\\n    \\t\\tsprintf(s, \"%d\", nums[i]);\\n    \\t\\tnumstring[i] = s;\\n    \\t}\\n    \\t//cmp(numstring[0], numstring[1]);\\n    //\\tprintStrArr(numstring, numsSize);\\n    \\tqsort(numstring, numsSize, sizeof(char*), cmp);\\n    //\\tprintStrArr(numstring, numsSize);\\n    \\t// cat all string\\n    \\tchar * buffer = malloc(sizeof(char) * 1280);\\n    \\tbuffer[0] = 0;\\n    \\n    \\tfor (int i = (numsSize - 1); i >= 0; --i){\\n    \\t\\tstrcat(buffer, numstring[i]);\\n    \\t\\tfree(numstring[i]);\\n    \\t}\\n        // all zeros\\n        if(buffer[0] == '0')\\n            buffer[1] = 0;\\n    \\treturn buffer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3811559,
                "title": "beats-97-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String s[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            s[i]=String.valueOf(nums[i]);\\n        }\\n        StringBuilder sb=new StringBuilder(\"\");\\n        Arrays.sort(s,(a,b)->(b+a).compareTo(a+b));\\n        for(String str:s)\\n        {\\n            sb.append(str);\\n        }\\n        String result=sb.toString();\\n        return result.startsWith(\"0\")?\"0\":result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String s[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            s[i]=String.valueOf(nums[i]);\\n        }\\n        StringBuilder sb=new StringBuilder(\"\");\\n        Arrays.sort(s,(a,b)->(b+a).compareTo(a+b));\\n        for(String str:s)\\n        {\\n            sb.append(str);\\n        }\\n        String result=sb.toString();\\n        return result.startsWith(\"0\")?\"0\":result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428129,
                "title": "100-beats-on-c-sol-n-approch-will-be-given",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nreturn should be a string so atfirst we convert the number to string and sort the string descending order using mycomp function which is return static bool. after that all the vector of string stored in one string and return. for if ans of 0th index char was 0 the we\\'ll return 0;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   static bool mycomp(string a, string b){\\n\\n       string s1=a+b;\\n       string s2=b+a;\\n\\n           return s1 > s2;\\n    \\n   }\\n    string largestNumber(vector<int>& nums) {\\n\\n       \\n        vector<string>ans;\\n\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(to_string(nums[i]));\\n\\n        }\\n\\n      \\n        sort(ans.begin(),ans.end() , mycomp);\\n\\n        if(ans[0]==\"0\"){\\n            return \"0\";\\n        }\\n\\n        string main=\"\";\\n\\n        for(int i=0;i<ans.size();i++){\\n\\n            main+=ans[i];\\n\\n        }\\n\\n        return main;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   static bool mycomp(string a, string b){\\n\\n       string s1=a+b;\\n       string s2=b+a;\\n\\n           return s1 > s2;\\n    \\n   }\\n    string largestNumber(vector<int>& nums) {\\n\\n       \\n        vector<string>ans;\\n\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(to_string(nums[i]));\\n\\n        }\\n\\n      \\n        sort(ans.begin(),ans.end() , mycomp);\\n\\n        if(ans[0]==\"0\"){\\n            return \"0\";\\n        }\\n\\n        string main=\"\";\\n\\n        for(int i=0;i<ans.size();i++){\\n\\n            main+=ans[i];\\n\\n        }\\n\\n        return main;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198582,
                "title": "c-c-python-java-easy-solution-custom-comparer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Upvote Please\\n```\\npublic class Solution {\\n    public string LargestNumber(int[] arr) {\\n        if(arr.All(_ => _ == 0)){\\n            return \"0\";\\n        }\\n        string result;\\n        Array.Sort(arr,delegate(int num1,int num2){\\n        return Convert.ToInt64(Convert.ToString(num2)+Convert.ToString(num1))\\n        .CompareTo(Convert.ToInt64(Convert.ToString(num1)+Convert.ToString(num2)));});\\n        result=string.Join(\"\",arr);\\n        return result;\\n    }\\n}\\n```\\n\\n# Python Solution -- Modify and work\\n\\n    from functools import cmp_to_key\\n    def compare(str1,str2):\\n        return int(str1+str2) - int(str2+str1)\\n\\n    def highestPosNum(arr):\\n        sortArray = sorted(arr, key=cmp_to_key(compare) ,reverse = True)\\n        print(sortArray)\\n        result = \"\".join(sortArray)\\n        print(result)\\n\\n# \\uD83D\\uDE4CUpvote Please \\uD83E\\uDD1E\\uD83D\\uDE80",
                "solutionTags": [
                    "C#",
                    "Array",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestNumber(int[] arr) {\\n        if(arr.All(_ => _ == 0)){\\n            return \"0\";\\n        }\\n        string result;\\n        Array.Sort(arr,delegate(int num1,int num2){\\n        return Convert.ToInt64(Convert.ToString(num2)+Convert.ToString(num1))\\n        .CompareTo(Convert.ToInt64(Convert.ToString(num1)+Convert.ToString(num2)));});\\n        result=string.Join(\"\",arr);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010602,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool comp(string a, string b){\\n        return a+b>b+a;\\n    }\\n\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> ans;\\n\\n        for(int i:nums)ans.push_back(to_string(i));\\n\\n        sort(ans.begin(),ans.end(),comp);\\n\\n        string res;\\n\\n        for(auto i : ans)res+=i;\\n\\n        return res[0]==\\'0\\' ? \"0\":res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool comp(string a, string b){\\n        return a+b>b+a;\\n    }\\n\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> ans;\\n\\n        for(int i:nums)ans.push_back(to_string(i));\\n\\n        sort(ans.begin(),ans.end(),comp);\\n\\n        string res;\\n\\n        for(auto i : ans)res+=i;\\n\\n        return res[0]==\\'0\\' ? \"0\":res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608900,
                "title": "most-easy-javascript",
                "content": "nums.sort((a, b) => `${b}${a}` - `${a}${b}`);\\n    return nums[0] === 0 ? \\'\\'+nums[0] : nums.join(\\'\\');",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "nums.sort((a, b) => `${b}${a}` - `${a}${b}`);\\n    return nums[0] === 0 ? \\'\\'+nums[0] : nums.join(\\'\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1365611,
                "title": "c-simple-solution",
                "content": "```\\n bool compare(string a,string b){\\n        return a+b > b+a;\\n    }\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(to_string(nums[i]));\\n        } \\n        sort(ans.begin(),ans.end(),compare);\\n        string res;\\n        for(string i:ans){\\n            res+=i;\\n        }\\n        if(res[0]==\\'0\\'){\\n            return \"0\";\\n        }\\n        return res;\\n    }\\n};\\n```\\n**if you like the solution upvote it and encourage me.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n bool compare(string a,string b){\\n        return a+b > b+a;\\n    }\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(to_string(nums[i]));\\n        } \\n        sort(ans.begin(),ans.end(),compare);\\n        string res;\\n        for(string i:ans){\\n            res+=i;\\n        }\\n        if(res[0]==\\'0\\'){\\n            return \"0\";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864833,
                "title": "c-solution",
                "content": "* Time complexity: O(nlogn)\\n\\tPrecisely time complexity is O(k*nlogn) where k is the average length of each num coverted to string and n is the length of nums. \\n* Space complexity: O(n)\\n\\n```\\npublic class Solution {\\n    public string LargestNumber(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return \"0\";\\n        \\n        string[] arr = new string[nums.Length];\\n        for(int i = 0; i < nums.Length; i++)\\n            arr[i] = nums[i].ToString();\\n           \\n        Array.Sort(arr, (a,b) =>\\n                   {\\n                      return (b + a).CompareTo(a + b); \\n                   });\\n        \\n        if(arr[0] == \"0\")\\n            return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        foreach(string s in arr)\\n            sb.Append(s);\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LargestNumber(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return \"0\";\\n        \\n        string[] arr = new string[nums.Length];\\n        for(int i = 0; i < nums.Length; i++)\\n            arr[i] = nums[i].ToString();\\n           \\n        Array.Sort(arr, (a,b) =>\\n                   {\\n                      return (b + a).CompareTo(a + b); \\n                   });\\n        \\n        if(arr[0] == \"0\")\\n            return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        foreach(string s in arr)\\n            sb.Append(s);\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864518,
                "title": "javascript-typescript-solution",
                "content": "// JS\\n// Runtime: 88 ms, faster than 51.58% of JavaScript online submissions for Largest Number.\\n// Memory Usage: 40.9 MB, less than 12.63% of JavaScript online submissions for Largest Number.\\n```\\nvar largestNumber = function (nums) {\\n  const res = nums\\n    .map(String)\\n    .sort((a, b) => {\\n      return a.concat(b) > b.concat(a) ? -1 : 1;\\n    })\\n    .join(\\'\\');\\n\\n  return res.charAt(0) === \\'0\\' ? \\'0\\' : res;\\n};\\n```\\n// TS\\n// Runtime: 84 ms, faster than 87.50% of TypeScript online submissions for Largest Number.\\n// Memory Usage: 40.5 MB, less than 12.50% of TypeScript online submissions for Largest Number.\\n```\\nfunction largestNumber(nums: number[]): string {\\n  const res = nums\\n    .map(String)\\n    .sort((a, b) => {\\n      return a.concat(b) > b.concat(a) ? -1 : 1;\\n    })\\n    .join(\\'\\');\\n\\n  return res.charAt(0) === \\'0\\' ? \\'0\\' : res;\\n}\\n```\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar largestNumber = function (nums) {\\n  const res = nums\\n    .map(String)\\n    .sort((a, b) => {\\n      return a.concat(b) > b.concat(a) ? -1 : 1;\\n    })\\n    .join(\\'\\');\\n\\n  return res.charAt(0) === \\'0\\' ? \\'0\\' : res;\\n};\\n```\n```\\nfunction largestNumber(nums: number[]): string {\\n  const res = nums\\n    .map(String)\\n    .sort((a, b) => {\\n      return a.concat(b) > b.concat(a) ? -1 : 1;\\n    })\\n    .join(\\'\\');\\n\\n  return res.charAt(0) === \\'0\\' ? \\'0\\' : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796262,
                "title": "fastest-typescript-javascript-solution-100-memory-and-100-space",
                "content": "```\\nfunction largestNumber(nums: number[]): string {\\n    if(nums.length <= 1) return nums.toString();\\n    let sorted = nums.map(n => n.toString()).sort((a, b) => {\\n        if(a.concat(b) > b.concat(a)) return -1;\\n        return 1;\\n    });\\n    if(sorted[0] === \"0\") return \"0\";\\n    return sorted.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "String"
                ],
                "code": "```\\nfunction largestNumber(nums: number[]): string {\\n    if(nums.length <= 1) return nums.toString();\\n    let sorted = nums.map(n => n.toString()).sort((a, b) => {\\n        if(a.concat(b) > b.concat(a)) return -1;\\n        return 1;\\n    });\\n    if(sorted[0] === \"0\") return \"0\";\\n    return sorted.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514705,
                "title": "java-clean-solution-5-ms-faster-than-67-86",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] str = new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            str[i]=String.valueOf(nums[i]);\\n        }\\n        Arrays.sort(str,(o1,o2)->{\\n\\t            String s1=o1+o2;\\n                String s2=o2+o1;\\n                return s2.compareTo(s1);\\n\\t        });\\n       \\n        if(\"0\".equals(str[0])){\\n            return str[0];\\n        }\\n        StringBuilder sb=new StringBuilder(nums.length);\\n        for(String s:str){\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] str = new String[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            str[i]=String.valueOf(nums[i]);\\n        }\\n        Arrays.sort(str,(o1,o2)->{\\n\\t            String s1=o1+o2;\\n                String s2=o2+o1;\\n                return s2.compareTo(s1);\\n\\t        });\\n       \\n        if(\"0\".equals(str[0])){\\n            return str[0];\\n        }\\n        StringBuilder sb=new StringBuilder(nums.length);\\n        for(String s:str){\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214614,
                "title": "1-line-scala",
                "content": "```\\nobject Solution {\\n  def largestNumber(nums: Array[Int]): String = {\\n    BigInt(nums.map(_.toString).sortWith((l, r) => l ++ r >= r ++ l).foldLeft(\"\")(_ + _)).toString\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def largestNumber(nums: Array[Int]): String = {\\n    BigInt(nums.map(_.toString).sortWith((l, r) => l ++ r >= r ++ l).foldLeft(\"\")(_ + _)).toString\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53168,
                "title": "my-python-solution-to-share-use-mergesort",
                "content": "Since we can realize that AB > BA,A should be put in front of B\\n\\n```\\nclass Solution:\\n    # @param {integer[]} nums\\n    # @return {string}\\n    def largestNumber(self, num):\\n        num = [str(x) for x in num]\\n        num = self.mergeSort(num)\\n        return str(int(\"\".join(num)))\\n    \\n    def mergeArray(self,left, right):\\n        \"\"\"\\n            merge the left and right array\\n        \"\"\"\\n        res = []\\n        i = j = 0\\n        while i < len(left) and j < len(right):\\n            if int(left[i] + right[j]) < int(right[j] + left[i]):\\n                res.append(right[j])\\n                j += 1\\n            else:\\n                res.append(left[i])\\n                i += 1\\n        while i < len(left):\\n            res.append(left[i])\\n            i += 1\\n        \\n        while j < len(right):\\n            res.append(right[j])\\n            j += 1\\n        return res\\n                \\n    def mergeSort(self,lists):\\n        if len(lists) <= 1:\\n            return lists\\n        mid = int(len(lists)/2)\\n        left = self.mergeSort(lists[:mid])\\n        right = self.mergeSort(lists[mid:])\\n        return self.mergeArray(left,right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # @param {integer[]} nums\\n    # @return {string}\\n    def largestNumber(self, num):\\n        num = [str(x) for x in num]\\n        num = self.mergeSort(num)\\n        return str(int(\"\".join(num)))\\n    \\n    def mergeArray(self,left, right):\\n        \"\"\"\\n            merge the left and right array\\n        \"\"\"\\n        res = []\\n        i = j = 0\\n        while i < len(left) and j < len(right):\\n            if int(left[i] + right[j]) < int(right[j] + left[i]):\\n                res.append(right[j])\\n                j += 1\\n            else:\\n                res.append(left[i])\\n                i += 1\\n        while i < len(left):\\n            res.append(left[i])\\n            i += 1\\n        \\n        while j < len(right):\\n            res.append(right[j])\\n            j += 1\\n        return res\\n                \\n    def mergeSort(self,lists):\\n        if len(lists) <= 1:\\n            return lists\\n        mid = int(len(lists)/2)\\n        left = self.mergeSort(lists[:mid])\\n        right = self.mergeSort(lists[mid:])\\n        return self.mergeArray(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53304,
                "title": "simple-and-clean-java-solution-commented",
                "content": "     public String largestNumber(int[] nums) {\\n    \\t//Convert to string array.\\n    \\tList<String> snums = new ArrayList<>(nums.length);\\n    \\tfor (int i = 0; i < nums.length; i++) {\\n    \\t\\tsnums.add(Integer.toString(nums[i]));\\n    \\t} \\n    \\t//sort based on the criterion whichever generates a bigger number in descending order.\\n        Collections.sort(snums, (a, b)-> {\\n        \\tString s1 = a + b;\\n        \\tString s2 = b + a;\\n        \\treturn s2.compareTo(s1);\\n        });\\n        //remove leading zeros.\\n        int k = 0;\\n        while (k < snums.size() - 1 && snums.get(k).equals(\"0\")) \\n        \\tk++;\\n        \\n        //output the result.\\n        StringBuffer ans = new StringBuffer();\\n        for (int i = k; i < snums.size(); i++) {\\n        \\tans.append(snums.get(i)); \\t\\n        }\\n        return ans.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public String largestNumber(int[] nums) {\\n    \\t//Convert to string array.\\n    \\tList<String> snums = new ArrayList<>(nums.length);\\n    \\tfor (int i = 0; i < nums.length; i++) {\\n    \\t\\tsnums.add(Integer.toString(nums[i]));\\n    \\t} \\n    \\t//sort based on the criterion whichever generates a bigger number in descending order.\\n        Collections.sort(snums, (a, b)-> {\\n        \\tString s1 = a + b;\\n        \\tString s2 = b + a;\\n        \\treturn s2.compareTo(s1);\\n        });\\n        //remove leading zeros.\\n        int k = 0;\\n        while (k < snums.size() - 1 && snums.get(k).equals(\"0\")) \\n        \\tk++;\\n        \\n        //output the result.\\n        StringBuffer ans = new StringBuffer();\\n        for (int i = k; i < snums.size(); i++) {\\n        \\tans.append(snums.get(i)); \\t\\n        }\\n        return ans.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 53362,
                "title": "share-to-simple-solution-using-customized-comparator-c",
                "content": "    struct less_than_key\\n    {\\n        inline bool operator() (int s1, int s2)\\n        {\\n            string t1=to_string(s1)+to_string(s2);\\n            string t2=to_string(s2)+to_string(s1);\\n            \\n            return (t1.compare(t2)>0);\\n        }\\n    };\\n    \\n    class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            \\n            sort(num.begin(),num.end(),less_than_key());\\n            \\n            string r=\"\";\\n            for(int i=0;i<num.size();i++)\\n            {\\n                r.append(to_string(num[i]));\\n            }\\n            if(r[0]=='0') return \"0\";\\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            \\n            sort(num.begin(),num.end(),less_than_key());\\n            \\n            string r=\"\";\\n            for(int i=0;i<num.size();i++)\\n            {\\n                r.append(to_string(num[i]));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 53372,
                "title": "showcase-c-code-4-lines-can-get-it-done",
                "content": "Do not get me wrong I am working with Java    \\n\\n    internal static string LargestNumber(List<int> vals)\\n        \\t{\\n        \\t\\tif(vals==null || vals.Count==0)\\n        \\t\\t\\treturn \"\";\\n        \\t\\tvals.Sort((a,b)=>String.Compare(b+\"\"+a,a+\"\"+b));\\n        \\t\\treturn vals[0]==0?\"0\":String.Join(\"\",vals);\\n        \\t}",
                "solutionTags": [],
                "code": "Do not get me wrong I am working with Java    \\n\\n    internal static string LargestNumber(List<int> vals)\\n        \\t{\\n        \\t\\tif(vals==null || vals.Count==0)\\n        \\t\\t\\treturn \"\";\\n        \\t\\tvals.Sort((a,b)=>String.Compare(b+\"\"+a,a+\"\"+b));\\n        \\t\\treturn vals[0]==0?\"0\":String.Join(\"\",vals);\\n        \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 53395,
                "title": "python-wrong-answer",
                "content": "Hi all, \\n\\nhere is a simple python code for this question, but I can't figure out a test case\\n\\n    class Solution:\\n    # @param num, a list of integers\\n    # @return a string\\n    def largestNumber(self, num):\\n        num = [str(x) for x in num]\\n        num.sort(cmp=lambda x, y: cmp(y+x, x+y))\\n        ret = ''.join(num)\\n        return ret.lstrip('0') or '0'\\n\\nThe idea is simple, first I convert all int in num to strings, then provide a custom compare function. In this lambda function, just concatenate and compare (y+x) and (x+y, the reason to switch (x+y) and (y+x) is because we want this array to be sorted in decreasing order.\\n\\nFor example, \\n\\ncmp(22, 221) -> should form 22221 (because 22221>22122), hence cmp(22,221) == -1\\n\\nMost of the test cases run through fine but the longest test case\\n\\n[6306,9385,7536,3462,4798,5422,5529,8070,6241,9094,7846,663,6221,216,6758,8353,3650,3836,8183,3516,5909,6744,1548,5712,2281......]\\n\\nFailed saying \"Wrong Answer\" and there is no Output.\\n\\nI tried this test case on my own machine and the function works perfectly. \\nI guess there is something wrong with the system for python?",
                "solutionTags": [],
                "code": "Hi all, \\n\\nhere is a simple python code for this question, but I can't figure out a test case\\n\\n    class Solution:\\n    # @param num, a list of integers\\n    # @return a string\\n    def largestNumber(self, num):\\n        num = [str(x) for x in num]\\n        num.sort(cmp=lambda x, y: cmp(y+x, x+y))\\n        ret = ''.join(num)\\n        return ret.lstrip('0') or '0'\\n\\nThe idea is simple, first I convert all int in num to strings, then provide a custom compare function. In this lambda function, just concatenate and compare (y+x) and (x+y, the reason to switch (x+y) and (y+x) is because we want this array to be sorted in decreasing order.\\n\\nFor example, \\n\\ncmp(22, 221) -> should form 22221 (because 22221>22122), hence cmp(22,221) == -1\\n\\nMost of the test cases run through fine but the longest test case\\n\\n[6306,9385,7536,3462,4798,5422,5529,8070,6241,9094,7846,663,6221,216,6758,8353,3650,3836,8183,3516,5909,6744,1548,5712,2281......]\\n\\nFailed saying \"Wrong Answer\" and there is no Output.\\n\\nI tried this test case on my own machine and the function works perfectly. \\nI guess there is something wrong with the system for python?",
                "codeTag": "Java"
            },
            {
                "id": 3291587,
                "title": "quite-short-kotlin-solution",
                "content": "Could be even shorter, but Leetcode still uses Kotlin 1.3, so `Comparator<Int>` declaration cannot be omitted.\\n\\n```\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String =\\n        nums.sortedWith(Comparator<Int> { a, b -> \"$b$a\".compareTo(\"$a$b\") })\\n            .takeIf { it.firstOrNull() != 0 }\\n            ?.joinToString(\"\") ?: \"0\"\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String =\\n        nums.sortedWith(Comparator<Int> { a, b -> \"$b$a\".compareTo(\"$a$b\") })\\n            .takeIf { it.firstOrNull() != 0 }\\n            ?.joinToString(\"\") ?: \"0\"\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618251,
                "title": "c-solution-largest-number-using-custom-comparator",
                "content": "**1. Custom Comparator**\\n* To construct the largest number, we want to ensure that the most significant digits are occupied by the largest digits.\\n##### Time Complexity - O(NLogN)\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(string &a, string &b){\\n        return a + b > b + a;\\n    } \\n    string largestNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        string ans = \"\";\\n        vector<string> str;\\n        for(int i = 0; i < n; i++){\\n            str.push_back(to_string(nums[i]));\\n        }\\n        \\n        sort(str.begin(), str.end(), cmp);\\n        \\n        // MSB is 0 , return 0\\n        if(str[0] == \"0\"){\\n            return \"0\";\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            ans += str[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string &a, string &b){\\n        return a + b > b + a;\\n    } \\n    string largestNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        string ans = \"\";\\n        vector<string> str;\\n        for(int i = 0; i < n; i++){\\n            str.push_back(to_string(nums[i]));\\n        }\\n        \\n        sort(str.begin(), str.end(), cmp);\\n        \\n        // MSB is 0 , return 0\\n        if(str[0] == \"0\"){\\n            return \"0\";\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            ans += str[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610256,
                "title": "c-using-array-sort-and-custom-string-comparer",
                "content": "Idea is simple.\\nconvert each numbers in array to string array.\\nNow to get largest number, we need to find the most significant number of each numbers in array in decreasing order and then concatenate the strings and return the result.\\nBut when the most significant number becomes same then we need some kind of custom comparer in which we would append the 2 strings from both side e.g str1 = a+b; str2= b+a; then compare both strings using default comparer. hence using Array.Sort and using custom comparer we will be able to sort in increasing order.\\nnow just the remaining part is to get each strings from last and keep appending in the result string builder object.\\nhere is the C# code\\n```\\npublic string LargestNumber(int[] nums) {\\n        \\n        string[] arr = new string[nums.Length];\\n        for(int i = 0; i < nums.Length; i++){\\n            arr[i] = nums[i].ToString();\\n        }\\n        \\n        Comparer<string> comparer = Comparer<string>.Default;\\n        Array.Sort<string>(arr, (x, y) =>\\n        {\\n            string str1 = x + y;\\n            string str2 = y + x;\\n            return comparer.Compare(str1, str2);\\n        });\\n        \\n        if(arr[nums.Length-1] == \"0\")\\n            return \"0\";\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = nums.Length-1; i >= 0; i--){\\n            sb.Append(arr[i]);\\n        }\\n        \\n        return sb.ToString();\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic string LargestNumber(int[] nums) {\\n        \\n        string[] arr = new string[nums.Length];\\n        for(int i = 0; i < nums.Length; i++){\\n            arr[i] = nums[i].ToString();\\n        }\\n        \\n        Comparer<string> comparer = Comparer<string>.Default;\\n        Array.Sort<string>(arr, (x, y) =>\\n        {\\n            string str1 = x + y;\\n            string str2 = y + x;\\n            return comparer.Compare(str1, str2);\\n        });\\n        \\n        if(arr[nums.Length-1] == \"0\")\\n            return \"0\";\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = nums.Length-1; i >= 0; i--){\\n            sb.Append(arr[i]);\\n        }\\n        \\n        return sb.ToString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399296,
                "title": "c-solution-fastest-custom-comparator",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), [] (int &n1, int &n2) {\\n            string num1 = to_string(n1); \\n            string num2 = to_string(n2);\\n            // Below is real beauty: xy > yx & yz > zy => xz > zx (x, y, z: +ve int)\\n            return num1 + num2 > num2 + num1;\\n        });\\n\\t\\t// Thanks @Hard_Code for suggesting: for leading zero, no need to convert number to string\\n\\t\\tif (nums[0] ==  0) return \"0\";\\n        string res = \"\";\\n        for (auto &num : nums)\\n            res += to_string(num);\\n        // return res[0] == \\'0\\' ? \"0\" : res;\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), [] (int &n1, int &n2) {\\n            string num1 = to_string(n1); \\n            string num2 = to_string(n2);\\n            // Below is real beauty: xy > yx & yz > zy => xz > zx (x, y, z: +ve int)\\n            return num1 + num2 > num2 + num1;\\n        });\\n\\t\\t// Thanks @Hard_Code for suggesting: for leading zero, no need to convert number to string\\n\\t\\tif (nums[0] ==  0) return \"0\";\\n        string res = \"\";\\n        for (auto &num : nums)\\n            res += to_string(num);\\n        // return res[0] == \\'0\\' ? \"0\" : res;\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921432,
                "title": "c-easy-solution-faster-than-98",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        \\n        vector <string> numbers;\\n        for (auto &num : nums)\\n            numbers.push_back(to_string(num));\\n        \\n        sort(numbers.begin(),numbers.end(),[](string &s1,string &s2){return s1+s2>s2+s1;});\\n        \\n        string s;\\n        for (string &number : numbers)\\n            s += number;\\n        \\n        return (s[0] == \\'0\\')? \"0\" : s;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        \\n        vector <string> numbers;\\n        for (auto &num : nums)\\n            numbers.push_back(to_string(num));\\n        \\n        sort(numbers.begin(),numbers.end(),[](string &s1,string &s2){return s1+s2>s2+s1;});\\n        \\n        string s;\\n        for (string &number : numbers)\\n            s += number;\\n        \\n        return (s[0] == \\'0\\')? \"0\" : s;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864533,
                "title": "python3-use-trie",
                "content": "Apparently, sorting is the easiest to implement. But when I saw the problem, I was devoted to using Trie to solve it. Here is the outcome. It performs well, but obviously with much larger code base.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.next = [None] * 10\\n        self.val = \\'\\'\\n\\n\\nclass Solution:\\n    def make_trie(self, node: TrieNode, n: int) -> None:\\n        nstr = str(n)\\n        for strd in nstr:  # pretty standard Trie construction\\n            intd = int(strd)\\n            if node.next[intd] is None:\\n                node.next[intd] = TrieNode()\\n            node = node.next[intd]\\n        node.val += nstr  # this is a tricky part, to handle repeated numbers\\n\\n    def arange(self, node: TrieNode) -> str:\\n        if not any(node.next) and node.val:\\n            return node.val\\n        res = \\'\\'\\n        for i in range(9, -1, -1):  # go from highest digit down\\n            if node.next[i] is not None:\\n                partial = self.arange(node.next[i])\\n                if node.val and node.val + partial > partial + node.val:\\n                    # this is a tricky part. If the node currently has a value\\n                    # attached, and there are more numbers extending from the\\n                    # current val, for each child value, we need to compare\\n                    # the outcome of different order: whether to use the node\\n                    # value before the child, or let child come out first.\\n                    # e.g. [8247, 824] => let 824 come out first because \\n                    # 8247824 < 8248247\\n                    # e.g. [128, 12] => let child come out first because\\n                    # 12812 > 12128\\n                    # e.g. [121, 12] => let 12 come out first because\\n                    # 12112 < 12121 \\n                    res += node.val + partial\\n                    node.val = \\'\\'  # node.val can only be used once\\n                else:\\n                    res += partial\\n        return res + node.val\\n\\n    def largestNumber(self, nums: List[int]) -> str:\\n        \"\"\"85 % ranking\"\"\"\\n        root = TrieNode()\\n        for n in nums:\\n            self.make_trie(root, n)\\n        res = self.arange(root)\\n        return res if res[0] != \\'0\\' else \\'0\\'  # edge case [0, 0] => \\'0\\' not \\'00\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.next = [None] * 10\\n        self.val = \\'\\'\\n\\n\\nclass Solution:\\n    def make_trie(self, node: TrieNode, n: int) -> None:\\n        nstr = str(n)\\n        for strd in nstr:  # pretty standard Trie construction\\n            intd = int(strd)\\n            if node.next[intd] is None:\\n                node.next[intd] = TrieNode()\\n            node = node.next[intd]\\n        node.val += nstr  # this is a tricky part, to handle repeated numbers\\n\\n    def arange(self, node: TrieNode) -> str:\\n        if not any(node.next) and node.val:\\n            return node.val\\n        res = \\'\\'\\n        for i in range(9, -1, -1):  # go from highest digit down\\n            if node.next[i] is not None:\\n                partial = self.arange(node.next[i])\\n                if node.val and node.val + partial > partial + node.val:\\n                    # this is a tricky part. If the node currently has a value\\n                    # attached, and there are more numbers extending from the\\n                    # current val, for each child value, we need to compare\\n                    # the outcome of different order: whether to use the node\\n                    # value before the child, or let child come out first.\\n                    # e.g. [8247, 824] => let 824 come out first because \\n                    # 8247824 < 8248247\\n                    # e.g. [128, 12] => let child come out first because\\n                    # 12812 > 12128\\n                    # e.g. [121, 12] => let 12 come out first because\\n                    # 12112 < 12121 \\n                    res += node.val + partial\\n                    node.val = \\'\\'  # node.val can only be used once\\n                else:\\n                    res += partial\\n        return res + node.val\\n\\n    def largestNumber(self, nums: List[int]) -> str:\\n        \"\"\"85 % ranking\"\"\"\\n        root = TrieNode()\\n        for n in nums:\\n            self.make_trie(root, n)\\n        res = self.arange(root)\\n        return res if res[0] != \\'0\\' else \\'0\\'  # edge case [0, 0] => \\'0\\' not \\'00\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863507,
                "title": "c-simplest-explained-solution-o-nlogn-faster-than-99-9",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> str_nums;\\n        for (auto x : nums) // turn numbers to strings\\n            str_nums.push_back(to_string(x));\\n        \\n        std::sort(str_nums.begin(), str_nums.end()); // sort by lexicographical order\\n        std::reverse(str_nums.begin(), str_nums.end());\\n        \\n        bool flag = false; // flag to keep track if there were swaps, if no more swaps needed - finished\\n        while (!flag) {\\n            flag = true;\\n            int i=0;\\n            while (i < str_nums.size()-1) {\\n                if (str_nums[i]+str_nums[i+1] < str_nums[i+1]+str_nums[i]) { // if larger when swapped - swap\\n                    std::swap(str_nums[i], str_nums[i+1]);\\n                    flag = false;\\n                }\\n                i++;\\n            }\\n        }\\n        string res = \"\";\\n        for (auto a : str_nums)\\n            res+=a;\\n        \\n        if (res[0] == \\'0\\')\\n            return \"0\";\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> str_nums;\\n        for (auto x : nums) // turn numbers to strings\\n            str_nums.push_back(to_string(x));\\n        \\n        std::sort(str_nums.begin(), str_nums.end()); // sort by lexicographical order\\n        std::reverse(str_nums.begin(), str_nums.end());\\n        \\n        bool flag = false; // flag to keep track if there were swaps, if no more swaps needed - finished\\n        while (!flag) {\\n            flag = true;\\n            int i=0;\\n            while (i < str_nums.size()-1) {\\n                if (str_nums[i]+str_nums[i+1] < str_nums[i+1]+str_nums[i]) { // if larger when swapped - swap\\n                    std::swap(str_nums[i], str_nums[i+1]);\\n                    flag = false;\\n                }\\n                i++;\\n            }\\n        }\\n        string res = \"\";\\n        for (auto a : str_nums)\\n            res+=a;\\n        \\n        if (res[0] == \\'0\\')\\n            return \"0\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807519,
                "title": "c-custom-sort",
                "content": "To much of edge cases to look for :)\\n**Status:** Accepted (32ms Code)\\n```\\nstring largestNumber(vector<int>& nums) {\\n        vector<string> container;\\n        for(int i : nums){\\n            container.push_back(to_string(i));\\n        }\\n        auto comp = [](string a, string b){\\n            string f = a + b;\\n            string s = b + a;\\n            return f > s;\\n        };\\n        sort(begin(container), end(container), comp);\\n        string res = \"\";\\n        if(container.front() == \"0\") return \"0\";\\n        for(auto i : container){\\n            res = res + i;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nstring largestNumber(vector<int>& nums) {\\n        vector<string> container;\\n        for(int i : nums){\\n            container.push_back(to_string(i));\\n        }\\n        auto comp = [](string a, string b){\\n            string f = a + b;\\n            string s = b + a;\\n            return f > s;\\n        };\\n        sort(begin(container), end(container), comp);\\n        string res = \"\";\\n        if(container.front() == \"0\") return \"0\";\\n        for(auto i : container){\\n            res = res + i;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473148,
                "title": "c-simple-solution",
                "content": "C# Simple Solution :\\n\\n``` \\npublic string LargestNumber(int[] nums) {\\n        \\n         if (nums.Any() == false) return string.Empty;\\n        \\n            var stringArray = nums.Select(x => x.ToString()).ToArray();\\n\\n            Array.Sort(stringArray, (string s1, string s2) =>\\n            {\\n                var str1 = s1 + s2;\\n                var str2 = s2 + s1;\\n                return str2.CompareTo(str1);\\n            });\\n        \\n             if(stringArray[0].Equals(\"0\"))\\n            {\\n                return \"0\";\\n            }\\n\\n            return string.Join(\"\", stringArray);\\n    }",
                "solutionTags": [],
                "code": "C# Simple Solution :\\n\\n``` \\npublic string LargestNumber(int[] nums) {\\n        \\n         if (nums.Any() == false) return string.Empty;\\n        \\n            var stringArray = nums.Select(x => x.ToString()).ToArray();\\n\\n            Array.Sort(stringArray, (string s1, string s2) =>\\n            {\\n                var str1 = s1 + s2;\\n                var str2 = s2 + s1;\\n                return str2.CompareTo(str1);\\n            });\\n        \\n             if(stringArray[0].Equals(\"0\"))\\n            {\\n                return \"0\";\\n            }\\n\\n            return string.Join(\"\", stringArray);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 469913,
                "title": "kotlin-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String {\\n        val output = nums.map {\"$it\"}.sortedWith(Comparator<String>{ a, b ->\\n            val s1 = a + b\\n            val s2 = b + a\\n            s2.compareTo(s1)\\n        }).joinToString(\"\")\\n        \\n        return if(output[0] == \\'0\\') \"0\" else output\\n    }\\n}\\n```\\n\\nHere\\'s the breakdown of each of the function calls.\\n\\nwe convert each number to String\\n``` \\nnums.map {\"$it\"} \\n```  \\n\\nWe\\'ll sort the output of map using a custom comparator.\\n```\\n.sortedWith(Comparator<String>{ a, b ->\\n            val s1 = a + b\\n            val s2 = b + a\\n            s2.compareTo(s1)\\n        })\\n```\\t\\t\\n\\nThen finally, join the sorted list together as one String.\\n```\\n.joinToString(\"\")\\n```\\n\\nHandle the edge case where the inputs are all 0s.\\n```\\nreturn if(output[0] == \\'0\\') \"0\" else output\\n```\\n\\n\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String {\\n        val output = nums.map {\"$it\"}.sortedWith(Comparator<String>{ a, b ->\\n            val s1 = a + b\\n            val s2 = b + a\\n            s2.compareTo(s1)\\n        }).joinToString(\"\")\\n        \\n        return if(output[0] == \\'0\\') \"0\" else output\\n    }\\n}\\n```\n``` \\nnums.map {\"$it\"} \\n```\n```\\n.sortedWith(Comparator<String>{ a, b ->\\n            val s1 = a + b\\n            val s2 = b + a\\n            s2.compareTo(s1)\\n        })\\n```\n```\\n.joinToString(\"\")\\n```\n```\\nreturn if(output[0] == \\'0\\') \"0\" else output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367588,
                "title": "python3-solution-using-lambda",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        \\n        maxlength = max(map(len, nums))\\n        \\n        nums.sort(key=lambda x:x*(maxlength // len(x) + 1), reverse=True)\\n        \\n        return \\'\\'.join(nums) if int(nums[0]) != 0 else \\'0\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        \\n        maxlength = max(map(len, nums))\\n        \\n        nums.sort(key=lambda x:x*(maxlength // len(x) + 1), reverse=True)\\n        \\n        return \\'\\'.join(nums) if int(nums[0]) != 0 else \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166558,
                "title": "satisfying-readable-functional-javascript-solution",
                "content": "Nearly pure functional JavaScript solution. Performs three simple transforms (each on their own line for readability):\\n1. maps nums into strings to more easily concatenate.\\n2. sorts strings by comparing both possible concatenations. \\n     - Simple case: If a is 9 and b is 2, 92 is greater than 29, so our sort function should sort a in front of b\\n     - Complex case: If a is 30 and b is 304, we\\'re effectively comparing the magnitute of 30304 and 30430\\n3. reduces sorted string array into a concatenated string\\n\\n```\\nlet largestNum = nums\\n\\t\\t.map(num => num.toString())\\n\\t\\t.sort((a, b) => parseInt(b + a) - parseInt(a + b))\\n\\t\\t.reduce((prev, curr) => prev += curr);\\n```\\n\\nWe can\\'t simply return this value given the edge case \"[0,0]\", where our output should be \"0\" and not \"00\". We then check if the first character of our largestNum is 0, and return accordingly:\\n\\n```\\nreturn largestNum.charAt(0) === \\'0\\' ? \\'0\\' : largestNum;\\n```\\n\\nI could have kept this solution \"pure\" (declaring no variables), as some one-liner solutions here have, but this would have come at the expense of readability.",
                "solutionTags": [],
                "code": "```\\nlet largestNum = nums\\n\\t\\t.map(num => num.toString())\\n\\t\\t.sort((a, b) => parseInt(b + a) - parseInt(a + b))\\n\\t\\t.reduce((prev, curr) => prev += curr);\\n```\n```\\nreturn largestNum.charAt(0) === \\'0\\' ? \\'0\\' : largestNum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140232,
                "title": "one-line-solution-in-java-accepted",
                "content": "```\\nreturn Arrays.stream(nums)\\n            .mapToObj(String::valueOf)\\n            .sorted((a, b) -> (b + a).compareTo(a + b))\\n            .reduce((a, b) -> \"0\".equals(a) ? \"0\" : a + b)\\n            .get();\\n```",
                "solutionTags": [],
                "code": "```\\nreturn Arrays.stream(nums)\\n            .mapToObj(String::valueOf)\\n            .sorted((a, b) -> (b + a).compareTo(a + b))\\n            .reduce((a, b) -> \"0\".equals(a) ? \"0\" : a + b)\\n            .get();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53197,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Largest Number** https://leetcode.com/problems/largest-number/?tab=Description\\n\\n**Algorithm**\\n* Use Python's cmp method to compare \"5\", \"9\". \"59\" < \"95\".\\n* https://docs.python.org/3/howto/sorting.html\\n\\n```\\nclass Solution(object):\\n    def largestNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: str\\n        \"\"\"\\n        if sum(nums) == 0:\\n            return \"0\"\\n        nums = [str(x) for x in nums]\\n        nums.sort(cmp=lambda x,y:int(y+x) - int(x+y))\\n        return \"\".join(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: str\\n        \"\"\"\\n        if sum(nums) == 0:\\n            return \"0\"\\n        nums = [str(x) for x in nums]\\n        nums.sort(cmp=lambda x,y:int(y+x) - int(x+y))\\n        return \"\".join(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53245,
                "title": "simple-c-solution-using-qsort-and-sprintf",
                "content": "    static int wcmp(const void *v1, const void *v2)\\n    {\\n        static char buf1[512], buf2[512];\\n        int len;\\n        len = sprintf(buf1, \"%d%d\", *(int *)v1, *(int *)v2);\\n        len = sprintf(buf2, \"%d%d\", *(int *)v2, *(int *)v1);\\n        for (int i = 0; i < len; ++i) {\\n            if (buf1[i] > buf2[i]) {\\n                return -1;\\n            }\\n            if (buf1[i] < buf2[i]) {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    char* largestNumber(int* nums, int numsSize)\\n    {\\n        static char str[1024];\\n        int i = 0, j = 0;\\n        qsort(nums, numsSize, sizeof(int), wcmp);\\n        str[0] = '0';\\n        str[1] = '\\\\0';\\n        while (i < numsSize && nums[i++] == 0);\\n        for (--i; i < numsSize; ++i) {\\n            j += sprintf(str + j, \"%d\", nums[i]);\\n        }\\n        return str;\\n    }",
                "solutionTags": [],
                "code": "    static int wcmp(const void *v1, const void *v2)\\n    {\\n        static char buf1[512], buf2[512];\\n        int len;\\n        len = sprintf(buf1, \"%d%d\", *(int *)v1, *(int *)v2);\\n        len = sprintf(buf2, \"%d%d\", *(int *)v2, *(int *)v1);\\n        for (int i = 0; i < len; ++i) {\\n            if (buf1[i] > buf2[i]) {\\n                return -1;\\n            }\\n            if (buf1[i] < buf2[i]) {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    char* largestNumber(int* nums, int numsSize)\\n    {\\n        static char str[1024];\\n        int i = 0, j = 0;\\n        qsort(nums, numsSize, sizeof(int), wcmp);\\n        str[0] = '0';\\n        str[1] = '\\\\0';\\n        while (i < numsSize && nums[i++] == 0);\\n        for (--i; i < numsSize; ++i) {\\n            j += sprintf(str + j, \"%d\", nums[i]);\\n        }\\n        return str;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 53252,
                "title": "my-4-lines-python-solution",
                "content": "    class Solution:\\n        def largestNumber(self, nums):\\n            st =  \"\".join(sorted(map(str, nums), cmp = lambda x, y: int(y + x) - int(x + y)))\\n            return  st if st[0] != \"0\" else \"0\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def largestNumber(self, nums):\\n            st =  \"\".join(sorted(map(str, nums), cmp = lambda x, y: int(y + x) - int(x + y)))\\n            return  st if st[0] != \"0\" else \"0\"",
                "codeTag": "Java"
            },
            {
                "id": 53268,
                "title": "8-ms-solution-using-c-stl-with-only-7-lines-code",
                "content": "    class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            vector<string> arr;\\n            arr.reserve(num.size());\\n    \\n            transform(num.begin(), num.end(), back_inserter(arr), \\n                        [](int x){return to_string(x);});\\n            sort(arr.begin(), arr.end(), [](string &s1, string &s2){ return s1+s2>s2+s1; });\\n            auto result = accumulate(arr.begin(), arr.end(), string());\\n            \\n            return (!result.size()||result[0]=='0')? \"0\":result;\\n        }\\n        \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            vector<string> arr;\\n            arr.reserve(num.size());\\n    \\n            transform(num.begin(), num.end(), back_inserter(arr), \\n                        [](int x){return to_string(x);}",
                "codeTag": "Java"
            },
            {
                "id": 53278,
                "title": "question-on-python-sort-comparator",
                "content": "Spend quite some time trying to figure out the difference between these two ways of using comparator:\\n\\n    def comparator(a, b):\\n        return str(a) + str(b) > str(b) + str(a)\\n    \\n    nums = [0, 23, 32]\\n    a = sorted(nums, cmp = comparator, reverse = True )\\n    b = sorted(nums, cmp = lambda a,b : cmp(str(a)+str(b), str(b)+str(a)), reverse=True)\\n\\nThe a is [0, 23, 32] whereas the b is [32, 23, 0]. Would someone please explain the difference?",
                "solutionTags": [
                    "Python"
                ],
                "code": "Spend quite some time trying to figure out the difference between these two ways of using comparator:\\n\\n    def comparator(a, b):\\n        return str(a) + str(b) > str(b) + str(a)\\n    \\n    nums = [0, 23, 32]\\n    a = sorted(nums, cmp = comparator, reverse = True )\\n    b = sorted(nums, cmp = lambda a,b : cmp(str(a)+str(b), str(b)+str(a)), reverse=True)\\n\\nThe a is [0, 23, 32] whereas the b is [32, 23, 0]. Would someone please explain the difference?",
                "codeTag": "Python3"
            },
            {
                "id": 53281,
                "title": "4ms-solution-in-c",
                "content": "Below is my solution, and the system shows it on the top of  C++. After reviewing some posts here, I've noticed many amazing short and nice answers, like this one: https://leetcode.com/discuss/32431/simple-10-line-c-solution , but I'm wondering why his code runs ~32ms, 13.78%. Can anyone give me a hint?\\n\\n    //3 change sort function, but still use return (s+t)>(t+s) \\n    //2 test auto & e :string vs auto e: string, 8ms, 93.3%, so no difference\\n    //1 use simple custom sort function, works, 8ms, 93.3%\\n    \\n    class Solution {\\n    private:\\n    static bool customStringSort(string s, string t){\\n        const char * i = s.c_str();\\n        const char * j = t.c_str();\\n     \\n        while(*i==*j){\\n            i++; j++;\\n        }\\n        if(*i =='\\\\0' &&  *j == '\\\\0') return 0;\\n        else if(*i == '\\\\0') return (s+t)>(t+s);\\n        else if(*j == '\\\\0') return (s+t)>(t+s);\\n        else return *i>*j;\\n    }\\n    \\n    public:\\n        string largestNumber(vector<int>& nums) {\\n            if(nums.empty()) return string();\\n            vector<string> words;\\n            for(auto e: nums)\\n            words.push_back(to_string(e));\\n            sort(words.begin(),words.end(), &Solution::customStringSort);\\n            \\n            if(stoi(words[0])==0)\\n            return \"0\";\\n            \\n            string res;\\n            for(auto e: words){\\n                res+=e;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n    static bool customStringSort(string s, string t){\\n        const char * i = s.c_str();\\n        const char * j = t.c_str();\\n     \\n        while(*i==*j){\\n            i++; j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 53354,
                "title": "share-my-csharp-solution-117ms",
                "content": "    public class Solution{\\n        public string LargestNumber(int[] num)\\n        {\\n            //This is awkward ;( just for test case\\n            if (Array.TrueForAll(num, x => x == 0))\\n                return \"0\";\\n\\n            Array.Sort(num,CompareNum);\\n            return String.Concat(num);\\n        }\\n\\n        private static int CompareNum(int a, int b)\\n        {\\n            string sa = b.ToString();\\n            string sb = a.ToString();\\n            return (sa + sb).CompareTo(sb + sa);\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution{\\n        public string LargestNumber(int[] num)\\n        {\\n            //This is awkward ;( just for test case\\n            if (Array.TrueForAll(num, x => x == 0))\\n                return \"0\";\\n\\n            Array.Sort(num,CompareNum);\\n            return String.Concat(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 53371,
                "title": "can-someone-figure-out-the-error-on-sort-function-line-12-invalid-use-of-non-static-member-function",
                "content": "    class Solution {\\n    public:\\n        bool compareNum(int i, int j){\\n            string x=to_string(i);\\n            string y=to_string(j);\\n            string a=x+y;\\n            string b=y+x;\\n            return a.compare(b) > 0 ? 1 : 0;\\n        }\\n        \\n        string largestNumber(vector<int> &num) {\\n            sort(num.begin(),num.end(),compareNum);\\n            string res=\"\";\\n            for(int i=0;i!=num.size();i++)\\n                res=res + to_string(num[i]);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool compareNum(int i, int j){\\n            string x=to_string(i);\\n            string y=to_string(j);\\n            string a=x+y;\\n            string b=y+x;\\n            return a.compare(b) > 0 ? 1 : 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 53381,
                "title": "a-very-concise-solution-using-c",
                "content": "The following codes are my solution to this question.\\nIt's very concise and easy to understand.\\nShare it with you.\\n\\n    class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            string str = \"\";\\n            while(!num.empty())\\n            {\\n                int n = num.size();  \\n                int j = 0;\\n                int vv = num[j];\\n                for(int i=1;i!=n;i++){\\n                    int uu = num[i];\\n                    uu = num[i];\\n                    vv = num[j];\\n                    if(uu != vv)\\n                        if(to_string(uu)+to_string(vv)>to_string(vv)+to_string(uu)){\\n                                j=i;\\n                        }\\n                }\\n                str += to_string(num[j]);\\n                num.erase(num.begin()+j);\\n            }\\n            while(str[0]=='0'&&str.size()>1) str.erase(str.begin());\\n            return str;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            string str = \"\";\\n            while(!num.empty())\\n            {\\n                int n = num.size();  \\n                int j = 0;\\n                int vv = num[j];\\n                for(int i=1;i!=n;i++){\\n                    int uu = num[i];\\n                    uu = num[i];\\n                    vv = num[j];\\n                    if(uu != vv)\\n                        if(to_string(uu)+to_string(vv)>to_string(vv)+to_string(uu)){\\n                                j=i;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 53407,
                "title": "my-o-nlogn-c-solution",
                "content": "    class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) \\n        {\\n            vector<string> snum;\\n            for (auto i : num)\\n                snum.push_back(to_string(i));\\n            \\n            sort(snum.begin(), snum.end(), \\n                [](string a, string b) \\n                {\\n                    return a + b > b + a;\\n                }\\n            );\\n            \\n            string res = \"\";\\n            for (auto s : snum)\\n                res += s;\\n            if (res == \"\" || res[0] == '0') return \"0\";\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string largestNumber(vector<int> &num) \\n        {\\n            vector<string> snum;\\n            for (auto i : num)\\n                snum.push_back(to_string(i));\\n            \\n            sort(snum.begin(), snum.end(), \\n                [](string a, string b) \\n                {\\n                    return a + b > b + a;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 53408,
                "title": "love-java8-lambda-4lines-solution",
                "content": "4 lines only.\\n\\n\\n      public String largestNumber(int[] num) {\\n    \\n        String[] ns = Arrays.stream(num).mapToObj(x -> \"\" + x).toArray(String[]::new);\\n    \\n        Arrays.sort(ns, (String x, String y) -> (y + x).compareTo(x + y));\\n    \\n        if(\"0\".equals(ns[0])) return \"0\";\\n    \\n        return Arrays.stream(ns).reduce((x, y) -> x + y).get();\\n      }",
                "solutionTags": [],
                "code": "4 lines only.\\n\\n\\n      public String largestNumber(int[] num) {\\n    \\n        String[] ns = Arrays.stream(num).mapToObj(x -> \"\" + x).toArray(String[]::new);\\n    \\n        Arrays.sort(ns, (String x, String y) -> (y + x).compareTo(x + y));\\n    \\n        if(\"0\".equals(ns[0])) return \"0\";\\n    \\n        return Arrays.stream(ns).reduce((x, y) -> x + y).get();\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 53415,
                "title": "share-my-c-19-ms-solution-with-comp-function",
                "content": "generally I used the comp function. \\nPlease note:\\n1. deal with zero (all zero's and some zeros)\\n2. the comp function promoted to long long type to avoid overflow. \\n\\n\\n    class Solution {\\n    private:\\n        static bool sortFunction(long long n1, long long  n2) {\\n            int d1 = 1, d2 = 1;\\n            while(d1 <= n1) d1 *= 10;\\n            while(d2 <= n2) d2 *= 10;\\n            return  (n1 * d2 + n2) < (n2 * d1 + n1);\\n        }\\n    public:\\n        string largestNumber(vector<int> &num) {\\n            int n = num.size();\\n            sort(num.begin(), num.end());\\n            if(n < 1 || 0== num[n -1]) return \"0\";\\n            int index ;\\n            for(int i = 0; i < n; i++){\\n                if(0 != num[i]){\\n                    index = i; \\n                    break;\\n                }\\n            }\\n            sort(num.begin() + index, num.end(), sortFunction);\\n            string result;\\n            for(int i = num.size() -1 ; i >= 0; i--){\\n                result += to_string(num[i]);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        static bool sortFunction(long long n1, long long  n2) {\\n            int d1 = 1, d2 = 1;\\n            while(d1 <= n1) d1 *= 10;\\n            while(d2 <= n2) d2 *= 10;\\n            return  (n1 * d2 + n2) < (n2 * d1 + n1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3839269,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=WDx6Y4i4xJ8\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool str_greater(string l, string r){\\n        return l + r > r + l;\\n    }\\n\\n    string largestNumber(vector<int>& nums) {\\n        string ans;\\n        vector<string> new_nums(nums.size());\\n        for(int i = 0; i < new_nums.size(); i++){\\n            new_nums[i] = to_string(nums[i]);\\n        }\\n        sort(new_nums.begin(), new_nums.end(), str_greater);\\n        for(auto num: new_nums){\\n            ans += num;\\n        }\\n        if(ans[0] == \\'0\\'){\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool str_greater(string l, string r){\\n        return l + r > r + l;\\n    }\\n\\n    string largestNumber(vector<int>& nums) {\\n        string ans;\\n        vector<string> new_nums(nums.size());\\n        for(int i = 0; i < new_nums.size(); i++){\\n            new_nums[i] = to_string(nums[i]);\\n        }\\n        sort(new_nums.begin(), new_nums.end(), str_greater);\\n        for(auto num: new_nums){\\n            ans += num;\\n        }\\n        if(ans[0] == \\'0\\'){\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764580,
                "title": "c-greedy-using-comparator-function",
                "content": "\\n# Code\\n```\\nstruct mycmp{\\n    bool operator()(string &a , string &b){\\n        string temp1 = a + b;\\n        string temp2 = b + a;\\n        if(temp1 > temp2)return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> temp;\\n        for(auto x : nums){\\n            int number = x;\\n            string str = \"\";\\n            if(number == 0)str = \"0\";\\n            while(number){\\n                char ch = ((number%10)+\\'0\\');\\n                str = ch + str;\\n                number = number / 10;\\n            }\\n            temp.push_back(str);\\n        }\\n        sort(temp.begin() , temp.end() , mycmp());\\n        string result = \"\";\\n        for(auto str : temp){\\n            if(str == \"0\" && result.size()==0)return \"0\";\\n            result += str;\\n        }\\n       return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct mycmp{\\n    bool operator()(string &a , string &b){\\n        string temp1 = a + b;\\n        string temp2 = b + a;\\n        if(temp1 > temp2)return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> temp;\\n        for(auto x : nums){\\n            int number = x;\\n            string str = \"\";\\n            if(number == 0)str = \"0\";\\n            while(number){\\n                char ch = ((number%10)+\\'0\\');\\n                str = ch + str;\\n                number = number / 10;\\n            }\\n            temp.push_back(str);\\n        }\\n        sort(temp.begin() , temp.end() , mycmp());\\n        string result = \"\";\\n        for(auto str : temp){\\n            if(str == \"0\" && result.size()==0)return \"0\";\\n            result += str;\\n        }\\n       return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630890,
                "title": "easy-to-understand-best-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- first we sort the string(lexicographically  sorting).\\n- In single digit number it works properly.\\n- But in some case like  32 and 3 its fails because accourding to lexicographical sorting 32>3 so largest no acc. to this is 323 but it is wrong. the largest by combination of these two numbers are 332,\\n- so we handle this case by  \\n- string t1 = a+b;\\n- string t2 = b+a;\\n- return t1>t2;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool mycomp(string a, string b ){\\n        string t1 = a+b;\\n        string t2 = b+a;\\n        return t1>t2;\\n    }\\n\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>snums;\\n        for(auto n:nums){\\n            snums.push_back(to_string(n));\\n        }\\n        \\n        //desc sorting\\n        sort(snums.begin(),snums.end(),mycomp);\\n        if(snums[0]==\"0\") return \"0\";\\n        string ans = \"\";\\n\\n        for(auto str : snums){\\n            ans+=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool mycomp(string a, string b ){\\n        string t1 = a+b;\\n        string t2 = b+a;\\n        return t1>t2;\\n    }\\n\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>snums;\\n        for(auto n:nums){\\n            snums.push_back(to_string(n));\\n        }\\n        \\n        //desc sorting\\n        sort(snums.begin(),snums.end(),mycomp);\\n        if(snums[0]==\"0\") return \"0\";\\n        string ans = \"\";\\n\\n        for(auto str : snums){\\n            ans+=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598443,
                "title": "java-o-nlogn-solution",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        PriorityQueue<String> pq = new PriorityQueue<>((s, t) -> (t + s).compareTo(s + t));\\n        for (int s : nums) pq.offer(Integer.toString(s));\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) sb.append(pq.poll());\\n        int zero = 0;\\n        String s = sb.toString();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else break;\\n        }\\n        s = s.substring(zero);\\n        return s.length() > 0 ? s : \"0\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        PriorityQueue<String> pq = new PriorityQueue<>((s, t) -> (t + s).compareTo(s + t));\\n        for (int s : nums) pq.offer(Integer.toString(s));\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) sb.append(pq.poll());\\n        int zero = 0;\\n        String s = sb.toString();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else break;\\n        }\\n        s = s.substring(zero);\\n        return s.length() > 0 ? s : \"0\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511091,
                "title": "java-solution-for-largest-number-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to sort the array of integers in a custom order that ensures the concatenated string forms the largest number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code first initializes a string array strs of the same length as the nums array.\\n2. It iterates through the nums array and converts each integer to a string, storing them in the strs array.\\n3. The code then sorts the strs array using a custom comparator. The comparator compares two strings s1 and s2 by concatenating them in two different orders: s1+s2 and s2+s1. It compares the results of the concatenation in reverse order (using -leftRight.compareTo(rightLeft)) to ensure a descending order.\\n4. After sorting, a StringBuilder sb is initialized to build the resulting string.\\n5. The code iterates through the sorted strs array and appends each string s to the StringBuilder.\\n6. Finally, the code removes any leading zeros from the resulting string by checking if the first character is \\'0\\' and the length is greater than 1. It uses sb.deleteCharAt(0) to remove the leading zero character.\\n7. The resulting StringBuilder is converted to a string using sb.toString() and returned as the largest possible number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n log n), where n is the length of the nums array. This is because the code performs a sorting operation on the strs array, which takes O(n log n) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the nums array. This is because the code creates a string array strs of the same length as nums and uses a StringBuilder sb to build the resulting string. The space used is proportional to the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n    String[] strs = new String[nums.length];\\n    for(int i=0; i<nums.length; i++)\\n    {\\n        strs[i] = String.valueOf(nums[i]);\\n    }\\n    Arrays.sort(strs, new Comparator<String>()\\n    {\\n        public int compare(String s1, String s2)\\n        {\\n            String leftRight = s1+s2;\\n            String rightLeft = s2+s1;\\n            return -leftRight.compareTo(rightLeft);\\n        }\\n        });\\n    \\n    StringBuilder sb = new StringBuilder();\\n    for(String s: strs)\\n    {\\n        sb.append(s);\\n    }\\n    while(sb.charAt(0)==\\'0\\' && sb.length()>1)\\n    {\\n        sb.deleteCharAt(0);\\n    }\\n    return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n    String[] strs = new String[nums.length];\\n    for(int i=0; i<nums.length; i++)\\n    {\\n        strs[i] = String.valueOf(nums[i]);\\n    }\\n    Arrays.sort(strs, new Comparator<String>()\\n    {\\n        public int compare(String s1, String s2)\\n        {\\n            String leftRight = s1+s2;\\n            String rightLeft = s2+s1;\\n            return -leftRight.compareTo(rightLeft);\\n        }\\n        });\\n    \\n    StringBuilder sb = new StringBuilder();\\n    for(String s: strs)\\n    {\\n        sb.append(s);\\n    }\\n    while(sb.charAt(0)==\\'0\\' && sb.length()>1)\\n    {\\n        sb.deleteCharAt(0);\\n    }\\n    return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144688,
                "title": "c-concise-solution-93ms-96",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string LargestNumber(int[] nums) \\n    {\\n        if(nums.All(_ => _ == 0)) return \"0\";\\n\\n        var s = nums.Select(_ => _.ToString()).ToList();\\n\\n        s.Sort((a, b) => (b+a).CompareTo(a+b));\\n\\n        return string.Concat(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestNumber(int[] nums) \\n    {\\n        if(nums.All(_ => _ == 0)) return \"0\";\\n\\n        var s = nums.Select(_ => _.ToString()).ToList();\\n\\n        s.Sort((a, b) => (b+a).CompareTo(a+b));\\n\\n        return string.Concat(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007690,
                "title": "using-comparator-function-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(string &s1,string &s2){\\n        return (s1+s2)>=(s2+s1);\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                count++;\\n            }    \\n        }\\n        if(count==nums.size())return \"0\";\\n        vector<string> s(nums.size(),\"\");\\n        for(int i=0;i<nums.size();i++){\\n            s[i]=to_string(nums[i]);\\n        }\\n        sort(s.begin(),s.end(),cmp);\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(string &s1,string &s2){\\n        return (s1+s2)>=(s2+s1);\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                count++;\\n            }    \\n        }\\n        if(count==nums.size())return \"0\";\\n        vector<string> s(nums.size(),\"\");\\n        for(int i=0;i<nums.size();i++){\\n            s[i]=to_string(nums[i]);\\n        }\\n        sort(s.begin(),s.end(),cmp);\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            ans+=s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970405,
                "title": "a-simple-approach",
                "content": "Simple Approach using 2 for loops.\\nUsed BigInteger class to store the generated number as it couldnt be accomodated in long data type.\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String res=\"\";\\n\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                String s1=Integer.toString(nums[i]);\\n                String s2=Integer.toString(nums[j]);\\n                if(((s2+s1).compareTo(s1+s2))>0){   \\n                    //comparing both string combinations i.e. s1+s2 and s2+s1 \\n                    int t=nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j]=t;\\n                }\\n            }\\n            res+=Integer.toString(nums[i]); //appending to final string\\n        }\\n\\n        BigInteger resValue = new BigInteger(res);   \\n        BigInteger zero = BigInteger.valueOf(0);\\n        \\n        return resValue.compareTo(zero)==0 ? \"0\" : res;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String res=\"\";\\n\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                String s1=Integer.toString(nums[i]);\\n                String s2=Integer.toString(nums[j]);\\n                if(((s2+s1).compareTo(s1+s2))>0){   \\n                    //comparing both string combinations i.e. s1+s2 and s2+s1 \\n                    int t=nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j]=t;\\n                }\\n            }\\n            res+=Integer.toString(nums[i]); //appending to final string\\n        }\\n\\n        BigInteger resValue = new BigInteger(res);   \\n        BigInteger zero = BigInteger.valueOf(0);\\n        \\n        return resValue.compareTo(zero)==0 ? \"0\" : res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953094,
                "title": "easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool compare(string a, string b){\\n        return a+b>b+a;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        int n=nums.size(),i;\\n        //create string vector and convert int to string\\n        vector<string> str;\\n        for(i=0;i<n;i++){\\n            str.push_back(to_string(nums[i]));\\n        }\\n        sort(str.begin(),str.end(),compare);\\n        string ans=\"\";\\n        if(str[0]==\"0\") {\\n            return \"0\";\\n        }\\n        for(i=0;i<n;i++){\\n            ans=ans+str[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(string a, string b){\\n        return a+b>b+a;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        int n=nums.size(),i;\\n        //create string vector and convert int to string\\n        vector<string> str;\\n        for(i=0;i<n;i++){\\n            str.push_back(to_string(nums[i]));\\n        }\\n        sort(str.begin(),str.end(),compare);\\n        string ans=\"\";\\n        if(str[0]==\"0\") {\\n            return \"0\";\\n        }\\n        for(i=0;i<n;i++){\\n            ans=ans+str[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903141,
                "title": "java-sorting-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array based on the importance of the elements in the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Get the String copy of the array\\n2. Sort the array based on the importance of each elements\\n3. validate whether the first element is \"0\", if so, return \"0\"\\n4. add all element to StringBuilder and return the String value of it\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlong(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] temp = new String[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            temp[i] = String.valueOf(nums[i]);\\n        }\\n        Arrays.sort(temp, new Comparator<String>(){\\n            @Override\\n            public int compare(String a, String b) {\\n                String fir = a + b;\\n                String sec = b + a;\\n                return sec.compareTo(fir);\\n            }\\n        });\\n        if (temp[0].equals(\"0\")) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (String i : temp) {\\n            sb.append(i);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String[] temp = new String[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            temp[i] = String.valueOf(nums[i]);\\n        }\\n        Arrays.sort(temp, new Comparator<String>(){\\n            @Override\\n            public int compare(String a, String b) {\\n                String fir = a + b;\\n                String sec = b + a;\\n                return sec.compareTo(fir);\\n            }\\n        });\\n        if (temp[0].equals(\"0\")) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (String i : temp) {\\n            sb.append(i);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869983,
                "title": "easy-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nthe main approach is to see how comparator func works here bssss ..baaki to strt ke zeroes htane hain uska logic hai\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(int a,int b)//here comparing to string like to_string(a)>to_string(b)..did\\'t work since there can be many edge cases where it wo\\'t satisfy the rule\\n//thus best is to see by adding the two strings as in example 1...2+10=>210 and 10+2=>102 since 210 is bigger thus order is 2 , 10...\\n{\\n   return to_string(a)+to_string(b)>to_string(b)+to_string(a);//i.e descending order\\n}\\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),cmp);\\n        string ans;\\n        bool zero=false,val=false;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=0)//now integer value aagyi to any number of zeroes can come\\n            {\\n              val=true;\\n              zero=false;\\n            }\\n\\n            if(zero==true&&nums[i]==0)//abi tk koi non zero value ni aai bt phke bi zero aaya and abi frse aara \\n              continue;\\n\\n             if(nums[i]==0&&val==false)//zero milgya and koi non zero value ni mili..strt m zero aagya\\n              zero=true;\\n             \\n         ans+=to_string(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool cmp(int a,int b)//here comparing to string like to_string(a)>to_string(b)..did\\'t work since there can be many edge cases where it wo\\'t satisfy the rule\\n//thus best is to see by adding the two strings as in example 1...2+10=>210 and 10+2=>102 since 210 is bigger thus order is 2 , 10...\\n{\\n   return to_string(a)+to_string(b)>to_string(b)+to_string(a);//i.e descending order\\n}\\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),cmp);\\n        string ans;\\n        bool zero=false,val=false;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=0)//now integer value aagyi to any number of zeroes can come\\n            {\\n              val=true;\\n              zero=false;\\n            }\\n\\n            if(zero==true&&nums[i]==0)//abi tk koi non zero value ni aai bt phke bi zero aaya and abi frse aara \\n              continue;\\n\\n             if(nums[i]==0&&val==false)//zero milgya and koi non zero value ni mili..strt m zero aagya\\n              zero=true;\\n             \\n         ans+=to_string(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862585,
                "title": "one-line-sort-comparator-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(int a,int b){\\n        string a_s = to_string(a);\\n        string b_s = to_string(b);\\n\\n        return (a_s + b_s) > (b_s + a_s);\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        string st = \"\";\\n        sort(nums.begin(),nums.end(),comp);\\n        \\n        for(int el : nums){\\n            st += to_string(el);\\n        }\\n        \\n        int n = st.size();\\n        int i = 0;\\n        \\n        while(i<n-1 and st[i] == \\'0\\'){\\n            i++;\\n        }\\n        \\n        return st.substr(i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(int a,int b){\\n        string a_s = to_string(a);\\n        string b_s = to_string(b);\\n\\n        return (a_s + b_s) > (b_s + a_s);\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        string st = \"\";\\n        sort(nums.begin(),nums.end(),comp);\\n        \\n        for(int el : nums){\\n            st += to_string(el);\\n        }\\n        \\n        int n = st.size();\\n        int i = 0;\\n        \\n        while(i<n-1 and st[i] == \\'0\\'){\\n            i++;\\n        }\\n        \\n        return st.substr(i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493295,
                "title": "sorting-with-go",
                "content": "```\\nfunc largestNumber(nums []int) string {\\n\\tvar arr []string\\n\\n\\tfor _, num := range nums {\\n\\t\\tarr = append(arr, strconv.Itoa(num))\\n\\t}\\n\\n\\tsort.Slice(arr, func(i, j int) bool {\\n\\t\\treturn isLarger(arr[i], arr[j])\\n\\t})\\n\\n\\tvar res strings.Builder\\n\\n\\tfor _, item := range arr {\\n\\t\\tif item == \"0\" && res.String() == \"0\" {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres.WriteString(item)\\n\\t}\\n\\n\\treturn res.String()\\n}\\n\\nfunc isLarger(str1, str2 string) bool {\\n\\tif str1 == str2 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tlength := len(str1)\\n\\n\\tif len(str2) < length {\\n\\t\\tlength = len(str2)\\n\\t}\\n\\n\\ti := 0\\n\\n\\tfor ; i < length; i++ {\\n\\t\\tif str1[i] > str2[i] {\\n\\t\\t\\treturn true\\n\\t\\t} else if str1[i] < str2[i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\tif i == len(str1) {\\n\\t\\treturn isLarger(str1, str2[i:])\\n\\t}\\n\\n\\treturn isLarger(str1[i:], str2)\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nfunc largestNumber(nums []int) string {\\n\\tvar arr []string\\n\\n\\tfor _, num := range nums {\\n\\t\\tarr = append(arr, strconv.Itoa(num))\\n\\t}\\n\\n\\tsort.Slice(arr, func(i, j int) bool {\\n\\t\\treturn isLarger(arr[i], arr[j])\\n\\t})\\n\\n\\tvar res strings.Builder\\n\\n\\tfor _, item := range arr {\\n\\t\\tif item == \"0\" && res.String() == \"0\" {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres.WriteString(item)\\n\\t}\\n\\n\\treturn res.String()\\n}\\n\\nfunc isLarger(str1, str2 string) bool {\\n\\tif str1 == str2 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tlength := len(str1)\\n\\n\\tif len(str2) < length {\\n\\t\\tlength = len(str2)\\n\\t}\\n\\n\\ti := 0\\n\\n\\tfor ; i < length; i++ {\\n\\t\\tif str1[i] > str2[i] {\\n\\t\\t\\treturn true\\n\\t\\t} else if str1[i] < str2[i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\tif i == len(str1) {\\n\\t\\treturn isLarger(str1, str2[i:])\\n\\t}\\n\\n\\treturn isLarger(str1[i:], str2)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493206,
                "title": "priority-queue-with-go",
                "content": "```\\nfunc largestNumber(nums []int) string {\\n\\tvar heap []string\\n\\n\\tfor _, num := range nums {\\n\\t\\theap = append(heap, strconv.Itoa(num))\\n\\t\\theapUp(heap, len(heap)-1)\\n\\t}\\n\\n\\tvar res strings.Builder\\n\\n\\tfor len(heap) > 0 {\\n\\t\\tif heap[0] == \"0\" && res.String() == \"0\" {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres.WriteString(heap[0])\\n\\n\\t\\theap[0] = heap[len(heap)-1]\\n\\t\\theap = heap[:len(heap)-1]\\n\\t\\theapDown(heap, 0, len(heap)-1)\\n\\t}\\n\\n\\treturn res.String()\\n}\\n\\nfunc isLarger(str1, str2 string) bool {\\n\\tif str1 == str2 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tlength := len(str1)\\n\\n\\tif len(str2) < length {\\n\\t\\tlength = len(str2)\\n\\t}\\n\\n\\ti := 0\\n\\n\\tfor ; i < length; i++ {\\n\\t\\tif str1[i] > str2[i] {\\n\\t\\t\\treturn true\\n\\t\\t} else if str1[i] < str2[i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\tif i == len(str1) {\\n\\t\\treturn isLarger(str1, str2[i:])\\n\\t}\\n\\n\\treturn isLarger(str1[i:], str2)\\n}\\n\\nfunc heapDown(heap []string, p, limit int) {\\n\\tl, r := 2*p+1, 2*p+2\\n\\tlarger := p\\n\\n\\tif l <= limit && isLarger(heap[l], heap[larger]) {\\n\\t\\tlarger = l\\n\\t}\\n\\n\\tif r <= limit && isLarger(heap[r], heap[larger]) {\\n\\t\\tlarger = r\\n\\t}\\n\\n\\tif larger != p {\\n\\t\\theap[p], heap[larger] = heap[larger], heap[p]\\n\\t\\theapDown(heap, larger, limit)\\n\\t}\\n}\\n\\nfunc heapUp(heap []string, p int) {\\n\\tparent := (p - 1) / 2\\n\\n\\tif parent >= 0 && isLarger(heap[p], heap[parent]) {\\n\\t\\theap[parent], heap[p] = heap[p], heap[parent]\\n\\t\\theapUp(heap, parent)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc largestNumber(nums []int) string {\\n\\tvar heap []string\\n\\n\\tfor _, num := range nums {\\n\\t\\theap = append(heap, strconv.Itoa(num))\\n\\t\\theapUp(heap, len(heap)-1)\\n\\t}\\n\\n\\tvar res strings.Builder\\n\\n\\tfor len(heap) > 0 {\\n\\t\\tif heap[0] == \"0\" && res.String() == \"0\" {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres.WriteString(heap[0])\\n\\n\\t\\theap[0] = heap[len(heap)-1]\\n\\t\\theap = heap[:len(heap)-1]\\n\\t\\theapDown(heap, 0, len(heap)-1)\\n\\t}\\n\\n\\treturn res.String()\\n}\\n\\nfunc isLarger(str1, str2 string) bool {\\n\\tif str1 == str2 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tlength := len(str1)\\n\\n\\tif len(str2) < length {\\n\\t\\tlength = len(str2)\\n\\t}\\n\\n\\ti := 0\\n\\n\\tfor ; i < length; i++ {\\n\\t\\tif str1[i] > str2[i] {\\n\\t\\t\\treturn true\\n\\t\\t} else if str1[i] < str2[i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\tif i == len(str1) {\\n\\t\\treturn isLarger(str1, str2[i:])\\n\\t}\\n\\n\\treturn isLarger(str1[i:], str2)\\n}\\n\\nfunc heapDown(heap []string, p, limit int) {\\n\\tl, r := 2*p+1, 2*p+2\\n\\tlarger := p\\n\\n\\tif l <= limit && isLarger(heap[l], heap[larger]) {\\n\\t\\tlarger = l\\n\\t}\\n\\n\\tif r <= limit && isLarger(heap[r], heap[larger]) {\\n\\t\\tlarger = r\\n\\t}\\n\\n\\tif larger != p {\\n\\t\\theap[p], heap[larger] = heap[larger], heap[p]\\n\\t\\theapDown(heap, larger, limit)\\n\\t}\\n}\\n\\nfunc heapUp(heap []string, p int) {\\n\\tparent := (p - 1) / 2\\n\\n\\tif parent >= 0 && isLarger(heap[p], heap[parent]) {\\n\\t\\theap[parent], heap[p] = heap[p], heap[parent]\\n\\t\\theapUp(heap, parent)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2321719,
                "title": "c-simple-solution",
                "content": "```\\nbool sort1(int &n1,int &n2)\\n{\\n        string s1=to_string(n1);\\n        string s2=to_string(n2);\\n        return s1+s2>s2+s1;\\n}\\nclass Solution {\\npublic:\\n   \\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),sort1);\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        int t=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[i]==\\'0\\')\\n              t++;\\n        }\\n        if(t==nums.size())\\n            return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool sort1(int &n1,int &n2)\\n{\\n        string s1=to_string(n1);\\n        string s2=to_string(n2);\\n        return s1+s2>s2+s1;\\n}\\nclass Solution {\\npublic:\\n   \\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),sort1);\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        int t=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[i]==\\'0\\')\\n              t++;\\n        }\\n        if(t==nums.size())\\n            return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940145,
                "title": "java-comparator-string",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String str[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++)str[i]=nums[i]+\"\";\\n        Arrays.sort(str,(a,b)->(b+a).compareTo(a+b));\\n        if(str[0].equals(\"0\"))return \"0\";\\n        String res=new String();\\n        for(String i:str)res+=i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String str[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++)str[i]=nums[i]+\"\";\\n        Arrays.sort(str,(a,b)->(b+a).compareTo(a+b));\\n        if(str[0].equals(\"0\"))return \"0\";\\n        String res=new String();\\n        for(String i:str)res+=i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863277,
                "title": "c-sorting-with-comparator",
                "content": "```\\nstatic bool oper(int x, int y)\\n        {\\n            string X = to_string(x);\\n            string Y = to_string(y);\\n            return X + Y > Y + X;\\n        }\\n    string largestNumber(vector<int> &nums)\\n    {\\n        sort(nums.begin(), nums.end(), oper);\\n        string ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            ans += to_string(nums[i]);\\n        }\\n        while (ans.length() > 1 && ans[0] == \\'0\\')\\n        {\\n            ans = ans.substr(1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic bool oper(int x, int y)\\n        {\\n            string X = to_string(x);\\n            string Y = to_string(y);\\n            return X + Y > Y + X;\\n        }\\n    string largestNumber(vector<int> &nums)\\n    {\\n        sort(nums.begin(), nums.end(), oper);\\n        string ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            ans += to_string(nums[i]);\\n        }\\n        while (ans.length() > 1 && ans[0] == \\'0\\')\\n        {\\n            ans = ans.substr(1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769852,
                "title": "detailed-visual-explanation-o-1-solution",
                "content": "```\\nclass Solution {\\n    /*\\n    \\n        what we are doing here is,we will sort the array in this way that it will create the largest array.\\n        \\n        now suppose we have an array  = [3,30,34]\\n        \\n 1:-\\n        \\n        a\\n        ^\\n        |\\n        |\\n       [3 , 30]\\n             |\\n             |\\n             b\\n    \\n      ab = \"330\"\\n      ba = \"303\"\\n      \\n      now here ab > ba so we will return ab\\n      \\n2:-\\n      \\n        a\\n        ^\\n        |\\n        |\\n       [3 , 30 , 34]\\n                  |\\n                  |\\n                  b\\n     ab = \"334\"\\n     ba = \"343\"\\n     \\n     now here we will swap a with b\\n     \\n     \\n        a\\n        ^\\n        |\\n        |\\n       [34 , 30 , 3]\\n                  |\\n                  |\\n                  b  \\n                  \\n3:- now b reach end of the array so we will move a one step ahead and b = a+1\\n\\n\\n             a\\n             ^\\n             |\\n             |\\n       [34 , 30 , 3]\\n                  |\\n                  |\\n                  b  \\n                  \\n        ab = 303\\n        ba = 330\\n        \\n        again we will swap  so it will be :-\\n        \\n             a\\n             ^\\n             |\\n             |\\n       [34 , 3 , 30]\\n                  |\\n                  |\\n                  b  \\n                  \\n\\nnow  we will convert to string and return \\n      \\n     \\n     \\n     And we are doing this by this lambda function:-\\n     \\n     [](int a, int b){\\n          \\n            return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n        \\n        \\n    */\\npublic:\\n    string largestNumber(vector<int>& num) {\\n        sort(num.begin(), num.end(), [](int a, int b){\\n          \\n            return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n        });\\n        string ans;\\n        for(int i=0;i<num.size();i++)\\n        {\\n          ans+=to_string(num[i]);\\n        }\\n       if(ans[0]==\\'0\\')\\n           return \"0\";\\n        return ans;\\n    }\\n};\\n```\\n\\n**PLEASE LET ME KNOW IF HAVE DOUBT OR SUGGESTION**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    \\n        what we are doing here is,we will sort the array in this way that it will create the largest array.\\n        \\n        now suppose we have an array  = [3,30,34]\\n        \\n 1:-\\n        \\n        a\\n        ^\\n        |\\n        |\\n       [3 , 30]\\n             |\\n             |\\n             b\\n    \\n      ab = \"330\"\\n      ba = \"303\"\\n      \\n      now here ab > ba so we will return ab\\n      \\n2:-\\n      \\n        a\\n        ^\\n        |\\n        |\\n       [3 , 30 , 34]\\n                  |\\n                  |\\n                  b\\n     ab = \"334\"\\n     ba = \"343\"\\n     \\n     now here we will swap a with b\\n     \\n     \\n        a\\n        ^\\n        |\\n        |\\n       [34 , 30 , 3]\\n                  |\\n                  |\\n                  b  \\n                  \\n3:- now b reach end of the array so we will move a one step ahead and b = a+1\\n\\n\\n             a\\n             ^\\n             |\\n             |\\n       [34 , 30 , 3]\\n                  |\\n                  |\\n                  b  \\n                  \\n        ab = 303\\n        ba = 330\\n        \\n        again we will swap  so it will be :-\\n        \\n             a\\n             ^\\n             |\\n             |\\n       [34 , 3 , 30]\\n                  |\\n                  |\\n                  b  \\n                  \\n\\nnow  we will convert to string and return \\n      \\n     \\n     \\n     And we are doing this by this lambda function:-\\n     \\n     [](int a, int b){\\n          \\n            return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n        \\n        \\n    */\\npublic:\\n    string largestNumber(vector<int>& num) {\\n        sort(num.begin(), num.end(), [](int a, int b){\\n          \\n            return to_string(a)+to_string(b) > to_string(b)+to_string(a);\\n        });\\n        string ans;\\n        for(int i=0;i<num.size();i++)\\n        {\\n          ans+=to_string(num[i]);\\n        }\\n       if(ans[0]==\\'0\\')\\n           return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755457,
                "title": "c-linq-oneliner",
                "content": "If all elements in the `num` array are zeroes, we can simply return \"0\". Otherwise, sort by a custom inline comparer.\\n```\\npublic class Solution \\n{\\n    public string LargestNumber(int[] nums) {        \\n        return nums.All(x => x == 0)\\n            ? \"0\"\\n            : string.Join(\\n                \"\", \\n                nums.Select(x => x.ToString())\\n                    .OrderByDescending(x => x, Comparer<string>.Create((x, y) => (x+y).CompareTo(y+x))));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string LargestNumber(int[] nums) {        \\n        return nums.All(x => x == 0)\\n            ? \"0\"\\n            : string.Join(\\n                \"\", \\n                nums.Select(x => x.ToString())\\n                    .OrderByDescending(x => x, Comparer<string>.Create((x, y) => (x+y).CompareTo(y+x))));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697536,
                "title": "c-with-explanation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool mycmp(string &s1,string &s2)\\n    {\\n        if((s1+s2)>(s2+s1)) return true;  //s1 will come first in sorted list\\n        return false;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        //sort according to digits\\n        //similar as we sort strings\\n        //problem will arise -> s1=34, and s2=349  -> 34934>34349\\n        //to solve this use custom comparator as:\\n        // (s1+s2)>(s2+s1) -> return true\\n            \\n        vector<string> vi;\\n        for(auto it: nums) vi.push_back(to_string(it));\\n        sort(vi.begin(),vi.end(),mycmp);  \\n        string ans;\\n        for(auto it: vi) ans+=it;\\n        \\n        //check if answer have only zeros e.g arr=[0,0,0,0]  -> ans=\"0000\"\\n        int i=0;\\n        while(i<ans.length() && ans[i]==\\'0\\') i++;\\n        if(i==ans.length()) //all are only zero\\n        {\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool mycmp(string &s1,string &s2)\\n    {\\n        if((s1+s2)>(s2+s1)) return true;  //s1 will come first in sorted list\\n        return false;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        //sort according to digits\\n        //similar as we sort strings\\n        //problem will arise -> s1=34, and s2=349  -> 34934>34349\\n        //to solve this use custom comparator as:\\n        // (s1+s2)>(s2+s1) -> return true\\n            \\n        vector<string> vi;\\n        for(auto it: nums) vi.push_back(to_string(it));\\n        sort(vi.begin(),vi.end(),mycmp);  \\n        string ans;\\n        for(auto it: vi) ans+=it;\\n        \\n        //check if answer have only zeros e.g arr=[0,0,0,0]  -> ans=\"0000\"\\n        int i=0;\\n        while(i<ans.length() && ans[i]==\\'0\\') i++;\\n        if(i==ans.length()) //all are only zero\\n        {\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657704,
                "title": "javascript-solution",
                "content": "```\\nvar largestNumber = function(nums) {\\n    nums.sort(compareFunc);\\n    \\n    let res = \"\";\\n\\n    for (let j = 0; j < nums.length; j++) {\\n        res += nums[j];\\n    }\\n   \\n    if (res.charAt(0) === \"0\") return \"0\";\\n    return res;\\n    \\n     \\n    function compareFunc(numStr1, numStr2) {\\n        let combinedNumStr1 = numStr1 + \"\" + numStr2;\\n        let combinedNumStr2 = numStr2 + \"\" + numStr1;\\n        \\n        return combinedNumStr2 - combinedNumStr1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar largestNumber = function(nums) {\\n    nums.sort(compareFunc);\\n    \\n    let res = \"\";\\n\\n    for (let j = 0; j < nums.length; j++) {\\n        res += nums[j];\\n    }\\n   \\n    if (res.charAt(0) === \"0\") return \"0\";\\n    return res;\\n    \\n     \\n    function compareFunc(numStr1, numStr2) {\\n        let combinedNumStr1 = numStr1 + \"\" + numStr2;\\n        let combinedNumStr2 = numStr2 + \"\" + numStr1;\\n        \\n        return combinedNumStr2 - combinedNumStr1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625165,
                "title": "python-lambda-simple-solution",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, nums):\\n        str_nums = map(str, nums)\\n        sort_rule = lambda x, y : 1 if x + y > y + x else -1\\n        sorted_nums = sorted(str_nums, key=functools.cmp_to_key(sort_rule), reverse=True)\\n        if sorted_nums[0] == \\'0\\':\\n            return \\'0\\'\\n        return \\'\\'.join(sorted_nums)\\n```\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums):\\n        str_nums = map(str, nums)\\n        sort_rule = lambda x, y : 1 if x + y > y + x else -1\\n        sorted_nums = sorted(str_nums, key=functools.cmp_to_key(sort_rule), reverse=True)\\n        if sorted_nums[0] == \\'0\\':\\n            return \\'0\\'\\n        return \\'\\'.join(sorted_nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604203,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(int a, int b){\\n        return (to_string(a)+to_string(b))>(to_string(b)+to_string(a));\\n    }\\n    string largestNumber(vector<int>& a) {\\n        sort(a.begin(), a.end(), comp);\\n        string ans=\"\";\\n        for(auto x: a) ans+=(to_string(x));\\n        return ans[0]==\\'0\\'?\"0\":ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(int a, int b){\\n        return (to_string(a)+to_string(b))>(to_string(b)+to_string(a));\\n    }\\n    string largestNumber(vector<int>& a) {\\n        sort(a.begin(), a.end(), comp);\\n        string ans=\"\";\\n        for(auto x: a) ans+=(to_string(x));\\n        return ans[0]==\\'0\\'?\"0\":ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487694,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static comp(string s1, string s2) {\\n        if(s1+s2 > s2+s1)\\n            return true;\\n        return false;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> v;\\n        for(auto i : nums) \\n            v.push_back(to_string(i));\\n        sort(v.begin(), v.end(), comp);\\n        string ans = \"\";\\n        for(auto w : v)\\n            ans += w;\\n        return (ans[0] == \\'0\\') ? \"0\" : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp(string s1, string s2) {\\n        if(s1+s2 > s2+s1)\\n            return true;\\n        return false;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> v;\\n        for(auto i : nums) \\n            v.push_back(to_string(i));\\n        sort(v.begin(), v.end(), comp);\\n        string ans = \"\";\\n        for(auto w : v)\\n            ans += w;\\n        return (ans[0] == \\'0\\') ? \"0\" : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373031,
                "title": "java-easy-solution",
                "content": "**Store the elements of the nums array into a new String array. Sort the array according to (a+b)is big or(b+a)\\nAfter sorting, club the elemnts into an string.**\\n```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String b[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            b[i]=Integer.toString(nums[i]);\\n        }\\n        Arrays.sort(b,(a,c) -> (c+a).compareTo(a+c));\\n        String s=\"\";\\n        if(b[0].equals(\"0\"))\\n            return \"0\";\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            s+=b[i];\\n        }\\n        return s;\\n    }\\n}\\n```\\n**Please Upvote if you like :)\\nThanks**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String b[]=new String[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            b[i]=Integer.toString(nums[i]);\\n        }\\n        Arrays.sort(b,(a,c) -> (c+a).compareTo(a+c));\\n        String s=\"\";\\n        if(b[0].equals(\"0\"))\\n            return \"0\";\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            s+=b[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276827,
                "title": "c-faster-than-100",
                "content": "# Only point is to understand the sort comparator!!!\\n**Best Of Luck**\\n```\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        if(a+b>b+a)return true;\\n        return false;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>v;\\n        int z=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)z++;\\n            string s=to_string(nums[i]);\\n            v.push_back(s);\\n        }\\n        string ans=\"\";\\n        sort(v.begin(),v.end(),comp);\\n        for(auto itr:v){\\n            ans+=itr;\\n        }\\n        if(v.size()==z)return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(string &a,string &b){\\n        if(a+b>b+a)return true;\\n        return false;\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        vector<string>v;\\n        int z=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)z++;\\n            string s=to_string(nums[i]);\\n            v.push_back(s);\\n        }\\n        string ans=\"\";\\n        sort(v.begin(),v.end(),comp);\\n        for(auto itr:v){\\n            ans+=itr;\\n        }\\n        if(v.size()==z)return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234030,
                "title": "java-easy-comparator-sorting",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String arr[] = new String[nums.length];\\n        int i = 0;\\n        for(int val : nums){\\n          arr[i++] = String.valueOf(val);\\n        }\\n      \\n      Arrays.sort(arr,new Comparator<>(){\\n        public int compare(String a,String b){\\n          return (b+a).compareTo(a+b);\\n        }\\n      });\\n     \\n      StringBuilder sb = new StringBuilder();\\n      for(String val : arr) sb.append(val);\\n      \\n      String ans = sb.toString();\\n      return ans.charAt(0)==\\'0\\' ? \"0\" : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String arr[] = new String[nums.length];\\n        int i = 0;\\n        for(int val : nums){\\n          arr[i++] = String.valueOf(val);\\n        }\\n      \\n      Arrays.sort(arr,new Comparator<>(){\\n        public int compare(String a,String b){\\n          return (b+a).compareTo(a+b);\\n        }\\n      });\\n     \\n      StringBuilder sb = new StringBuilder();\\n      for(String val : arr) sb.append(val);\\n      \\n      String ans = sb.toString();\\n      return ans.charAt(0)==\\'0\\' ? \"0\" : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227288,
                "title": "python-solution-faster-than-94-14",
                "content": "\\n    def largestNumber(self, nums: List[int]) -> str:\\n        d=[]\\n        for i in nums:\\n            d.append(str(i))\\n        k=sorted(d,key=lambda x:x*10,reverse=True)\\n        \\n        res=\"\"\\n        for i in k:\\n            res += str(i)\\n        if int(res)==0:\\n            return \"0\"\\n        return res\\n",
                "solutionTags": [],
                "code": "\\n    def largestNumber(self, nums: List[int]) -> str:\\n        d=[]\\n        for i in nums:\\n            d.append(str(i))\\n        k=sorted(d,key=lambda x:x*10,reverse=True)\\n        \\n        res=\"\"\\n        for i in k:\\n            res += str(i)\\n        if int(res)==0:\\n            return \"0\"\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 929934,
                "title": "python3-bubble-sort-selection-sort-insertion-sort-quick-sort-and-merge-sort",
                "content": "Approach 1: Custom Comparator\\n```python\\nclass LargerNumKey(str):\\n    def __lt__(x, y):\\n        return x + y > y + x\\n\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        else:\\n            return \"\".join(sorted(map(str, nums), key = LargerNumKey))\\n```\\n\\nApproach 2: Bubble Sort\\n```python\\n# Bubble Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        for i in range(len(nums)):\\n            for j in range(len(nums) - i - 1):\\n                if nums[j] + nums[j+1] < nums[j+1] + nums[j]:\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return \"\".join(nums)\\n```\\n\\nApproach 3: Selection Sort\\n```python\\n# Selection Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        for i in range(len(nums) - 1):\\n            max_index = i\\n            for j in range(i, len(nums)):\\n                if nums[j] + nums[max_index] > nums[max_index] + nums[j]:\\n                    max_index = j\\n            nums[i], nums[max_index] = nums[max_index], nums[i]\\n        return \"\".join(nums)\\n```\\nApproach 4: Insertion Sort\\n```python\\n# Insertion Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        for i in range(1, len(nums)):\\n            key = nums[i]\\n            j = i - 1\\n            while j >= 0 and nums[j] + key < key + nums[j]:\\n                nums[j + 1] = nums[j]\\n                j -= 1\\n            nums[j + 1] = key\\n        return \\'\\'.join(nums)\\n```\\n\\nApproach 5: Quick Sort\\n```python\\n# Quick Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return \\'\\'.join(nums)\\n    \\n    def quick_sort(self, nums, low, high):\\n        if low < high:\\n            pi = self.partition(nums, low, high)\\n            self.quick_sort(nums, low, pi - 1)\\n            self.quick_sort(nums, pi + 1, high)\\n    \\n    def partition(self, nums, low, high):\\n        pivot = nums[high]\\n        i = low - 1\\n        for j in range(low, high):\\n            if nums[j] + pivot > pivot + nums[j]:\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n        nums[i + 1], nums[high] = nums[high], nums[i + 1]\\n        return i + 1\\n```\\nApproach 6: Merge Sort\\n```python\\n# Merge Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        mid = len(nums) // 2 - 1\\n        l1 = self.divide(nums, 0, mid)\\n        l2 = self.divide(nums, mid + 1, len(nums) - 1)\\n        return \"\".join(self.merge(l1, l2))\\n    \\n    def divide(self, nums, start, end):\\n        if end < start:\\n            return []\\n        if end == start:\\n            return [nums[start]]\\n        mid = start + (end - start + 1) // 2 - 1\\n        l1 = self.divide(nums, start, mid)\\n        l2 = self.divide(nums, mid + 1, end)\\n        return self.merge(l1, l2)\\n\\n    def merge(self, l1, l2):\\n        i, j = 0, 0\\n        res = []\\n        while i < len(l1) and j < len(l2):\\n            if l1[i] + l2[j] > l2[j] + l1[i]:\\n                res.append(l1[i])\\n                i += 1\\n            else:\\n                res.append(l2[j])\\n                j += 1\\n        if i < len(l1):\\n            res += l1[i:]\\n        if j < len(l2):\\n            res += l2[j:]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass LargerNumKey(str):\\n    def __lt__(x, y):\\n        return x + y > y + x\\n\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        else:\\n            return \"\".join(sorted(map(str, nums), key = LargerNumKey))\\n```\n```python\\n# Bubble Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        for i in range(len(nums)):\\n            for j in range(len(nums) - i - 1):\\n                if nums[j] + nums[j+1] < nums[j+1] + nums[j]:\\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\\n        return \"\".join(nums)\\n```\n```python\\n# Selection Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        for i in range(len(nums) - 1):\\n            max_index = i\\n            for j in range(i, len(nums)):\\n                if nums[j] + nums[max_index] > nums[max_index] + nums[j]:\\n                    max_index = j\\n            nums[i], nums[max_index] = nums[max_index], nums[i]\\n        return \"\".join(nums)\\n```\n```python\\n# Insertion Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        for i in range(1, len(nums)):\\n            key = nums[i]\\n            j = i - 1\\n            while j >= 0 and nums[j] + key < key + nums[j]:\\n                nums[j + 1] = nums[j]\\n                j -= 1\\n            nums[j + 1] = key\\n        return \\'\\'.join(nums)\\n```\n```python\\n# Quick Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        self.quick_sort(nums, 0, len(nums) - 1)\\n        return \\'\\'.join(nums)\\n    \\n    def quick_sort(self, nums, low, high):\\n        if low < high:\\n            pi = self.partition(nums, low, high)\\n            self.quick_sort(nums, low, pi - 1)\\n            self.quick_sort(nums, pi + 1, high)\\n    \\n    def partition(self, nums, low, high):\\n        pivot = nums[high]\\n        i = low - 1\\n        for j in range(low, high):\\n            if nums[j] + pivot > pivot + nums[j]:\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n        nums[i + 1], nums[high] = nums[high], nums[i + 1]\\n        return i + 1\\n```\n```python\\n# Merge Sort\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        if not any(nums):\\n            return \"0\"\\n        nums[:] = map(str, nums)\\n        mid = len(nums) // 2 - 1\\n        l1 = self.divide(nums, 0, mid)\\n        l2 = self.divide(nums, mid + 1, len(nums) - 1)\\n        return \"\".join(self.merge(l1, l2))\\n    \\n    def divide(self, nums, start, end):\\n        if end < start:\\n            return []\\n        if end == start:\\n            return [nums[start]]\\n        mid = start + (end - start + 1) // 2 - 1\\n        l1 = self.divide(nums, start, mid)\\n        l2 = self.divide(nums, mid + 1, end)\\n        return self.merge(l1, l2)\\n\\n    def merge(self, l1, l2):\\n        i, j = 0, 0\\n        res = []\\n        while i < len(l1) and j < len(l2):\\n            if l1[i] + l2[j] > l2[j] + l1[i]:\\n                res.append(l1[i])\\n                i += 1\\n            else:\\n                res.append(l2[j])\\n                j += 1\\n        if i < len(l1):\\n            res += l1[i:]\\n        if j < len(l2):\\n            res += l2[j:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868532,
                "title": "c-proof-of-the-concatenation-comparator-s-transtivity-simple-implementation",
                "content": "Note: We use a.b to represent the concatenation of non-negative integers a and b\\n\\nTheorem: Let a, b, and c be non-negative integers. If a.b > b.a and b.c > c.b , we have a.c > c.a\\n\\nProof: We use [a] to denote the length of the decimal representation of a . For example, if a = 10 , we have [a] = 2\\n\\nSince a.b > b.a and b.c > c.b , we have\\n\\na * 10^[b] + b > b * 10^[a] + a\\nb * 10^[c] + c > c * 10^[b] + b\\n\\n, which is equivalent to\\n\\na * (10^[b] - 1) > b * (10^[a] - 1)\\nb * (10^[c] - 1) > c * (10^[b] - 1)\\n\\nObviously, 10^[a] - 1 > 0 , 10^[b] - 1 > 0 , and 10^[c] - 1 > 0 . Since c >= 0 , according to the above inequalities, we know that b > 0 and a > 0 . After multiplying the above two inequalities and cancelling b and (10^[b] - 1) , we have\\n\\na * (10^[c] - 1) > c * (10^[a] - 1)\\n\\nThis is equivalent to\\n\\na * 10^[c] + c > c * 10^[a] + a\\n\\n, which means a.c > c.a .\\n\\nMy C++ implementation with extra array:\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> data;\\n        for(int i=0;i<nums.size();i++)\\n            data.push_back(to_string(nums[i]));\\n        sort(data.begin(),data.end(),[](string const &a, string const &b){\\n\\t\\t\\t\\treturn a+b>b+a;\\n\\t\\t\\t\\t}\\n\\t\\t\\t);\\n        string sol = \"\";\\n        for(int i=0;i<data.size();i++){\\n            sol += data[i];\\n        }\\n        if(sol[0] == \\'0\\')\\n            return \"0\";\\n        return sol;\\n        \\n    }\\n};\\n\\n```\\n\\nMy C++ implementation without extra array:\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),[](int const &a, int const &b)\\n             {\\n                 string sa = to_string(a);\\n                 string sb = to_string(b);\\n                 string ab = sa+sb;\\n                 string ba = sb+sa;\\n                 return ab>ba;\\n             }\\n            );\\n        string sol = \"\";\\n        for(int x: nums){\\n            sol += to_string(x);\\n        }\\n        if(sol[0] == \\'0\\')\\n            return \"0\";\\n        return sol;\\n        \\n    }\\n};\\n```\\nthanks to @iomonad",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        vector<string> data;\\n        for(int i=0;i<nums.size();i++)\\n            data.push_back(to_string(nums[i]));\\n        sort(data.begin(),data.end(),[](string const &a, string const &b){\\n\\t\\t\\t\\treturn a+b>b+a;\\n\\t\\t\\t\\t}\\n\\t\\t\\t);\\n        string sol = \"\";\\n        for(int i=0;i<data.size();i++){\\n            sol += data[i];\\n        }\\n        if(sol[0] == \\'0\\')\\n            return \"0\";\\n        return sol;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),[](int const &a, int const &b)\\n             {\\n                 string sa = to_string(a);\\n                 string sb = to_string(b);\\n                 string ab = sa+sb;\\n                 string ba = sb+sa;\\n                 return ab>ba;\\n             }\\n            );\\n        string sol = \"\";\\n        for(int x: nums){\\n            sol += to_string(x);\\n        }\\n        if(sol[0] == \\'0\\')\\n            return \"0\";\\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864736,
                "title": "sharing-my-simple-c-solution-easy-to-understand-expalanation-added",
                "content": "A simple solution that comes to our mind is to sort all numbers in descending order, but simply sorting doesn\\u2019t work. For example, 548 is greater than 60, but in output 60 comes before 548. As a second example, 98 is greater than 9, but 9 comes before 98 in output.\\n\\nSo how do we go about it? The idea is to use any comparison based sorting algorithm.\\n\\nIn the used sorting algorithm, instead of using the default comparison, write a comparison function myCompare() and use it to sort numbers.\\n\\nGiven two numbers X and Y, how should myCompare() decide which number to put first \\u2013 we compare two numbers XY (Y appended at the end of X) and YX (X appended at the end of Y). If XY is larger, then X should come before Y in output, else Y should come before. For example, let X and Y be 542 and 60. To compare X and Y, we compare 54260 and 60542. Since 60542 is greater than 54260,\\nwe put Y first.\\n```\\nclass Solution {\\npublic:\\n    static bool mycomp(string a,string b)\\n    {\\n       string ab=a+b;\\n        string ba=b+a;\\n        return(ab>ba);\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<string> tp;\\n        for(int i=0;i<n;i++)\\n            tp.push_back(to_string(nums[i]));\\n        string ans=\"\";\\n        sort(tp.begin(),tp.end(),mycomp);\\n        for(int i=0;i<n;i++)\\n        {\\n           ans+=tp[i];\\n        }\\n        if(ans[0]==\\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool mycomp(string a,string b)\\n    {\\n       string ab=a+b;\\n        string ba=b+a;\\n        return(ab>ba);\\n    }\\n    string largestNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<string> tp;\\n        for(int i=0;i<n;i++)\\n            tp.push_back(to_string(nums[i]));\\n        string ans=\"\";\\n        sort(tp.begin(),tp.end(),mycomp);\\n        for(int i=0;i<n;i++)\\n        {\\n           ans+=tp[i];\\n        }\\n        if(ans[0]==\\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864106,
                "title": "kotlin-sorting-the-string-array",
                "content": "Solution - [github](https://github.com/An7One/leetcode-solutions-kotlin-an7one/tree/main/src/main/kotlin/com/an7one/leetcode/lvl4/lc0179)\\n\\nProblem List related to #String - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/string)\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/largest-number/\\n *\\n * Time Complexity:     O(`nNums` * len * lg(`nNums`)) + O(`nNums` * len) ~ O(`nNums` * len * lg(`nNums`))\\n *  len, the average length of the string\\n *\\n * Space Complexity:    O(`nNums`)\\n *\\n * Reference:\\n * https://leetcode.com/problems/largest-number/discuss/864106/Kotlin-Sorting-the-String-Array/1277846\\n */\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String {\\n\\t    // not used\\n        // val nNums = nums.size\\n\\t\\t\\n        val strs = nums.map{ it.toString() }.toMutableList().also {\\n            it.sortWith(Comparator { a, b -> (b + a).compareTo(a + b) })\\n        }.toList()\\n\\n        return if(strs[0][0] == \\'0\\') \"0\" else strs.joinToString (\"\")\\n    }\\n}\\n```\\nThank @yaxarat\\n\\nMore naively\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/largest-number/\\n *\\n * Time Complexity:     O(`nNums` * len * lg(`nNums`)) + O(`nNums` * len) ~ O(`nNums` * len * lg(`nNums`))\\n *  len, the average length of the string\\n *\\n * Space Complexity:    O(`nNums`)\\n *\\n * Reference:\\n * https://leetcode.com/problems/largest-number/discuss/53158/My-Java-Solution-to-share\\n */\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String {\\n        // sanity check\\n        if(nums.isEmpty()) return \"\"\\n        \\n        val size = nums.size\\n        val strs = Array(size){ \"\" }\\n        for(i in 0 until size){\\n            strs[i] = nums[i].toString()\\n        }\\n        \\n        strs.sortWith(Comparator{ a, b -> (b + a).compareTo(a + b) })\\n        \\n        if(strs[0][0] == \\'0\\') return \"0\"\\n        \\n        val builder = StringBuilder()\\n        for(str in strs){\\n            builder.append(str)\\n        }\\n        \\n        return builder.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/largest-number/\\n *\\n * Time Complexity:     O(`nNums` * len * lg(`nNums`)) + O(`nNums` * len) ~ O(`nNums` * len * lg(`nNums`))\\n *  len, the average length of the string\\n *\\n * Space Complexity:    O(`nNums`)\\n *\\n * Reference:\\n * https://leetcode.com/problems/largest-number/discuss/864106/Kotlin-Sorting-the-String-Array/1277846\\n */\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String {\\n\\t    // not used\\n        // val nNums = nums.size\\n\\t\\t\\n        val strs = nums.map{ it.toString() }.toMutableList().also {\\n            it.sortWith(Comparator { a, b -> (b + a).compareTo(a + b) })\\n        }.toList()\\n\\n        return if(strs[0][0] == \\'0\\') \"0\" else strs.joinToString (\"\")\\n    }\\n}\\n```\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/largest-number/\\n *\\n * Time Complexity:     O(`nNums` * len * lg(`nNums`)) + O(`nNums` * len) ~ O(`nNums` * len * lg(`nNums`))\\n *  len, the average length of the string\\n *\\n * Space Complexity:    O(`nNums`)\\n *\\n * Reference:\\n * https://leetcode.com/problems/largest-number/discuss/53158/My-Java-Solution-to-share\\n */\\nclass Solution {\\n    fun largestNumber(nums: IntArray): String {\\n        // sanity check\\n        if(nums.isEmpty()) return \"\"\\n        \\n        val size = nums.size\\n        val strs = Array(size){ \"\" }\\n        for(i in 0 until size){\\n            strs[i] = nums[i].toString()\\n        }\\n        \\n        strs.sortWith(Comparator{ a, b -> (b + a).compareTo(a + b) })\\n        \\n        if(strs[0][0] == \\'0\\') return \"0\"\\n        \\n        val builder = StringBuilder()\\n        for(str in strs){\\n            builder.append(str)\\n        }\\n        \\n        return builder.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864050,
                "title": "o-n-solution-with-trie-stack",
                "content": "1. It is possible to sort faster than O(n*Log(n)). It is similar to \"Counting sort\", but instead of counting we can build Trie (Prefix tree) with single pass O(n). And than traverse this Tree in special order (from digit \\'9\\' to digit \\'0\\'), also O(n). This approach significantly reduces number of comparisons, becase all numbers are already splitted into \"Buskets\". For example all numbers in busket \\'2\\' are definetely smaller than any number in busket \\'4\\'.\\n\\nC#\\n```\\npublic class Solution\\n{\\n    public string LargestNumber(int[] nums)\\n    {\\n        var root = new Trie();\\n        foreach(var n in nums)\\n        {\\n            root.Add(n);\\n        }\\n\\n        var stack = new Stack<Trie>();\\n        var sb = new StringBuilder();\\n        dfs(root, sb, stack);\\n\\n        while(stack.Count > 0)\\n        {\\n            stack.Pop().Append(sb);\\n        }\\n\\n        return sb.ToString();\\n    }\\n\\n    private void dfs(Trie node, StringBuilder sb, Stack<Trie> stack)\\n    {\\n        if(node.Count > 0)\\n        {\\n            while(stack.Count > 0 && node.CompareTo(stack.Peek()) < 0)\\n            {\\n                stack.Pop().Append(sb);\\n            }\\n\\n            stack.Push(node);\\n        }\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            var next = node.Children[i];\\n            if(next != null)\\n            {\\n                dfs(next, sb, stack);\\n            }\\n        }\\n    }\\n\\n    class Trie: IComparable<Trie>\\n    {\\n        public Trie[] Children = new Trie[10];\\n        public int Count;\\n        public string Number;\\n\\n        private void Add(int n)\\n        {\\n            var node = this;\\n            var s = n.ToString();\\n            foreach (var c in s)\\n            {\\n                node = node.Children[c-\\'0\\'] ??= new Trie();\\n            }\\n\\n            node.Number = s;\\n            node.Count++;\\n        }\\n\\n        public int CompareTo(Trie other)\\n        {\\n            var a = Number + other.Number;\\n            var b = other.Number + Number;\\n            return string.Compare(a, b, StringComparison.Ordinal);\\n        }\\n\\n        public void Append(StringBuilder sb)\\n        {\\n            if (sb.Length == 0 && Number == \"0\")\\n            {\\n                sb.Append(Number);\\n                return;\\n            }\\n\\n            while(Count-- > 0) sb.Append(Number);\\n        }\\n    }\\n}\\n```\\n\\n\\n2. Second solution, but with O(n*Log(n)) complexity:\\n```\\npublic class Solution: IComparer<string>\\n{\\n\\tpublic string LargestNumber(int[] nums)\\n\\t{\\n\\t\\tvar result = nums.Select(n => n.ToString())\\n                         .OrderByDescending(s => s, this)\\n                         .Aggregate((a, b) => a + b);\\n\\n\\t\\treturn result.Length > 0 && result[0] != \\'0\\' ? result : \"0\";\\n\\t}\\n\\n    public int Compare(string x, string y)\\n    {\\n        return (x + y).CompareTo(y + x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string LargestNumber(int[] nums)\\n    {\\n        var root = new Trie();\\n        foreach(var n in nums)\\n        {\\n            root.Add(n);\\n        }\\n\\n        var stack = new Stack<Trie>();\\n        var sb = new StringBuilder();\\n        dfs(root, sb, stack);\\n\\n        while(stack.Count > 0)\\n        {\\n            stack.Pop().Append(sb);\\n        }\\n\\n        return sb.ToString();\\n    }\\n\\n    private void dfs(Trie node, StringBuilder sb, Stack<Trie> stack)\\n    {\\n        if(node.Count > 0)\\n        {\\n            while(stack.Count > 0 && node.CompareTo(stack.Peek()) < 0)\\n            {\\n                stack.Pop().Append(sb);\\n            }\\n\\n            stack.Push(node);\\n        }\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            var next = node.Children[i];\\n            if(next != null)\\n            {\\n                dfs(next, sb, stack);\\n            }\\n        }\\n    }\\n\\n    class Trie: IComparable<Trie>\\n    {\\n        public Trie[] Children = new Trie[10];\\n        public int Count;\\n        public string Number;\\n\\n        private void Add(int n)\\n        {\\n            var node = this;\\n            var s = n.ToString();\\n            foreach (var c in s)\\n            {\\n                node = node.Children[c-\\'0\\'] ??= new Trie();\\n            }\\n\\n            node.Number = s;\\n            node.Count++;\\n        }\\n\\n        public int CompareTo(Trie other)\\n        {\\n            var a = Number + other.Number;\\n            var b = other.Number + Number;\\n            return string.Compare(a, b, StringComparison.Ordinal);\\n        }\\n\\n        public void Append(StringBuilder sb)\\n        {\\n            if (sb.Length == 0 && Number == \"0\")\\n            {\\n                sb.Append(Number);\\n                return;\\n            }\\n\\n            while(Count-- > 0) sb.Append(Number);\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution: IComparer<string>\\n{\\n\\tpublic string LargestNumber(int[] nums)\\n\\t{\\n\\t\\tvar result = nums.Select(n => n.ToString())\\n                         .OrderByDescending(s => s, this)\\n                         .Aggregate((a, b) => a + b);\\n\\n\\t\\treturn result.Length > 0 && result[0] != \\'0\\' ? result : \"0\";\\n\\t}\\n\\n    public int Compare(string x, string y)\\n    {\\n        return (x + y).CompareTo(y + x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863511,
                "title": "java-largest-number-shortest-and-elegant-solution",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String result = Arrays.stream(nums).boxed().collect(Collectors.toList())\\n                        .stream().sorted(new NumComp())\\n                        .map(num -> num.toString()).collect(Collectors.joining());\\n        \\n        return result.startsWith(\"0\") ? \"0\" : result;\\n    }\\n}\\n\\nclass NumComp implements Comparator<Integer> {\\n    @Override\\n    public int compare (Integer a, Integer b) {\\n        String ab = a.toString().concat(b.toString());\\n        String ba = b.toString().concat(a.toString());\\n        \\n        return ba.compareTo(ab);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String result = Arrays.stream(nums).boxed().collect(Collectors.toList())\\n                        .stream().sorted(new NumComp())\\n                        .map(num -> num.toString()).collect(Collectors.joining());\\n        \\n        return result.startsWith(\"0\") ? \"0\" : result;\\n    }\\n}\\n\\nclass NumComp implements Comparator<Integer> {\\n    @Override\\n    public int compare (Integer a, Integer b) {\\n        String ab = a.toString().concat(b.toString());\\n        String ba = b.toString().concat(a.toString());\\n        \\n        return ba.compareTo(ab);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863431,
                "title": "largest-number-c-lexicographic-sorting",
                "content": "The key is to sort the nums vector based on the lexicographic combination of any two numbers. Ex. a = 102, b = 201, should be lexicographically compared as \"102201\" vs. \"201102\", a perfect use for an inline comparator.\\n```\\nstring largestNumber(vector<int>& nums) {\\n\\tif(nums.empty()) return \"\";\\n\\tsort(nums.begin(), nums.end(), [](const int a, const int b) {\\n\\t\\treturn ((to_string(a)+to_string(b)) > (to_string(b)+to_string(a)));\\n\\t});\\n\\tif(!nums[0]) return \"0\";\\n\\n\\tstring largestNum;\\n\\tfor(auto num : nums) {\\n\\t\\tlargestNum += to_string(num);\\n\\t}\\n\\treturn largestNum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring largestNumber(vector<int>& nums) {\\n\\tif(nums.empty()) return \"\";\\n\\tsort(nums.begin(), nums.end(), [](const int a, const int b) {\\n\\t\\treturn ((to_string(a)+to_string(b)) > (to_string(b)+to_string(a)));\\n\\t});\\n\\tif(!nums[0]) return \"0\";\\n\\n\\tstring largestNum;\\n\\tfor(auto num : nums) {\\n\\t\\tlargestNum += to_string(num);\\n\\t}\\n\\treturn largestNum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 863403,
                "title": "largest-number-java-maxheap-solution",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        int len = nums.length;\\n        \\n        StringBuilder ans = new StringBuilder();\\n        \\n        PriorityQueue<String> maxHeap = new PriorityQueue<>(\\n            (s1, s2) -> (s2+s1).compareTo(s1+s2) >= 0 ? 1 : -1 ) ;\\n        \\n        for(int i=0; i<len; i++){\\n            String s = nums[i] + \"\";\\n            \\n            maxHeap.add(s);\\n        }\\n        \\n        while(!maxHeap.isEmpty()){\\n            ans.append(maxHeap.poll());\\n        }\\n        \\n        if(ans.charAt(0) == \\'0\\') return \"0\";\\n        \\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        int len = nums.length;\\n        \\n        StringBuilder ans = new StringBuilder();\\n        \\n        PriorityQueue<String> maxHeap = new PriorityQueue<>(\\n            (s1, s2) -> (s2+s1).compareTo(s1+s2) >= 0 ? 1 : -1 ) ;\\n        \\n        for(int i=0; i<len; i++){\\n            String s = nums[i] + \"\";\\n            \\n            maxHeap.add(s);\\n        }\\n        \\n        while(!maxHeap.isEmpty()){\\n            ans.append(maxHeap.poll());\\n        }\\n        \\n        if(ans.charAt(0) == \\'0\\') return \"0\";\\n        \\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803034,
                "title": "swift-simple-sweet",
                "content": "```\\nfunc largestNumber(_ nums: [Int]) -> String {\\n\\tlet sorted = nums.map{ String($0) }.sorted { $0 + $1 > $1 + $0 }\\n\\tif sorted[0] == \"0\" { return \"0\" }\\n\\n\\treturn sorted.joined()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestNumber(_ nums: [Int]) -> String {\\n\\tlet sorted = nums.map{ String($0) }.sorted { $0 + $1 > $1 + $0 }\\n\\tif sorted[0] == \"0\" { return \"0\" }\\n\\n\\treturn sorted.joined()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 728585,
                "title": "priorityqueue-java",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String res = \"\";\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> (b+a).compareTo(a+b));\\n        boolean isNonZeroFound = false;\\n        for(int num : nums) {\\n            pq.offer(\"\"+num);\\n            if(num != 0)    isNonZeroFound = true;\\n        }\\n        if(!isNonZeroFound)     return \"0\";\\n        while(!pq.isEmpty())    res += pq.poll();\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] nums) {\\n        String res = \"\";\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> (b+a).compareTo(a+b));\\n        boolean isNonZeroFound = false;\\n        for(int num : nums) {\\n            pq.offer(\"\"+num);\\n            if(num != 0)    isNonZeroFound = true;\\n        }\\n        if(!isNonZeroFound)     return \"0\";\\n        while(!pq.isEmpty())    res += pq.poll();\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694909,
                "title": "python-easy-solution-by-replacing-elements",
                "content": "```\\n\\nclass Solution(object):\\n    def largestNumber(self, nums):\\n\\t    \"\"\"\\n        :type nums: List[int]\\n        :rtype: str\\n        \"\"\"\\n\\t\\n        if len(nums) == 0: return \"\"\\n        \\n        final_str = \\'\\'\\n        flag = 0\\n        \\n\\t\\t# Arranging the array elements\\n        for x in range(0, len(nums)-1):\\n            for y in range(x+1, len(nums)):\\n                a, b = str(nums[x]), str(nums[y])\\n\\t\\t\\t\\tif(int(b+a) > int(a+b)): \\n                    nums[x], nums[y] = nums[y], nums[x]\\n\\t\\t\\n\\t\\t# Now the array elements are arranged\\n        \\n        if nums[0] == 0: return \\'0\\'\\n\\t\\t\\n\\t\\t# iterating through all the newly arranged elements and forming a string version\\n                   \\n        while flag < len(nums): \\n            final_str += str(nums[flag])\\n            flag+=1\\n                    \\n        return final_str \\n\\n```\\n\\n* Time complexity - O(n^2)\\n* Space complexity - O(1)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def largestNumber(self, nums):\\n\\t    \"\"\"\\n        :type nums: List[int]\\n        :rtype: str\\n        \"\"\"\\n\\t\\n        if len(nums) == 0: return \"\"\\n        \\n        final_str = \\'\\'\\n        flag = 0\\n        \\n\\t\\t# Arranging the array elements\\n        for x in range(0, len(nums)-1):\\n            for y in range(x+1, len(nums)):\\n                a, b = str(nums[x]), str(nums[y])\\n\\t\\t\\t\\tif(int(b+a) > int(a+b)): \\n                    nums[x], nums[y] = nums[y], nums[x]\\n\\t\\t\\n\\t\\t# Now the array elements are arranged\\n        \\n        if nums[0] == 0: return \\'0\\'\\n\\t\\t\\n\\t\\t# iterating through all the newly arranged elements and forming a string version\\n                   \\n        while flag < len(nums): \\n            final_str += str(nums[flag])\\n            flag+=1\\n                    \\n        return final_str \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565000,
                "title": "a-different-python-solution",
                "content": "1st Approach\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        nums = sorted(nums, key=lambda x:str(x)*10, reverse=True)\\n        return \\'\\'.join(nums) if nums[0] != \\'0\\' else \\'0\\'\\n```\\n\\n2nd Approach\\n\\n```\\nclass LargerNumKey(str):\\n    def __lt__(x,y):\\n        return x+y > y+x\\n    \\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        nums = sorted(nums, key = LargerNumKey)\\n        return \\'\\'.join(nums) if nums[0] != \\'0\\' else \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        nums = sorted(nums, key=lambda x:str(x)*10, reverse=True)\\n        return \\'\\'.join(nums) if nums[0] != \\'0\\' else \\'0\\'\\n```\n```\\nclass LargerNumKey(str):\\n    def __lt__(x,y):\\n        return x+y > y+x\\n    \\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        nums = sorted(nums, key = LargerNumKey)\\n        return \\'\\'.join(nums) if nums[0] != \\'0\\' else \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545225,
                "title": "simple-c-using-custom-sort",
                "content": "bool mycompare(string a,string b)\\n{\\n\\n    string ab=a+b;\\n    string ba=b+a;\\n    return ab>ba;\\n}\\n\\nclass Solution {\\npublic:\\n\\n    string largestNumber(vector<int>& nums) {\\n       if(nums.size()==0) return \"\";\\n       vector<string>v;\\n       for(int i=0;i<nums.size();i++)\\n           v.push_back(to_string(nums[i]));\\n        sort(v.begin(),v.end(),mycompare);\\n        string result=\"\";\\n        if(v[0]==\"0\") return \"0\";\\n        for(int i=0;i<v.size();i++)\\n            result+=v[i];\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string largestNumber(vector<int>& nums) {\\n       if(nums.size()==0) return \"\";\\n       vector<string>v;\\n       for(int i=0;i<nums.size();i++)\\n           v.push_back(to_string(nums[i]));\\n        sort(v.begin(),v.end(),mycompare);\\n        string result=\"\";\\n        if(v[0]==\"0\") return \"0\";\\n        for(int i=0;i<v.size();i++)\\n            result+=v[i];\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 533262,
                "title": "go-0ms",
                "content": "```\\ntype mySlice []string\\n\\nfunc (s mySlice) Len() int {\\n    return len(s)\\n}\\n\\nfunc (s mySlice) Less(i, j int) bool {\\n    return s[i] + s[j] > s[j] + s[i]\\n}\\n\\nfunc (s mySlice) Swap(i, j int) {\\n    s[i], s[j] = s[j], s[i]\\n}\\n\\nfunc largestNumber(nums []int) string {\\n    strs := make([]string, len(nums))\\n    flag := true\\n    for i := 0; i < len(nums); i++ {\\n        strs[i] = strconv.Itoa(nums[i])\\n        flag = flag && (nums[i] == 0)\\n    }\\n    if flag {\\n        return \"0\"\\n    } \\n    sort.Sort(mySlice(strs))\\n    return strings.Join(strs, \"\")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype mySlice []string\\n\\nfunc (s mySlice) Len() int {\\n    return len(s)\\n}\\n\\nfunc (s mySlice) Less(i, j int) bool {\\n    return s[i] + s[j] > s[j] + s[i]\\n}\\n\\nfunc (s mySlice) Swap(i, j int) {\\n    s[i], s[j] = s[j], s[i]\\n}\\n\\nfunc largestNumber(nums []int) string {\\n    strs := make([]string, len(nums))\\n    flag := true\\n    for i := 0; i < len(nums); i++ {\\n        strs[i] = strconv.Itoa(nums[i])\\n        flag = flag && (nums[i] == 0)\\n    }\\n    if flag {\\n        return \"0\"\\n    } \\n    sort.Sort(mySlice(strs))\\n    return strings.Join(strs, \"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511460,
                "title": "java-easy-9-line-solution-with-explanation",
                "content": "This questions is all about using a comparator. I used a Priority Queue to  implement one. \\nBelow is the code with comments for better understanding.\\n```\\npublic String largestNumber(int[] nums) {\\n\\tif(nums.length == 0) return \"\";                                     // handle corner case\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> {\\n\\t\\tString temp1 = String.valueOf(a), temp2 = String.valueOf(b);    // convert nums to string\\n\\t\\tString res1 = temp1+temp2, res2 = temp2+temp1;                  // concatenate both ways\\n\\t\\treturn res2.compareTo(res1);                                    // bigger concatenated no has higher priority\\n\\t});\\n\\tfor(int n : nums) pq.offer(n);                                      // add all nums to priority queue\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile(!pq.isEmpty()) sb.append(pq.poll());                          // generate string from queue content\\n\\treturn sb.charAt(0)==\\'0\\' ? \"0\" : sb.toString();                     // handle corner case of all 0 input\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestNumber(int[] nums) {\\n\\tif(nums.length == 0) return \"\";                                     // handle corner case\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> {\\n\\t\\tString temp1 = String.valueOf(a), temp2 = String.valueOf(b);    // convert nums to string\\n\\t\\tString res1 = temp1+temp2, res2 = temp2+temp1;                  // concatenate both ways\\n\\t\\treturn res2.compareTo(res1);                                    // bigger concatenated no has higher priority\\n\\t});\\n\\tfor(int n : nums) pq.offer(n);                                      // add all nums to priority queue\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile(!pq.isEmpty()) sb.append(pq.poll());                          // generate string from queue content\\n\\treturn sb.charAt(0)==\\'0\\' ? \"0\" : sb.toString();                     // handle corner case of all 0 input\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379360,
                "title": "python-easy-solution-comparator-implementation-with-lt",
                "content": "Code:\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        \\n        class C(str):\\n            def __lt__(self, b):\\n                return self+b > b+self\\n        \\n        return str(int(\"\".join(sorted(nums, key = C))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        nums = list(map(str, nums))\\n        \\n        class C(str):\\n            def __lt__(self, b):\\n                return self+b > b+self\\n        \\n        return str(int(\"\".join(sorted(nums, key = C))))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564593,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1567903,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1571943,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1771553,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1569000,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1921601,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1742988,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1824454,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1567904,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1567905,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1564593,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1567903,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1571943,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1771553,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1569000,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1921601,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1742988,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1824454,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1567904,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1567905,
                "content": [
                    {
                        "username": "myoldaccountabandoned",
                        "content": "We use *a.b* to represent the concatenation of non-negative integers *a* and *b* .\\n\\n**Theorem:**\\n\\nLet *a*, *b*, and *c* be non-negative integers. If *a.b > b.a* and *b.c > c.b* , we have *a.c > c.a* .\\n\\n**Proof:**\\n\\nWe use *[a]* to denote the length of the decimal representation of *a* . For example, if *a = 10* , we have *[a] = 2* .\\n\\nSince *a.b > b.a* and *b.c > c.b* , we have\\n\\n*a * 10^[b] + b > b * 10^[a] + a*\\n*b * 10^[c] + c > c * 10^[b] + b*\\n\\n, which is equivalent to\\n\\n*a * (10^[b] - 1) > b * (10^[a] - 1)*\\n*b * (10^[c] - 1) > c * (10^[b] - 1)*\\n\\nObviously, *10^[a] - 1 > 0* , *10^[b] - 1 > 0* , and *10^[c] - 1 > 0* . Since *c >= 0* , according to the above inequalities, we know that *b > 0* and *a > 0* . After multiplying the above two inequalities and cancelling *b* and *(10^[b] - 1)* , we have\\n\\n*a * (10^[c] - 1) > c * (10^[a] - 1)*\\n\\nThis is equivalent to\\n\\n*a * 10^[c] + c > c * 10^[a] + a*\\n\\n, which means *a.c > c.a* .\\n\\nQ.E.D."
                    },
                    {
                        "username": "jli794",
                        "content": "The solution of the problem rests on observing that if AB > BA. Then we have ACB > BCA for any C. This is not sth that would be intuitive to everyone. And proving it would takes much case by case reasoning. Which is not sth I want to do during interviews.\\n\\nAfter making the observation, it still takes some clever reasoning to see that sorting using the above comparator would give the largest number. \\n\\nUltimately, the programming part is trivial, but the mathematical reasoning is un-intuitive and would be very hard to come up with during an interview.\\n\\nSo I'd be pretty pissed if I get sth like this on an interview. 1/10, not good."
                    },
                    {
                        "username": "sihan_sun",
                        "content": "This is not true. Let\\'s say A is 506 and B is 50, while C is 8. In this case AB=50650 and BA=50506, so we have AB>BA. However, ACB=506850 and BCA=508506, so we have BCA>ACB. "
                    },
                    {
                        "username": "sreejab",
                        "content": "Is the test case wrong for \\nInput: [3,30,34,5,9] \\nOutput: \"9534330\" ? \\n\\nShould the output not be \"9543330\""
                    },
                    {
                        "username": "yogeshft",
                        "content": "no read the question again  you might be considering digits instead of  \"integers\""
                    },
                    {
                        "username": "pankhuripatel",
                        "content": "you reversed the number 34, we can\\'t do that. we have to arrange these numbers without sorting them\\n"
                    },
                    {
                        "username": "taskin",
                        "content": "[@PratikGehlot](/PratikGehlot) They have used some test cases where it breaks this condition such as test case 50\\nnums = [34323,3432]\\nOutput=    \"343233432\"\\nExpected= \"343234323\""
                    },
                    {
                        "username": "abandewar",
                        "content": "[@user9409Y](/user9409Y)  You can not break the number and rearrange the digit as you are trying here for 34 -> 43."
                    },
                    {
                        "username": "PratikGehlot",
                        "content": "[@user9409Y](/user9409Y) you cannot break the numbers, we need to use as it is"
                    },
                    {
                        "username": "the_guess",
                        "content": "In the problem statement It is said that we cannot break any array element. The only property we have to use is concatenation of elements of array.\\nIn this Example, the arrangement will look like {9,5,34,3,30}\\nThis is the best possible arrangement"
                    },
                    {
                        "username": "user9409Y",
                        "content": "That\\'s what exactly I was looking for. 9543330 is greater than 9534330 therefore that given \\ntest case is incorrect!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the testcases with all 0's\nExample: [0,0,0]"
                    },
                    {
                        "username": "markov_r",
                        "content": "There is also an incorrect test case [00, 0], there is no number 00."
                    },
                    {
                        "username": "ypadu",
                        "content": "The solution can't be correct without the transitivity:\\n\\nIf AB > BA and BC > CB, then we have AC > CA.\\n\\nBut how to prove it?"
                    },
                    {
                        "username": "shashwat0105",
                        "content": "AB>BA means A>B, BC>CB means B>C, Hence, A>B>C => A>C"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Man the 0\\'s cases were evil"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I tried to do the leetcode original solution in C++, but sadly it gives \"heap-buffer-overflow\" error in some test cases... ;("
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "I just found this problem was from China National Olympiad in Informatics (china NOI) in 1998.\\nYou can solve this problem on this website: https://www.luogu.com.cn/problem/P1012"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "[@hazemati](/hazemati) It is up to you. We live in a free world.\\nI just wanted to point out that this problem is a rip off of the \"China National Olympiad in Informatics\" and the website proves it."
                    },
                    {
                        "username": "hazemati",
                        "content": "uhhhm, why would I go onto another website to solve this problem, when I can just solve it right here on leetcode?"
                    },
                    {
                        "username": "heimi",
                        "content": "The problem link is: [Here][1]. My solution passed all the test cases except the last one. After checking the result, I found the only difference is between column 75 - 81. My sequence is 8308830 and the expected is 8308308. Both are from [830, 8308]. Apparently, 8308830 is the best answer.\\n\\n\\n  [1]: https://leetcode.com/problems/largest-number/"
                    },
                    {
                        "username": "benjaminwhite",
                        "content": "All python solutions I've seen use `cmp` in `sort` which only exists in python 2. Has anyone found a solution that uses a `key` function instead?"
                    },
                    {
                        "username": "nandoaires",
                        "content": "You can always use cmp_to_key from itertools"
                    },
                    {
                        "username": "Triquetra",
                        "content": "I wrote one, see [here](https://leetcode.com/problems/largest-number/solutions/2884355/)."
                    }
                ]
            },
            {
                "id": 1913328,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 1571386,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 2072360,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 2063221,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 2036964,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 2035888,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 2011454,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 1959752,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 1956755,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            },
            {
                "id": 1810620,
                "content": [
                    {
                        "username": "kanhu_pasayat",
                        "content": "gand"
                    },
                    {
                        "username": "fl0ydwong",
                        "content": "the test case :\\n\\ninput : [20,1];\\n\\nOutput:\"210\";\\n\\nExpected:\"201\";\\n\\n\\n \"210\" is not the largest number in this test case,kidding me......"
                    },
                    {
                        "username": "dsachin98",
                        "content": "you can\\'t break the sequence while providing the expected output ! "
                    },
                    {
                        "username": "hanykelany63",
                        "content": "Number 20 can\\'t be 02  \\u2192  so the correct is 20 + 1 \\u2192 \"201\""
                    },
                    {
                        "username": "Anas_Sain_006",
                        "content": "201 is the correct answer\\n"
                    },
                    {
                        "username": "moshiurse",
                        "content": "You cannot break portion of any element. "
                    },
                    {
                        "username": "ee07dazn",
                        "content": "nums =\\n[3,30,34,5,9]\\nmy output = \"\"9543330\"\\nexpected (from leetcode) = \"9534330\"\\nmy output is bigger as requested in the question..leetcode\\'s expected answer seems wrong. Or am i missing somehting?"
                    },
                    {
                        "username": "pokaramakrishna",
                        "content": "[3,30,34,5,9]\\nOutput\\n\"9543330\"\\nExpected\\n\"9534330\"\\n9543330 is larger than 9534330 but expected output is given as 9534330.I think this test case is wrong."
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can not change the digits of a number. For example, the number \"34\" cna not became \"43\". You just have to re-order the numbers and concatnate them so it becames the largest possible."
                    },
                    {
                        "username": "ParulShah",
                        "content": "What to do in this testcase [34323,3432] ?"
                    },
                    {
                        "username": "gopalgupta29444",
                        "content": "9543330 this a  largest number \\n9534330  this is smallest value form 9543330\\ntell me about second test case  "
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number. For example the number \"34\" can not became \"43\". Just re-order the numbers they give in a way it becames the biggest possible."
                    },
                    {
                        "username": "rishirajpathak63",
                        "content": "swapping of digits is not allowed...you have to make a largest number from the given values only...you don\\'t have to swap any of the digits in the process..."
                    },
                    {
                        "username": "Tpdi",
                        "content": "There\\'s a testcase, nums = [0, 0] with expected \"0\". Shouldn\\'t it be \"00\"?"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "sadly, this is a base case. If answer[0] == \\'0\\' return \"0\". It is a mean test case by leetcode I must say."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "Input: nums = [3,30,34,5,9]\\noutput should be 9543330 right?but it is givenOutput: \"9534330\"\\n"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "You can\\'t sort the digits of a number, if you have a digit \"34\" it can not became \"43\". you just have to re-order the positions of the given numbers they give to you. for example if you have [\"5\", \"45\"], the biggest number is \"545\"."
                    },
                    {
                        "username": "UsGitHu611",
                        "content": "for what... test case 2:  nums = [3,30,34,5,9], Output : \"9543330\" , Expected : \"9534330\" what i doing not?\\n\\nconst largestNumber = (nums) => {\\n    return nums.join().match(/[0-9]/g).sort((a,b)=>b-a).join(\\'\\')\\n};"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "If a number has more than 1 digit, like number 34, you can not sort the digits in a single number to became 43. which is the exact mistake you made. You have just to reorder the digits in the array and then concactenated them so it become the largest number possible."
                    },
                    {
                        "username": "Din_Srg",
                        "content": "Check the testcase of [9,89,98]"
                    }
                ]
            }
        ]
    }
]