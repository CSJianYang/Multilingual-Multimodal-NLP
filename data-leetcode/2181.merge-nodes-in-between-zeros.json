[
    {
        "title": "Merge Nodes in Between Zeros",
        "question_content": "You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.\nFor every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.\nReturn the head of the modified linked list.\n&nbsp;\nExample 1:\n\nInput: head = [0,3,1,0,4,5,2,0]\nOutput: [4,11]\nExplanation: \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 3 + 1 = 4.\n- The sum of the nodes marked in red: 4 + 5 + 2 = 11.\n\nExample 2:\n\nInput: head = [0,1,0,3,0,2,2,0]\nOutput: [1,3,4]\nExplanation: \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 1 = 1.\n- The sum of the nodes marked in red: 3 = 3.\n- The sum of the nodes marked in yellow: 2 + 2 = 4.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [3, 2 * 105].\n\t0 <= Node.val <= 1000\n\tThere are no two consecutive nodes with Node.val == 0.\n\tThe beginning and end of the linked list have Node.val == 0.",
        "solutions": [
            {
                "id": 1785026,
                "title": "recursive-vs-iterative-without-dummy-o-1-space-intuition",
                "content": "For these modification Questions , **Recursion** is a great tool in these linked list question.\\n\\n**My Intuition** :\\nWhenever `the process is having repeated tasks again and again especially in Linked List`, We use **Recursion**.\\n# For eg -> \\n```\\n1. Skip M nodes, delete N nodes nodes\\n2. Reverse every K nodes.\\n3. Skip M node, Reverse N nodes.\\n4. get sum between consecutive 0\\'s.{This Question}.\\n```\\n\\nYou see all above question are having **same tasks again and again**, and thats why **I thought of Recursion**.\\n              \\n\\n**Algorithm**: In Recursion , we only have to consider about first part and rest will be done by principle of recursion.\\n1. Fetch the sum between two consecutive 0.\\n2. Assign the sum to first node between 2 consecutive 0\\'s.\\n3. Call function for the next parts.\\n4. Whatever was returned from the function , assign it to next of the first node on which we assigned the sum previously.\\n5. Return the New head as head->next.\\n\\n**We are using Constant space because we are not creating any extra node for sum.**\\n**We are just assigning the sum to already existed node.**\\n# C++ Recursive : Very Easy\\n    ListNode* mergeNodes(ListNode* head){\\n\\t    //BASE CASE -> if we have a single zero, simply return null\\n        if(!head->next) return nullptr;\\n        \\n        //fetch sum from current 0 to next 0\\n        ListNode* ptr= head->next;\\n        int sum=0;\\n        while(ptr->val!=0) sum+= ptr->val, ptr=ptr->next;\\n        \\n        //assign sum on the first node between nodes having value 0.\\n        head->next->val= sum;\\n        \\n        //call and get the answer and connect the answer to next of head->next\\n        head->next->next= mergeNodes(ptr);\\n        \\n        //return head->next..=> new head\\n        return head->next;\\n    }\\n**Time**: O(N).\\n**Space**: O(1) {Excluding recursion space}.\\n\\n\\t\\n# C++ Iterative :\\tFaster than 95%\\nSame as Recursive above but in iterative version.\\nDoing everything INPLACE without creating new node for sum, as in recursion.\\n   \\n     ListNode* mergeNodes(ListNode* head) {\\n         head=head->next;\\n         ListNode* start=head;\\n         while(start){\\n\\t\\t    ListNode* end= start;   /* Point to first node of current part for getting sum */\\n            int sum=0;\\n            while(end->val!=0) sum+= end->val , end=end->next;\\n            start->val=sum;   /*assign sum to first node between two 0*/\\n            start->next=end->next;   /*make this connect to first node of next part*/\\n            start=start->next;    /*go..to..next..part*/\\n\\t\\t }\\n         return head;\\n    }\\n\\n**Time** -> O(N)\\n**Space** -> O(1) {We are doing everything **inplace**, **without creating new nodes for sum**}\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Skip M nodes, delete N nodes nodes\\n2. Reverse every K nodes.\\n3. Skip M node, Reverse N nodes.\\n4. get sum between consecutive 0\\'s.{This Question}.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1819981,
                "title": "python-simple-solution-99-97-faster-o-n-time-o-1-space",
                "content": "Understanding:\\nIterate through the list and keep adding the digits till you find a \\'0\\'. When you find a \\'0\\' add it to the list and repeat the process again.\\n\\nAlgorithm:\\n- Initialize sum = 0, pointer 1 to the head and pointer 2 to the next element in the list.\\n- Loop through the list till pointer 2 reaches the end of the list.\\n- In the loop, if pointer 2\\'s value is 0 then, make pointer 1 move to the next list item and give it the value of the current sum. Re-initialize the sum to 0.\\n- Else keep adding pointer 2\\'s value to the current sum.\\n- Increment pointer 2.\\n- When pointer 2 reaches the end of the list, make pointer 1\\'s next None. (We store the sum values in the same list to make it memory efficient)\\n- Return the second element on the list. (First element is a 0)\\n\\n```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        ptr1 = head\\n        ptr2 = head.next\\n        s = 0\\n        while ptr2:\\n            if ptr2.val == 0:\\n                ptr1 = ptr1.next\\n                ptr1.val=s\\n                s=0\\n            else:\\n                s+=ptr2.val\\n            ptr2 = ptr2.next\\n        ptr1.next=None\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        ptr1 = head\\n        ptr2 = head.next\\n        s = 0\\n        while ptr2:\\n            if ptr2.val == 0:\\n                ptr1 = ptr1.next\\n                ptr1.val=s\\n                s=0\\n            else:\\n                s+=ptr2.val\\n            ptr2 = ptr2.next\\n        ptr1.next=None\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784765,
                "title": "one-pass",
                "content": "**C++**\\n```cpp\\nListNode* mergeNodes(ListNode* head) {\\n    for (auto *p_z = head, *p = head->next; p != nullptr; p = p->next) {\\n        if (p->val != 0)\\n            p_z->val += p->val;\\n        else {\\n            p_z->next = p->next != nullptr ? p : nullptr;\\n            p_z = p;\\n        }\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* mergeNodes(ListNode* head) {\\n    for (auto *p_z = head, *p = head->next; p != nullptr; p = p->next) {\\n        if (p->val != 0)\\n            p_z->val += p->val;\\n        else {\\n            p_z->next = p->next != nullptr ? p : nullptr;\\n            p_z = p;\\n        }\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784766,
                "title": "java-python-3-one-pass-two-pointers-copy-sum-to-0-nodes",
                "content": "Use zero nodes to store the sum of merged nodes, remove the last zero node, which is unused.\\n\\n1. Use `prev` to connect and move among all zero nodes;\\n2. Use `head` to traverse nodes between zero nodes, and add their values to the previous zero node;\\n3. Always use `prev` point to the node right before current zero node, hence we can remove the last zero node easily.\\n\\n```java\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MIN_VALUE), prev = dummy;\\n        while (head != null && head.next != null) {\\n            prev.next = head; // prev connects next 0 node.\\n            head = head.next; // head forward to a non-zero node.\\n            while (head != null && head.val != 0) { // traverse all non-zero nodes between two zero nodes.\\n                prev.next.val += head.val; // add current value to the previous zero node.\\n                head = head.next; // forward one step.\\n            }\\n            prev = prev.next; // prev point to the summation node (initially 0).\\n        }\\n        prev.next = null; // cut off last 0 node.\\n        return dummy.next;\\n    }\\n```\\n```python\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = ListNode(-math.inf)\\n        while head and head.next:\\n            prev.next = head\\n            head = head.next\\n            while head and head.val != 0:\\n                prev.next.val += head.val\\n                head = head.next\\n            prev = prev.next\\n        prev.next = None    \\n        return dummy.next\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, extra space: `O(1)`, where `n` is the number of nodes.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MIN_VALUE), prev = dummy;\\n        while (head != null && head.next != null) {\\n            prev.next = head; // prev connects next 0 node.\\n            head = head.next; // head forward to a non-zero node.\\n            while (head != null && head.val != 0) { // traverse all non-zero nodes between two zero nodes.\\n                prev.next.val += head.val; // add current value to the previous zero node.\\n                head = head.next; // forward one step.\\n            }\\n            prev = prev.next; // prev point to the summation node (initially 0).\\n        }\\n        prev.next = null; // cut off last 0 node.\\n        return dummy.next;\\n    }\\n```\n```python\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = ListNode(-math.inf)\\n        while head and head.next:\\n            prev.next = head\\n            head = head.next\\n            while head and head.val != 0:\\n                prev.next.val += head.val\\n                head = head.next\\n            prev = prev.next\\n        prev.next = None    \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784911,
                "title": "java-easy-o-n",
                "content": "\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode curr, root = new ListNode();\\n\\t\\tcurr = root;\\n        int sum = 0;\\n        while(head!=null){\\n            if(head.val==0 && sum!=0){\\n                curr.next = new ListNode(sum);\\n                curr = curr.next;\\n                sum = 0;\\n            }\\n            sum+=head.val;\\n            head = head.next;\\n        }\\n        return root.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode curr, root = new ListNode();\\n\\t\\tcurr = root;\\n        int sum = 0;\\n        while(head!=null){\\n            if(head.val==0 && sum!=0){\\n                curr.next = new ListNode(sum);\\n                curr = curr.next;\\n                sum = 0;\\n            }\\n            sum+=head.val;\\n            head = head.next;\\n        }\\n        return root.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1784898,
                "title": "c-easy-to-understand-linked-list",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* res = new ListNode(0);\\n        ListNode* ret = res;\\n        int sm = 0;\\n        head = head->next;\\n        \\n        while(head != NULL){\\n            if(head->val == 0){\\n                res->next = new ListNode(sm);\\n                res = res->next;\\n                sm = 0;\\n            } else {\\n                sm += head->val;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return ret->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* res = new ListNode(0);\\n        ListNode* ret = res;\\n        int sm = 0;\\n        head = head->next;\\n        \\n        while(head != NULL){\\n            if(head->val == 0){\\n                res->next = new ListNode(sm);\\n                res = res->next;\\n                sm = 0;\\n            } else {\\n                sm += head->val;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return ret->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784963,
                "title": "c-sc-o-1",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head->val==0){\\n            head=head->next;\\n        }\\n        ListNode* res=head;\\n        ListNode* temp=head;\\n        int sum=0;\\n        \\n        while(temp){\\n            if(temp->val!=0){\\n                sum+=temp->val;\\n                temp=temp->next;\\n            } \\n            else{\\n                res->val=sum;\\n                res->next = temp->next;\\n                temp = temp->next;\\n                res = temp;\\n                sum = 0;\\n            }\\n            \\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head->val==0){\\n            head=head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2759708,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        ListNode* node=dummy;\\n        ListNode* temp=head;\\n        temp=temp->next;\\n        int sum=0;\\n        while(temp!=NULL){\\n            while(temp->val!=0){\\n                sum+=temp->val;\\n                temp=temp->next;\\n                }\\n            node->next=new ListNode(sum);\\n            node=node->next;\\n            temp=temp->next;\\n            sum=0;\\n        }\\n        return dummy->next;\\n    }\\n};\\n\\nif it helps Plzz don\\'t Forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        ListNode* node=dummy;\\n        ListNode* temp=head;\\n        temp=temp->next;\\n        int sum=0;\\n        while(temp!=NULL){\\n            while(temp->val!=0){\\n                sum+=temp->val;\\n                temp=temp->next;\\n                }\\n            node->next=new ListNode(sum);\\n            node=node->next;\\n            temp=temp->next;\\n            sum=0;\\n        }\\n        return dummy->next;\\n    }\\n};\\n\\nif it helps Plzz don\\'t Forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125965,
                "title": "java-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode newList=new ListNode(0);\\n        ListNode newHead=newList;\\n       ListNode newtemp= newList;\\n/*---------------------------------------------------------------*/\\n        ListNode temp=head.next;\\n        int sum=0;\\n        if(head==null && head.next==null) return head;\\n/*---------------------------------------------------------------*/  \\n        while(temp!=null){  //traverse linkelist\\n            sum +=temp.val;  //sum elements until zero\\n            if(temp.val==0){\\n               ListNode node=new ListNode(sum); //create a new node; \\n               newtemp.next=node; //connect with dummy node which is created initially\\n                newtemp=newtemp.next; //shift pointer to newly created node\\n                sum=0; //reset sum\\n            }\\n            temp=temp.next;\\n        }\\n/*---------------------------------------------------------------*/\\n        return newHead.next; //skip dummy node which is created initially\\n    }\\n}\\n```\\n**Please UPVOTE if you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode newList=new ListNode(0);\\n        ListNode newHead=newList;\\n       ListNode newtemp= newList;\\n/*---------------------------------------------------------------*/\\n        ListNode temp=head.next;\\n        int sum=0;\\n        if(head==null && head.next==null) return head;\\n/*---------------------------------------------------------------*/  \\n        while(temp!=null){  //traverse linkelist\\n            sum +=temp.val;  //sum elements until zero\\n            if(temp.val==0){\\n               ListNode node=new ListNode(sum); //create a new node; \\n               newtemp.next=node; //connect with dummy node which is created initially\\n                newtemp=newtemp.next; //shift pointer to newly created node\\n                sum=0; //reset sum\\n            }\\n            temp=temp.next;\\n        }\\n/*---------------------------------------------------------------*/\\n        return newHead.next; //skip dummy node which is created initially\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958515,
                "title": "easy-solution-beginners-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *temp = head, *temp2 = head->next;\\n        int sum = 0;\\n        while(temp2){\\n            if(temp2->val == 0){\\n                temp->next = new ListNode(sum);\\n                temp->next->next = temp2->next;\\n                temp = temp->next; \\n                sum = 0; \\n            }\\n            sum+= temp2->val;\\n            temp2 = temp2->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *temp = head, *temp2 = head->next;\\n        int sum = 0;\\n        while(temp2){\\n            if(temp2->val == 0){\\n                temp->next = new ListNode(sum);\\n                temp->next->next = temp2->next;\\n                temp = temp->next; \\n                sum = 0; \\n            }\\n            sum+= temp2->val;\\n            temp2 = temp2->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327299,
                "title": "java-easy-solution-easy-to-understand-beat-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake loop for iteration .While iterating increment the count variable when your pointer points to 0. When you find two consecutive zero\\'s add the inbetween node val in sum variable. At last add your sum into new ListNode and return it.\\n\\n# Complexity\\n- Time complexity:\\n**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode ans=new ListNode();\\n        ListNode temp=ans;\\n        ListNode curr=head;\\n        int sum=0;\\n        int count=0;\\n        while(curr!=null){\\n            if(curr.val==0) count++;\\n                 else sum+=curr.val;\\n\\n            if(count==2){\\n                ListNode node=new ListNode(sum);\\n                ans.next=node;\\n                ans=ans.next;\\n                sum=0;\\n                count=1;\\n            }\\n            curr=curr.next;\\n        }\\n        return temp.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode ans=new ListNode();\\n        ListNode temp=ans;\\n        ListNode curr=head;\\n        int sum=0;\\n        int count=0;\\n        while(curr!=null){\\n            if(curr.val==0) count++;\\n                 else sum+=curr.val;\\n\\n            if(count==2){\\n                ListNode node=new ListNode(sum);\\n                ans.next=node;\\n                ans=ans.next;\\n                sum=0;\\n                count=1;\\n            }\\n            curr=curr.next;\\n        }\\n        return temp.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805052,
                "title": "easy-solution-using-c",
                "content": "class Solution {\\n\\npublic:\\n\\n    ListNode* mergeNodes(ListNode* head) {\\n\\t\\n        ListNode* temp= head;\\n        ListNode* naya = new ListNode(0);\\n        ListNode* ans = naya;\\n        temp=temp->next;\\n        int sum=0;\\n        while(temp )\\n        {\\n            \\n            if(temp->val==0)\\n            {\\n               naya->next= new ListNode(sum);\\n                naya=naya->next;\\n                sum=0;\\n            }\\n            else{\\n                sum+=temp->val;\\n            }\\n            temp=temp->next;\\n        }\\n        return ans->next;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    ListNode* mergeNodes(ListNode* head) {\\n\\t\\n        ListNode* temp= head;\\n        ListNode* naya = new ListNode(0);\\n        ListNode* ans = naya;\\n        temp=temp->next;\\n        int sum=0;\\n        while(temp )\\n        {\\n            \\n            if(temp->val==0)\\n            {\\n               naya->next= new ListNode(sum);\\n                naya=naya->next;\\n                sum=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1784780,
                "title": "python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/793daa0aab0733bfadd4041fdaa6f8bdd38fe229) for solutions of weekly 281. \\n\\n```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = node = ListNode()\\n        chunk = head\\n        while chunk: \\n            chunk = chunk.next \\n            sm = 0 \\n            while chunk and chunk.val: \\n                sm += chunk.val \\n                chunk = chunk.next \\n            if sm: node.next = node = ListNode(sm)\\n        return dummy.next \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = node = ListNode()\\n        chunk = head\\n        while chunk: \\n            chunk = chunk.next \\n            sm = 0 \\n            while chunk and chunk.val: \\n                sm += chunk.val \\n                chunk = chunk.next \\n            if sm: node.next = node = ListNode(sm)\\n        return dummy.next \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235707,
                "title": "javascript-solution",
                "content": "```\\nvar mergeNodes = function(head) {\\n    var res = new ListNode()\\n    var ans = res ;\\n    var current = head.next;\\n    var sum = 0;\\n    while(current){\\n              \\n            if(current.val != 0){\\n                sum = sum + current.val;\\n            }else{\\n                res.next = new ListNode(sum);\\n                sum = 0;\\n                res = res.next;\\n            }\\n        current = current.next;\\n            \\n    }\\n    return ans.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeNodes = function(head) {\\n    var res = new ListNode()\\n    var ans = res ;\\n    var current = head.next;\\n    var sum = 0;\\n    while(current){\\n              \\n            if(current.val != 0){\\n                sum = sum + current.val;\\n            }else{\\n                res.next = new ListNode(sum);\\n                sum = 0;\\n                res = res.next;\\n            }\\n        current = current.next;\\n            \\n    }\\n    return ans.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784873,
                "title": "python-3-dummy-node-o-n-time-solution",
                "content": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        d=ListNode(0)\\n        t=0\\n        r=ListNode(0,d)\\n        while head:\\n            if head.val!=0:\\n                t+=head.val\\n            else:\\n                print(t)\\n                if t!=0:\\n                    d.next=ListNode(t)\\n                    d=d.next\\n                    t=0\\n            head=head.next\\n        return r.next.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        d=ListNode(0)\\n        t=0\\n        r=ListNode(0,d)\\n        while head:\\n            if head.val!=0:\\n                t+=head.val\\n            else:\\n                print(t)\\n                if t!=0:\\n                    d.next=ListNode(t)\\n                    d=d.next\\n                    t=0\\n            head=head.next\\n        return r.next.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873060,
                "title": "java",
                "content": "Pls upvote if u like it\\n\\n```\\npublic ListNode mergeNodes(ListNode head) {\\n    ListNode cur;\\n    ListNode res = new ListNode(-1);\\n    cur = res;\\n    int sum = 0;\\n\\n    while (head != null) {\\n        if (head.val != 0) {\\n            sum += head.val;\\n        } else {\\n            cur.next = new ListNode(sum);\\n            cur = cur.next;\\n            sum = 0;\\n        }\\n        head = head.next;\\n    }\\n    return res.next.next;\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode mergeNodes(ListNode head) {\\n    ListNode cur;\\n    ListNode res = new ListNode(-1);\\n    cur = res;\\n    int sum = 0;\\n\\n    while (head != null) {\\n        if (head.val != 0) {\\n            sum += head.val;\\n        } else {\\n            cur.next = new ListNode(sum);\\n            cur = cur.next;\\n            sum = 0;\\n        }\\n        head = head.next;\\n    }\\n    return res.next.next;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798702,
                "title": "python-beats-98-o-n-time-complexity-o-1-space-complexity-explained",
                "content": "\\n\\n# Approach\\n1. Create two pointers on poiting to head and another pointing to head.next.\\n2. Initialize the sum as 0\\n3. loop till the end, keep on adding the value of 2nd pointer to sum variable till you encounter value 0\\n4. when you encounter 0 set the value of sum to the next of first pointer.\\n5. Keep on doing this till you reach at last node, at last set the 1st pointer Next to None so you only get three values to your head ListNode.\\n6. Since the node always starts with 0 so return head.next to only return the sum values except the first 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = curr = head\\n        curr = curr.next\\n        sum = 0\\n        while curr:\\n            if curr.val == 0:\\n                dummy = dummy.next\\n                dummy.val = sum\\n                sum = 0\\n            else:\\n                sum += curr.val\\n            curr = curr.next\\n        dummy.next = None\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = curr = head\\n        curr = curr.next\\n        sum = 0\\n        while curr:\\n            if curr.val == 0:\\n                dummy = dummy.next\\n                dummy.val = sum\\n                sum = 0\\n            else:\\n                sum += curr.val\\n            curr = curr.next\\n        dummy.next = None\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784818,
                "title": "simple-python-solution-in-o-n-time",
                "content": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        ans = ListNode()\\n        dummy = ans\\n        while current is not None and current.next is not None:\\n            if current.val == 0:\\n                count = 0\\n                current = current.next\\n                while current.val != 0 and current is not None:\\n                    count += current.val\\n                    current = current.next\\n                dummy.next = ListNode(count)\\n                dummy = dummy.next\\n        return ans.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current = head\\n        ans = ListNode()\\n        dummy = ans\\n        while current is not None and current.next is not None:\\n            if current.val == 0:\\n                count = 0\\n                current = current.next\\n                while current.val != 0 and current is not None:\\n                    count += current.val\\n                    current = current.next\\n                dummy.next = ListNode(count)\\n                dummy = dummy.next\\n        return ans.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784739,
                "title": "c-simulation-o-n-time",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. \\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/merge-nodes-in-between-zeros/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space excluding those taken by answer\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        while (head) {\\n            if (head->val == 0) head = head->next; // skip leading `0`\\n            if (!head) break;\\n            int sum = 0;\\n            while (head->val != 0) { // sum numbers before the next `0`\\n                sum += head->val;\\n                head = head->next;\\n            }\\n            tail->next = new ListNode(sum); // append `sum`\\n            tail = tail->next;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```\\n\\n## Solution 2.\\n\\nIf we are asked to do it in-place.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/merge-nodes-in-between-zeros/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) as it\\'s done in-place\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        while (head) {\\n            if (head->val == 0) head = head->next;\\n            if (!head) break;\\n            auto node = head;\\n            head = head->next;\\n            while (head->val != 0) {\\n                node->val += head->val;\\n                head = head->next;\\n            }\\n            tail->next = node;\\n            tail = tail->next;\\n            node->next = nullptr;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```\\n\\nIf you are asked to add the code to free node:\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/merge-nodes-in-between-zeros/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) as it\\'s done in-place\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        while (head) {\\n            if (head->val == 0) {\\n                auto p = head;\\n                head = head->next;\\n                delete p;\\n            }\\n            if (!head) break;\\n            auto node = head;\\n            head = head->next;\\n            while (head->val != 0) {\\n                node->val += head->val;\\n                auto p = head;\\n                head = head->next;\\n                delete p;\\n            }\\n            tail->next = node;\\n            tail = tail->next;\\n            node->next = nullptr;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/merge-nodes-in-between-zeros/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space excluding those taken by answer\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        while (head) {\\n            if (head->val == 0) head = head->next; // skip leading `0`\\n            if (!head) break;\\n            int sum = 0;\\n            while (head->val != 0) { // sum numbers before the next `0`\\n                sum += head->val;\\n                head = head->next;\\n            }\\n            tail->next = new ListNode(sum); // append `sum`\\n            tail = tail->next;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/merge-nodes-in-between-zeros/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) as it\\'s done in-place\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        while (head) {\\n            if (head->val == 0) head = head->next;\\n            if (!head) break;\\n            auto node = head;\\n            head = head->next;\\n            while (head->val != 0) {\\n                node->val += head->val;\\n                head = head->next;\\n            }\\n            tail->next = node;\\n            tail = tail->next;\\n            node->next = nullptr;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-281/problems/merge-nodes-in-between-zeros/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) as it\\'s done in-place\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        while (head) {\\n            if (head->val == 0) {\\n                auto p = head;\\n                head = head->next;\\n                delete p;\\n            }\\n            if (!head) break;\\n            auto node = head;\\n            head = head->next;\\n            while (head->val != 0) {\\n                node->val += head->val;\\n                auto p = head;\\n                head = head->next;\\n                delete p;\\n            }\\n            tail->next = node;\\n            tail = tail->next;\\n            node->next = nullptr;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869542,
                "title": "python-simple-python-solution-nested-loop",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 6310 ms, faster than 29.52% of Python3 online submissions for Merge Nodes in Between Zeros.\\n# Memory Usage: 104.3 MB, less than 16.40% of Python3 online submissions for Merge Nodes in Between Zeros.\\n\\n\\tclass Solution:\\n\\t\\tdef mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tcurrent_node = head.next\\n\\n\\t\\t\\tresult = new_node = ListNode(0)\\n\\n\\t\\t\\twhile current_node:\\n\\n\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\t\\twhile current_node.val != 0:\\n\\t\\t\\t\\t\\tcurrent_sum = current_sum + current_node.val\\n\\t\\t\\t\\t\\tcurrent_node = current_node.next\\n\\n\\t\\t\\t\\tnew_node.next = ListNode(current_sum)\\n\\t\\t\\t\\tnew_node = new_node.next\\n\\n\\t\\t\\t\\tcurrent_node = current_node.next\\n\\n\\t\\t\\treturn result.next\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 6310 ms, faster than 29.52% of Python3 online submissions for Merge Nodes in Between Zeros.\\n# Memory Usage: 104.3 MB, less than 16.40% of Python3 online submissions for Merge Nodes in Between Zeros.\\n\\n\\tclass Solution:\\n\\t\\tdef mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tcurrent_node = head.next\\n\\n\\t\\t\\tresult = new_node = ListNode(0)\\n\\n\\t\\t\\twhile current_node:\\n\\n\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\t\\twhile current_node.val != 0:\\n\\t\\t\\t\\t\\tcurrent_sum = current_sum + current_node.val\\n\\t\\t\\t\\t\\tcurrent_node = current_node.next\\n\\n\\t\\t\\t\\tnew_node.next = ListNode(current_sum)\\n\\t\\t\\t\\tnew_node = new_node.next\\n\\n\\t\\t\\t\\tcurrent_node = current_node.next\\n\\n\\t\\t\\treturn result.next\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 2013635,
                "title": "js-o-n-easy-to-understand",
                "content": "```\\nvar mergeNodes = function(head) {\\n    let count = 0;\\n    \\n    let node = head; // start on first zero\\n    \\n    while(node.next) {\\n        node.val += node.next.val; // add current value to node\\n        node.next = node.next.next; // remove value between zeroes\\n        \\n        // remove last zero\\n        if(!node.next.next) {\\n            node.next = null;\\n            break;\\n        }\\n        // traverse node to next 0\\n        if(node.next.val === 0) {\\n            node = node.next;\\n        }\\n    }\\n    \\n    return head;\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeNodes = function(head) {\\n    let count = 0;\\n    \\n    let node = head; // start on first zero\\n    \\n    while(node.next) {\\n        node.val += node.next.val; // add current value to node\\n        node.next = node.next.next; // remove value between zeroes\\n        \\n        // remove last zero\\n        if(!node.next.next) {\\n            node.next = null;\\n            break;\\n        }\\n        // traverse node to next 0\\n        if(node.next.val === 0) {\\n            node = node.next;\\n        }\\n    }\\n    \\n    return head;\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843973,
                "title": "beginner-friendly-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode curr, root = new ListNode();\\n        curr = root;\\n        int sum = 0;\\n        while(head != null){\\n            if(head.val == 0 && sum != 0){\\n                curr.next = new ListNode(sum);\\n                curr = curr.next;\\n                sum = 0;   \\n            }\\n            sum += head.val;\\n            head = head.next;\\n        }\\n        return root.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode curr, root = new ListNode();\\n        curr = root;\\n        int sum = 0;\\n        while(head != null){\\n            if(head.val == 0 && sum != 0){\\n                curr.next = new ListNode(sum);\\n                curr = curr.next;\\n                sum = 0;   \\n            }\\n            sum += head.val;\\n            head = head.next;\\n        }\\n        return root.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803365,
                "title": "c-easy-approach-for-beginners-with-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/a265d01a-6f11-4fe1-aa9b-0ddf91a004e3_1645947685.9593856.jpeg)\\n\\n\\n```\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *temp = head->next;\\n        ListNode *one = head->next;\\n        ListNode *two = head->next;\\n        while(two->next)\\n        {   \\n            two = two->next;\\n            if(two->next == NULL){\\n                one->next = NULL;\\n                return temp;\\n            }\\n            if(two->val == 0){\\n                two = two->next;\\n                one->next = two;\\n                one = one->next;  \\n            }\\n            else{\\n                one->val+=two->val;\\n            }\\n        }\\n return temp;       \\n    }",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/a265d01a-6f11-4fe1-aa9b-0ddf91a004e3_1645947685.9593856.jpeg)\\n\\n\\n```\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *temp = head->next;\\n        ListNode *one = head->next;\\n        ListNode *two = head->next;\\n        while(two->next)\\n        {   \\n            two = two->next;\\n            if(two->next == NULL){\\n                one->next = NULL;\\n                return temp;\\n            }\\n            if(two->val == 0){\\n                two = two->next;\\n                one->next = two;\\n                one = one->next;  \\n            }\\n            else{\\n                one->val+=two->val;\\n            }\\n        }\\n return temp;       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4060432,
                "title": "easy-boys-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* res = new ListNode(0);\\n        ListNode* list = res;\\n        int b=0;\\n        head = head->next;\\n        while(head) {\\n            b = b + head->val;\\n            if(head->val == 0) {\\n                ListNode* temp = new ListNode(b);\\n                list->next = temp;\\n                list = list->next;\\n                b=0;\\n            }\\n            head = head->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* res = new ListNode(0);\\n        ListNode* list = res;\\n        int b=0;\\n        head = head->next;\\n        while(head) {\\n            b = b + head->val;\\n            if(head->val == 0) {\\n                ListNode* temp = new ListNode(b);\\n                list->next = temp;\\n                list = list->next;\\n                b=0;\\n            }\\n            head = head->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856525,
                "title": "best-c-solution-simple-approach-beats-100-in-time-and-memory",
                "content": "\\n\\n# Code\\n```\\n// SC - O(N)\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum = 0;\\n        ListNode *ans = new ListNode(-1), *temp = ans;\\n        ListNode *curr = head->next;\\n\\n        while(curr!= NULL){\\n            while(curr->val != 0){\\n                sum += curr->val;\\n                curr = curr->next;\\n            }\\n            ListNode *n = new ListNode(sum);\\n            temp->next = n;\\n            temp = n;\\n            sum = 0;\\n            curr = curr->next;\\n        }\\n\\n        return ans->next;\\n    }\\n};\\n\\n// SC - O(1)\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        head = head->next;\\n        ListNode *start = head;\\n\\n        while(start!= NULL){\\n            ListNode *end = start;\\n            int sum = 0;\\n            while(end->val != 0){\\n                sum += end->val;\\n                end = end->next;\\n            }\\n            start->val = sum;\\n            start->next = end->next;\\n            start = start->next;\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\n// SC - O(N)\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum = 0;\\n        ListNode *ans = new ListNode(-1), *temp = ans;\\n        ListNode *curr = head->next;\\n\\n        while(curr!= NULL){\\n            while(curr->val != 0){\\n                sum += curr->val;\\n                curr = curr->next;\\n            }\\n            ListNode *n = new ListNode(sum);\\n            temp->next = n;\\n            temp = n;\\n            sum = 0;\\n            curr = curr->next;\\n        }\\n\\n        return ans->next;\\n    }\\n};\\n\\n// SC - O(1)\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        head = head->next;\\n        ListNode *start = head;\\n\\n        while(start!= NULL){\\n            ListNode *end = start;\\n            int sum = 0;\\n            while(end->val != 0){\\n                sum += end->val;\\n                end = end->next;\\n            }\\n            start->val = sum;\\n            start->next = end->next;\\n            start = start->next;\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829141,
                "title": "python-3-one-pass-beats-99-1862ms",
                "content": "```python3 []\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        backbone = ListNode()\\n        prefix, prev = 0, backbone\\n        while head:\\n            if head.val == 0:\\n                if prefix > 0:\\n                    prev.next = ListNode(prefix)\\n                    prefix = 0\\n                    prev = prev.next\\n            else:\\n                prefix += head.val\\n            head = head.next\\n\\n        return backbone.next\\n```\\n[]()![Screenshot 2023-07-28 at 16.53.38.png](https://assets.leetcode.com/users/images/33b88ec0-74e4-4d5c-aea2-765c93a0702f_1690552538.3757708.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        backbone = ListNode()\\n        prefix, prev = 0, backbone\\n        while head:\\n            if head.val == 0:\\n                if prefix > 0:\\n                    prev.next = ListNode(prefix)\\n                    prefix = 0\\n                    prev = prev.next\\n            else:\\n                prefix += head.val\\n            head = head.next\\n\\n        return backbone.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493093,
                "title": "c-easy-solution-easy-approach",
                "content": "# Intuition\\nAdding up the Sum btw two Zeros in the Linked List given and adding it into the new Linked List.\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(N)**  Since the Linked List is Traversed Once.\\n\\n- Space complexity:\\n**O(1)**   Constant Space is used in the code.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode*ans=new ListNode(0);int temp=0;ListNode*curr=ans;\\n        while(head!=NULL){\\n            \\n            if(head->val==0){\\n                ListNode* temp1=new ListNode(temp);\\n                curr->next=temp1;curr=curr->next;\\n                temp=0;\\n            }\\n            else{temp+=head->val;}\\n\\n            head=head->next;\\n        }\\n        ans=ans->next->next;\\n        return ans;\\n    }\\n};\\n\\n            /////////// Please Upvote ///////////\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode*ans=new ListNode(0);int temp=0;ListNode*curr=ans;\\n        while(head!=NULL){\\n            \\n            if(head->val==0){\\n                ListNode* temp1=new ListNode(temp);\\n                curr->next=temp1;curr=curr->next;\\n                temp=0;\\n            }\\n            else{temp+=head->val;}\\n\\n            head=head->next;\\n        }\\n        ans=ans->next->next;\\n        return ans;\\n    }\\n};\\n\\n            /////////// Please Upvote ///////////\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343092,
                "title": "c-o-n-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode* temp=head->next;\\n        ListNode* ans = NULL;\\n        ListNode* temp1 = ans;\\n        while( temp!=NULL )\\n        {\\n            if( temp->val == 0 )\\n            {\\n                ListNode* newnode = new ListNode( sum );\\n                if( ans == NULL )\\n                {\\n                    ans = newnode;\\n                    temp1 = ans;\\n                }\\n                else\\n                {\\n                    temp1->next = newnode;\\n                    temp1 = temp1->next;\\n                }\\n                sum = 0;\\n            }\\n            else\\n            {\\n                sum = sum + temp->val;\\n            }\\n            temp = temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode* temp=head->next;\\n        ListNode* ans = NULL;\\n        ListNode* temp1 = ans;\\n        while( temp!=NULL )\\n        {\\n            if( temp->val == 0 )\\n            {\\n                ListNode* newnode = new ListNode( sum );\\n                if( ans == NULL )\\n                {\\n                    ans = newnode;\\n                    temp1 = ans;\\n                }\\n                else\\n                {\\n                    temp1->next = newnode;\\n                    temp1 = temp1->next;\\n                }\\n                sum = 0;\\n            }\\n            else\\n            {\\n                sum = sum + temp->val;\\n            }\\n            temp = temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257042,
                "title": "easiest-and-99-faster-soln-both-in-memory-and-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution, what we are doing is we are just adding the value of nodes other than 0 to node having value 0 and we are joining only nodes having value 0\\nAnd at the end we are just skipping the node having value 0\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* prev = head, *curr= prev->next;\\n\\n        while(curr){\\n            \\n            if(prev->val==0){       //adding value of other nodes to \\n                while(curr->val!=0){    //node with value 0\\n                    prev->val +=curr->val;\\n                    curr = curr->next;\\n                }\\n                if(curr->next == NULL){ // for handling last node with 0\\n                    prev->next = NULL;\\n                    break;\\n                }\\n                if(curr->val==0){   //joining nodes with value 0\\n                    prev->next=curr;\\n                    prev=curr;\\n                }\\n            }\\n            curr=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* prev = head, *curr= prev->next;\\n\\n        while(curr){\\n            \\n            if(prev->val==0){       //adding value of other nodes to \\n                while(curr->val!=0){    //node with value 0\\n                    prev->val +=curr->val;\\n                    curr = curr->next;\\n                }\\n                if(curr->next == NULL){ // for handling last node with 0\\n                    prev->next = NULL;\\n                    break;\\n                }\\n                if(curr->val==0){   //joining nodes with value 0\\n                    prev->next=curr;\\n                    prev=curr;\\n                }\\n            }\\n            curr=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218290,
                "title": "time-o-n-90-beats-space-o-1-98-beats-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode*p = head,*q = head;\\n        ListNode* ans = q;\\n        int x = 0;\\n        while(p!= NULL){\\n            x = 0;\\n            p = p->next;\\n            if(!p)break;\\n            while(p->val!=0){\\n                x += p->val;\\n                p = p->next;\\n            }\\n            // p = p->next;\\n            q->val = x;\\n            ans = q;\\n            q = q->next;\\n        }\\n        ans->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode*p = head,*q = head;\\n        ListNode* ans = q;\\n        int x = 0;\\n        while(p!= NULL){\\n            x = 0;\\n            p = p->next;\\n            if(!p)break;\\n            while(p->val!=0){\\n                x += p->val;\\n                p = p->next;\\n            }\\n            // p = p->next;\\n            q->val = x;\\n            ans = q;\\n            q = q->next;\\n        }\\n        ans->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185524,
                "title": "python-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution will combine the first few nodes until the next 0 and then connect that node to the rest of the nodes merged. Therefore, we can use a recursive method to find the solution. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the value of the head is 0 and the next node is null, return null. Otherwise, merge nodes by adding the value of the next node until the next zero is reached. Then set head.next to the recursive call on the rest of the nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.val == 0 and head.next is None:\\n            return None\\n        \\n        while head.next.val != 0:\\n            head.val += head.next.val\\n            head.next = head.next.next\\n        \\n        head.next = self.mergeNodes(head.next)\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.val == 0 and head.next is None:\\n            return None\\n        \\n        while head.next.val != 0:\\n            head.val += head.next.val\\n            head.next = head.next.next\\n        \\n        head.next = self.mergeNodes(head.next)\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172806,
                "title": "easy-python-solution-conversion-of-linked-list-to-list",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n        lst=[]\\n        sm=0\\n        while head:\\n            if head.val==0:\\n                if sm>0:\\n                    lst.append(sm)\\n                sm=0\\n            sm+=head.val\\n            head=head.next\\n        final_lst=ListNode(0)\\n        tmp=final_lst\\n        for i in lst:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final_lst.next\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n        lst=[]\\n        sm=0\\n        while head:\\n            if head.val==0:\\n                if sm>0:\\n                    lst.append(sm)\\n                sm=0\\n            sm+=head.val\\n            head=head.next\\n        final_lst=ListNode(0)\\n        tmp=final_lst\\n        for i in lst:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final_lst.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159608,
                "title": "merge-nodes-in-between",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it is given that the two zeroes cannot be together and thus it gives an intuition that the possibly we have to find the sum so far and then reintilialize the sum back to zero and traverse till the node becomes None.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a dummy node and then point the cur to the head of the given linked list..then when the cur.val becomes zero then make sum to zero and assign the so far sum to the created node and contiue tha pattern..\\n\\n    For further details walk through the code........\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy=ListNode(0)\\n        ptr=dummy\\n        cur=head.next\\n        s=0\\n        while cur:\\n            while cur.val!=0:\\n                s=s+cur.val\\n                cur=cur.next\\n            ptr.next=ListNode(s)\\n            #pointing the so far sum to the linked list element...\\n            ptr=ptr.next\\n            cur=cur.next\\n            s=0\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy=ListNode(0)\\n        ptr=dummy\\n        cur=head.next\\n        s=0\\n        while cur:\\n            while cur.val!=0:\\n                s=s+cur.val\\n                cur=cur.next\\n            ptr.next=ListNode(s)\\n            #pointing the so far sum to the linked list element...\\n            ptr=ptr.next\\n            cur=cur.next\\n            s=0\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843175,
                "title": "c-easily-understandable-code",
                "content": "We are traversing the whole list and if any 0 encountered then we simply add in our newly generated Linked List i.e. ptr\\nWe add a condition sum>0 that is only for first element\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        \\n        ListNode*ptr=new ListNode();\\n        ListNode*p=ptr;\\n        \\n        int temp=0,sum=0;\\n        \\n        while(head){\\n            \\n            if(head->val==0){\\n                sum=temp;\\n                \\n                if(sum>0){\\n                    ptr->next=new ListNode(sum);\\n                    ptr=ptr->next;\\n                }\\n                \\n                temp=0;\\n            }\\n            \\n            else{\\n                temp+=head->val;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return p->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        \\n        ListNode*ptr=new ListNode();\\n        ListNode*p=ptr;\\n        \\n        int temp=0,sum=0;\\n        \\n        while(head){\\n            \\n            if(head->val==0){\\n                sum=temp;\\n                \\n                if(sum>0){\\n                    ptr->next=new ListNode(sum);\\n                    ptr=ptr->next;\\n                }\\n                \\n                temp=0;\\n            }\\n            \\n            else{\\n                temp+=head->val;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return p->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583947,
                "title": "easy-o-n-java",
                "content": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head)\\n    {\\n        ListNode curr =new ListNode()  ;\\n        ListNode root = curr;\\n        int sum=0;\\n        while (head !=null)\\n        {\\n            if(head.val ==0  && sum!= 0)\\n            {\\n                curr.val=sum;\\n                if(head.next == null) break;;\\n                curr.next= new ListNode();\\n                curr=  curr.next;\\n                sum=0;\\n            }\\n            sum +=head.val;  \\n            head =head.next;\\n            \\n        }\\n        return root ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head)\\n    {\\n        ListNode curr =new ListNode()  ;\\n        ListNode root = curr;\\n        int sum=0;\\n        while (head !=null)\\n        {\\n            if(head.val ==0  && sum!= 0)\\n            {\\n                curr.val=sum;\\n                if(head.next == null) break;;\\n                curr.next= new ListNode();\\n                curr=  curr.next;\\n                sum=0;\\n            }\\n            sum +=head.val;  \\n            head =head.next;\\n            \\n        }\\n        return root ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349037,
                "title": "cpp-solution-but-its-actually-sc-o-1",
                "content": "After solving this question when I came to discuss section, I saw solutions where they are saying that its space complexity is O(1) and are either making a whole new linked list or not freeing up the memory, causing memory leak. In both of the cases, the interviewer will show you the path to the door.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void del(ListNode* node)\\n    {\\n        if(node->next == NULL){\\n            node = NULL;\\n            return;\\n        }\\n        ListNode* toDel = node->next;\\n        node->next = toDel->next;\\n        delete toDel;\\n    }\\n    \\n    \\n    ListNode* mergeNodes(ListNode* head)\\n    {\\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        temp = dummy;\\n        while(temp!=NULL)\\n        {\\n            if(temp->val == 0 || temp->next->val == 0)\\n            {\\n                temp = temp->next;\\n            }\\n            else\\n            {\\n                temp -> val += temp->next->val;\\n                del(temp);\\n            }   \\n        }\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        temp = dummy;\\n        while(temp!=NULL)\\n        {\\n            if(temp->next->val == 0)\\n            {\\n                del(temp);\\n            }\\n            temp = temp->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\nThe approach is simple firstly sum the non zero nodes then eliminate the zeros. You can try to short it up via deleting 0 in first loop but it will look complex that is why I am leaving it here. Peace :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void del(ListNode* node)\\n    {\\n        if(node->next == NULL){\\n            node = NULL;\\n            return;\\n        }\\n        ListNode* toDel = node->next;\\n        node->next = toDel->next;\\n        delete toDel;\\n    }\\n    \\n    \\n    ListNode* mergeNodes(ListNode* head)\\n    {\\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        temp = dummy;\\n        while(temp!=NULL)\\n        {\\n            if(temp->val == 0 || temp->next->val == 0)\\n            {\\n                temp = temp->next;\\n            }\\n            else\\n            {\\n                temp -> val += temp->next->val;\\n                del(temp);\\n            }   \\n        }\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        temp = dummy;\\n        while(temp!=NULL)\\n        {\\n            if(temp->next->val == 0)\\n            {\\n                del(temp);\\n            }\\n            temp = temp->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827698,
                "title": "c-3-different-solutions-recursive-iterative",
                "content": "Solution 1: Iterative with extra space\\nTime: O(N)\\nSpace: O(N)\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* sentinel = new ListNode(-1);\\n        ListNode* main = new ListNode(-1);\\n        sentinel->next = main;\\n        ListNode* cur = head->next;\\n        \\n        while (cur != nullptr) {\\n            int sum = 0;\\n            while (cur->val != 0) {\\n                sum += cur->val;   \\n                cur = cur->next;\\n            }\\n            main->val = sum;\\n            cur = cur->next;\\n            if (cur) {\\n                main->next = new ListNode(-1);\\n                main = main->next;\\n            }  \\n        }\\n        \\n        return sentinel->next;\\n    }\\n};\\n```\\n\\nSolution 2: Iterative with no extra space\\nTime: O(N)\\nSpace: O(1)\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* sentinel = new ListNode(-1);;\\n        sentinel->next = head;\\n        ListNode* cur = head->next;\\n        ListNode* zero = head;\\n        \\n        while (cur) {\\n            int sum = 0;\\n            while (cur->val != 0) {\\n                sum += cur->val;   \\n                cur = cur->next;\\n            }\\n            zero->val = sum;\\n            if (cur->next)\\n                zero->next = cur;\\n            else\\n                zero->next = nullptr;\\n            zero = zero->next;\\n            cur = cur->next; \\n        }\\n        \\n        return sentinel->next;\\n    }\\n};\\n```\\n\\nSolution 3: Recursive with no extra space\\nTime: O(N)\\nSpace: O(N) if we consider the recursion stack frame and O(1) without considering it \\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        head = head->next;\\n        if (head == nullptr)\\n            return head;\\n        \\n        int sum = 0;\\n        ListNode* cur = head;\\n        while (cur->val != 0) {\\n            sum += cur->val;\\n            cur = cur->next;\\n        }\\n        \\n        head->val = sum;\\n        head->next = mergeNodes(cur);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* sentinel = new ListNode(-1);\\n        ListNode* main = new ListNode(-1);\\n        sentinel->next = main;\\n        ListNode* cur = head->next;\\n        \\n        while (cur != nullptr) {\\n            int sum = 0;\\n            while (cur->val != 0) {\\n                sum += cur->val;   \\n                cur = cur->next;\\n            }\\n            main->val = sum;\\n            cur = cur->next;\\n            if (cur) {\\n                main->next = new ListNode(-1);\\n                main = main->next;\\n            }  \\n        }\\n        \\n        return sentinel->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* sentinel = new ListNode(-1);;\\n        sentinel->next = head;\\n        ListNode* cur = head->next;\\n        ListNode* zero = head;\\n        \\n        while (cur) {\\n            int sum = 0;\\n            while (cur->val != 0) {\\n                sum += cur->val;   \\n                cur = cur->next;\\n            }\\n            zero->val = sum;\\n            if (cur->next)\\n                zero->next = cur;\\n            else\\n                zero->next = nullptr;\\n            zero = zero->next;\\n            cur = cur->next; \\n        }\\n        \\n        return sentinel->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        head = head->next;\\n        if (head == nullptr)\\n            return head;\\n        \\n        int sum = 0;\\n        ListNode* cur = head;\\n        while (cur->val != 0) {\\n            sum += cur->val;\\n            cur = cur->next;\\n        }\\n        \\n        head->val = sum;\\n        head->next = mergeNodes(cur);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809310,
                "title": "iterative-method-using-dummy-node-c",
                "content": "This is the approach I came up with:\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* ptr = dummy;\\n        ListNode* temp = head;\\n        while(temp->next!=NULL){\\n            int sum=0;\\n            while(temp->next!=NULL && temp->next->val!=0){\\n                sum+=temp->next->val;\\n                temp=temp->next;\\n            }\\n            ListNode* x = new ListNode(sum);\\n            ptr->next=x;\\n            ptr=ptr->next;\\n            temp=temp->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* ptr = dummy;\\n        ListNode* temp = head;\\n        while(temp->next!=NULL){\\n            int sum=0;\\n            while(temp->next!=NULL && temp->next->val!=0){\\n                sum+=temp->next->val;\\n                temp=temp->next;\\n            }\\n            ListNode* x = new ListNode(sum);\\n            ptr->next=x;\\n            ptr=ptr->next;\\n            temp=temp->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802383,
                "title": "recursive-and-iterative-solution-c-easy",
                "content": "**Recursive solution**\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        do\\n        {\\n            fast=fast->next;\\n        }\\n        while(fast->val!=0);\\n            \\n        int sum =0;\\n        while(slow!=fast)\\n        {\\n            sum+=slow->val;\\n            slow=slow->next;\\n        }\\n        ListNode *newll = new ListNode(sum);\\n        newll->next = mergeNodes(fast->next);\\n        return newll;\\n    \\n    }\\n};\\n```\\n\\n**Iterative solution**\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        head=head->next;\\n        ListNode*start=head;\\n        while(start)\\n        {\\n            ListNode*end=start;\\n            int sum=0;\\n            while(end->val!=0){ sum+=end->val; end=end->next;}\\n            start->val=sum;\\n            start->next=end->next;\\n            start=start->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n***Do upvote if it helped! Feel free to comment :)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        do\\n        {\\n            fast=fast->next;\\n        }\\n        while(fast->val!=0);\\n            \\n        int sum =0;\\n        while(slow!=fast)\\n        {\\n            sum+=slow->val;\\n            slow=slow->next;\\n        }\\n        ListNode *newll = new ListNode(sum);\\n        newll->next = mergeNodes(fast->next);\\n        return newll;\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        head=head->next;\\n        ListNode*start=head;\\n        while(start)\\n        {\\n            ListNode*end=start;\\n            int sum=0;\\n            while(end->val!=0){ sum+=end->val; end=end->next;}\\n            start->val=sum;\\n            start->next=end->next;\\n            start=start->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785166,
                "title": "c-simple-code-with-explanation-faster-than-100-00",
                "content": "1. From while Loop Keep Traversing Link List till the last\\n2. If the values are non zero, keep adding them to sum -->  [` else if (head.val != 0)`]\\n3. Just before encountering zero, assign this sum value to the new node of newly created Link list -->  [` if (head.next.val == 0)`]\\n4. Also don\\'t forget to reset this sum value to zero.\\n\\n```\\n\\n public ListNode MergeNodes(ListNode head) \\n {           \\t\\n\\t\\tListNode MergeHead = new ListNode();\\n\\t\\tListNode fast = MergeHead;\\n\\t\\tif (head.next == null) return MergeHead;\\n\\t\\tint sum = 0;\\n\\n\\t\\twhile (head != null && head.next != null)\\n\\t\\t{\\n\\t\\t\\tif (head.next.val == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum = sum + head.val;      //Add Non zero value to sum just before encountering zero.\\n\\t\\t\\t\\tfast.next = new ListNode(sum); \\n\\t\\t\\t\\tfast = fast.next;\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse if (head.val != 0)\\n\\t\\t\\t\\tsum = sum + head.val;   //Keep Adding Non zero values to Sum\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n\\t\\treturn MergeHead.next;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n\\n public ListNode MergeNodes(ListNode head) \\n {           \\t\\n\\t\\tListNode MergeHead = new ListNode();\\n\\t\\tListNode fast = MergeHead;\\n\\t\\tif (head.next == null) return MergeHead;\\n\\t\\tint sum = 0;\\n\\n\\t\\twhile (head != null && head.next != null)\\n\\t\\t{\\n\\t\\t\\tif (head.next.val == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum = sum + head.val;      //Add Non zero value to sum just before encountering zero.\\n\\t\\t\\t\\tfast.next = new ListNode(sum); \\n\\t\\t\\t\\tfast = fast.next;\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse if (head.val != 0)\\n\\t\\t\\t\\tsum = sum + head.val;   //Keep Adding Non zero values to Sum\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n\\t\\treturn MergeHead.next;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784795,
                "title": "java-solution-o-n-time-and-o-n-space",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/501ed990-12c9-4c5c-8a9d-ae3472035b2a_1645329769.3603394.png)\\n\\n\\n```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        \\n        ListNode t = head;\\n        List<Integer> list = new ArrayList<>();\\n        int sum =0;\\n        while(t != null){\\n            if(t.val == 0){\\n                if(sum != 0){\\n                    list.add(sum);\\n                    sum =0;\\n                }\\n            }\\n            sum += t.val;\\n            t=t.next;\\n        }\\n        \\n       ListNode root = null;\\n        for (int i = list.size()-1; i >= 0 ; i--)\\n        root = insert(root, list.get(i));\\n        return root;\\n    }\\n    \\n    \\n    public ListNode insert(ListNode root, int item)\\n    {\\n        ListNode temp = new ListNode();\\n        temp.val = item;\\n        temp.next = root;\\n        root = temp;\\n        return root;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        \\n        ListNode t = head;\\n        List<Integer> list = new ArrayList<>();\\n        int sum =0;\\n        while(t != null){\\n            if(t.val == 0){\\n                if(sum != 0){\\n                    list.add(sum);\\n                    sum =0;\\n                }\\n            }\\n            sum += t.val;\\n            t=t.next;\\n        }\\n        \\n       ListNode root = null;\\n        for (int i = list.size()-1; i >= 0 ; i--)\\n        root = insert(root, list.get(i));\\n        return root;\\n    }\\n    \\n    \\n    public ListNode insert(ListNode root, int item)\\n    {\\n        ListNode temp = new ListNode();\\n        temp.val = item;\\n        temp.next = root;\\n        root = temp;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784792,
                "title": "cpp-solution-linkedlist",
                "content": "slow and fast pointer\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeNodes(ListNode* head) {\\n\\t\\t\\tListNode *slow = nullptr;\\n\\t\\t\\tListNode *fast = head;\\n\\t\\t\\tListNode *newHead = nullptr;\\n\\t\\t\\twhile(fast and fast->next){\\n\\t\\t\\t\\tif(fast->val == 0){\\n\\t\\t\\t\\t\\tfast = fast->next;\\n\\n\\t\\t\\t\\t\\t// change the slow->next = fast;\\n\\t\\t\\t\\t\\tif(newHead==nullptr){\\n\\t\\t\\t\\t\\t\\tnewHead = fast;\\n\\t\\t\\t\\t\\t\\tslow = fast;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tslow->next = fast;\\n\\t\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tfast = fast->next;\\n\\t\\t\\t\\tslow->val += fast->val;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(fast->val==0){\\n\\t\\t\\t\\tslow->next = nullptr;\\n\\t\\t\\t}\\n\\t\\t\\treturn newHead;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeNodes(ListNode* head) {\\n\\t\\t\\tListNode *slow = nullptr;\\n\\t\\t\\tListNode *fast = head;\\n\\t\\t\\tListNode *newHead = nullptr;\\n\\t\\t\\twhile(fast and fast->next){\\n\\t\\t\\t\\tif(fast->val == 0){\\n\\t\\t\\t\\t\\tfast = fast->next;\\n\\n\\t\\t\\t\\t\\t// change the slow->next = fast;\\n\\t\\t\\t\\t\\tif(newHead==nullptr){\\n\\t\\t\\t\\t\\t\\tnewHead = fast;\\n\\t\\t\\t\\t\\t\\tslow = fast;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3863400,
                "title": "basic-approach-only-for-noobs-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode * tmp= head;\\n        ListNode * tmp1= head;\\n        tmp=tmp->next;\\n        while(tmp !=NULL){\\n            if(tmp->val != 0){\\n                sum+=tmp->val;\\n            }\\n            else if(tmp->next==NULL){\\n                tmp1->val=sum;\\n                tmp1->next=NULL;}\\n            else{\\n                tmp1->next=tmp;\\n                tmp1->val = sum;\\n                sum =0;\\n                tmp1=tmp1->next;\\n            }\\n            tmp=tmp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode * tmp= head;\\n        ListNode * tmp1= head;\\n        tmp=tmp->next;\\n        while(tmp !=NULL){\\n            if(tmp->val != 0){\\n                sum+=tmp->val;\\n            }\\n            else if(tmp->next==NULL){\\n                tmp1->val=sum;\\n                tmp1->next=NULL;}\\n            else{\\n                tmp1->next=tmp;\\n                tmp1->val = sum;\\n                sum =0;\\n                tmp1=tmp1->next;\\n            }\\n            tmp=tmp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758243,
                "title": "easy-to-understand-clear-code-c",
                "content": "# Intuition\\n- Walk through list untill second zero is found, then add the previous values to that, or\\n- Send a temporary pointer through the list to gather the values to add, then stop it at the next zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We walk through the list, and if the node we are on is a 0, we begin a new loop using the adder node. We walk that through the list, and break once we have found a second 0.\\n\\n- Once that happens, we have two cases ->\\n\\n1. We are at the end of the list, and we check with adder->next->next. If so, we assign the temporary node (first zero) to point to a null pointer and return the list.\\n2. We have another section of integers to add. We then update the pointers of temp, pointing it to the second 0 (adder->next), and reassign temp to the last integer (adder). We then push temp forward one, to push it onto a zero value, allowing the inner loop to repeat again.\\n3. We are able to only walk through each element once, allowing us to keep a O(n) runtime, and keep memory low with two pointers and an integer being stored.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head) return NULL;\\n\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        ListNode* last=NULL;\\n        int sum=0;\\n        while(fast){\\n            if(fast->val!=0)\\n                sum+=fast->val;\\n            else{\\n                slow->val=sum;\\n                last=slow;\\n                slow=slow->next;\\n                sum=0;\\n            }\\n            fast=fast->next;\\n        }\\n        ListNode* temp=last->next;\\n        last->next=NULL;\\n        while(temp){\\n            ListNode* nxt=temp;\\n            temp=temp->next;\\n            nxt->next=NULL;\\n            delete nxt;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head) return NULL;\\n\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        ListNode* last=NULL;\\n        int sum=0;\\n        while(fast){\\n            if(fast->val!=0)\\n                sum+=fast->val;\\n            else{\\n                slow->val=sum;\\n                last=slow;\\n                slow=slow->next;\\n                sum=0;\\n            }\\n            fast=fast->next;\\n        }\\n        ListNode* temp=last->next;\\n        last->next=NULL;\\n        while(temp){\\n            ListNode* nxt=temp;\\n            temp=temp->next;\\n            nxt->next=NULL;\\n            delete nxt;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665707,
                "title": "easy-simple-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode* temp=head->next;\\n        vector<int>v;\\n        while(temp!=NULL)\\n        {\\n            sum+=temp->val;\\n           if(temp->val==0)\\n           {\\n               v.push_back(sum);\\n               sum=0;   \\n           }\\n           temp=temp->next;\\n        }\\n        ListNode* newhead=new ListNode(-1);\\n        ListNode* dummy=newhead;\\n        for(auto it:v)\\n        {\\n            ListNode* t=new ListNode();\\n            t->val=it;\\n            t->next=NULL;\\n            dummy->next=t;\\n            dummy=t;\\n        }\\n        return newhead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode* temp=head->next;\\n        vector<int>v;\\n        while(temp!=NULL)\\n        {\\n            sum+=temp->val;\\n           if(temp->val==0)\\n           {\\n               v.push_back(sum);\\n               sum=0;   \\n           }\\n           temp=temp->next;\\n        }\\n        ListNode* newhead=new ListNode(-1);\\n        ListNode* dummy=newhead;\\n        for(auto it:v)\\n        {\\n            ListNode* t=new ListNode();\\n            t->val=it;\\n            t->next=NULL;\\n            dummy->next=t;\\n            dummy=t;\\n        }\\n        return newhead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582310,
                "title": "easy-c-solution-beat-80-6",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head) return NULL;\\n\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        ListNode* last=NULL;\\n        int sum=0;\\n        while(fast){\\n            if(fast->val!=0)\\n                sum+=fast->val;\\n            else{\\n                slow->val=sum;\\n                last=slow;\\n                slow=slow->next;\\n                sum=0;\\n            }\\n            fast=fast->next;\\n        }\\n        ListNode* temp=last->next;\\n        last->next=NULL;\\n        while(temp){\\n            ListNode* nxt=temp;\\n            temp=temp->next;\\n            nxt->next=NULL;\\n            delete nxt;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head) return NULL;\\n\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        ListNode* last=NULL;\\n        int sum=0;\\n        while(fast){\\n            if(fast->val!=0)\\n                sum+=fast->val;\\n            else{\\n                slow->val=sum;\\n                last=slow;\\n                slow=slow->next;\\n                sum=0;\\n            }\\n            fast=fast->next;\\n        }\\n        ListNode* temp=last->next;\\n        last->next=NULL;\\n        while(temp){\\n            ListNode* nxt=temp;\\n            temp=temp->next;\\n            nxt->next=NULL;\\n            delete nxt;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561804,
                "title": "simple-explanation-with-dummy-node-and-previous-pointer",
                "content": "# Intuition\\n*The Intution here is just that you have to look for nodes with zeros and merge the other nodes into those zero node.\\nHere is one exception that needs to be handled the last node which is explained below.*\\n\\n# Approach\\n1. Create a dummy node.\\n2. Point that dummy node to head.\\n3. Iterate from dummy node till end & check if next value is 0.\\n4. If next is 0 then simply go to next node else add the value from next node to current node and set pointer of current node to next to next node.\\n5. Store the cur node to a different variable before going to next node for skipping the last 0.\\n6. At last return the head.\\n\\n# Complexity\\n\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode()  # dummy node\\n        dummy.next = head\\n        cur = dummy\\n\\n        while cur.next:\\n            prev = cur      # prev node before cur to skip last 0\\n            if cur.next.val == 0:\\n                cur = cur.next\\n            if cur.next:\\n                cur.val += cur.next.val\\n                cur.next = cur.next.next\\n        prev.next = None    # setting last 0 node to none\\n        return head \\n```\\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar mergeNodes = function(head) {\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    let cur = dummy;\\n    let prev;\\n    while (cur.next){\\n        prev = cur;\\n        if (cur.next.val === 0){\\n            cur = cur.next;\\n        }\\n        if (cur.next){\\n            cur.val += cur.next.val\\n            cur.next = cur.next.next\\n        }\\n    }\\n    prev.next = null;\\n    return head;\\n};\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "TypeScript",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode()  # dummy node\\n        dummy.next = head\\n        cur = dummy\\n\\n        while cur.next:\\n            prev = cur      # prev node before cur to skip last 0\\n            if cur.next.val == 0:\\n                cur = cur.next\\n            if cur.next:\\n                cur.val += cur.next.val\\n                cur.next = cur.next.next\\n        prev.next = None    # setting last 0 node to none\\n        return head \\n```\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar mergeNodes = function(head) {\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    let cur = dummy;\\n    let prev;\\n    while (cur.next){\\n        prev = cur;\\n        if (cur.next.val === 0){\\n            cur = cur.next;\\n        }\\n        if (cur.next){\\n            cur.val += cur.next.val\\n            cur.next = cur.next.next\\n        }\\n    }\\n    prev.next = null;\\n    return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499742,
                "title": "super-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = head.next;\\n        ListNode newNode = new ListNode();\\n        head=newNode;\\n\\n        int sum = 0;\\n        while(node != null) {\\n            if(node.val == 0) {\\n                newNode.next=new ListNode(sum);\\n                newNode = newNode.next;\\n                sum=0;\\n            } else {\\n                sum=sum+node.val;\\n            }\\n            node=node.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = head.next;\\n        ListNode newNode = new ListNode();\\n        head=newNode;\\n\\n        int sum = 0;\\n        while(node != null) {\\n            if(node.val == 0) {\\n                newNode.next=new ListNode(sum);\\n                newNode = newNode.next;\\n                sum=0;\\n            } else {\\n                sum=sum+node.val;\\n            }\\n            node=node.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379067,
                "title": "c-super-easy-solution-traversing-only-once-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum all the values at 0 node then move pointer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStay at the 0 node and sum all the values at the 0 node until another 0 node comes, then move the pointer to that 0 node and repeat the process. This will go on until we get to the last 0 node.\\n\\nWe have to take an extra pointer *prev* because at the last 0 we do not have to include that. And the previous pointer point to NULL.\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are traversing through only once.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space is used other than pointers.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* prev = temp;\\n        while(temp->next != nullptr){\\n            // Pointer to traverse until the next 0 is found\\n            ListNode* p = temp->next;\\n            while(p->val != 0){\\n                temp->val += p->val;\\n                p = p->next;\\n            }\\n            prev = temp;\\n            temp->next = p;\\n            temp = temp->next;\\n        }\\n        prev->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* prev = temp;\\n        while(temp->next != nullptr){\\n            // Pointer to traverse until the next 0 is found\\n            ListNode* p = temp->next;\\n            while(p->val != 0){\\n                temp->val += p->val;\\n                p = p->next;\\n            }\\n            prev = temp;\\n            temp->next = p;\\n            temp = temp->next;\\n        }\\n        prev->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232696,
                "title": "easiest-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep on adding the data values of each node of the given linked-list and as soon as a node with value `0` is encountered, change the value of the node pointed to by `copy1` pointer to the current sum value and set `sum = 0`. After the given list is traversed completely, set the next field of the `prev` pointer to `NULL`.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: `O(1)`  &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; (because of variable `sum`)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head){\\n        ListNode* copy1 = head, *copy2 = head;\\n        ListNode* prev = NULL;\\n\\n        int sum = 0;\\n        for(head = head->next; head!=NULL; head = head->next){\\n            sum += head->val;\\n            if(head->val==0){\\n                copy1->val = sum;\\n                prev = copy1;\\n                copy1 = copy1->next;\\n                sum = 0;\\n            }\\n        }\\n        prev->next = NULL;\\n\\n        return copy2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head){\\n        ListNode* copy1 = head, *copy2 = head;\\n        ListNode* prev = NULL;\\n\\n        int sum = 0;\\n        for(head = head->next; head!=NULL; head = head->next){\\n            sum += head->val;\\n            if(head->val==0){\\n                copy1->val = sum;\\n                prev = copy1;\\n                copy1 = copy1->next;\\n                sum = 0;\\n            }\\n        }\\n        prev->next = NULL;\\n\\n        return copy2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180731,
                "title": "python3-beats-85-80-simple-solution",
                "content": "# Please upvote guys, if you find the solution helpful.\\uD83E\\uDEF6\\uD83C\\uDFFB\\uD83E\\uDEF6\\uD83C\\uDFFB\\uD83E\\uDEF6\\uD83C\\uDFFB\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        sum=0\\n        while head:\\n            if head.val == 0:\\n                if sum:\\n                    lst.append(sum)\\n                sum=0\\n            else:\\n                sum+=head.val\\n            head = head.next\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n\\n                \\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        sum=0\\n        while head:\\n            if head.val == 0:\\n                if sum:\\n                    lst.append(sum)\\n                sum=0\\n            else:\\n                sum+=head.val\\n            head = head.next\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n\\n                \\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145777,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* c=head;\\n        vector<int>v;\\n        while(c!=nullptr)\\n        {\\n            v.push_back(c->val);\\n            c=c->next;\\n        }\\n        ListNode* res=new ListNode();\\n        c=res;\\n        vector<int>ans;\\n        int t=0;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                c->next=new ListNode(t);\\n                c=c->next;\\n                t=0;\\n            }\\n            else\\n            {\\n                t+=v[i];\\n            }\\n           \\n        }\\n        \\n        \\n        return res->next;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* c=head;\\n        vector<int>v;\\n        while(c!=nullptr)\\n        {\\n            v.push_back(c->val);\\n            c=c->next;\\n        }\\n        ListNode* res=new ListNode();\\n        c=res;\\n        vector<int>ans;\\n        int t=0;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                c->next=new ListNode(t);\\n                c=c->next;\\n                t=0;\\n            }\\n            else\\n            {\\n                t+=v[i];\\n            }\\n           \\n        }\\n        \\n        \\n        return res->next;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142810,
                "title": "java-easy-sol",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode ans = new ListNode(0,null);\\n        ListNode toReturn = ans;\\n        int temp = 0;\\n        head = head.next;\\n        while (head!=null) {\\n            while (head.val!=0) {\\n                temp += head.val;\\n                head = head.next;\\n            }\\n            head = head.next;\\n            ListNode a = new ListNode(temp,null);\\n            ans.next = a;\\n            ans = ans.next;\\n            temp = 0;\\n        }\\n        return toReturn.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode ans = new ListNode(0,null);\\n        ListNode toReturn = ans;\\n        int temp = 0;\\n        head = head.next;\\n        while (head!=null) {\\n            while (head.val!=0) {\\n                temp += head.val;\\n                head = head.next;\\n            }\\n            head = head.next;\\n            ListNode a = new ListNode(temp,null);\\n            ans.next = a;\\n            ans = ans.next;\\n            temp = 0;\\n        }\\n        return toReturn.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140196,
                "title": "java-2-solutions-commented",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n### Solution 1:\\n\\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        // create a dummy node to store the new linkedlist\\n        ListNode node = new ListNode(-1, null);\\n        ListNode h = node;  // pointer to iterate on the new list\\n        head = head.next;   // skip the first 0\\n\\n        // traverse until we are at the last 0 \\n        while (head.next != null) {\\n            // create new linkedlist with value 0 at next position\\n            h.next = new ListNode(0, null);\\n            h = h.next;     // move up to it\\n            // skip until we get a non-zero value\\n            while (head.val == 0) {\\n                head = head.next;\\n            }\\n            // traverse until we find another 0\\n            // till then keep adding the node values to the new node\\n            while (head.val != 0) {\\n                h.val += head.val;  // add the value\\n                head = head.next;\\n            }\\n        }\\n\\n        // dummy\\'s next is the head of the ans list\\n        return node.next;   \\n    }\\n}\\n```\\n#### Clean solution: \\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = new ListNode(-1, null);\\n        ListNode h = node; \\n        head = head.next;   \\n\\n        while (head.next != null) {\\n            h.next = new ListNode(0, null);\\n            h = h.next;    \\n            while (head.val == 0) {\\n                head = head.next;\\n            }\\n            while (head.val != 0) {\\n                h.val += head.val; \\n                head = head.next;\\n            }\\n        }\\n\\n        return node.next;   \\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$\\n##### Space complexity: $$O(n)$$\\n---\\n\\n### Solution 2:\\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = new ListNode(-1, null);     // dummy node\\n        ListNode n = node;  // dummy iterator\\n\\n        while (head != null) {\\n            head = head.next;  // skip the current 0\\n            int sum = 0;       // to calculate sum of non-zeros\\n            // traverse until 0 encounter\\n            while (head != null && head.val != 0) {\\n                sum += head.val;   // add the node value\\n                head = head.next;\\n            }\\n            // non-zero element sum will always be > 0\\n            if (sum > 0) {\\n                // create a new linkedlist with sum value\\n                n.next = new ListNode(sum); \\n                n = n.next; // move up to it\\n            }\\n        }\\n\\n        // return dummy\\'s next which is head of ans list\\n        return node.next;   \\n    }\\n}\\n```\\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = new ListNode(-1, null);\\n        ListNode n = node;\\n        while (head != null) {\\n            head = head.next;\\n            int sum = 0;\\n            while (head != null && head.val != 0) {\\n                sum += head.val;\\n                head = head.next;\\n            }\\n            if (sum > 0) {\\n                n.next = new ListNode(sum);\\n                n = n.next;\\n            }\\n        }\\n\\n        return node.next;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        // create a dummy node to store the new linkedlist\\n        ListNode node = new ListNode(-1, null);\\n        ListNode h = node;  // pointer to iterate on the new list\\n        head = head.next;   // skip the first 0\\n\\n        // traverse until we are at the last 0 \\n        while (head.next != null) {\\n            // create new linkedlist with value 0 at next position\\n            h.next = new ListNode(0, null);\\n            h = h.next;     // move up to it\\n            // skip until we get a non-zero value\\n            while (head.val == 0) {\\n                head = head.next;\\n            }\\n            // traverse until we find another 0\\n            // till then keep adding the node values to the new node\\n            while (head.val != 0) {\\n                h.val += head.val;  // add the value\\n                head = head.next;\\n            }\\n        }\\n\\n        // dummy\\'s next is the head of the ans list\\n        return node.next;   \\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = new ListNode(-1, null);\\n        ListNode h = node; \\n        head = head.next;   \\n\\n        while (head.next != null) {\\n            h.next = new ListNode(0, null);\\n            h = h.next;    \\n            while (head.val == 0) {\\n                head = head.next;\\n            }\\n            while (head.val != 0) {\\n                h.val += head.val; \\n                head = head.next;\\n            }\\n        }\\n\\n        return node.next;   \\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = new ListNode(-1, null);     // dummy node\\n        ListNode n = node;  // dummy iterator\\n\\n        while (head != null) {\\n            head = head.next;  // skip the current 0\\n            int sum = 0;       // to calculate sum of non-zeros\\n            // traverse until 0 encounter\\n            while (head != null && head.val != 0) {\\n                sum += head.val;   // add the node value\\n                head = head.next;\\n            }\\n            // non-zero element sum will always be > 0\\n            if (sum > 0) {\\n                // create a new linkedlist with sum value\\n                n.next = new ListNode(sum); \\n                n = n.next; // move up to it\\n            }\\n        }\\n\\n        // return dummy\\'s next which is head of ans list\\n        return node.next;   \\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = new ListNode(-1, null);\\n        ListNode n = node;\\n        while (head != null) {\\n            head = head.next;\\n            int sum = 0;\\n            while (head != null && head.val != 0) {\\n                sum += head.val;\\n                head = head.next;\\n            }\\n            if (sum > 0) {\\n                n.next = new ListNode(sum);\\n                n = n.next;\\n            }\\n        }\\n\\n        return node.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123886,
                "title": "dekh-bro-easy-hai-beats-98-cpp-solution",
                "content": "# Intuition\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *temp = head ->next;\\n        int sum = 0;\\n        vector<int> arr;\\n        while(temp!=NULL){\\n            if(temp->val!=0){\\n                sum += temp->val;\\n                temp = temp->next;\\n            }else{\\n                if(sum!=0){\\n                    arr.push_back(sum);\\n                    sum = 0;\\n                }\\n                temp = temp ->next;\\n            }\\n        }\\n\\n\\n        // for(int i = 0;i<arr.size();i++){\\n        //     cout<<arr[i]<<\" \";\\n        // }\\n\\n        temp = head;\\n        int count=0;\\n        for(int i = 0;i<arr.size();i++){\\n            temp ->val = arr[i];\\n            temp = temp->next;\\n            count++;\\n        }\\n        temp = head;\\n        int k = 1;\\n        while(k<count){\\n            temp = temp->next;\\n            k++;\\n        }\\n        temp->next = NULL;\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *temp = head ->next;\\n        int sum = 0;\\n        vector<int> arr;\\n        while(temp!=NULL){\\n            if(temp->val!=0){\\n                sum += temp->val;\\n                temp = temp->next;\\n            }else{\\n                if(sum!=0){\\n                    arr.push_back(sum);\\n                    sum = 0;\\n                }\\n                temp = temp ->next;\\n            }\\n        }\\n\\n\\n        // for(int i = 0;i<arr.size();i++){\\n        //     cout<<arr[i]<<\" \";\\n        // }\\n\\n        temp = head;\\n        int count=0;\\n        for(int i = 0;i<arr.size();i++){\\n            temp ->val = arr[i];\\n            temp = temp->next;\\n            count++;\\n        }\\n        temp = head;\\n        int k = 1;\\n        while(k<count){\\n            temp = temp->next;\\n            k++;\\n        }\\n        temp->next = NULL;\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3110365,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *p = head->next;\\n        ListNode *ne = new ListNode();\\n        ListNode *q = ne;\\n        int re=0;\\n        while(p!=0){\\n            if(p->val!=0){\\n                re+=p->val;\\n                \\n            }\\n           \\n            if(p->val==0){              \\n                q->next = new ListNode(re);\\n                q = q->next;\\n                re=0;\\n            }\\n            p = p->next;\\n        }\\n        return ne->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *p = head->next;\\n        ListNode *ne = new ListNode();\\n        ListNode *q = ne;\\n        int re=0;\\n        while(p!=0){\\n            if(p->val!=0){\\n                re+=p->val;\\n                \\n            }\\n           \\n            if(p->val==0){              \\n                q->next = new ListNode(re);\\n                q = q->next;\\n                re=0;\\n            }\\n            p = p->next;\\n        }\\n        return ne->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110358,
                "title": "c-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p=head;\\n        ListNode* q= new ListNode();\\n        ListNode* x=q;\\n        int sum=0;\\n        int i=0,flag=0;\\n        p=p->next;\\n        while(p!=NULL){\\n        if(p->val==0){\\n            x->next= new ListNode(sum);\\n            x=x->next;\\n           sum=0;\\n        }\\n        sum=sum+(p->val);\\n        p=p->next;\\n        }\\n        return q->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p=head;\\n        ListNode* q= new ListNode();\\n        ListNode* x=q;\\n        int sum=0;\\n        int i=0,flag=0;\\n        p=p->next;\\n        while(p!=NULL){\\n        if(p->val==0){\\n            x->next= new ListNode(sum);\\n            x=x->next;\\n           sum=0;\\n        }\\n        sum=sum+(p->val);\\n        p=p->next;\\n        }\\n        return q->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029444,
                "title": "c-beginner-friendly-solutions-two-solutions",
                "content": "***If You Helped, Please Upvote !!!***\\n#### Brute Force Approach\\n\\n* Time Complexity = *`O(n) + O(n)`*, where n = number of nodes\\n* Space Complexity = *`O(n)`*\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        vector<int> mergedNodeVal;\\n        int sum = 0;\\n        while(head) {   // O(n)\\n            if(head -> val == 0) {\\n                if(sum) mergedNodeVal.push_back(sum);\\n                sum = 0;\\n            }\\n            sum += head -> val;\\n            head = head -> next;\\n        }\\n        if(sum) mergedNodeVal.push_back(sum);\\n\\n        // Create New Linked List\\n        if(mergedNodeVal.size() == 0) return nullptr;\\n\\n        ListNode* answer = new ListNode(mergedNodeVal[0]);\\n        ListNode* curr = answer;\\n\\n        for(int i = 1; i < mergedNodeVal.size(); i++) { // O(n)\\n            ListNode* newNode = new ListNode(mergedNodeVal[i]);\\n            curr -> next = newNode;\\n            curr = newNode;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n\\n##### Second Approach \\n* Time Complexity = *`O(n)`*\\n* Space Complexity = *`O(1)`*\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* curr = head->next;\\n        ListNode* move = head;\\n        ListNode* prev = nullptr;\\n\\n        while(curr) {\\n            if(curr->val) {\\n                move -> val += curr -> val;\\n            }else {\\n                move -> next = curr;\\n                prev = move;\\n                move = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        prev -> next = nullptr;\\n        return head;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        vector<int> mergedNodeVal;\\n        int sum = 0;\\n        while(head) {   // O(n)\\n            if(head -> val == 0) {\\n                if(sum) mergedNodeVal.push_back(sum);\\n                sum = 0;\\n            }\\n            sum += head -> val;\\n            head = head -> next;\\n        }\\n        if(sum) mergedNodeVal.push_back(sum);\\n\\n        // Create New Linked List\\n        if(mergedNodeVal.size() == 0) return nullptr;\\n\\n        ListNode* answer = new ListNode(mergedNodeVal[0]);\\n        ListNode* curr = answer;\\n\\n        for(int i = 1; i < mergedNodeVal.size(); i++) { // O(n)\\n            ListNode* newNode = new ListNode(mergedNodeVal[i]);\\n            curr -> next = newNode;\\n            curr = newNode;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* curr = head->next;\\n        ListNode* move = head;\\n        ListNode* prev = nullptr;\\n\\n        while(curr) {\\n            if(curr->val) {\\n                move -> val += curr -> val;\\n            }else {\\n                move -> next = curr;\\n                prev = move;\\n                move = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        prev -> next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940191,
                "title": "c-solution-o-n-time-complexity-98-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n//Linear Time complexity\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p = new ListNode(0);\\n        ListNode* cur =  head;\\n        ListNode* answer = p;\\n        cur = cur->next;\\n        int sum = 0;\\n        while(cur){\\n           if(cur->val==0){\\n                answer->next = new ListNode(sum);\\n                answer = answer->next;\\n                sum=0;\\n                cur = cur->next;\\n            }\\n             else{\\n                sum += cur->val;\\n                cur = cur->next;\\n            }\\n        }\\n        return p->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n//Linear Time complexity\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p = new ListNode(0);\\n        ListNode* cur =  head;\\n        ListNode* answer = p;\\n        cur = cur->next;\\n        int sum = 0;\\n        while(cur){\\n           if(cur->val==0){\\n                answer->next = new ListNode(sum);\\n                answer = answer->next;\\n                sum=0;\\n                cur = cur->next;\\n            }\\n             else{\\n                sum += cur->val;\\n                cur = cur->next;\\n            }\\n        }\\n        return p->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787661,
                "title": "easy-python-solution-in-o-n-tc",
                "content": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        sm=0\\n        temp=temp.next\\n        curr=head\\n        while temp:\\n            if temp.val==0:\\n                curr=curr.next\\n                curr.val=sm\\n                sm=0\\n            else:\\n                sm+=temp.val\\n            temp=temp.next\\n        curr.next=None\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        sm=0\\n        temp=temp.next\\n        curr=head\\n        while temp:\\n            if temp.val==0:\\n                curr=curr.next\\n                curr.val=sm\\n                sm=0\\n            else:\\n                sm+=temp.val\\n            temp=temp.next\\n        curr.next=None\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697653,
                "title": "merge-nodes-in-between-zeros",
                "content": "```\\npublic class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        if (head == null) return head;\\n        ListNode fackNode = new ListNode(-1);\\n        ListNode tail = fackNode;\\n        ListNode curr = head.next;\\n        int sum = 0;\\n        while (curr != null) {\\n            if (curr.val == 0) {\\n                tail.next = new ListNode(sum);\\n                tail = tail.next;\\n                sum = 0;\\n            }\\n            sum += curr.val;\\n            curr = curr.next;\\n        }\\n        return fackNode.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        if (head == null) return head;\\n        ListNode fackNode = new ListNode(-1);\\n        ListNode tail = fackNode;\\n        ListNode curr = head.next;\\n        int sum = 0;\\n        while (curr != null) {\\n            if (curr.val == 0) {\\n                tail.next = new ListNode(sum);\\n                tail = tail.next;\\n                sum = 0;\\n            }\\n            sum += curr.val;\\n            curr = curr.next;\\n        }\\n        return fackNode.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661191,
                "title": "c-time-complexity-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int x = 0;\\n        ListNode* p = head;\\n        ListNode* q = head;\\n        ListNode* r;\\n        ListNode* ans = q;\\n        while(p!=NULL){\\n            if(x > 0 && p->val == 0){\\n                q->val = x;\\n                x = 0;\\n                r = q;\\n                q = q->next;\\n            }\\n            x += p->val;\\n            p = p->next;\\n        }\\n        r->next = NULL;\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int x = 0;\\n        ListNode* p = head;\\n        ListNode* q = head;\\n        ListNode* r;\\n        ListNode* ans = q;\\n        while(p!=NULL){\\n            if(x > 0 && p->val == 0){\\n                q->val = x;\\n                x = 0;\\n                r = q;\\n                q = q->next;\\n            }\\n            x += p->val;\\n            p = p->next;\\n        }\\n        r->next = NULL;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649923,
                "title": "c-explained-in-the-simplest-way",
                "content": "```\\nListNode* mergeNodes(ListNode* head) {\\n        \\n        ListNode* pseudo = new ListNode(0); // created a linked list with initialized with 0\\n        ListNode* ptr = pseudo; // pointing the pseudo node\\n        ListNode* temp = head; // for iteration\\n        \\n        temp = temp->next; // as temp is already 0 so, point to next var\\n        \\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            while(temp->val != 0){\\n                sum += temp->val;\\n                temp = temp->next;                            \\n            } // sum a group from a 0 to another 0\\n            \\n            ptr->next = new ListNode(sum); // a next node in the output pseudo LL will be created with value as \\'sum\\'\\n            ptr = ptr->next;\\n            temp = temp->next; // temp is ready for another loop till 0\\n            sum = 0;\\n        }\\n        \\n        return pseudo->next; // pseudo and ptr are kept diff because pseudo will still store the start of the output LL, while ptr will keep adding one by one node, thus pseudo can return LL from second element as first one is 0\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* mergeNodes(ListNode* head) {\\n        \\n        ListNode* pseudo = new ListNode(0); // created a linked list with initialized with 0\\n        ListNode* ptr = pseudo; // pointing the pseudo node\\n        ListNode* temp = head; // for iteration\\n        \\n        temp = temp->next; // as temp is already 0 so, point to next var\\n        \\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            while(temp->val != 0){\\n                sum += temp->val;\\n                temp = temp->next;                            \\n            } // sum a group from a 0 to another 0\\n            \\n            ptr->next = new ListNode(sum); // a next node in the output pseudo LL will be created with value as \\'sum\\'\\n            ptr = ptr->next;\\n            temp = temp->next; // temp is ready for another loop till 0\\n            sum = 0;\\n        }\\n        \\n        return pseudo->next; // pseudo and ptr are kept diff because pseudo will still store the start of the output LL, while ptr will keep adding one by one node, thus pseudo can return LL from second element as first one is 0\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637446,
                "title": "java-linear-time-solution-beginner-friendly-100-fast",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode newList = head;\\n        ListNode curr_head = head.next;\\n        int sum = 0;\\n        while(curr_head != null)\\n        {\\n            sum = 0;\\n            while(curr_head.val != 0)\\n            {\\n                sum = sum + curr_head.val;\\n                curr_head = curr_head.next;\\n            }\\n            newList.next = curr_head;\\n            curr_head.val = sum;\\n            newList = newList.next;\\n            curr_head = curr_head.next;\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode newList = head;\\n        ListNode curr_head = head.next;\\n        int sum = 0;\\n        while(curr_head != null)\\n        {\\n            sum = 0;\\n            while(curr_head.val != 0)\\n            {\\n                sum = sum + curr_head.val;\\n                curr_head = curr_head.next;\\n            }\\n            newList.next = curr_head;\\n            curr_head.val = sum;\\n            newList = newList.next;\\n            curr_head = curr_head.next;\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542936,
                "title": "easy-python-solution",
                "content": "```\\ndef mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tcurr = head\\n\\twhile(curr):\\n\\t\\tif(curr.val == 0):\\n\\t\\t\\ts = 0\\n\\t\\t\\ttar = curr\\n\\t\\t\\tcurr = curr.next\\n\\t\\t\\twhile(curr.val != 0):\\n\\t\\t\\t\\ts += curr.val\\n\\t\\t\\t\\tcurr = curr.next\\n\\t\\t\\ttar.val = s\\n\\t\\t\\tif(curr.next):\\n\\t\\t\\t\\ttar.next = curr\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttar.next = None\\n\\t\\t\\t\\tbreak\\n\\treturn head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tcurr = head\\n\\twhile(curr):\\n\\t\\tif(curr.val == 0):\\n\\t\\t\\ts = 0\\n\\t\\t\\ttar = curr\\n\\t\\t\\tcurr = curr.next\\n\\t\\t\\twhile(curr.val != 0):\\n\\t\\t\\t\\ts += curr.val\\n\\t\\t\\t\\tcurr = curr.next\\n\\t\\t\\ttar.val = s\\n\\t\\t\\tif(curr.next):\\n\\t\\t\\t\\ttar.next = curr\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttar.next = None\\n\\t\\t\\t\\tbreak\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2523998,
                "title": "2-pointer-approach-easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n      int sum=0;\\n        while(fast.next!=null)\\n        {\\n            sum+=fast.val;\\n            if(fast.next.val==0)\\n            {\\n                slow.val=sum;\\n                if(fast.next.next!=null)\\n                    slow=slow.next;\\n                sum=0;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n      int sum=0;\\n        while(fast.next!=null)\\n        {\\n            sum+=fast.val;\\n            if(fast.next.val==0)\\n            {\\n                slow.val=sum;\\n                if(fast.next.next!=null)\\n                    slow=slow.next;\\n                sum=0;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257370,
                "title": "java-two-pointers-solution",
                "content": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n      ListNode start = head, curr = head;\\n      int value = 0;\\n      while(start.next != null) {\\n        value += start.val;\\n        if(start.next.val == 0) {\\n          curr.val= value;\\n          \\n          if(start.next.next != null)\\n             curr = curr.next;\\n          value = 0;\\n        }\\n        start = start.next;\\n      }\\n      curr.next = null;\\n      \\n      return head;\\n    }\\n}\\n\\n```\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n      ListNode start = head, curr = head;\\n      int value = 0;\\n      while(start.next != null) {\\n        value += start.val;\\n        if(start.next.val == 0) {\\n          curr.val= value;\\n          \\n          if(start.next.next != null)\\n             curr = curr.next;\\n          value = 0;\\n        }\\n        start = start.next;\\n      }\\n      curr.next = null;\\n      \\n      return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163401,
                "title": "merge-nodes-java-with-approach-comments-o-n-time-o-1-space",
                "content": "### **Approach** \\n1) Idea here is to UPDATE the Nodes with value as 0 (occurring at start, between & end) with the sum of values of non-zeros elements between them.\\n2) Updating process of Nodes with 0 value starts from the head (which is itself node with 0 value) and continues in nodes with zeros values occurring in between the linked-list. \\n3) But the last node in the list with 0 value is skipped as we don\\'t require it.\\n\\n**Time Complexity** : O(n)  As we only require Only One traversal\\n**Space Complexity** : O(1)\\n\\n*Please do upvote if you find this solution helpful!*\\n\\n### **Code**:\\n\\n```\\npublic ListNode mergeNodes(ListNode head) {\\n        if (head == null) return null;\\n\\n        // We start iterating from next element of head (as first element is 0)\\n        // \\'ptr\\' stores current node\\n        ListNode ptr = head.next;\\n\\n        // \\'previousZeroNode\\' stores the address of previous node encountered with value 0\\n        //\\'previous\\' stores the previous node to \\'ptr\\' Node\\n        ListNode previousZeroNode = head, previous = null;\\n\\n        // this \\'sumBetweenZeros\\' stores sum of values between two zeros\\n        int sumBetweenZeros = 0;\\n\\n\\n        while (ptr != null){\\n            // if current node\\'s value is not zero, simply sum the value & update the \\'previous\\' node\\n            if (ptr.val != 0){\\n                sumBetweenZeros += ptr.val;\\n                previous = ptr;\\n            }\\n\\n            // if current node\\'s value is zero, mark the \\'previousZeroNode\\' node value with sum of\\n            // non-zeros values between two zeros AND point the next node of \\'previousZeroNode\\' with the\\n            // current zero node (which is \\'ptr\\' now) iff the current node (\\'ptr\\') is not the last\\n            // \\'zero node\\' of the linked-list   (We need to return non-zero nodes)\\n            else{\\n                previousZeroNode.val = sumBetweenZeros;\\n\\n                if (ptr.next == null)\\n                    previousZeroNode.next = null;\\n                else\\n                    previousZeroNode.next = ptr;\\n\\n                previousZeroNode = previousZeroNode.next;\\n\\n                // make the previous node\\'s next to null as previous node will be having non-zeros values\\n                previous.next = null;\\n\\n                // Reinitialize the sum to 0 as now we will again make the pairs of elements between two zeros\\n                sumBetweenZeros = 0;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        // Head will now store the non-zero value as we have updated it\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode mergeNodes(ListNode head) {\\n        if (head == null) return null;\\n\\n        // We start iterating from next element of head (as first element is 0)\\n        // \\'ptr\\' stores current node\\n        ListNode ptr = head.next;\\n\\n        // \\'previousZeroNode\\' stores the address of previous node encountered with value 0\\n        //\\'previous\\' stores the previous node to \\'ptr\\' Node\\n        ListNode previousZeroNode = head, previous = null;\\n\\n        // this \\'sumBetweenZeros\\' stores sum of values between two zeros\\n        int sumBetweenZeros = 0;\\n\\n\\n        while (ptr != null){\\n            // if current node\\'s value is not zero, simply sum the value & update the \\'previous\\' node\\n            if (ptr.val != 0){\\n                sumBetweenZeros += ptr.val;\\n                previous = ptr;\\n            }\\n\\n            // if current node\\'s value is zero, mark the \\'previousZeroNode\\' node value with sum of\\n            // non-zeros values between two zeros AND point the next node of \\'previousZeroNode\\' with the\\n            // current zero node (which is \\'ptr\\' now) iff the current node (\\'ptr\\') is not the last\\n            // \\'zero node\\' of the linked-list   (We need to return non-zero nodes)\\n            else{\\n                previousZeroNode.val = sumBetweenZeros;\\n\\n                if (ptr.next == null)\\n                    previousZeroNode.next = null;\\n                else\\n                    previousZeroNode.next = ptr;\\n\\n                previousZeroNode = previousZeroNode.next;\\n\\n                // make the previous node\\'s next to null as previous node will be having non-zeros values\\n                previous.next = null;\\n\\n                // Reinitialize the sum to 0 as now we will again make the pairs of elements between two zeros\\n                sumBetweenZeros = 0;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        // Head will now store the non-zero value as we have updated it\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137829,
                "title": "java-o-n-time-and-space-easy-solution",
                "content": "```\\nclass Solution {\\n\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode result = new ListNode(0);\\n        ListNode headResult = result;\\n        int currentSum = 0;\\n        \\n        while(head != null) {\\n            if(head.val == 0 && currentSum != 0) {\\n                result.next = new ListNode(currentSum);\\n                result = result.next;\\n                currentSum = 0;\\n            } else {\\n                currentSum += head.val;\\n            }\\n            \\n            head = head.next;\\n        }\\n        \\n        return headResult.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode result = new ListNode(0);\\n        ListNode headResult = result;\\n        int currentSum = 0;\\n        \\n        while(head != null) {\\n            if(head.val == 0 && currentSum != 0) {\\n                result.next = new ListNode(currentSum);\\n                result = result.next;\\n                currentSum = 0;\\n            } else {\\n                currentSum += head.val;\\n            }\\n            \\n            head = head.next;\\n        }\\n        \\n        return headResult.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109863,
                "title": "easy-java-solution-two-pointer",
                "content": "\\n\\t\\tListNode slow=head;\\n        ListNode fast=head;\\n        ListNode res=new ListNode();\\n        ListNode ans=res;\\n        int sum=0;\\n        while(slow!=null)\\n        {\\n            if(fast.next == null)\\n            {\\n                break;\\n            }\\n            sum+=slow.val;\\n            slow=slow.next;\\n            fast=fast.next;\\n            if(fast.val==0)\\n            {\\n                res.next=new ListNode(sum);\\n                res=res.next;\\n                sum=0;\\n            }\\n        }\\n        return ans.next;",
                "solutionTags": [],
                "code": "\\n\\t\\tListNode slow=head;\\n        ListNode fast=head;\\n        ListNode res=new ListNode();\\n        ListNode ans=res;\\n        int sum=0;\\n        while(slow!=null)\\n        {\\n            if(fast.next == null)\\n            {\\n                break;\\n            }\\n            sum+=slow.val;\\n            slow=slow.next;\\n            fast=fast.next;\\n            if(fast.val==0)\\n            {\\n                res.next=new ListNode(sum);\\n                res=res.next;\\n                sum=0;\\n            }\\n        }\\n        return ans.next;",
                "codeTag": "Unknown"
            },
            {
                "id": 1950988,
                "title": "c",
                "content": "```\\npublic ListNode MergeNodes(ListNode head) {\\n        \\n        ListNode answ = new ListNode();\\n        ListNode curr = answ;\\n\\n        while (head.next != null)\\n        {\\n            int sum = 0;\\n\\n            head = head.next;\\n            while (head != null && head.val != 0)\\n            {\\n                sum += head.val;\\n                head = head.next;\\n            }\\n\\n            curr.next = new ListNode(sum);\\n            curr = curr.next;\\n        }\\n\\n        return answ.next;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic ListNode MergeNodes(ListNode head) {\\n        \\n        ListNode answ = new ListNode();\\n        ListNode curr = answ;\\n\\n        while (head.next != null)\\n        {\\n            int sum = 0;\\n\\n            head = head.next;\\n            while (head != null && head.val != 0)\\n            {\\n                sum += head.val;\\n                head = head.next;\\n            }\\n\\n            curr.next = new ListNode(sum);\\n            curr = curr.next;\\n        }\\n\\n        return answ.next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1880031,
                "title": "easy-java-solution-using-loops",
                "content": "Take a new node as current node. The question says that its guaranteed that the linkedlist starts and ends with 0. Hence take current node as the second node of the linkedlist. Take another new node as previous node. Use this previous node to store the last node with val 0 found. \\n\\nLoop through the linkedlist. Always check that current node is not null & next of current node is not null. What does it mean when next of current node is null? It means that we have reached the last node of the linkedlist which has value 0. Hence terminate the loop.\\n\\nInside the loop, check whether the node value is non zero. If so, then simply add the value of current node to previous node value and point current node to its next. Keep doing this unless you find a node with zero value. When node with value 0 found, point the previous node\\'s next to current node which has 0, then make current node as previous node and point current node to its next.\\n\\nAfter the loop ends, simply point the previous node\\'s next to null since the question says to remove all nodes with value 0. Return head.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode curr = head.next, prev = head;\\n        \\n        while(curr != null && curr.next != null){\\n            if(curr.val != 0){\\n                prev.val += curr.val;\\n            }\\n            else{\\n                prev.next = curr;\\n                prev = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        prev.next = null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode curr = head.next, prev = head;\\n        \\n        while(curr != null && curr.next != null){\\n            if(curr.val != 0){\\n                prev.val += curr.val;\\n            }\\n            else{\\n                prev.next = curr;\\n                prev = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        prev.next = null;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840041,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode MergeNodes(ListNode head) \\n    {\\n        ListNode cur = head;\\n        \\n        while(cur.next != null)\\n        {\\n            ListNode nextN = cur.next;\\n            \\n            ListNode nextNext = nextN.next;\\n            nextN.next = null;\\n\\n            if(nextN.val!=0)\\n                cur.val += nextN.val;\\n            else if(nextN.val==0 && nextNext!=null)\\n                cur = nextN;\\n\\n            cur.next = nextNext;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode MergeNodes(ListNode head) \\n    {\\n        ListNode cur = head;\\n        \\n        while(cur.next != null)\\n        {\\n            ListNode nextN = cur.next;\\n            \\n            ListNode nextNext = nextN.next;\\n            nextN.next = null;\\n\\n            if(nextN.val!=0)\\n                cur.val += nextN.val;\\n            else if(nextN.val==0 && nextNext!=null)\\n                cur = nextN;\\n\\n            cur.next = nextNext;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811630,
                "title": "easy-iterative-c-solution-o-1-space-and-o-n-time-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeNodes(ListNode* head) {\\n\\t\\t\\tListNode* root = new ListNode(0);\\n\\t\\t\\tListNode* tmp = root;\\n\\n\\t\\t\\twhile(head){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\twhile(head and head->val){\\n\\t\\t\\t\\t\\tsum+=head->val;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(sum>0) {\\n\\t\\t\\t\\t\\ttmp->next = new ListNode(sum);\\n\\t\\t\\t\\t\\ttmp = tmp->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\treturn root->next;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* mergeNodes(ListNode* head) {\\n\\t\\t\\tListNode* root = new ListNode(0);\\n\\t\\t\\tListNode* tmp = root;\\n\\n\\t\\t\\twhile(head){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\twhile(head and head->val){\\n\\t\\t\\t\\t\\tsum+=head->val;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1810495,
                "title": "simple-javascript-solution-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar mergeNodes = function(head) {\\n    let result = new ListNode(-1);\\n    let temp = result;\\n    while(head){\\n        if(head.val==0 && head.next){\\n            temp.next = new ListNode(0);\\n            temp = temp.next;\\n        }\\n        temp.val += head.val;\\n        head = head.next;\\n    }\\n    return result.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar mergeNodes = function(head) {\\n    let result = new ListNode(-1);\\n    let temp = result;\\n    while(head){\\n        if(head.val==0 && head.next){\\n            temp.next = new ListNode(0);\\n            temp = temp.next;\\n        }\\n        temp.val += head.val;\\n        head = head.next;\\n    }\\n    return result.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1801213,
                "title": "merge-nodes-in-between-zeros",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) \\n    {\\n        if (!head)\\n            return head;\\n        ListNode* ans = new ListNode(0); // Create a dummy node.\\n        ListNode* x = ans;\\n        int sum = 0;\\n        while (head)\\n        {\\n            if (head->val == 0) // Whenever find zero append the sum to the ans linked list.\\n            {\\n                ans->next = new ListNode(sum);\\n                ans = ans->next;\\n                sum = 0;  // Make the sum = 0 for further computations.\\n                head = head->next;\\n                continue;\\n            }\\n            sum += head->val;\\n            head = head->next;\\n        }\\n        return x->next->next; // Return next->next since first two inserted numbers in the list will be zero for obvious reasons.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) \\n    {\\n        if (!head)\\n            return head;\\n        ListNode* ans = new ListNode(0); // Create a dummy node.\\n        ListNode* x = ans;\\n        int sum = 0;\\n        while (head)\\n        {\\n            if (head->val == 0) // Whenever find zero append the sum to the ans linked list.\\n            {\\n                ans->next = new ListNode(sum);\\n                ans = ans->next;\\n                sum = 0;  // Make the sum = 0 for further computations.\\n                head = head->next;\\n                continue;\\n            }\\n            sum += head->val;\\n            head = head->next;\\n        }\\n        return x->next->next; // Return next->next since first two inserted numbers in the list will be zero for obvious reasons.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796873,
                "title": "go-best-solution-100-space-and-time-visual-and-explanation",
                "content": "**Explanation:**\\n1. Make a node that will be the sum of all nodes within group\\n2. After adding a node to the sum, delete node\\n2. Repeat step two while current node is not equal to 0 \\n3. When current equals 0, modificaiton node is assigned to current (val of 0) for a reset\\n4. Loop ends with one 0 remaining\\n5. snip off remaining zero by setting the last modified nodes next pointer to nil \\n##### **Visual** :\\n![image](https://assets.leetcode.com/users/images/413756fc-c021-430c-8b86-43fd1b33393b_1645725469.6684468.gif)\\n#### **Code**:\\n```\\nfunc mergeNodes(head *ListNode) *ListNode {\\n    if head == nil || head.Val == 0 && head.Next == nil{\\n        return nil\\n    }\\n    curr := head\\n    mod := &ListNode{}\\n    for curr.Next != nil  {\\n        if curr.Val == 0 {\\n            mod = curr\\n            curr = curr.Next\\n        }\\n        if curr.Val != 0 {\\n            mod.Val += curr.Val\\n            *curr = *curr.Next\\n        }\\n    }\\n    mod.Next = nil\\n    return head\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeNodes(head *ListNode) *ListNode {\\n    if head == nil || head.Val == 0 && head.Next == nil{\\n        return nil\\n    }\\n    curr := head\\n    mod := &ListNode{}\\n    for curr.Next != nil  {\\n        if curr.Val == 0 {\\n            mod = curr\\n            curr = curr.Next\\n        }\\n        if curr.Val != 0 {\\n            mod.Val += curr.Val\\n            *curr = *curr.Next\\n        }\\n    }\\n    mod.Next = nil\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796285,
                "title": "python-solution-with-explanation",
                "content": "In this what we have done is that we create an empty linked list at the same time as we iterate over our current given head linked list and keep on adding the values of current values and check for each value if by chance it comes equal to \"0\" , then we add the value of the current sum what we get from past values in our created linked list and at the end return it.\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l=ListNode()\\n        ans=l\\n        s=0\\n        while(head!=None):\\n            if(head.val==0):\\n                if(s==0):\\n                    pass\\n                else:\\n                    f=ListNode(s)\\n                    l.next=f\\n                    l=l.next\\n                    s=0\\n            else:\\n                s=s+head.val\\n                \\n            head=head.next\\n        \\n        return(ans.next)\\n```\\nIf u understood the code then plz....UPVOTE...thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l=ListNode()\\n        ans=l\\n        s=0\\n        while(head!=None):\\n            if(head.val==0):\\n                if(s==0):\\n                    pass\\n                else:\\n                    f=ListNode(s)\\n                    l.next=f\\n                    l=l.next\\n                    s=0\\n            else:\\n                s=s+head.val\\n                \\n            head=head.next\\n        \\n        return(ans.next)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787072,
                "title": "2181-python3-o-n-easy-to-understand-runtime-4723-ms-20-00-faster-memory-72-9-mb",
                "content": "How can you use two pointers to modify the original list into the new list?\\n~\\nHave a pointer traverse the entire linked list, while another pointer looks at a node that is currently being modified.\\n~\\nKeep on summing the values of the nodes between the traversal pointer and the modifying pointer until the former comes across a \\u20180\\u2019. In that case, the modifying pointer is incremented to modify the next node.\\n~\\nDo not forget to have the next pointer of the final node of the modified list point to null.\\n\\n```\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        head = head.next\\n        node = head\\n        while node:\\n            while node.next.val != 0:\\n                node.val += node.next.val\\n                node.next = node.next.next\\n            \\n            node.next = node.next.next\\n            node = node.next\\n\\n        return head\\n    \\n# Time: O(N)\\n# Space: O(1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9f2a5768-b77e-44c1-afa4-bbfbb876a064_1645381822.4103515.png)\\n\\n--------\\n--------\\n**Find this solution and many others on my Github:** https://github.com/dimon41k2010/LeetCodeTasks/blob/main/2181-merge-nodes-in-between-zeros/2181-merge-nodes-in-between-zeros.py\\n\\n**Please upvote if it makes sence and helpful to you. Let\\'s stay motivated! Peace.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        head = head.next\\n        node = head\\n        while node:\\n            while node.next.val != 0:\\n                node.val += node.next.val\\n                node.next = node.next.next\\n            \\n            node.next = node.next.next\\n            node = node.next\\n\\n        return head\\n    \\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786889,
                "title": "hop-between-zeros-in-place-modification-o-1-space-c-clean-code",
                "content": "**Intuition :**\\n---------------------------------------\\n* Idea here is to *Hop between ZEROS* , \\n\\n* i.e we start merging/summing values from current zero till next zero.\\n* Once we have sum of all nodes between current and next zero, \\n* Simply store that sum in current zero and move to next zero.\\n* Also, before moving to next zero, we connect current and next zero.\\n\\t* And skip nodes in between them.\\n\\t\\t\\t     \\n\\t\\t\\tEx:     [ 0 -> 1 -> 2 -> 3 -> 0 . . . . . . ]\\n\\t\\t     \\n\\t\\t\\t-> So here we add values of all nodes between zeros,\\n\\t\\t\\t\\t => sum = 1 + 2 + 3 = 6\\n\\t\\t\\t-> Thus, we update value of current zero with sum and move to next zero\\n\\t\\t\\t\\n\\t\\t\\tNew list will look like : [ 6 -> 0 . . . . . . ]\\n\\t\\t\\n*  We will continue this till the last zero, and for last zero we would skip that (ignore it !!!)\\n\\n---------------------------------------\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* zero = head;\\n        ListNode* ptr = head->next;\\n        while(ptr) {\\n            if(ptr->val) {\\n                zero->val += ptr->val;\\n            }\\n            else {\\n                if(!ptr->next) zero->next = NULL;\\n                else zero->next = ptr;\\n                \\n                zero = ptr;\\n            }\\n            ptr = ptr->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n---------------------------------------\\n\\n**Complexity :**\\n\\n* Time : `O(N)`\\n* Space : `O(1)`\\n\\n---------------------------------------\\n\\n***If you like this, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* zero = head;\\n        ListNode* ptr = head->next;\\n        while(ptr) {\\n            if(ptr->val) {\\n                zero->val += ptr->val;\\n            }\\n            else {\\n                if(!ptr->next) zero->next = NULL;\\n                else zero->next = ptr;\\n                \\n                zero = ptr;\\n            }\\n            ptr = ptr->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785479,
                "title": "c-solution-using-stack-o-n-time-o-1-space",
                "content": "**Simply add the node values between zeroes**\\nStore the first zero in the stack. Now , till another zero occurs, we will traverse the linked list, and keep adding the value of the nodes to a single node. As soon as another zero is encountered, we will pop from the stack and add the new node to the next of dummy head and move the traversing pointer forward.\\nFinally, after the operation is done return the new head\\'s next of the linked list which initially referred to the dummy node.\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head) return NULL;\\n        stack<int>p;\\n\\t\\t//make a dummy node\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* newHead = dummy;\\n        ListNode* temp = head;\\n        bool flag = false;\\n        int sum = 0;\\n        while(temp){\\n\\t\\t//when this is the first zero \\n            if(temp -> val == 0 && p.empty() == true){\\n                p.push(0);\\n            }\\n\\t\\t\\t//now another zero occurs so pop and make the new list\\n            else if(temp->val == 0 && p.empty() == false){\\n                p.pop();\\n                ListNode* newnode = new ListNode(sum);\\n                dummy -> next = newnode;\\n                dummy = dummy -> next;\\n                sum = 0;\\n\\t\\t\\t\\t//remember to push this zero as the start for other range\\n                p.push(0);\\n            }\\n            else{\\n\\t\\t\\t//keep adding the node values\\n                sum += temp -> val;\\n            }\\n            temp = temp -> next;\\n        }\\n\\t\\t//return the new head\\n        return newHead -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(!head) return NULL;\\n        stack<int>p;\\n\\t\\t//make a dummy node\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* newHead = dummy;\\n        ListNode* temp = head;\\n        bool flag = false;\\n        int sum = 0;\\n        while(temp){\\n\\t\\t//when this is the first zero \\n            if(temp -> val == 0 && p.empty() == true){\\n                p.push(0);\\n            }\\n\\t\\t\\t//now another zero occurs so pop and make the new list\\n            else if(temp->val == 0 && p.empty() == false){\\n                p.pop();\\n                ListNode* newnode = new ListNode(sum);\\n                dummy -> next = newnode;\\n                dummy = dummy -> next;\\n                sum = 0;\\n\\t\\t\\t\\t//remember to push this zero as the start for other range\\n                p.push(0);\\n            }\\n            else{\\n\\t\\t\\t//keep adding the node values\\n                sum += temp -> val;\\n            }\\n            temp = temp -> next;\\n        }\\n\\t\\t//return the new head\\n        return newHead -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784822,
                "title": "c-dummynodes-concept-fast-easytounderstand-o-n",
                "content": "1. On the Go find the sum and just insert at last of dummy node.\\n2.  dummy\\'s next will always point to the head of required node.\\n\\n```\\n  class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n         \\n        ListNode *curr = head;\\n        ListNode *second = NULL;\\n        ListNode *dummy = new ListNode(0);\\n        ListNode *tail = dummy;\\n          \\n        while(curr!=NULL && curr->next!=NULL){\\n            second = curr->next;\\n            int sum = 0;\\n            \\n            while(second->val != 0){\\n                sum+=second->val;\\n                second=second->next;\\n            }\\n            \\n            ListNode *temp = new ListNode(sum);\\n            tail->next = temp;\\n            tail = temp;\\n            \\n            curr=second;   \\n        }\\n        \\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n         \\n        ListNode *curr = head;\\n        ListNode *second = NULL;\\n        ListNode *dummy = new ListNode(0);\\n        ListNode *tail = dummy;\\n          \\n        while(curr!=NULL && curr->next!=NULL){\\n            second = curr->next;\\n            int sum = 0;\\n            \\n            while(second->val != 0){\\n                sum+=second->val;\\n                second=second->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1784799,
                "title": "merge-nodes",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        \\n        int sum=0;\\n        ListNode* ans=new ListNode(0);\\n        ListNode* temp=ans;\\n        head=head->next;\\n        while(head != NULL){\\n            if(head->val==0){\\n                if(sum != 0){\\n                    temp->next=new ListNode(sum);\\n                    temp=temp->next;\\n                    sum=0;\\n                }\\n            }else{\\n                sum+=head->val;\\n            }\\n            head=head->next;\\n        }\\n        \\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        \\n        int sum=0;\\n        ListNode* ans=new ListNode(0);\\n        ListNode* temp=ans;\\n        head=head->next;\\n        while(head != NULL){\\n            if(head->val==0){\\n                if(sum != 0){\\n                    temp->next=new ListNode(sum);\\n                    temp=temp->next;\\n                    sum=0;\\n                }\\n            }else{\\n                sum+=head->val;\\n            }\\n            head=head->next;\\n        }\\n        \\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014152,
                "title": "basic-solution-pls-check",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n      ListNode * temp = head;\\n      ListNode * temp1 = head;\\n      ListNode * newhead = temp1;\\n      int sum=0;\\n      bool flag = false;\\n      while(temp!=NULL){\\n         if(temp->val==0 && flag){\\n           temp1->val= sum;\\n           if(temp->next == NULL){\\n              temp1->next=NULL;\\n           }\\n           temp1=temp1->next;\\n           sum=0;\\n         }\\n         else{\\n           flag = true;\\n           sum+=temp->val;\\n         }\\n         temp = temp->next;\\n      }\\n     \\n      return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n      ListNode * temp = head;\\n      ListNode * temp1 = head;\\n      ListNode * newhead = temp1;\\n      int sum=0;\\n      bool flag = false;\\n      while(temp!=NULL){\\n         if(temp->val==0 && flag){\\n           temp1->val= sum;\\n           if(temp->next == NULL){\\n              temp1->next=NULL;\\n           }\\n           temp1=temp1->next;\\n           sum=0;\\n         }\\n         else{\\n           flag = true;\\n           sum+=temp->val;\\n         }\\n         temp = temp->next;\\n      }\\n     \\n      return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009477,
                "title": "easy-solution-without-extra-space",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func mergeNodes(_ head: ListNode?) -> ListNode? {\\n        let newHead = ListNode(-1)\\n        var temp = head?.next\\n\\n\\n        while temp?.next != nil {\\n            if temp!.next!.val == 0 {\\n                temp?.next = temp?.next?.next\\n                temp = temp?.next\\n            } else {\\n                temp?.val += temp!.next!.val\\n               temp?.next = temp?.next?.next\\n            }\\n        }\\n        return  head?.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func mergeNodes(_ head: ListNode?) -> ListNode? {\\n        let newHead = ListNode(-1)\\n        var temp = head?.next\\n\\n\\n        while temp?.next != nil {\\n            if temp!.next!.val == 0 {\\n                temp?.next = temp?.next?.next\\n                temp = temp?.next\\n            } else {\\n                temp?.val += temp!.next!.val\\n               temp?.next = temp?.next?.next\\n            }\\n        }\\n        return  head?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979222,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head;\\n        ListNode zero = new ListNode();\\n        ListNode res = zero;\\n        int z = 0;\\n        int sum = 0;\\n        while(temp != null) {\\n            if(temp.val == 0) {\\n                z++;\\n            } else {\\n                sum += temp.val;\\n            }\\n            if(z == 2) {\\n                res.next = new ListNode(sum);\\n                res = res.next;\\n                sum = 0;\\n                z = 1;\\n            }\\n            temp = temp.next;\\n        }\\n        return zero.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head;\\n        ListNode zero = new ListNode();\\n        ListNode res = zero;\\n        int z = 0;\\n        int sum = 0;\\n        while(temp != null) {\\n            if(temp.val == 0) {\\n                z++;\\n            } else {\\n                sum += temp.val;\\n            }\\n            if(z == 2) {\\n                res.next = new ListNode(sum);\\n                res = res.next;\\n                sum = 0;\\n                z = 1;\\n            }\\n            temp = temp.next;\\n        }\\n        return zero.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979219,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head;\\n        ListNode zero = new ListNode();\\n        ListNode res = zero;\\n        int z = 0;\\n        int sum = 0;\\n        while(temp != null) {\\n            if(temp.val == 0) {\\n                z++;\\n            } else {\\n                sum += temp.val;\\n            }\\n            if(z == 2) {\\n                res.next = new ListNode(sum);\\n                res = res.next;\\n                sum = 0;\\n                z = 1;\\n            }\\n            temp = temp.next;\\n        }\\n        return zero.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head;\\n        ListNode zero = new ListNode();\\n        ListNode res = zero;\\n        int z = 0;\\n        int sum = 0;\\n        while(temp != null) {\\n            if(temp.val == 0) {\\n                z++;\\n            } else {\\n                sum += temp.val;\\n            }\\n            if(z == 2) {\\n                res.next = new ListNode(sum);\\n                res = res.next;\\n                sum = 0;\\n                z = 1;\\n            }\\n            temp = temp.next;\\n        }\\n        return zero.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833344,
                "title": "simple-java-solution-and-explanation-in-very-simple-language",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved the question by using an extra linked list (dummy) and point it to using temp node. Then Traverse the linked list.\\n* when we found node value 0 then create new list node then connect it to temp node then shift temp to next node then assign again sum to 0.\\n* When sum is not 0 add the value of nodes with sum.\\n* We return dummy.next because in starting when we create dummy node we creates an extra node, so that\\'s why we skip first node of dummy linked list.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode temp = dummy;\\n        int sum = 0;\\n        head = head.next;\\n\\n        while(head != null){\\n            if(head.val == 0){\\n                ListNode n = new ListNode(sum);\\n                temp.next = n;\\n                temp = temp.next;\\n                sum = 0;\\n            }\\n            else\\n                sum += head.val;\\n\\n            head = head.next;\\n        }\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode temp = dummy;\\n        int sum = 0;\\n        head = head.next;\\n\\n        while(head != null){\\n            if(head.val == 0){\\n                ListNode n = new ListNode(sum);\\n                temp.next = n;\\n                temp = temp.next;\\n                sum = 0;\\n            }\\n            else\\n                sum += head.val;\\n\\n            head = head.next;\\n        }\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830429,
                "title": "simple-jugaad-nothing-rocket-science-easy-to-understand-for-freshers-noobs-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaking a dummy node and putting the address of my new node in it\\'s next part..AS SIMPLE AS THAT\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        ListNode ptr=dummy;\\n        int s=0;\\n        head=head.next;\\n        while(head!=null)\\n        {\\n            if(head.val==0)\\n            {\\n                ListNode res=new ListNode(s);\\n                ptr.next=res;\\n                ptr=ptr.next;\\n                s=0;\\n            }\\n            else\\n                s+=head.val;\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        ListNode ptr=dummy;\\n        int s=0;\\n        head=head.next;\\n        while(head!=null)\\n        {\\n            if(head.val==0)\\n            {\\n                ListNode res=new ListNode(s);\\n                ptr.next=res;\\n                ptr=ptr.next;\\n                s=0;\\n            }\\n            else\\n                s+=head.val;\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776612,
                "title": "easy-java-solution-clean-code-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int sum = 0;\\n        ListNode ans = temp;\\n        ListNode traverse = head.next;\\n\\n        while(traverse != null) {\\n            if(traverse.val == 0) {\\n                temp.next = new ListNode(sum);\\n                temp = temp.next;\\n                sum = 0;\\n            }\\n            else {\\n                sum += traverse.val;\\n            }\\n            traverse = traverse.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int sum = 0;\\n        ListNode ans = temp;\\n        ListNode traverse = head.next;\\n\\n        while(traverse != null) {\\n            if(traverse.val == 0) {\\n                temp.next = new ListNode(sum);\\n                temp = temp.next;\\n                sum = 0;\\n            }\\n            else {\\n                sum += traverse.val;\\n            }\\n            traverse = traverse.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762052,
                "title": "two-approaches-updating-same-list-creating-new-list-c",
                "content": "\\n# **UPDATING SAME LIST**\\n\\n\\n\\n    class Solution {\\n    public:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p=head;\\n        ListNode* q=p;\\n        int sum=0;\\n        head=head->next;\\n        while(head!=NULL){\\n            if(head->val==0){\\n                p=p->next;\\n                p->val=sum;\\n                sum=0;\\n            }\\n            else{\\n                sum+=head->val;\\n            }\\n            head=head->next;\\n        }\\n        p->next=NULL;\\n        return q->next;\\n      }\\n    };\\n\\t\\n\\t\\n\\t\\n# **CREATING NEW LIST**\\n\\n\\n    class Solution {\\n    public:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p=new ListNode(-1);\\n        ListNode* k=p;\\n        int sum=0;\\n        head=head->next;\\n        while(head!=NULL){\\n            if(head->val==0){\\n                ListNode* d=new ListNode(sum);\\n                p->next=d;\\n                p=p->next;\\n                sum=0;\\n            }\\n            else{\\n                sum+=head->val;\\n            }\\n            head=head->next;\\n        }\\n        return k->next;\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* p=head;\\n        ListNode* q=p;\\n        int sum=0;\\n        head=head->next;\\n        while(head!=NULL){\\n            if(head->val==0){\\n                p=p->next;\\n                p->val=sum;\\n                sum=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3563565,
                "title": "easy-java-solution-using-2-while-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head.next;\\n        ListNode zeroNode = new ListNode();\\n        int startPt = 1;\\n        ListNode ansTemp = zeroNode;\\n        while(temp != null) {\\n            int sum = 0;\\n            while(temp.val != 0) {\\n                sum += temp.val;\\n                temp = temp.next;\\n            }\\n            if(startPt==1) {\\n                zeroNode.val = sum;\\n                startPt=0;\\n            } else {\\n                zeroNode.next = new ListNode(sum);\\n                zeroNode = zeroNode.next;\\n            }\\n            temp = temp.next;\\n        }\\n        return ansTemp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head.next;\\n        ListNode zeroNode = new ListNode();\\n        int startPt = 1;\\n        ListNode ansTemp = zeroNode;\\n        while(temp != null) {\\n            int sum = 0;\\n            while(temp.val != 0) {\\n                sum += temp.val;\\n                temp = temp.next;\\n            }\\n            if(startPt==1) {\\n                zeroNode.val = sum;\\n                startPt=0;\\n            } else {\\n                zeroNode.next = new ListNode(sum);\\n                zeroNode = zeroNode.next;\\n            }\\n            temp = temp.next;\\n        }\\n        return ansTemp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549694,
                "title": "beats-80-c-super-simple-intuitive-approach",
                "content": "# Intuition\\nTo solve this problem fast, we need to only iterate through the list once. We have two options in how we can do this -> \\n1. Walk through list untill second zero is found, then add the previous values to that, or \\n2. Send a temporary pointer through the list to gather the values to add, then stop it at the next zero.\\n\\nGoing with the latter will be easier, because we can deal with pointers that are only being reassigned forward, and to nodes we have temporary pointers on.\\n\\n# Approach\\nWe walk through the list, and if the node we are on is a 0, we begin a new loop using the adder node. We walk that through the list, and break once we have found a second 0.\\n\\nOnce that happens, we have two cases -> \\n1. We are at the end of the list, and we check with adder->next->next. If so, we assign the temporary node (first zero) to point to a null pointer and return the list.\\n2. We have another section of integers to add. We then update the pointers of temp, pointing it to the second 0 (adder->next), and reassign temp to the last integer (adder). We then push temp forward one, to push it onto a zero value, allowing the inner loop to repeat again.\\n\\nWe are able to only walk through each element once, allowing us to keep a $$O(n)$$ runtime, and keep memory low with two pointers and an integer being stored.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n### If this solution helped you out, please leave a like! Have a good day :)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head; // pointer declarations\\n        ListNode* adder = temp;\\n        while(temp){ // outer while loop, should never finish\\n            if(temp->val == 0){ // if we are at a first 0\\n                adder = temp; // reassign adder\\n                int add = 0; // and declare a temporary int\\n                while(adder->next != 0){ // inner loop walks through list from same spot\\n                    adder = adder->next; // move adder\\n                    add = add + adder->val; // update adding sum\\n                    if(adder->next->val == 0){break;} // and break if we hit a second 0.\\n                } // now we have gotten the sum to add to the first 0, and adder at last non-zero; must determine if there are more ints to add:\\n                temp->val = temp->val + add; // update temp (first 0) to new value\\n                if(adder->next->next == nullptr){ // if this is the last set of numbers\\n                    temp->next = nullptr; // assign last element to point at nothing, and return the list\\n                    return head;\\n                }else{ // still another set, need to update pointers and start summing again\\n                    temp->next = adder->next; // point temp to the next 0\\n                    temp = adder; // move temp to last int\\n                    temp = temp->next; // push temp to the 0\\n                }\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head; // pointer declarations\\n        ListNode* adder = temp;\\n        while(temp){ // outer while loop, should never finish\\n            if(temp->val == 0){ // if we are at a first 0\\n                adder = temp; // reassign adder\\n                int add = 0; // and declare a temporary int\\n                while(adder->next != 0){ // inner loop walks through list from same spot\\n                    adder = adder->next; // move adder\\n                    add = add + adder->val; // update adding sum\\n                    if(adder->next->val == 0){break;} // and break if we hit a second 0.\\n                } // now we have gotten the sum to add to the first 0, and adder at last non-zero; must determine if there are more ints to add:\\n                temp->val = temp->val + add; // update temp (first 0) to new value\\n                if(adder->next->next == nullptr){ // if this is the last set of numbers\\n                    temp->next = nullptr; // assign last element to point at nothing, and return the list\\n                    return head;\\n                }else{ // still another set, need to update pointers and start summing again\\n                    temp->next = adder->next; // point temp to the next 0\\n                    temp = adder; // move temp to last int\\n                    temp = temp->next; // push temp to the 0\\n                }\\n            }\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441015,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = head.next;\\n        ListNode nn = new ListNode();\\n        head = nn;\\n\\n        int sum = 0;\\n        while(node != null) {\\n            if(node.val == 0) {\\n                nn.next = new ListNode(sum);\\n                nn = nn.next;\\n                sum = 0;\\n            } else {\\n                sum += node.val;\\n            }\\n            node = node.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode node = head.next;\\n        ListNode nn = new ListNode();\\n        head = nn;\\n\\n        int sum = 0;\\n        while(node != null) {\\n            if(node.val == 0) {\\n                nn.next = new ListNode(sum);\\n                nn = nn.next;\\n                sum = 0;\\n            } else {\\n                sum += node.val;\\n            }\\n            node = node.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291554,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func mergeNodes(_ head: ListNode?) -> ListNode? {\\n        \\n        var p = head?.next\\n        \\n        while let next = p?.next {\\n            if next.val != 0 {\\n                p?.val += next.val\\n                p?.next = next.next\\n            }\\n            else {\\n                p?.next = next.next\\n                p = p?.next\\n            }\\n        }\\n        \\n        return head?.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mergeNodes(_ head: ListNode?) -> ListNode? {\\n        \\n        var p = head?.next\\n        \\n        while let next = p?.next {\\n            if next.val != 0 {\\n                p?.val += next.val\\n                p?.next = next.next\\n            }\\n            else {\\n                p?.next = next.next\\n                p = p?.next\\n            }\\n        }\\n        \\n        return head?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263908,
                "title": "simple-pointers",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* h) {\\n        \\n        ListNode* h1;\\n        h1 = h;\\n        \\n        h1 = h1->next;\\n        ListNode* ans = h1;\\n                \\n        \\n        while(h1)\\n        {\\n            ListNode* t = h1;\\n            ListNode* f = h1;\\n            while(f->next && f->next->val!=0)\\n            {\\n                t->val += f->next->val;\\n                f = f->next;\\n            }\\n            if(f->next && f->next->val==0)\\n            {\\n                f = f->next;\\n                if(f)\\n                {\\n                 h1->next = f->next;   \\n                }\\n            }\\n            h1 = h1->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* h) {\\n        \\n        ListNode* h1;\\n        h1 = h;\\n        \\n        h1 = h1->next;\\n        ListNode* ans = h1;\\n                \\n        \\n        while(h1)\\n        {\\n            ListNode* t = h1;\\n            ListNode* f = h1;\\n            while(f->next && f->next->val!=0)\\n            {\\n                t->val += f->next->val;\\n                f = f->next;\\n            }\\n            if(f->next && f->next->val==0)\\n            {\\n                f = f->next;\\n                if(f)\\n                {\\n                 h1->next = f->next;   \\n                }\\n            }\\n            h1 = h1->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226855,
                "title": "python-simple-iterative",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = head\\n\\n        while head:\\n            # sum all non-zero nodes in zero node\\n            while head.next.val != 0:\\n                head.val += head.next.val\\n                head.next = head.next.next\\n            # remove last zero node\\n            if not head.next.next:\\n                head.next = None\\n            head = head.next\\n        \\n        return dummy\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = head\\n\\n        while head:\\n            # sum all non-zero nodes in zero node\\n            while head.next.val != 0:\\n                head.val += head.next.val\\n                head.next = head.next.next\\n            # remove last zero node\\n            if not head.next.next:\\n                head.next = None\\n            head = head.next\\n        \\n        return dummy\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223970,
                "title": "c-easy-to-understand-very-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp=head;\\n        int sum=0;\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* res=ans;\\n        while(temp->next){\\n            sum+=temp->val;\\n            temp=temp->next;\\n            if(temp->val==0){\\n                ans->next=new ListNode(sum);\\n                ans=ans->next;\\n                sum=0;\\n            }\\n        }\\n        ans->next=NULL;\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp=head;\\n        int sum=0;\\n        ListNode* ans=new ListNode(-1);\\n        ListNode* res=ans;\\n        while(temp->next){\\n            sum+=temp->val;\\n            temp=temp->next;\\n            if(temp->val==0){\\n                ans->next=new ListNode(sum);\\n                ans=ans->next;\\n                sum=0;\\n            }\\n        }\\n        ans->next=NULL;\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197059,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode MergeNodes(ListNode head) {\\n        ListNode ans=new();\\n        ListNode prev=new();\\n        ListNode result=ans;\\n        int tmp;\\n        while(head!=null){\\n            if(head.val==0){\\n                tmp=0;\\n                head=head.next;\\n                while(head.val!=0 ){\\n                    tmp+=head.val;\\n                    head=head.next;\\n                }\\n                ans.val=tmp;\\n                ans.next=new ListNode();\\n                prev=ans;\\n                ans=ans.next;\\n            }\\n            if(head.next==null)\\n                break;\\n        }\\n        prev.next=null;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode MergeNodes(ListNode head) {\\n        ListNode ans=new();\\n        ListNode prev=new();\\n        ListNode result=ans;\\n        int tmp;\\n        while(head!=null){\\n            if(head.val==0){\\n                tmp=0;\\n                head=head.next;\\n                while(head.val!=0 ){\\n                    tmp+=head.val;\\n                    head=head.next;\\n                }\\n                ans.val=tmp;\\n                ans.next=new ListNode();\\n                prev=ans;\\n                ans=ans.next;\\n            }\\n            if(head.next==null)\\n                break;\\n        }\\n        prev.next=null;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141560,
                "title": "c-easy-explaination",
                "content": "- Checking with the head first and if it is zero then move to head\\'s next.\\n- Taking two pointers pointing at head first and traversing both the pointers to take the sum of Nodes which are not Zero.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head->val==0)\\n        head=head->next;\\n        ListNode*t=head;\\n        ListNode*p=head;\\n        int sum=0;\\n        while(t){\\n        if(t->val!=0){ //doing sum if head->val is not 0\\n            sum+=t->val;\\n            t=t->next;\\n        }else{       \\n            p->val=sum;  //initialising sum again\\n            p->next=t->next;\\n            t=t->next;\\n            p=t;\\n            sum=0;\\n        }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head->val==0)\\n        head=head->next;\\n        ListNode*t=head;\\n        ListNode*p=head;\\n        int sum=0;\\n        while(t){\\n        if(t->val!=0){ //doing sum if head->val is not 0\\n            sum+=t->val;\\n            t=t->next;\\n        }else{       \\n            p->val=sum;  //initialising sum again\\n            p->next=t->next;\\n            t=t->next;\\n            p=t;\\n            sum=0;\\n        }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107864,
                "title": "respect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution\\n{\\n    public ListNode MergeNodes(ListNode head)\\n    {\\n        ListNode result = new ListNode(0);\\n        ListNode temp = result;\\n        int sum = 0;\\n        while(head != null)\\n        {\\n            sum += head.val;\\n            if(head.val == 0)\\n            {\\n                temp.next = new ListNode();\\n                temp = temp.next;\\n                temp.val = sum;\\n                sum = 0;\\n            }\\n            head = head.next;\\n        }\\n        return result.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution\\n{\\n    public ListNode MergeNodes(ListNode head)\\n    {\\n        ListNode result = new ListNode(0);\\n        ListNode temp = result;\\n        int sum = 0;\\n        while(head != null)\\n        {\\n            sum += head.val;\\n            if(head.val == 0)\\n            {\\n                temp.next = new ListNode();\\n                temp = temp.next;\\n                temp.val = sum;\\n                sum = 0;\\n            }\\n            head = head.next;\\n        }\\n        return result.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031541,
                "title": "simple-go-in-place-solution-in-one-run",
                "content": "# Intuition\\nWe probaly want to do it in place. So whenever we encounter node with next node with not 0 value we should add it to current node value and delete thet node. Also wee nedd to remove and jump forward when we find a node with 0 value.\\n\\n# Approach\\nAt first I tried to implement loop with current runner value, but after some test aproach with loop comparing incoming node value was better. It took less code to implement the loop as the :jumping\" over the zero value node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1) as we only need a pointer to one node\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc mergeNodes(head *ListNode) *ListNode {\\n    runner := head.Next\\n    for runner != nil {\\n      for runner.Next.Val != 0 {\\n        runner.Val += runner.Next.Val\\n        runner.Next = runner.Next.Next\\n      }\\n        runner.Next = runner.Next.Next\\n        runner = runner.Next\\n    }\\n    return head.Next\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc mergeNodes(head *ListNode) *ListNode {\\n    runner := head.Next\\n    for runner != nil {\\n      for runner.Next.Val != 0 {\\n        runner.Val += runner.Next.Val\\n        runner.Next = runner.Next.Next\\n      }\\n        runner.Next = runner.Next.Next\\n        runner = runner.Next\\n    }\\n    return head.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3023966,
                "title": "python-solution-using-while-loop",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = head\\n        temp = temp.next\\n        curr = head\\n        sum = 0\\n        while temp:\\n            if temp.val != 0:\\n                sum += temp.val\\n            else:\\n                curr = curr.next\\n                curr.val = sum\\n                sum = 0\\n            temp = temp.next\\n        curr.next = None\\n        return head.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = head\\n        temp = temp.next\\n        curr = head\\n        sum = 0\\n        while temp:\\n            if temp.val != 0:\\n                sum += temp.val\\n            else:\\n                curr = curr.next\\n                curr.val = sum\\n                sum = 0\\n            temp = temp.next\\n        curr.next = None\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944317,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->By Iterating on given linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode myNode=new ListNode(7);\\n        ListNode p=myNode;\\n        int sum=0;\\n        ListNode p1=head.next;\\n        while(p1!=null){\\n            sum+=(p1.val);\\n            if(p1.next.val==0){\\n                ListNode tmp=new ListNode(sum);\\n                p.next=tmp;\\n                p=p.next;\\n                sum=0;\\n                p1=p1.next;\\n            }\\n            p1=p1.next;\\n        }\\n        p.next=null;\\n        return myNode.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode myNode=new ListNode(7);\\n        ListNode p=myNode;\\n        int sum=0;\\n        ListNode p1=head.next;\\n        while(p1!=null){\\n            sum+=(p1.val);\\n            if(p1.next.val==0){\\n                ListNode tmp=new ListNode(sum);\\n                p.next=tmp;\\n                p=p.next;\\n                sum=0;\\n                p1=p1.next;\\n            }\\n            p1=p1.next;\\n        }\\n        p.next=null;\\n        return myNode.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898531,
                "title": "c-patching-non-zero-nodes-together-easy-to-understand",
                "content": "# Approach\\nStart with head node:\\n-> If **next** node have **non-zero value**, add it to current node and delete the **next** node\\n-> Else just delete the next node and **move forward** in the linked list to the **new next node**.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* itr = head;\\n        while(itr){\\n            if(itr->next->val != 0) {itr->val += itr->next->val; itr->next = itr->next->next;}\\n            else {itr->next = itr->next->next; itr = itr->next;}\\n        }\\n        return head;\\n    }\\n};\\n```\\nHope you will find it helpful...",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* itr = head;\\n        while(itr){\\n            if(itr->next->val != 0) {itr->val += itr->next->val; itr->next = itr->next->next;}\\n            else {itr->next = itr->next->next; itr = itr->next;}\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888777,
                "title": "simple-python-solution-upto-90-faster",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = 0\\n        final= []\\n        n = 0\\n        while(head.next):\\n            #print(temp)\\n            if head.val == 0:\\n                if temp != 0:\\n                    final.append(temp)\\n                    n+=1\\n                    temp =0\\n            else:\\n                temp += head.val  \\n            head = head.next\\n        \\n        temp += head.val\\n        if temp != 0:\\n            final.append(temp)\\n            n+=1\\n        \\n        nod = ListNode(final[-1])\\n        if n>1:\\n            for i in range(n-2,-1,-1):\\n                nod = ListNode(final[i],nod)\\n        return nod\\n        \\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = 0\\n        final= []\\n        n = 0\\n        while(head.next):\\n            #print(temp)\\n            if head.val == 0:\\n                if temp != 0:\\n                    final.append(temp)\\n                    n+=1\\n                    temp =0\\n            else:\\n                temp += head.val  \\n            head = head.next\\n        \\n        temp += head.val\\n        if temp != 0:\\n            final.append(temp)\\n            n+=1\\n        \\n        nod = ListNode(final[-1])\\n        if n>1:\\n            for i in range(n-2,-1,-1):\\n                nod = ListNode(final[i],nod)\\n        return nod\\n        \\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867525,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n    \\n    ListNode * stop=head;\\n            ListNode * farward =head->next;\\n        while(farward!=NULL)\\n        {\\n            if(farward->val!=0)\\n            {\\n                stop->val=stop->val + farward->val;\\n               \\n            }\\n            else\\n            {\\n                if(farward->next == NULL)\\n                {\\n                   stop->next=NULL; \\n                }\\n                else\\n                {\\n                   stop->next=farward;   \\n                }\\n             stop=farward; \\n            }\\n            \\n            farward=farward->next;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n    \\n    ListNode * stop=head;\\n            ListNode * farward =head->next;\\n        while(farward!=NULL)\\n        {\\n            if(farward->val!=0)\\n            {\\n                stop->val=stop->val + farward->val;\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2778867,
                "title": "python-99-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n        head1 = head\\n        head2 = head.next\\n        result = 0\\n        while head2:\\n            if head2.val == 0:\\n                head1 = head1.next\\n                head1.val = result\\n                result = 0\\n            else:\\n                result += head2.val\\n            head2 = head2.next\\n        head1.next=None\\n        return head.next\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n        head1 = head\\n        head2 = head.next\\n        result = 0\\n        while head2:\\n            if head2.val == 0:\\n                head1 = head1.next\\n                head1.val = result\\n                result = 0\\n            else:\\n                result += head2.val\\n            head2 = head2.next\\n        head1.next=None\\n        return head.next\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698348,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        //ans is a ListNode stores the values that are in between zero\\'s will be merged up\\n        ListNode ans = new ListNode(0);\\n        //temp2 is dummy variable points to ans\\n        ListNode temp2 = ans;\\n        //Since in description they have said first node and last consist of zero\\n        //Then skip the first node\\n        head = head.next;\\n        \\n        int sum = 0;\\n        \\n        while(head!=null){\\n            //If the value of the node is not null then add it to the sum\\n           if(head.val!=0){\\n               sum += head.val;\\n               head = head.next;\\n              \\n           }\\n            //if value of the node is zero then add present sum to the end of temp2\\n            //make sure to put sum = 0\\n            else if(head.val == 0){\\n                \\n                temp2.next = new ListNode(sum);\\n                temp2 = temp2.next;\\n                sum = 0;\\n                head = head.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n//Time Complexity is O(n) n->size of the list\\n//Space Complexity is O(n) \\n//Please UpVote if you liked it!\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        //ans is a ListNode stores the values that are in between zero\\'s will be merged up\\n        ListNode ans = new ListNode(0);\\n        //temp2 is dummy variable points to ans\\n        ListNode temp2 = ans;\\n        //Since in description they have said first node and last consist of zero\\n        //Then skip the first node\\n        head = head.next;\\n        \\n        int sum = 0;\\n        \\n        while(head!=null){\\n            //If the value of the node is not null then add it to the sum\\n           if(head.val!=0){\\n               sum += head.val;\\n               head = head.next;\\n              \\n           }\\n            //if value of the node is zero then add present sum to the end of temp2\\n            //make sure to put sum = 0\\n            else if(head.val == 0){\\n                \\n                temp2.next = new ListNode(sum);\\n                temp2 = temp2.next;\\n                sum = 0;\\n                head = head.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n//Time Complexity is O(n) n->size of the list\\n//Space Complexity is O(n) \\n//Please UpVote if you liked it!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670911,
                "title": "java-solution",
                "content": "# Intuition\\nWe are sure that the length of the linked list is atleast 3 because the constraints make it clear. So we can as well start summing up the nonzero values from head.next onwards. Then it just becomes a matter of checking if the list nodes contain 0 or any other value. \\n\\n# Approach\\nSo, I\\'ve started creating a new result list. I traverse through the input linked list checking whether the node has 0 or non zero value. I keep adding the node.val until I encounter a 0 containing node, create a node and set node.val as the resultant sum. If I encounter 0 in this process then I move my result list pointer to the next node and then continue summing until I encounter another 0. This process is repeated till the length of the input list and the head of the result list is returned.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head.next;\\n        ListNode newHead = new ListNode(0);\\n        ListNode result = newHead;\\n        while(temp.next != null) {\\n            if(temp.val != 0) {\\n                newHead.val += temp.val;\\n            } else {\\n                newHead = newHead.next = new ListNode(0);\\n            }\\n            temp = temp.next;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head.next;\\n        ListNode newHead = new ListNode(0);\\n        ListNode result = newHead;\\n        while(temp.next != null) {\\n            if(temp.val != 0) {\\n                newHead.val += temp.val;\\n            } else {\\n                newHead = newHead.next = new ListNode(0);\\n            }\\n            temp = temp.next;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634639,
                "title": "very-very-easy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic ListNode mergeNodes(ListNode head) {\\n        \\n        \\n\\t\\t\\tif(head.next.next == null){\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\tListNode ptr=head.next;\\n\\t\\t\\twhile(ptr != null){\\n\\t\\t\\t\\twhile(ptr.next.val != 0){\\n\\t\\t\\t\\t\\tptr.val+=ptr.next.val;\\n\\t\\t\\t\\t\\tptr.next=ptr.next.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ptr.next.val == 0){\\n\\t\\t\\t\\t\\tptr.next=ptr.next.next;\\n\\t\\t\\t\\t\\tptr=ptr.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn head.next;\\n\\t\\t} \\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic ListNode mergeNodes(ListNode head) {\\n        \\n        \\n\\t\\t\\tif(head.next.next == null){\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2618610,
                "title": "c-easy-to-understand-two-pointer-method-which-80-soln-by-time",
                "content": "```\\n/* Create two pointer s and f which will provide the range of nodes\\nto be included as sum of their value in the modified list and keep \\ns and f till f reaches the end of the original list*/\\nListNode* mergeNodes(ListNode* head) {\\n        ListNode *h = new ListNode(-1);\\n        ListNode *t = h;\\n        ListNode *s = head, *f = head->next;\\n        while(f){\\n            int sum=0;\\n            while(f->val!=0){\\n                sum+=f->val;\\n                f=f->next;\\n            }\\n            ListNode *n = new ListNode(sum);\\n            t -> next = n;\\n            t = n;\\n            s = f;\\n            f=f->next;\\n        }\\n        return h->next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/* Create two pointer s and f which will provide the range of nodes\\nto be included as sum of their value in the modified list and keep \\ns and f till f reaches the end of the original list*/\\nListNode* mergeNodes(ListNode* head) {\\n        ListNode *h = new ListNode(-1);\\n        ListNode *t = h;\\n        ListNode *s = head, *f = head->next;\\n        while(f){\\n            int sum=0;\\n            while(f->val!=0){\\n                sum+=f->val;\\n                f=f->next;\\n            }\\n            ListNode *n = new ListNode(sum);\\n            t -> next = n;\\n            t = n;\\n            s = f;\\n            f=f->next;\\n        }\\n        return h->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2597046,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        \\n\\t\\tstruct ListNode * sum=new ListNode(); //create a Linked list to store the sum between zeros\\n        struct ListNode * temp=sum;   // for the link of the val in linked list create a temp node\\n        head=head->next; // first node of the given linked list start with 0 so move forward one step\\n        int s=0;  //store the sum\\n        while(head!=NULL){  \\n            if(head->val==0){  \\n                temp->next=new ListNode(s);\\n                temp=temp->next;\\n                s=0;\\n            }\\n            s+=head->val;\\n            head=head->next;\\n        }\\n        head=sum->next;\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        \\n\\t\\tstruct ListNode * sum=new ListNode(); //create a Linked list to store the sum between zeros\\n        struct ListNode * temp=sum;   // for the link of the val in linked list create a temp node\\n        head=head->next; // first node of the given linked list start with 0 so move forward one step\\n        int s=0;  //store the sum\\n        while(head!=NULL){  \\n            if(head->val==0){  \\n                temp->next=new ListNode(s);\\n                temp=temp->next;\\n                s=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2585900,
                "title": "btw-this-is-the-1000th-discussion-post",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        vector<int>v;int temp=0;\\n        while(head){\\n            if(head->val!=0){\\n                temp+=head->val;\\n            }\\n            else if(temp!=0){\\n                v.push_back(temp);\\n                temp=0;\\n            }\\n            head=head->next;\\n        }\\n        ListNode *root=new ListNode(v[0]),*l1=root,*l2=nullptr;\\n        for(int i=1;i<v.size();i++){\\n            l2=new ListNode(v[i]);\\n            root->next=l2;\\n            root=root->next;\\n        }\\n        return l1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/12569ebf-1084-49d6-a042-c13134330cb0_1663392641.7128615.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        vector<int>v;int temp=0;\\n        while(head){\\n            if(head->val!=0){\\n                temp+=head->val;\\n            }\\n            else if(temp!=0){\\n                v.push_back(temp);\\n                temp=0;\\n            }\\n            head=head->next;\\n        }\\n        ListNode *root=new ListNode(v[0]),*l1=root,*l2=nullptr;\\n        for(int i=1;i<v.size();i++){\\n            l2=new ListNode(v[i]);\\n            root->next=l2;\\n            root=root->next;\\n        }\\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567726,
                "title": "java-simple-and-small-code",
                "content": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode ans = new ListNode(-1);\\n        ListNode t = ans;\\n        ListNode temp = head.next;\\n        int sum = 0;\\n        while(temp != null){\\n            if(temp.val != 0){\\n                sum += temp.val;\\n            }\\n            else{\\n                t.next = new ListNode(sum);\\n                t = t.next; \\n                sum = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode ans = new ListNode(-1);\\n        ListNode t = ans;\\n        ListNode temp = head.next;\\n        int sum = 0;\\n        while(temp != null){\\n            if(temp.val != 0){\\n                sum += temp.val;\\n            }\\n            else{\\n                t.next = new ListNode(sum);\\n                t = t.next; \\n                sum = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561623,
                "title": "scala-easy-solution-explained",
                "content": "```\\n\\n    def mergeNodes(head: ListNode): ListNode = {\\n        merge(head.next, 0)\\n    }\\n    \\n    \\n    def merge(node: ListNode, carryOn: Int): ListNode = {\\n        if (node == null) {\\n            null\\n        } else {\\n            if (node.x == 0) {\\n                ListNode(carryOn, merge(node.next, 0))\\n            } else {\\n                merge(node.next, carryOn + node.x)\\n            }\\n        }\\n    }\\n```\\n\\n\\nexample process\\ngiven input head = [0,3,1,0,4,5,2,0]\\nmerge non zero nodes\\n\\nthis needs a recursion solution. \\nWe only have a handle on a single node with the movement happening through the link \\'next\\' to the next one, and next one, and so on. So we can solve it by focusing on a single node and use to build a memory of info we need from nodes we\\'ve already passed. Also we don\\'t know anything about the upcoming nodes until we actually .next into them. E.g. on iteration three we only know about the node 3 and basically could just pass forward a list of nodes we\\'ve passed and then operate on that, but it\\'d be excessive. Just passing a carry on value and adding to it and resetting it to zero where appropriate would be better. \\n\\nsteps for the example above:\\n1. look at 0 => special case. We know it\\'ll be zero always and we don\\'t want a zero in the output. So we just ignore it by immediatelly calling head.next for the first iteration. And just set the initial carry on value (where the sums will be gathered, then cleaned after next zero, etc) to 0. `merge(head.next, 0)` \\n2. look at 3 => we don\\'t want to create this as a node in output, but we do need this as an input when we move forward to the next one. So we carry it on without creating any new ListNode objects (`merge(node.next, carryOn + node.x)`). (carryOn then is 0+3=3)\\n3. look at 1 => identical to previous step, except now we have incoming carryOn (value 3), so we\\'ll at it to the existing carryOn.  (`merge(node.next, carryOn + node.x)`) (carryOn then is 3+1=4)\\n4. look at 0 => we know that at this point we have a full carryOn with us and we can create a new object in the output array. But we also need to continue iterating, so at this step we also need to make sure to call the recursion function again in a different way, and this time setting the carryOn back to 0. `ListNode(carryOn, merge(node.next, 0))` - creates new object to the output, sets the carryOn as the node value (total sum between this and a previous zero, here 4) and sets the next node as the recursion function which will provide the next node in due time. \\n5. ...next steps the same way as above...\\n6. once the array has been passed in full, we also need a way to terminate it. As we still need the last item in the array to be operated on, we\\'ll continue normally at the last iteration and still pass the .next. This is of course null and we\\'ll create a null check at the beginning of the recursion function to terminate. `if (node == null) {return null}`",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n    def mergeNodes(head: ListNode): ListNode = {\\n        merge(head.next, 0)\\n    }\\n    \\n    \\n    def merge(node: ListNode, carryOn: Int): ListNode = {\\n        if (node == null) {\\n            null\\n        } else {\\n            if (node.x == 0) {\\n                ListNode(carryOn, merge(node.next, 0))\\n            } else {\\n                merge(node.next, carryOn + node.x)\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2553961,
                "title": "easy-hai-bro-just-give-it-a-view-you-got-this-buddy",
                "content": "ListNode* dummy= new ListNode(0);\\n       ListNode* dummyp=dummy;\\n       ListNode* temp=head->next;;\\n        int sum=0;\\n        while(temp!=NULL)\\n        {   sum=0;\\n            while(temp->val!=0)\\n            {\\n                sum=sum+temp->val;\\n                temp=temp->next;\\n            }\\n           ListNode* store= new ListNode(sum);\\n           dummyp->next=store;\\n           dummyp=store;\\n         temp=temp->next;\\n         \\n         \\n        }\\n        return dummy->next;",
                "solutionTags": [],
                "code": "ListNode* dummy= new ListNode(0);\\n       ListNode* dummyp=dummy;\\n       ListNode* temp=head->next;;\\n        int sum=0;\\n        while(temp!=NULL)\\n        {   sum=0;\\n            while(temp->val!=0)\\n            {\\n                sum=sum+temp->val;\\n                temp=temp->next;\\n            }\\n           ListNode* store= new ListNode(sum);\\n           dummyp->next=store;\\n           dummyp=store;\\n         temp=temp->next;\\n         \\n         \\n        }\\n        return dummy->next;",
                "codeTag": "Unknown"
            },
            {
                "id": 2553185,
                "title": "one-pass-c-solution",
                "content": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *start=head,*prev=head;;\\n        int sum=0;\\n        start=head->next;\\n        while(start!=NULL)\\n        {\\n            if(start->val==0)\\n            {\\n               start->val=sum;\\n                prev->next=start;\\n                prev=start;\\n                sum=0;\\n            }\\n            else\\n                sum=sum+start->val;\\n            start=start->next;\\n        }\\n        prev->next=NULL;\\n        return head->next;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *start=head,*prev=head;;\\n        int sum=0;\\n        start=head->next;\\n        while(start!=NULL)\\n        {\\n            if(start->val==0)\\n            {\\n               start->val=sum;\\n                prev->next=start;\\n                prev=start;\\n                sum=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2552253,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* dummyNode = new ListNode(); // created a dummy node for making the new linked list for returning the answer\\n        ListNode* dummyPointer = dummyNode;\\n        ListNode* temp = head -> next;\\n        \\n        while(temp != NULL){\\n            int sum = 0;\\n            while(temp -> val != 0){\\n                sum += temp -> val;\\n                temp = temp -> next;\\n            }\\n            dummyPointer -> next = new ListNode(sum);\\n            dummyPointer = dummyPointer -> next;\\n            temp = temp -> next;\\n        }\\n        return dummyNode -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* dummyNode = new ListNode(); // created a dummy node for making the new linked list for returning the answer\\n        ListNode* dummyPointer = dummyNode;\\n        ListNode* temp = head -> next;\\n        \\n        while(temp != NULL){\\n            int sum = 0;\\n            while(temp -> val != 0){\\n                sum += temp -> val;\\n                temp = temp -> next;\\n            }\\n            dummyPointer -> next = new ListNode(sum);\\n            dummyPointer = dummyPointer -> next;\\n            temp = temp -> next;\\n        }\\n        return dummyNode -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544761,
                "title": "java-solution-easy-to-understand-simple-code",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode h = null, t = h;\\n\\n        ListNode temp = head;\\n        int sum = 0;\\n        while (temp != null) {\\n            if (temp.val == 0) {\\n                if (sum == 0) {\\n                    temp = temp.next;\\n                    continue;\\n                }\\n                if (h == null) {\\n                    h = new ListNode(sum);\\n                    h.next = null;\\n                    t = h;\\n                    sum = 0;\\n                    continue;\\n                }\\n                ListNode node = new ListNode(sum);\\n                t.next = node;\\n                t = node;\\n                sum = 0;\\n            }\\n            else sum += temp.val;\\n            temp = temp.next;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode h = null, t = h;\\n\\n        ListNode temp = head;\\n        int sum = 0;\\n        while (temp != null) {\\n            if (temp.val == 0) {\\n                if (sum == 0) {\\n                    temp = temp.next;\\n                    continue;\\n                }\\n                if (h == null) {\\n                    h = new ListNode(sum);\\n                    h.next = null;\\n                    t = h;\\n                    sum = 0;\\n                    continue;\\n                }\\n                ListNode node = new ListNode(sum);\\n                t.next = node;\\n                t = node;\\n                sum = 0;\\n            }\\n            else sum += temp.val;\\n            temp = temp.next;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541543,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    ListNode newHead = new ListNode(),temp = newHead;\\n    public ListNode mergeNodes(ListNode head) {\\n        head = head.next;\\n        int sum = 0;\\n        while(head!=null)\\n        {\\n            if(head.val == 0){\\n                temp.next = new ListNode(sum);\\n                temp = temp.next;\\n                sum = 0;\\n            }\\n            else\\n                sum+=head.val;\\n            head = head.next;\\n        }\\n        return newHead.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    ListNode newHead = new ListNode(),temp = newHead;\\n    public ListNode mergeNodes(ListNode head) {\\n        head = head.next;\\n        int sum = 0;\\n        while(head!=null)\\n        {\\n            if(head.val == 0){\\n                temp.next = new ListNode(sum);\\n                temp = temp.next;\\n                sum = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2526355,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head->val==0)head=head->next;\\n        ListNode* prev=head;\\n        ListNode* temp=head;\\n        int sum=0;\\n        while(temp){\\n            if(temp->val!=0){\\n                sum=sum+temp->val;\\n                temp=temp->next;\\n            }\\n            else{\\n                prev->val=sum;\\n                prev->next=temp->next;\\n                temp=temp->next;\\n                prev=temp;\\n                sum=0;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        if(head->val==0)head=head->next;\\n        ListNode* prev=head;\\n        ListNode* temp=head;\\n        int sum=0;\\n        while(temp){\\n            if(temp->val!=0){\\n                sum=sum+temp->val;\\n                temp=temp->next;\\n            }\\n            else{\\n                prev->val=sum;\\n                prev->next=temp->next;\\n                temp=temp->next;\\n                prev=temp;\\n                sum=0;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526263,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nIF YOU DON\\'T UNDERSTAND, JUST LEAVE A COMMENT AND I\\'LL  EXPLAIN THE SOLUTION TO YOU \\n```\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* ans = new ListNode(0);\\n        ListNode* ptr =  ans; \\n        int currSum = 0 ;\\n        while (head!= nullptr)\\n        {\\n            if (head->val != 0 )\\n            {\\n                currSum += head->val;\\n            }\\n            else \\n            {\\n              ptr->next = new ListNode(currSum);\\n              ptr = ptr->next;\\n              currSum =0 ;\\n            }\\n            head = head->next;\\n        }\\n        return ans->next->next;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nIF YOU DON\\'T UNDERSTAND, JUST LEAVE A COMMENT AND I\\'LL  EXPLAIN THE SOLUTION TO YOU \\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* ans = new ListNode(0);\\n        ListNode* ptr =  ans; \\n        int currSum = 0 ;\\n        while (head!= nullptr)\\n        {\\n            if (head->val != 0 )\\n            {\\n                currSum += head->val;\\n            }\\n            else \\n            {\\n              ptr->next = new ListNode(currSum);\\n              ptr = ptr->next;\\n              currSum =0 ;\\n            }\\n            head = head->next;\\n        }\\n        return ans->next->next;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520909,
                "title": "c-linked-list-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *dummy = new ListNode(0);\\n        ListNode *temp = dummy;\\n        int sum = 0;\\n        while(head)\\n        {\\n            if(head -> val == 0)\\n            {\\n                head = head -> next;\\n                sum = 0;\\n            }\\n            else\\n            {\\n                while(head -> val != 0)\\n                {\\n                    sum += head -> val;\\n                    head = head -> next;\\n                }\\n                temp -> next = new ListNode(sum);\\n                temp = temp -> next;\\n            }\\n        }\\n        return dummy-> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *dummy = new ListNode(0);\\n        ListNode *temp = dummy;\\n        int sum = 0;\\n        while(head)\\n        {\\n            if(head -> val == 0)\\n            {\\n                head = head -> next;\\n                sum = 0;\\n            }\\n            else\\n            {\\n                while(head -> val != 0)\\n                {\\n                    sum += head -> val;\\n                    head = head -> next;\\n                }\\n                temp -> next = new ListNode(sum);\\n                temp = temp -> next;\\n            }\\n        }\\n        return dummy-> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505660,
                "title": "c-visual-explanation-shortest-solution-o-n",
                "content": "We are holding current 0 node with currentZero variable. And if value of visited node(iter) not zero, we adding its value to currentZero. When see another zero we make the new zero node next of currentZero, and currentZero be new zero node too.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *iter = head->next, *currentZero = head;\\n        \\n        while(iter->next != NULL)\\n        {\\n            if(iter->val == 0)\\n                currentZero = currentZero->next = iter;\\n            else\\n                currentZero->val += iter->val;\\n            \\n            iter = iter->next;\\n        }\\n        \\n        currentZero -> next = NULL;\\n        return head;\\n    }\\n};\\n```\\n\\n***\\n\\n![image](https://assets.leetcode.com/users/images/7c699ff3-dec8-4c4d-9b05-28ea8e1ba666_1661873668.6344547.png)\\n\\n**set next of currentZero to founded zero\\nthen\\nset currentZero to founded zero**\\n\\n![image](https://assets.leetcode.com/users/images/53a36307-2015-46b7-9ecb-2f8485b8639d_1661966491.3570447.png)\\n \\n\\n\\n***\\n\\n![image](https://assets.leetcode.com/users/images/dcffb02b-2da8-4930-bd15-d2f3d33f0432_1668439347.2554092.png)\\n\\n\\n\\n\\n\\n**next of iter is NULL so it stopped the loop, but the last state of the list is as above, so we make null next of currentZero**\\n***\\n**The result is as below**\\n![image](https://assets.leetcode.com/users/images/611f4471-3d2c-4d98-b5a9-9a563df8ec08_1661874516.866114.png)\\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *iter = head->next, *currentZero = head;\\n        \\n        while(iter->next != NULL)\\n        {\\n            if(iter->val == 0)\\n                currentZero = currentZero->next = iter;\\n            else\\n                currentZero->val += iter->val;\\n            \\n            iter = iter->next;\\n        }\\n        \\n        currentZero -> next = NULL;\\n        return head;\\n    }\\n};\\n```\n```\\nbool shouldYouUpvote() { return (I helped == true) ? upvote : nothing; }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501148,
                "title": "java-simple-o-n",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n      var curr = head;\\n      var dummyHead = new ListNode(0);\\n      var resCurr = dummyHead;\\n\\n      while (curr.next != null) {\\n        var tmp = curr.next;\\n        var sum = 0;\\n\\n        while (tmp.val != 0) {\\n          sum += tmp.val;\\n          tmp = tmp.next;\\n        }\\n\\n        curr = tmp;\\n        resCurr.next = new ListNode(sum);\\n        resCurr = resCurr.next;\\n      }\\n\\n      return dummyHead.next;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n      var curr = head;\\n      var dummyHead = new ListNode(0);\\n      var resCurr = dummyHead;\\n\\n      while (curr.next != null) {\\n        var tmp = curr.next;\\n        var sum = 0;\\n\\n        while (tmp.val != 0) {\\n          sum += tmp.val;\\n          tmp = tmp.next;\\n        }\\n\\n        curr = tmp;\\n        resCurr.next = new ListNode(sum);\\n        resCurr = resCurr.next;\\n      }\\n\\n      return dummyHead.next;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472571,
                "title": "almighty-c-easy-solution-folloow-up",
                "content": "**Upvote it**\\n\\n```\\nListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n      \\n        while(temp!=NULL){\\n            int sum = 0;\\n            ListNode* prev = temp;\\n            \\n            while(prev!=NULL && prev->val !=0){\\n                sum+=prev->val;\\n                prev=prev->next;\\n            }\\n            temp->next = prev->next;\\n            temp->val = sum;\\n            temp=temp->next;\\n        }\\n        \\n        return head->next;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n      \\n        while(temp!=NULL){\\n            int sum = 0;\\n            ListNode* prev = temp;\\n            \\n            while(prev!=NULL && prev->val !=0){\\n                sum+=prev->val;\\n                prev=prev->next;\\n            }\\n            temp->next = prev->next;\\n            temp->val = sum;\\n            temp=temp->next;\\n        }\\n        \\n        return head->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2471792,
                "title": "easy-c-solution",
                "content": "\\n\\n        ListNode* mergeNodes(ListNode* head) {\\n\\n        head  = head->next;\\n        \\n        ListNode* p = head;\\n        \\n        while(p){\\n            ListNode* end = p;\\n            int sum = 0;\\n            while(end->val != 0){\\n                sum+= end->val;\\n                end = end->next;\\n            }\\n            \\n            p->val = sum;\\n            \\n            p->next = end->next;\\n            \\n            p = p->next;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n        ListNode* mergeNodes(ListNode* head) {\\n\\n        head  = head->next;\\n        \\n        ListNode* p = head;\\n        \\n        while(p){\\n            ListNode* end = p;\\n            int sum = 0;\\n            while(end->val != 0){\\n                sum+= end->val;\\n                end = end->next;\\n            }\\n            \\n            p->val = sum;\\n            \\n            p->next = end->next;\\n            \\n            p = p->next;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2469895,
                "title": "python-fast-and-easy-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        temp = head\\n        zero = head\\n        if temp.next is None:\\n            return\\n        temp = temp.next\\n        sm=0\\n        while(temp):            \\n            if temp.val !=0:\\n                sm+=temp.val\\n                temp = temp.next\\n            else:\\n                temp.val = sm\\n                sm =0\\n                zero.next = temp\\n                zero = temp\\n                temp = temp.next\\n                \\n        return head.next \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        temp = head\\n        zero = head\\n        if temp.next is None:\\n            return\\n        temp = temp.next\\n        sm=0\\n        while(temp):            \\n            if temp.val !=0:\\n                sm+=temp.val\\n                temp = temp.next\\n            else:\\n                temp.val = sm\\n                sm =0\\n                zero.next = temp\\n                zero = temp\\n                temp = temp.next\\n                \\n        return head.next \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440489,
                "title": "c-easy-to-understand-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n     head=head->next;\\n     ListNode* ptr=head;\\n        \\n     while(ptr){\\n\\t    ListNode* end= ptr;  \\n        int sum=0;\\n        while(end->val!=0){\\n            sum+= end->val;\\n            end=end->next;\\n        }\\n        ptr->val=sum; \\n        ptr->next=end->next;   \\n        ptr=ptr->next;    \\n\\t }\\n     return head;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n     head=head->next;\\n     ListNode* ptr=head;\\n        \\n     while(ptr){\\n\\t    ListNode* end= ptr;  \\n        int sum=0;\\n        while(end->val!=0){\\n            sum+= end->val;\\n            end=end->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2439160,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n     \\n\\t ListNode temp = head;\\n        while(temp!=null){    \\n            if(temp.next.val!=0){\\n                temp.val = temp.val+temp.next.val;\\n                temp.next = temp.next.next;\\n            }else{\\n                temp.next = temp.next.next;\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n     \\n\\t ListNode temp = head;\\n        while(temp!=null){    \\n            if(temp.next.val!=0){\\n                temp.val = temp.val+temp.next.val;\\n                temp.next = temp.next.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2420758,
                "title": "easy-to-understand-java-code-87-faster",
                "content": "**Do Upvote!!**\\n```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head.next;\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode node = dummyHead;\\n        while(temp != null){\\n            if(temp.val == 0 && temp.next == null){\\n                node.next = null;\\n                break;\\n            }\\n            if(temp.val == 0){\\n                ListNode newnode = new ListNode(0);\\n                node.next = newnode;\\n                node = newnode;\\n            }else{\\n                node.val += temp.val;\\n            }\\n            temp = temp.next;\\n        }\\n        return dummyHead;\\n    }\\n}\\n```\\n# upvote",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode temp = head.next;\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode node = dummyHead;\\n        while(temp != null){\\n            if(temp.val == 0 && temp.next == null){\\n                node.next = null;\\n                break;\\n            }\\n            if(temp.val == 0){\\n                ListNode newnode = new ListNode(0);\\n                node.next = newnode;\\n                node = newnode;\\n            }else{\\n                node.val += temp.val;\\n            }\\n            temp = temp.next;\\n        }\\n        return dummyHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374870,
                "title": "easy-cpp-beginner-s-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *prev,*curr,*preprev;\\n        int sum=0;\\n        preprev=NULL;\\n        prev=head;\\n        curr=head;\\n        while(curr!=NULL)\\n        { \\n            if(curr->val==0 and curr!=head)\\n            {\\n                preprev=prev;\\n                prev->val=sum;\\n                sum=0;\\n                prev=prev->next;\\n            }\\n            else\\n            {\\n                sum+=curr->val;\\n            }\\n            curr=curr->next;\\n        }\\n        preprev->next=NULL;\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode *prev,*curr,*preprev;\\n        int sum=0;\\n        preprev=NULL;\\n        prev=head;\\n        curr=head;\\n        while(curr!=NULL)\\n        { \\n            if(curr->val==0 and curr!=head)\\n            {\\n                preprev=prev;\\n                prev->val=sum;\\n                sum=0;\\n                prev=prev->next;\\n            }\\n            else\\n            {\\n                sum+=curr->val;\\n            }\\n            curr=curr->next;\\n        }\\n        preprev->next=NULL;\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343424,
                "title": "most-easiest-solution-cpp-faster-than-97",
                "content": "ListNode* mergeNodes(ListNode* head) {\\n         \\n        ListNode* temp = head;\\n        ListNode* finale = temp;\\n        int ans=0;\\n        while(head ){\\n            \\n            ans += head->val;\\n            \\n            if(head->val==0){\\n                temp->val=ans;\\n               if(head->next==NULL){\\n                    break;\\n                }\\n                temp=temp->next;\\n\\n                ans=0;\\n            }\\n            \\n            \\n          head=head->next; \\n        }\\n    \\n     temp->next = NULL;\\n        \\n        return finale->next;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "ListNode* mergeNodes(ListNode* head) {\\n         \\n        ListNode* temp = head;\\n        ListNode* finale = temp;\\n        int ans=0;\\n        while(head ){\\n            \\n            ans += head->val;\\n            \\n            if(head->val==0){\\n                temp->val=ans;\\n               if(head->next==NULL){\\n                    break;\\n                }\\n                temp=temp->next;\\n\\n                ans=0;\\n            }\\n            \\n            \\n          head=head->next; \\n        }\\n    \\n     temp->next = NULL;\\n        \\n        return finale->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2328055,
                "title": "python-simple-simulation",
                "content": "\\n    def mergeNodes(self, head):\\n        cur, total = head.next, 0\\n        \\n        r1 = r2 = ListNode()\\n        \\n        while cur:\\n            if cur.val == 0:\\n                r1.next = ListNode(total)\\n                r1 = r1.next\\n                total = 0\\n            else:\\n                total += cur.val\\n                \\n            cur = cur.next\\n            \\n        return r2.next",
                "solutionTags": [],
                "code": "\\n    def mergeNodes(self, head):\\n        cur, total = head.next, 0\\n        \\n        r1 = r2 = ListNode()\\n        \\n        while cur:\\n            if cur.val == 0:\\n                r1.next = ListNode(total)\\n                r1 = r1.next\\n                total = 0\\n            else:\\n                total += cur.val\\n                \\n            cur = cur.next\\n            \\n        return r2.next",
                "codeTag": "Python3"
            },
            {
                "id": 2313797,
                "title": "easy-java-solution",
                "content": "\\'\\'\\'\\n\\n    public ListNode mergeNodes(ListNode head) {\\n        \\n        ListNode result = new ListNode();\\n        ListNode res = result;\\n        head = head.next;\\n        while(head.next != null){\\n            if(head.val != 0)\\n                res.val += head.val;\\n            else{\\n                res.next = new ListNode();\\n                res = res.next;\\n            }\\n            head = head.next;\\n        }\\n        return result;\\n        \\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    public ListNode mergeNodes(ListNode head) {\\n        \\n        ListNode result = new ListNode();\\n        ListNode res = result;\\n        head = head.next;\\n        while(head.next != null){\\n            if(head.val != 0)\\n                res.val += head.val;\\n            else{\\n                res.next = new ListNode();\\n                res = res.next;\\n            }\\n            head = head.next;\\n        }\\n        return result;\\n        \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2306881,
                "title": "simple-iterative-one-pass-solution-o-n",
                "content": "Intuition : Iterate trough the list keeping track of the sum of all nodes that are not zero, If the node has value 0 create a new node with the calculated running sum and update sum to zero.\\n\\n```\\n// Time Complexity : O(n)\\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode sentinial = new ListNode(0);\\n        ListNode cur = sentinial;\\n        int sum = 0;\\n        while(head != null){\\n            if(head.val == 0 && sum != 0) {\\n                ListNode newNode = new ListNode(sum);\\n                sum = 0;\\n                cur.next = newNode;\\n                cur = cur.next;\\n            }else{\\n                sum += head.val;\\n            }\\n            head = head.next;\\n        }\\n        return sentinial.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode sentinial = new ListNode(0);\\n        ListNode cur = sentinial;\\n        int sum = 0;\\n        while(head != null){\\n            if(head.val == 0 && sum != 0) {\\n                ListNode newNode = new ListNode(sum);\\n                sum = 0;\\n                cur.next = newNode;\\n                cur = cur.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2299852,
                "title": "python-easy-o-n-solution",
                "content": "```\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n    \\n        temp = head.next \\n        temp1 = None\\n        slow = head\\n\\n        sums = 0 \\n        \\n        while temp != None :\\n            \\n            \\n            if temp.val != 0 :\\n                \\n                sums += temp.val \\n                \\n            elif temp.val == 0 :\\n                \\n                slow.val = sums \\n                temp1 = slow\\n                slow = slow.next \\n                sums = 0 \\n                \\n            temp = temp.next \\n            \\n        temp1.next = None\\n        return head \\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n    \\n        temp = head.next \\n        temp1 = None\\n        slow = head\\n\\n        sums = 0 \\n        \\n        while temp != None :\\n            \\n            \\n            if temp.val != 0 :\\n                \\n                sums += temp.val \\n                \\n            elif temp.val == 0 :\\n                \\n                slow.val = sums \\n                temp1 = slow\\n                slow = slow.next \\n                sums = 0 \\n                \\n            temp = temp.next \\n            \\n        temp1.next = None\\n        return head \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2294886,
                "title": "c-what-did-i-just-do",
                "content": "Here is my code.\\nThe code was submitted successfully.\\nBut then the runtime and memory usage are not that optimum.\\n\\n```\\nRuntime: 1514 ms, faster than 7.30% of C++ online submissions for Merge Nodes in Between Zeros.\\nMemory Usage: 253 MB, less than 85.31% of C++ online submissions for Merge Nodes in Between Zeros.\\n```\\n\\nSince I am still learning about LinkedList, can anyone tell how can I optimize this solution?\\nThat would be of great help. \\nThank You\\n\\n# Code\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head -> next;\\n        ListNode* pointer = head;\\n        \\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            if(temp -> val == 0){\\n                pointer -> val = sum;\\n                if(temp -> next != NULL){\\n                    pointer = pointer -> next;                    \\n                }\\n                sum = 0;\\n            } else {\\n                sum += temp -> val;\\n            }\\n            \\n            temp = temp -> next;\\n        }\\n        \\n        pointer -> next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nRuntime: 1514 ms, faster than 7.30% of C++ online submissions for Merge Nodes in Between Zeros.\\nMemory Usage: 253 MB, less than 85.31% of C++ online submissions for Merge Nodes in Between Zeros.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp = head -> next;\\n        ListNode* pointer = head;\\n        \\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            if(temp -> val == 0){\\n                pointer -> val = sum;\\n                if(temp -> next != NULL){\\n                    pointer = pointer -> next;                    \\n                }\\n                sum = 0;\\n            } else {\\n                sum += temp -> val;\\n            }\\n            \\n            temp = temp -> next;\\n        }\\n        \\n        pointer -> next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292356,
                "title": "go-one-pass",
                "content": "```\\nfunc mergeNodes(head *ListNode) *ListNode {\\n    var newHead, tail *ListNode\\n    \\n    currentSum := 0\\n    \\n    for head != nil {\\n        currentSum += head.Val\\n        \\n        if head.Val == 0 && currentSum != 0 {\\n            newNode := &ListNode {\\n                Val: currentSum,\\n            }    \\n            \\n            if newHead == nil {\\n                newHead = newNode\\n                tail = newNode\\n            } else {\\n                tail.Next = newNode\\n                tail = newNode\\n            }\\n            \\n            currentSum = 0\\n        }    \\n        \\n        head = head.Next\\n    }\\n    \\n    return newHead\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```\\nfunc mergeNodes(head *ListNode) *ListNode {\\n    var newHead, tail *ListNode\\n    \\n    currentSum := 0\\n    \\n    for head != nil {\\n        currentSum += head.Val\\n        \\n        if head.Val == 0 && currentSum != 0 {\\n            newNode := &ListNode {\\n                Val: currentSum,\\n            }    \\n            \\n            if newHead == nil {\\n                newHead = newNode\\n                tail = newNode\\n            } else {\\n                tail.Next = newNode\\n                tail = newNode\\n            }\\n            \\n            currentSum = 0\\n        }    \\n        \\n        head = head.Next\\n    }\\n    \\n    return newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286916,
                "title": "simple-solution-c-linked-list-traversal",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* &head) {\\n        ListNode* p = head->next;\\n        ListNode* q = head;\\n        while(p != NULL && p->next != NULL){\\n            int sum = 0;\\n            while(p->val != 0){\\n                sum += p->val;\\n                p = p->next;\\n            }\\n            q->val = sum;\\n            if(p->next == NULL) q->next = NULL;\\n            else q->next = p;\\n            q = p;\\n            p = p->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* &head) {\\n        ListNode* p = head->next;\\n        ListNode* q = head;\\n        while(p != NULL && p->next != NULL){\\n            int sum = 0;\\n            while(p->val != 0){\\n                sum += p->val;\\n                p = p->next;\\n            }\\n            q->val = sum;\\n            if(p->next == NULL) q->next = NULL;\\n            else q->next = p;\\n            q = p;\\n            p = p->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281493,
                "title": "c-easy-to-understand",
                "content": "```\\n\\t\\t\\t  //please upvote//\\n\\t\\t\\t  \\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode *ans = new ListNode();\\n        ListNode *a = ans;\\n        ListNode *p = head->next;\\n        while(p->next!=NULL){\\n            if(p->val==0){\\n                ans->val = sum;\\n                sum=0;\\n                ans->next = new ListNode();\\n                ans = ans->next;\\n            }\\n            else{\\n                sum = sum + p->val;\\n            }\\n            p = p->next;   \\n        }\\n        ans->val = sum;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\t\\t\\t  //please upvote//\\n\\t\\t\\t  \\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        int sum=0;\\n        ListNode *ans = new ListNode();\\n        ListNode *a = ans;\\n        ListNode *p = head->next;\\n        while(p->next!=NULL){\\n            if(p->val==0){\\n                ans->val = sum;\\n                sum=0;\\n                ans->next = new ListNode();\\n                ans = ans->next;\\n            }\\n            else{\\n                sum = sum + p->val;\\n            }\\n            p = p->next;   \\n        }\\n        ans->val = sum;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269092,
                "title": "kotlin-fast-solution-92-of-kotlin-submissions",
                "content": "fun mergeNodes(head: ListNode?): ListNode? {\\n        \\n    if (head?.next == null) return head\\n    var current = head.next\\n    var preivous = head\\n\\n    while (current?.next != null) {\\n        if (current.`val` == 0) {\\n\\n            preivous?.next = current\\n            preivous = current\\n            current = current.next\\n        } else {\\n            preivous?.`val` = preivous?.`val`?.plus(current.`val`)!!\\n            current = current.next\\n        }\\n    }\\n    preivous?.next = null\\n\\n    return head\\n    }",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "fun mergeNodes(head: ListNode?): ListNode? {\\n        \\n    if (head?.next == null) return head\\n    var current = head.next\\n    var preivous = head\\n\\n    while (current?.next != null) {\\n        if (current.`val` == 0) {\\n\\n            preivous?.next = current\\n            preivous = current\\n            current = current.next\\n        } else {\\n            preivous?.`val` = preivous?.`val`?.plus(current.`val`)!!\\n            current = current.next\\n        }\\n    }\\n    preivous?.next = null\\n\\n    return head\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2250762,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        \\n        ListNode* temp=head;\\n        ListNode* seek=head->next;        \\n        int sum=0;\\n        \\n        while(seek!=NULL){\\n            if(seek->val ==0){\\n                temp->val=sum;\\n                if(seek->next==NULL){\\n                    temp->next=NULL;\\n                }else{\\n                    temp->next=seek;\\n                    temp=temp->next;\\n                }\\n                sum=0;\\n            }\\n            \\n            sum+=seek->val;\\n            seek=seek->next;\\n        }    \\n        \\n        temp->next=NULL;\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        \\n        ListNode* temp=head;\\n        ListNode* seek=head->next;        \\n        int sum=0;\\n        \\n        while(seek!=NULL){\\n            if(seek->val ==0){\\n                temp->val=sum;\\n                if(seek->next==NULL){\\n                    temp->next=NULL;\\n                }else{\\n                    temp->next=seek;\\n                    temp=temp->next;\\n                }\\n                sum=0;\\n            }\\n            \\n            sum+=seek->val;\\n            seek=seek->next;\\n        }    \\n        \\n        temp->next=NULL;\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235227,
                "title": "c-easy-solution-faster-than-83-93-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //approach is to add all the values between first zero and the second zero, after fetching the value\\n\\tall we need to do is update the value and flicker around with the chain.\\n    \\n    ListNode* mergeNodes(ListNode* head) {\\n       ListNode* stat=head;  // stat will go to next only when another  zero is encountered \\n        ListNode* ans=head;  // we will use this to not lose the head \\n        ListNode* curr=head->next; // curr will iterate throughout \\n        int sum=0;\\n        \\n        while(curr->next!=NULL){\\n            sum+=curr->val;\\n            \\n            if(curr->val==0){\\n                stat->val=sum;\\n                sum=0;\\n                 stat->next=NULL;\\n                 stat->next= curr;\\n                stat=stat->next;  \\n            }\\n            curr=curr->next;\\n        }\\n         //we need to update the stat with the sum that we fetched\\n            stat->val=sum;\\n            stat->next=NULL;\\n          //making the next of stat as NULL is important\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //approach is to add all the values between first zero and the second zero, after fetching the value\\n\\tall we need to do is update the value and flicker around with the chain.\\n    \\n    ListNode* mergeNodes(ListNode* head) {\\n       ListNode* stat=head;  // stat will go to next only when another  zero is encountered \\n        ListNode* ans=head;  // we will use this to not lose the head \\n        ListNode* curr=head->next; // curr will iterate throughout \\n        int sum=0;\\n        \\n        while(curr->next!=NULL){\\n            sum+=curr->val;\\n            \\n            if(curr->val==0){\\n                stat->val=sum;\\n                sum=0;\\n                 stat->next=NULL;\\n                 stat->next= curr;\\n                stat=stat->next;  \\n            }\\n            curr=curr->next;\\n        }\\n         //we need to update the stat with the sum that we fetched\\n            stat->val=sum;\\n            stat->next=NULL;\\n          //making the next of stat as NULL is important\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230306,
                "title": "easy-cpp-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        bool checker = false ;\\n        int sum = 0;\\n        ListNode* check = head;\\n        ListNode* temp = head;\\n        while(check!=NULL){\\n            if(check->val==0 && checker == false){\\n                checker = true;\\n                check = check->next;\\n                continue;\\n            }\\n            if(checker){\\n                sum = sum + check->val;\\n            if(check->val==0 && checker == true){\\n                temp->val = sum;\\n                if(check->next==NULL)\\n                    temp->next = NULL;\\n                else \\n                temp = temp->next;\\n                sum = 0;\\n            }\\n            }\\n            check = check->next;\\n        }\\n            return head;        \\n    }\\n};\\n```\\n[https://github.com/Reehan9/Leetcode-Solutions]\\n#### Please upvote if you find this helpful",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        bool checker = false ;\\n        int sum = 0;\\n        ListNode* check = head;\\n        ListNode* temp = head;\\n        while(check!=NULL){\\n            if(check->val==0 && checker == false){\\n                checker = true;\\n                check = check->next;\\n                continue;\\n            }\\n            if(checker){\\n                sum = sum + check->val;\\n            if(check->val==0 && checker == true){\\n                temp->val = sum;\\n                if(check->next==NULL)\\n                    temp->next = NULL;\\n                else \\n                temp = temp->next;\\n                sum = 0;\\n            }\\n            }\\n            check = check->next;\\n        }\\n            return head;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215866,
                "title": "a-recursive-solution",
                "content": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t\\n            if not head:\\n                return head            \\n\\n            if head.val==0:\\n                while head and head.val==0:\\n                    head = head.next\\n            if head:\\n                while head.next and head.next.val!=0:\\n                    head.next.val+= head.val\\n                    head=head.next\\n                head.next = self.mergeNodes(head.next)\\n            \\n            return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t\\n            if not head:\\n                return head            \\n\\n            if head.val==0:\\n                while head and head.val==0:\\n                    head = head.next\\n            if head:\\n                while head.next and head.next.val!=0:\\n                    head.next.val+= head.val\\n                    head=head.next\\n                head.next = self.mergeNodes(head.next)\\n            \\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214295,
                "title": "simply-modifying-head-itself-using-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* h1=head;\\n        ListNode* h2=head;\\n        while(h2){\\n            int sum=0;\\n            h2=h2->next;\\n            while(h2 && h2->val!=0){\\n                sum+=h2->val;\\n                h2=h2->next;\\n            }\\n            if(sum==0) return head;\\n            h1->val=sum;\\n            h1->next=h2->next;\\n            h1=h1->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* h1=head;\\n        ListNode* h2=head;\\n        while(h2){\\n            int sum=0;\\n            h2=h2->next;\\n            while(h2 && h2->val!=0){\\n                sum+=h2->val;\\n                h2=h2->next;\\n            }\\n            if(sum==0) return head;\\n            h1->val=sum;\\n            h1->next=h2->next;\\n            h1=h1->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209570,
                "title": "c-o-1-space-complexity-u-can-t-find-more-better-approach",
                "content": "UPVOTE IF LIKED.\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp=head->next;\\n        int sum=0;\\n        ListNode* temp2=head;\\n        while(temp!=nullptr)\\n        {\\n            if(temp->val!=0)\\n            {\\n                sum+=temp->val;\\n            }\\n            else \\n            {\\n                temp2->val=sum;\\n                if(temp->next==nullptr)\\n                    temp2->next=nullptr;\\n                else\\n                    temp2=temp2->next;\\n                sum=0;   \\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeNodes(ListNode* head) {\\n        ListNode* temp=head->next;\\n        int sum=0;\\n        ListNode* temp2=head;\\n        while(temp!=nullptr)\\n        {\\n            if(temp->val!=0)\\n            {\\n                sum+=temp->val;\\n            }\\n            else \\n            {\\n                temp2->val=sum;\\n                if(temp->next==nullptr)\\n                    temp2->next=nullptr;\\n                else\\n                    temp2=temp2->next;\\n                sum=0;   \\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205260,
                "title": "easy-rust-solution-o-n",
                "content": "```rust\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn merge_nodes(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n      let mut res: Box<ListNode> = Box::new(ListNode::new(0));\\n      let mut cur_node = &mut res;\\n        \\n      let mut head = head.as_ref();\\n\\n      while let Some(node) = head{ \\n          head = node.next.as_ref();\\n          \\n          if node.val == 0 && node.next != None {\\n            cur_node.next = Some(Box::new(ListNode::new(0)));\\n            cur_node = cur_node.next.as_mut().unwrap();\\n              \\n            continue;\\n          }\\n\\n         cur_node.val += node.val;\\n      }\\n\\n      res.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn merge_nodes(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n      let mut res: Box<ListNode> = Box::new(ListNode::new(0));\\n      let mut cur_node = &mut res;\\n        \\n      let mut head = head.as_ref();\\n\\n      while let Some(node) = head{ \\n          head = node.next.as_ref();\\n          \\n          if node.val == 0 && node.next != None {\\n            cur_node.next = Some(Box::new(ListNode::new(0)));\\n            cur_node = cur_node.next.as_mut().unwrap();\\n              \\n            continue;\\n          }\\n\\n         cur_node.val += node.val;\\n      }\\n\\n      res.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1994860,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1983018,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1943757,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1795249,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1779576,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1763839,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1739059,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            },
            {
                "id": 1831520,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "How to avoid : ***runtime error: signed integer overflow: 2147483646 + 3 cannot be represented in type \\'int\\' (solution.cpp)*** ??"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "The test cases in this question are designed in a such a way that you would be able to represent it in int data type only. I don\\'t why you are facing this issue. Could you please share the testcases?"
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "My code is working but still thinking if it is possible to make space complexity O(1)."
                    },
                    {
                        "username": "Akash_Verma2000",
                        "content": "[@Dine_09kau](/Dine_09kau)  Thank you"
                    },
                    {
                        "username": "Dine_09kau",
                        "content": "see my code, if it help you \\nclass Solution {\\n    public ListNode mergeNodes(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = head;\\n        int sum = 0;\\n        int n = 0;\\n        while(curr.next != null) {\\n            if(curr.next.val != 0) {\\n                sum += curr.next.val;\\n            }\\n            else {\\n                prev.val = sum;\\n                prev.next = curr;\\n                prev = curr; \\n                sum = 0;\\n                n++; \\n            }\\n             curr = curr.next;\\n        }\\n        curr = head;\\n        for(int i = 0; i < n-1; i++) {\\n            curr = curr.next;\\n        }\\n        curr.next = null;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "heyaryahere",
                        "content": "I have no idea on which data type should i return the answer (list, string etc)?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "return the head of the updated list"
                    },
                    {
                        "username": "Ashutosh_Bhai",
                        "content": "It\\'s given in the question. You need to return the head only."
                    },
                    {
                        "username": "speedhs",
                        "content": "Can we solve this in O(1) space??"
                    },
                    {
                        "username": "geo1923",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) I agree, and on top of that, it should be a question for the interviewer IMO"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "For sure, however it\\'s questionable whether or not it\\'s worth to modify the original as opposed to making a new list and returning it."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Write a separate function for summation thing.\\nalso maintain two pointers, prev and curr \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "jokeislove",
                        "content": "Hi Everyone! I was trying to test it as below. But got Error from that. Anyone has ideas?\n\npublic static void main(String[] args) {\n\t\t//0,3,1,0,4,5,2,0\n\t\tListNode l=new ListNode();\n\t\tl.addNode(0);\n\t\tl.addNode(3);\n\t\tl.addNode(1);\n\t\tl.addNode(0);\n\t\tl.addNode(4);\n\t\tl.addNode(5);\n\t\tl.addNode(2);\n\t\tl.addNode(0);\n\t\tListNode result=mergeNodes(l);\n\t\tresult.display();\n\t}"
                    },
                    {
                        "username": "FasunleKehinde",
                        "content": "You cannot test it like that. Linked-list should not be treated as such. Since it is a linear data structure, you can only traverse the list and check `val` and `next` on every node in the list. Every node has a head. The current `val` of the head is given e.g 3; The value of the actual node is neither `3` nor `new ListNode(3)`\n\nYou could check my solution. It has linear time $$O(n)$$ and space complexity of $$O(1)$$\n\nhttps://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/2996264/merge-linked-list-nodes-linear-time-and-constant-space-implementation/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "agamgupta6582",
                        "content": "why this code is giving error \\n if(head==NULL)\\n         return head;\\n        ListNode *curr=head->next,*temp;\\n        int sum=0;\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp=curr->next;\\n           if(curr->val!=0)\\n           {    \\n               sum+=curr->val;\\n               cout<<sum;\\n               delete(curr);\\n                \\n           }\\n           else\\n           {\\n               curr->val=sum;\\n               sum=0;\\n               \\n           }\\n           curr=temp;\\n\\n        }\\n        return head->next;"
                    },
                    {
                        "username": "Shraeya_Botuku",
                        "content": "struct ListNode *curr=head->next,*temp;\\nyou missed writing struct keyword"
                    }
                ]
            }
        ]
    }
]